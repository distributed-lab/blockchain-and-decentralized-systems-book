# 3 密码学与密钥管理


## 
    3.1 密码学简介

在本小节中，我们将介绍密码学作为一门科学的基本内容，不深入讨论。我们将了解其任务而基本机制，并考虑应用于比特币协议中的具体密码学机制与函数。此外，我们将关注数字签名的工作特点以及用于操作数字签名的数字密钥；这些方面主要是实践性质的。

_密码学是利用数学方法保护信息的科学。_在信息系统发展中，密码学的作用难以高估。比特币成为了世界上首个主要流程与操作都得到密码保护的支付系统。

你将有机会学习信息安全的基本原则，并了解与比特币协议相关的最重要的密码算法。

**_密码信息安全原则_**

密码学的发展始于古代。其历史可以追溯到四千多年前。最初，密码学只解决了一个问题——在传输与存储数据时确保保密性。昔时为了解决这个问题，采用了诸如文本混淆、文本符号混合、使用替代字母表等机制。

目前，密码学采用数学基础。它涉及特殊的转换，这些转换定义在数学的分支中，如数论与信息论、群论、环论、域论等以及其他一些领域。这种数学大多数人并不熟悉，因为大多数教育机构并未教授此类内容。

现代密码学包括对称加密与非对称加密方案、数字签名方案、数据哈希方案、密钥管理方法、零知识证明方案、后量子密码学等。


```
基本安全服务
确保数据保密性
确保数据完整性
确保数据可访问性
确保数据真实性
```


_保密性_意味着未经授权的人无法访问存储或传输的文档的语义内容。最常见的服务方式是通过加密（对称或非对称加密）提供。

_完整性_意味着未经授权的人无法不可察觉地修改数据。从载体读取或从网络接收数据后，验证数据完整性的任务通常通过哈希与校验和验证来解决。

_可访问性_意味着有权访问某些信息的各方将确保能够访问到该信息。

_真实性_意味着能够证明数据确实来自特定作者。确保数据真实性的任务通常使用数字签名来解决。我们以下给出其简化定义。


```
注意：与上述列出的其他服务不同，可访问性是通过非密码学方法确保的（如冗余、使用不间断电源系统等）。
```


**_密钥概念_**

现代加密密钥是_使用随机数生成器根据一定规则创建并通过特殊算法计算的特定长度的数字序列。_加密密钥是密码操作的核心部分。大多数密码方案的安全性通常取决于密钥的安全性。

在一般情况下，比特币中的_私钥_是一个大的随机自然数。有特殊的软件与硬件随机数生成器，它们形成一个恒定长度的随机序列（对于软件数字生成器，更正确要对_伪随机数_说）。私钥是由这个恒定长度的随机序列生成的自然数。公钥是通过数学变换从私钥计算得出的（见图 3–1）。


![alt_text](images/image1.png "image_tooltip")


图 3–1


```
注意：当涉及到被认为足够可靠的密码算法（根据密码学标准），所谓逆变换，进行从公钥获取私钥，实际上无法完成。
```


在密码分析领域，存在某些方法能够比简单地迭代数字更有效地攻击密码方案。然而，对于较长长度的密钥，实际实施攻击需要庞大的计算能力。这个过程将需要很长时间（使用当前算法与硬件需要数十亿年甚至更长时间）。

**_秘密密钥的生成与处理_**

在实践中，密钥和数字签名生成方案的正确运作以及安全机制的可靠性非常重要。在加密货币中，_只有知道需要计算有效的数字签名的私钥，才可以证明硬币的所有权。_对于密钥所有者，重要的是没有其他人能够窃取、计算或生成相同的密钥数据。

这意味着什么？比特币与其他加密货币的用户应该使用可靠的随机数生成器（以及真正随机的种子），这些生成器能够产生客观随机的序列，在任何其他条件下都不会重复。正如我们已经提到的，生成器可以是软件或硬件。它们之间有什么区别？

_软件生成器_无法生成足够随机的数字。它们生成所谓的伪随机数。这意味着在一定周期后，数字开始重复，而且这个周期是可以确定的。显然，攻击者可以利用这样的知识。

_硬件生成器_通常基于难以或不可能预测的随机过程。特殊的传感器检测某些过程的噪音（例如 Zener 击穿二极管、核辐射），将其数字化，并产生一串随机位。基于流数据，你可以生成密钥并在密码方案中使用它们。

我们将为你提供一个相关的例子。在比特币早期发展阶段，安卓(英文：Android） 设备只有一个钱包应用——比特币钱包（英文：Bitcoin Wallet）。应用的创建者偶尔在随机数生成器软件的代码中留下了一个漏洞。它生成的数字范围很窄，因此可以预测到可能属于该钱包用户的密钥子集。攻击者可以遍历这个子集中的密钥，并有很高的概率找到某些密钥所对应的硬币。事情就是这样发生的。这引发了一场巨大的丑闻，因为有大量比特币被盗。随后，发布了一次及时的更新来消除这个漏洞，但是盗窃已经发生了。

生成随机数非常重要。一些随机数生成器可以结合软件与硬件实现。此外，为了提高随机性，开发人员到生成随机数的过程中（例如，可以利用智能手机的麦克风、陀螺仪、任何加速度计数据等来产生噪音）还引入了更多的_熵_（不可预测性）[30]。

_密钥泄露_是未经授权的人获得秘密信息的状态；这还意味着可能潜在地存在这种访问，甚至怀疑存在这种可能性。

一个被泄露的私钥对任何信息安全系统都是一种严重威胁。因此，为保护私钥（或其他机密数据）采取特殊措施：敏感数据不会以明文形式写入计算机的硬盘，而是存储在加密、密码保护等方法的独立介质上。

如果怀疑密钥已被泄露，应予以废弃并更换。

**_单向函数与 NP 完全问题的概念_**

在了解哈希函数之前，让我们先考虑一下单向函数是什么以及它具有哪些特征。单向函数是一种数学函数，具有以下特点：



* 对于任何输入参数获得其输出值相对简单
* 对于其输出值获得输入参数非常困难（这意味着解决一个 NP 完全问题）

一个简单的例子可以是一个打破的杯子：捡起所有的碎片并将它们恢复成一个完整的杯子是非常麻烦的。同样的道理也适用于单向函数：如果你只有输出数据，假设你不能恢复初始消息。理论上，这是可能的，但在实践中，这个任务可能会非常困难（前提是特定的单向函数足够可靠）。

NP 完全问题是寻找初始消息的特定任务（更确切地说，满足特定条件的对象）。按照我们的例子，解决 NP 完全问题相当于恢复未破碎的杯子。找到对象是一个复杂的任务，因为它需要搜索大量可能的选项。不过，一旦有了现成的解决方案，你可以相对容易地检查它是否符合条件。

NP 完全问题没有快速解决方案对现代密码学至关重要：如果有一种方法可以在合理的时间内解决问题（而不是数百万年），那么大量现代密码学原语就面临风险。一些 NP 完全问题的例子包括查找哈希函数的原像与找到与特定公钥匹配的私钥，以及所谓的旅行商问题（我们稍后会详细讨论）。

旅行推销员问题是关于找到所有可能路线中最有利的路线。根据条件，必须经过所有标记的城市，然后返回到初始城市。两个城市之间的移动有一定的成本。为了解决这个问题并选择最优路线，推销员需要查看所有可能的移动方式。请注意随着城市数量的增加，找到这样一条路线的复杂度呈指数增长。如果问题条件中有 5 个城市，我们将有12条可能的路线，但是如果有10个城市，我们将不得不查看 181,400 条路线。

**_哈希函数_**

_哈希函数是输入任意长度的数据集转换为使用特定算法执行的固定长度的输出位串的函数。_

哈希函数是一种单向函数，意味着通过输出值（一定长度的数字），你无法确定已输入的数据。如果只有通过穷举法进行攻击，它才被认为是具有密码学安全性的。这意味着确保输出值具有特定值的唯一解决方案是遍历所有可能的输入值。图 3–2 中显示了哈希函数的示意图。


![alt_text](images/image2.png "image_tooltip")


图 3–2

在输入端，哈希函数可以接收几乎无限大小的消息（任何数据）。在输出端，得到一个唯一的标识符（哈希值）。通过使用具有密码学安全性的哈希函数获得的哈希值，确定最初提交到其输入的数据是什么是不可能的。此外，比特币使用几种不同的哈希算法。

哈希函数的工作原理可以通过一个例子来理解，即一个函数对输入消息中的所有数字进行求和，并产生一个长度为一个符号的结果。这个函数的特点如下。首先，由于计数算法的简单性，可以快速地得到结果。其次，这个函数是单向的，因为输出值只包含消息中数字的总和信息，而不包含数字的位置信息。因此，猜测初始消息的复杂性随着消息本身的长度越来越增加（图 3–3）。


![alt_text](images/image3.png "image_tooltip")


图 3–3

然而，使用这个函数可能是不安全的，因为相对容易在其中找到特定的碰撞：在这种情况下，可以替换输入消息（即，提交具有相同数字的消息到函数的输入），从而得到相同的结果（图 3–4）。


![alt_text](images/image4.png "image_tooltip")


图 3–4

现在，让我们考虑一下哈希函数必须具备哪些特性，以确保其使用是足够安全的。


```
哈希函数的要求
抗碰撞
抵抗找到第一个愿像的能力
抵抗找到第二个愿像的能力
```


_抗碰撞_意味着没有算法可以在相对短的时间内找到碰撞。碰撞是指当多个输入值在哈希函数的输出处匹配相同的值时发生的情况（见图 3–5）。


![alt_text](images/image5.png "image_tooltip")


图 3–5

_抵抗找到第一个愿像的能力（不可逆性）_意味着知道相应的哈希值将不会让你在现实时间内恢复初始消息（可能需要一生时间甚至更长）。

_抵抗找到第二个愿像的能力_意味着拥有一个初始消息与相应的哈希值的一方不能创建另一个具有相同哈希函数输出的消息。

此外，密码学上抗性强的哈希函数必须确保即使改变一个输入比特，平均而言，会导致一半输出比特的改变。这个特性可以通过以下示例轻松说明（图  3–6）。鲍勃创建了一笔交易，向爱丽丝发送了 10 比特币，然后获得了相应的哈希值。如果有人想要替换交易，改变转账金额（比如不是 10 而是 100 比特币），那么交易的伪造将会被立即检测出来。


![alt_text](images/image6.png "image_tooltip")


图 3–6

SHA-1（安全哈希算法 1；英文： Secure Hash Algorithm 1）是现有哈希函数中的一个很好的例子[31]，被认为相对可靠，其工作原理相对容易解释。其运作的核心在于对输入数据进行循环混淆（80 个循环），并使用字节操作（与、异或、旋转、加、或）。在图 3–7 中，可以看到SHA-1的一个循环（操作可以非常简单，并且可以在最基本的硬件设备上执行），其中：

是常量值，

是具有输入数据的可变函数（每 20 个循环更改一次），

是修改后的输入数据元素（4 字节），

<&lt;<x表示向左旋转x个位置。


![alt_text](images/image7.png "image_tooltip")


图 3–7

**_哈希函数的应用_**

哈希函数对于获取数据集的唯一标识符非常有用。在比特币中，需要哈希函数来实现_时间戳_与链接区块，以及提供特定数据标识符（用于证明特定数据的存在），同时又不会透露确切的数据。因此，哈希函数已经变得非常普遍。让我们来看一下它们的主要应用。

哈希值被用作数据传输的校验和。为了验证消息在传输过程中没有因数据通道中的某些噪音而意外损坏，接收方可以从接收到的数据重新计算哈希值，并将其与现有的哈希值进行比较。

此外，这些函数用于查找存储的数据重复项或比较大型数据集。为了避免直接比较大量数据，可以存储相应的哈希值并进行比较。如果不同数据集的哈希函数值相同，那么数据本身很可能也相匹配。这显著加快了诸如数字签名创建等过程。通常，在签署文档时，签署的不是消息数据本身，而是此数据的哈希值。假定哈希值与消息与签名一起发送。通过这种方式，接收方可以验证消息的完整性以及数字签名的正确性。

**_哈希树（Merkle trees）_**

哈希树（英文：Merkle trees）是一种数据结构，将单独的数据块与单个根值相连。它允许证明特定数据块与特定根值相匹配。这个概念最早是由拉尔夫·查尔斯·默克尔（英文：Ralph C. Merkle）于 1979 年发表的 [32]。哈希树的最早实现之一被应用在 BitTorrent 协议（俗称比特洪流）中。

哈希树包括以下组件（图 3–8）：



* 哈希叶节点（Merkle leaves）
* 哈希节点（Merkle nodes）
* 哈希根节点（Merkle root）


![alt_text](images/image8.png "image_tooltip")


图 3–8

_哈希叶节点_代表需要包含在结构中的数据块的哈希值。_哈希节点_是通过连接并对两个子节点或哈希叶节点进行哈希运算得到的值。_哈希根节点_也是一个节点，即哈希树顶部的节点。


```
哈希树的特点包括：
修改其中一个块中至少一个数据位将完全改变哈希根值。
如果其中一个块发生损坏，可以快速且高精度地确定哪个块已被修改。
可以迅速证明特定块是否是哈希树结构的一部分。
```


**_对称加密_**

简单来说，_文档加密是以一种修改文档文本的方式，只有持有相应密钥的人才能够恢复原始文本。_让我们来看一下加密的工作原理。

我们将从最常见的类型开始——对称加密。此过程的示意图如图 3–9 所示。


![alt_text](images/image9.png "image_tooltip")


图 3–9

有一个函数执行数据加密：它接收明文和加密密钥作为输入，并返回加密后的数据，即密文。数据解密通过另一个函数完成：它接收加密数据与相同的加密密钥作为输入，并将原始数据（明文）返回到输出。这种加密类型称为对称加密，因为加密与解密都使用相同的密钥。

对称加密的主要优势而广泛应用的原因是将明文转换为密文的速度较快，相比其他加密方法而言。

对称加密的一个显著例子是 Vernam 密码，也称为_一次性密码本_（图 3–10）。这种方法的核心在于使用一次性密钥对输入文本进行模加。在这种情况下，加密密钥（同时也是解密密钥）和输入文本的长度必须相等。这个密码是一个很好的例子，因为它是完全安全的：拥有密文的对手无法获得任何关于初始消息的信息。


![alt_text](images/image10.png "image_tooltip")


图 3–10

这种加密方法只有在密钥是随机生成的情况下才被认为是足够安全的。生成一个长尺寸的随机密钥会带来另一个限制，因为真正的随机生成器速度较慢（如果你比较需要传输密钥的通道容量的话）。

让我们来观察现代对称加密算法之一——高级加密标准（英文：Advanced Encryption Standard；AES）[33]的结构方案（图 3–11）。这个加密算法的一个有趣特点是数据被表示为字节矩阵，并且所有操作都是在这个矩阵的元素上执行的。AES中使用的基本操作如下：



* _Substitute _是将矩阵元素替换为相应的表值
* _Shift Rows _是将矩阵行循环向左移动相应数量的元素
* _Mix Columns _是将矩阵列乘以静态预定义的矩阵
* _Add Round Key _是将状态矩阵与一个轮密钥相加


![alt_text](images/image11.png "image_tooltip")


图 3–11

对称加密存在一些缺点。主要挑战在于在安全通信开始之前将秘密密钥传输给预期的接收者，并确保其保密性；这是因为发送方和接收方都需要拥有此密钥。第二个缺点在于仅基于对称加密进行安全通信的系统中为每个新参与者创建和存储新密钥的复杂性。随着参与者数量的增加，这个问题的复杂性二次增长（随着新用户的增加，生成的新密钥数量也增加）。例如，如果系统中有 10 个用户，则生成的密钥数量将为 45 个。如果我们假设用户数量增加了十倍（ 100 个用户），那么生成的密钥数量将为 4950 个（是之前的一百倍）。

**_非对称加密_**

非对称加密是在 1970 年代提出的，它对密码学产生了革命性的影响。非对称加密使用所谓的密钥对，而不是像对称加密中那样只使用一个密钥。密钥对通常包括_一个私钥_和_一个公钥_。私钥必须保密，而公钥可以传输给要进行交互的对方。

假设爱丽丝想要接收只有她能阅读的朋友消息。根据非对称加密方案，她生成了一对密钥。她将私钥保存在她的秘密地方，例如将公钥发布在社交媒体上的个人页面上，或者通知潜在的通信对方。

当爱丽丝的其中一个朋友想要给她发送私密消息时，他使用爱丽丝的公钥对文件进行加密，然后通过公开的数据通道传输该文件。收到消息后，爱丽丝使用她的私钥对其进行解密。任何拦截此消息的其他方都无法访问消息的文本内容。这种方法的好处在于系统中的密钥数量与参与者数量成正比（线性关系），而且密钥不需要通过机密渠道传输（只需要提供完整性的通道，这要容易得多）。而对称加密的情况下，密钥的数量呈指数增长，这会占据参与者设备上更多的物理内存。

在图 3–12 中，可以看到非对称加密的工作原理。有一个加密函数，它接收开放数据与公钥作为输入，并将加密数据返回到输出。逆函数被称为解密函数。它接受加密消息和接收者的私钥，并返回消息的明文。


![alt_text](images/image12.png "image_tooltip")


图 3–12

**_数字签名_**

另一个非对称加密的应用是数字签名

数字签名是如何工作的呢？想要签署消息的人首先生成密钥对。用于生成数字签名的私钥保密。公钥被公开以便接收签名消息的人能够验证其真实性。现在，为了签署消息，一个人使用他的私钥，并发送两个文件：一个签名消息和一个附加的签名。另一个想要确保文件被正确形成和签名的人可以拿公钥与消息来验证签名是否匹配。


```
注意：在数字签名方案中，用公钥验证签名值与签署文件有关。因此，必须安全传输公钥（除非有公钥证书，其中包含与密钥相关的特定身份数据），以防止签名与公钥被替换。
```


生成签名的函数输入作者的消息和私钥，并在输出中生成附加到消息的签名数据（见图 3–13）。之后，将消息和签名发送给接收者。接收者使用验证函数来验证签名是否正确。该函数接受三个参数：消息、签名值与公钥。它返回一个布尔值，即签名是有效还是无效。如果消息已被替换、签名数据被篡改，或者用于验证的公钥不正确（被损坏或替换），则签名可能会被证明不正确。


![alt_text](images/image13.png "image_tooltip")


图 3–13

**_对手模型与威胁模型_**

构建可靠信息系统的前提之一是制定安全策略。为此，通常使用信息安全威胁模型和信息安全违规者模型的描述。

威胁模型是对可能的威胁进行结构化描述的方式（威胁来源、针对特定威胁的信息安全服务、威胁实施的可能方式）。

对手模型是对手的结构化描述（可能的对手类别、他的目标、技术能力和资格）。

让我们首先考虑在比特币系统中谁可能成为对手。对手是指违反系统（协议）安全策略的一个人或一群人。以下人员可能成为比特币系统中的对手：



* 用户
* 验证者
* 社区成员
* 比特币服务的所有者
* 钱包开发者

值得注意的是，每个可能的对手都是系统参与者对手可以参与其管理，影响相应的设备以进行修改等等。换句话说，对手在攻击系统时几乎没有任何限制。

对手的可能目的是什么？首先是修改数据库以改变用户“余额”的状态。其次，试图限制特定节点或多个节点对当前数据库状态的访问。此外，对手的目的可能是部署恶意软件或直接修改用户软件。

为了完整性对手模型，还要考虑对手的技术能力和资质。比特币是一个节点可能具有各种水平的能力（从单个笔记本电脑到集群）的系统。因此，任何潜在的对手都应该被认为具有最新的软件与硬件以及较高的资质。

让我们尝试描述比特币的威胁模型。我们将考虑比特币会计系统必须提供哪些信息安全服务，以及可能会违反的服务。

_机密性_。默认情况下，比特币不提供此安全服务。也就是说，数据库是公开的，并且所有用户之间的交易和消息都是以明文传输的。

_完整性_。比特币中区块链技术的使用专门致力于提供这种安全服务（因此，它需要对与数据处理相关的所有过程：存储、传输等进行最大关注）。

_可访问性_。正如之前提到的，比特币数据库是公开可用的。因此，每个用户都可以独立审计比特币会计系统内的所有流程。

根据对手的类别和能力，考虑可以在比特币中实施的威胁：



1. 攻击者可能创建一个双重支付的交易（凭空产生地制造资金）。
2. 一个声誉良好的攻击者可能会说服社区采用具有某些漏洞的更新。
3. 攻击者可能创建一个分叉并注入一些漏洞。之后，他可能以某种方式将一些用户转移到目标（有漏洞的）系统上。
4. 攻击者可能在比特币之上构建一个有漏洞的协议，并说服比特币的参与者使用新构建的协议。
5. 攻击者可能积累大量的计算能力，并尝试创建替代链。
6. 攻击者可能获取其他参与者的设备访问权限（因此可以控制大部分计算能力）。
7. 攻击者可能修改网络节点软件。
8. 攻击者可能创建假网站河钱包（提供虚假信息）。
9. 攻击者可能修改其设备并进行分发。
10. 攻击者可能修改自己的钱包（软件）。
11. 攻击者可能拦截/替换系统参与者之间的任何消息（例如，为了传输不正确的交易历史或限制特定节点访问当前数据库状态）。
12. 攻击者可能模仿任何系统参与者甚至整个网络（通过此方式，可以向特定用户或特定一组用户强制提供替代历史记录）。
13. 攻击者可能轻易隐藏自己的行为（因为在比特币协议中用户没有被识别）。
14. 攻击者可能通过分析其互联网流量来识别特定交易的参与者（假定互联网服务提供商能够追踪特定用户的所有进出流量）。

提及了可能的威胁后，我们需要说明如何对抗它们。前四种威胁是最难实施的，因为这需要系统参与者的大量支持。由于用户货币的安全直接取决于提出的更新，这些提议将会被仔细审查，并在其中悄悄注入后门是非常棘手的。

威胁5和6的目标是获得大量的计算能力。这些威胁的实施成本非常高，很少有攻击的收益超过执行它们的开销。另一方面，这类攻击对用户十分危险，因为在这些情况攻击者欺骗用户的同时避免了违反协议。

下面的4个威胁（7-10）比前面的威胁要容易实施得多。它们通常可以由软件与硬件供应商来实施。由于并非每个用户都检查钱包源代码中的漏洞，这类攻击更可能发生。它们可能导致用户失去他们的加密货币。为了防范此类攻击，用户需要检查钱包软件的漏洞，并只使用来自可信来源的软件。

剩下的4个威胁（11-14）最容易执行，因为它们是在网络层实施的。这类攻击很少会导致用户丢失加密货币，但它们可能限制某个特定用户访问相关信息，并限制他在网络上的操作。保护一个分散系统免受此类攻击通常更加困难，但可以通过增加每个用户与其他网络节点的连接数量来实现。

尽管列出了以上内容，攻击者被假定**不能**：



* 猜测哪个公钥被用于特定的比特币地址
* 获取受保护设备内存中的私钥
* 检测存储特定多重签名地址（见4.5）私钥的第二（或第三）设备

## 
    3.2 比特币中的加密学


这个小节探讨了如何利用椭圆曲线的加密属性来建立无需信任的系统中的互动。

**_椭圆曲线的特点_**

椭圆曲线密码学是构建 2018 年最快速与最有效的非对称加密转换方法之一 [34]。特别是，比特币使用了ECDSA，这是一种标准化的数字签名算法。

椭圆曲线（英文：elliptic curve，EC）在实数域上由平面上满足方程 y² = x³ + ax + b 的坐标点组成，其中 a 和 b 是实数，还有一个所谓的无穷远点，它没有实数坐标。指定的标准方程是魏尔斯特拉斯方程的一个特例。国家标准技术研究所（英文：The National Institute of Standards and Technology；NIST）建议在数字签名算法中使用 15 条椭圆曲线 [35]。最常用的是伪随机椭圆曲线（使用伪随机方法生成 EC 参数和域，通常使用哈希函数）。但是，比特币中的曲线不在 NIST 建议的范围内，并是一种特殊类型的 EC，因为系数与基本字段是为了提高操作效率而有意选择的。在比特币中，a = 0，b = 7，因此椭圆曲线由方程 y² = x³ + 7 定义 [36]。该曲线在实数域上的图形显示在图 3–14 中，更详细的曲线部分包含拐点显示在图 3–15 中。


![alt_text](images/image14.png "image_tooltip")


图 3–14


![alt_text](images/image15.png "image_tooltip")


图 3–15

椭圆曲线点群的主要操作包括：_加法、加倍与标量乘法_。请注意，每个列出的操作的结果也是属于 EC 的一个点 [37]。

曲线上点的和在实数域中具有简单的几何解释（图 3–16）。两点和的和是第三个点=+，它是通过点和A2的直线与椭圆曲线的第三个相交点（-）在 Ox 轴上的逆向。

_标量乘法是一个点与其自身的多次相加。_图 3–17 展示了点如何被加倍。


![alt_text](images/image16.png "image_tooltip")


图 3–16


![alt_text](images/image17.png "image_tooltip")


图 3–17

**_比特币地址的创建_**

了解哈希函数的主要原则与 ECDSA 密钥生成的特点足以深入了解比特币中的地址生成。在最简单的情况下，地址是通过对公钥应用哈希算法得到的（见图 3–18）。具体来说，使用了安全哈希算法2（英文：Secure Hash Algorithm 2；SHA-2）和RACE原始完整性校验讯息摘要（英文：RACE Integrity Primitives Evaluation Message Digest；RIPEMD），即SHA256和RIPEMD160。


![alt_text](images/image18.png "image_tooltip")


图 3–18

公钥使用 SHA256 进行哈希处理；为了得到结果，RIPEMD160 被使用为计算哈希值。输出结果是一个 160 位（20 字节）的数字。接下来，将此数字表示为 Base58Check 编码。在编码过程中，附加了 4 字节的校验和和1字节的版本信息，之后，将这25字节的数字按照编码字母表转换成字符串。得到的长度为 35 个字符的字符串被认为是一个比特币地址。


```
注意：以上方案创建的地址格式被称为 P2PKH（英文：pay to public key hash；支付到公钥哈希）。其他的比特币地址格式将在4.5中考虑。
```


Base58Check编码字母表类似于广泛应用的base64编码字母表，但它不包含难以区别的字符，比如"I"（大写"I"）、"l"（小写"L"）、"O"（大写"o"）和"0"（零），以及符号"+"和"/"。

为什么比特币中定义了这些特定的地址生成规则？首先，在数字签名算法被破解的情况下，隐藏公钥可以保护用户免受盗窃的危险。其次，应用了各种的函数以最小化对哈希函数的攻击风险。由于比特币中使用的哈希函数标准是独立的，两种算法都存在后门的可能性极小。

**_比特币中的保密_**

比特币协议处理交易与区块的数据，并通过全球网络接收与传输这些数据。在传输过程中，数据实际上并未加密，而是保持明文状态。试图防止未经授权的人在传输过程中修改这些数据的价值有限，因为数据已经被散列或者可以通过数字签名进行认证。此外，这些数据并未加密，以便任何人都可以进行验证。

对于在比特币网络中传输的数据进行加密的几乎唯一目的是提高网络节点本身的隐私级别。这对于节点所有者想要匿名行事是很重要的（有关详细信息，请参见7.1）。

**_比特币中密钥遭受攻击的基本向量_**

有几种攻击者可以破坏用于存储比特币的密钥的方法：



* 入侵数学方面（椭圆曲线、密钥生成算法、哈希算法或数字签名算法）
* 入侵生成密钥或执行签名的硬件
* 通信协议的入侵（握手、密钥交换、TLS、签名验证过程等）
* 软件钱包的入侵（密钥生成、随机性源、密钥存储、注入可执行代码等）
* 社交攻击

*****常见问题*****

_“在使用ECDSA获取公钥时是否使用随机数生成器？”_

不使用。公钥是根据特定的私钥计算出来的，这个计算是单向的。比特币使用基于自己椭圆曲线的密码学，其定义为方程 y2=x3+7。公钥是具有坐标x和y的一个点。由于私钥是一个特定的大自然数，公钥可以按照以下方式计算出来：公钥 = 私钥 × G，其中G是基点（椭圆曲线上的一个点）。这个操作的结果是曲线上的一个新点。基点 G 是 secp256k1 规范的一个恒定参数。拥有公钥后，可以生成一个钱包地址。

_“能否将 P 除以 G 以得到私钥？”_

在密码学中，这被称为椭圆曲线点群中离散对数问题的解决方案。这个方程不能直接解决。用着密码分析寻找解决方案。理论上存在能够解决这个问题的方法，但它们需要目前不可用的大量计算能力与内存。

_“公钥只用于获取地址吗？”_

不是。除了获取地址外，公钥还用于接收与使用硬币。用户首先计算他的地址，然后在其上接收硬币。用户需要公钥来证明自己是特定地址的所有者。所有验证者都会计算公钥的哈希值，然后验证它是否与用户的地址相匹配。

_“量子计算机对比特币构成威胁吗？”_

截至 2018 年的撰写时，根据其当前的寄存器长度，量子计算机对比特币中使用的加密机制并不构成威胁。然而，量子计算机正在逐渐发展，寄存器长度也在增加，因此它们能够解决的问题复杂度也增加。未来几年，量子计算理论上可能对现代椭圆加密构成威胁——即可能通过知晓公钥计算出私钥。只有比特币的密码学将不发展，才这种事情能发生，但这种可能性较小。

_“量子计算机对比特币中应用的算法威胁如何减缓？”_

首先需要注意比特币协议可以进行更新（使用更长的数字签名密钥或实施后量子数字签名算法）。如果协议不进行更新，即使按照当前规则，攻击者也只有大约 10 分钟的时间来猜测密钥、创建替代交易并尝试确认。一般情况下，一笔常规交易获得第一次确认的平均时间为 10 分钟（从其在网络上传播的时刻计算）。当用户在其地址上接收到比特币时，他不会立即公开公钥，因此它无法被攻击（在实际操作中，同时破解 SHA-2 和 RIPEMD160 哈希函数的概率极小；使用量子计算机分别破解每一个的情况也是如此）。数字签名的公钥可能会在使用比特币时（发送出账交易到网络时）遭受攻击。这意味着在 2018 年，量子计算机并不直接对比特币构成威胁。此外，攻击的可能性取决于财务利润的大小：对于小额金额，使用量子计算机进行攻击在经济上并不划算，因为其成本将大大超过收益的价值。

_“查明某一个在比特币中的人通过联想他跟数字签名是否有可能?”_

不可能。这是错的，因为这样的数字签名没有认证。在比特币中没有颁发用户公钥证书的认证机构（英文：Certification authorities, CA）。因此，唯一确定一个人是非常困难的。此外，比特币被认为是相对匿名的。但是，可以尝试通过其他方法来实现。例如，当某人将比特币兑换成现金时，你可以识别交易对方，可以使用标记的纸币，可以追踪用于将交易发送到网络的软件和 IP 地址。然而，默认情况下，数字签名并未与特定人员关联。


## 3.3 密钥存储与处理

虽然某些国家存在数字签名与数字身份的相关法规与实践，但可以肯定的是，这些机制在人们生活中的应用一直以来都非常有限。然而，随着比特币的出现，人们意识到数字化资产权利是 21 世纪不可避免的事件，符合当今的需求。由于比特币架构的特殊性，它仅依赖于数字交易验证的方法，以至于连一个交易机器人也可以成为网络用户。实现用户之间这种交互的最佳方式是使用加密密钥和数字签名方案。然而，这种方法要求用户在处理密钥时格外小心。因此，密钥生命周期管理（生成、存储、恢复）相关的问题具有极其重要的意义。

在本节中，我们将深入探讨数字钱包中密钥的存储与处理过程，同时考虑实现这些过程的最相关方法。这些内容将帮助了解钱包的工作原理，以及它们如何根据密钥处理方法进行分类，还可以评估每种方法的风险和好处。

**_数字钱包的主要功能_**

对钱包说，人们通常指的是用来存放钱的东西。这就是为什么有些用户经常感到迷惑；有些人错误地认为数字钱包用于存储硬币。严格来说，这是不正确的。数字硬币是一种抽象概念，在现实中既不存在，也不会被存储在任何地方。因此，问题是数字钱包中发生了什么过程，以及如何更好地组织这些过程？

钱包用于存储与用户余额相关的密钥。因此，_钱包的主要功能是存储并管理密钥_。只有当数字钱包被正确设计时，才能实现这些功能。


```
数字钱包模块
密钥生成和存储模块
同步当前状态模块
处理现有交易模块
创建交易及其签名模块
```


数字钱包可以具备各种高级功能，在各种各样的应用之间可能存在差异。然而，每个数字钱包都提供交易认证机制、恢复访问钱包的功能，以及发送并接收付款、显示余额和交易历史的功能。

**_钱包同步的基本方法_**


```
密钥在远程服务器上存储并处理
密钥存储在远程服务器上但由用户进行处理
密钥在用户的应用程序中存储并处理
以多重签名的方式结合之前的方法
```


当涉及到存储私钥，通常人们需要面对一些挑战：如何保护密钥免于丢失或盗窃，以及如何备份并导出它们以便在其他设备上使用。目前还没有一个完全符合所有要求的理想解决方案[38]。因此，形成了几种基本的密钥存储方法。

每种方法都有其优缺点，选择哪种方法取决于你的具体需求。这些方法在本质上的区别在于密钥存储的位置和处理的位置。

**_在服务器上处理并存储密钥_**

在密钥存储并处理在专用服务器上的情况是其中一种最简单的情形；提供钱包的服务完全控制着密钥。因此，钱包的用户没有任何对密钥的访问权限，意味着他们并不拥有真正加密货币，尽管这样的服务非常受欢迎。它们为每个用户提供了账户和虚拟余额，该余额对应数字货币的余额（图 3–19）。然而，实际访问这些加密货币的途径是由该服务所拥有的密钥提供的。


![alt_text](images/image19.png "image_tooltip")


图 3–19

在这种情况下，有两种用户之间转移代币的选项：



* 在同一中心化服务的两个用户之间
* 在特定服务的用户和比特币钱包用户之间

对于第一种情况，一切都很简单。由于硬币并没有离开系统的范围，服务只是在用户账户间（在服务维护的数据库内部）更改用户余额，而没有创建真正的比特币交易。

如果需要从外部钱包存入资金或将资金提取到外部钱包，显然需要创建一个实际的（_链上_）交易。在这种情况下，服务创建了这笔交易，并使用其密钥将资金发送到外部钱包，或以其他方式从外部钱包接收资金到其地址。因此，服务管理了所有地址。

这种类型的钱包很受欢迎，因为用户在使用它时可以获得很多优势。首先，用户实际上可以进行即时支付，而无需支付费用，因为他们并不创建任何真正的交易。事实上，这是大多数服务采用这种方法的主要原因之一。此外，这些服务允许用户从多个设备简单地访问账户。即使忘记了账户密码，也可以轻松恢复。

然而，这种方法也存在一些缺点。其中之一是在这种系统中，用户无法访问他们的数字货币。他们不掌控密钥，因此也无法掌控数字货币的流通。用户完全依赖于此类服务：要使用另一个服务，用户必须将当前服务中的所有资金提取出来并发送到另一个钱包。

这是在开发中最简单的钱包实现之一。密钥的存储和处理都在服务器端进行。通常，你甚至不需要在设备上安装软件来管理密钥。为此，服务器使用与特定数字货币的完整网络节点相同的钱包。由于所有操作都在服务器上执行，客户端应用程序非常简单（以及其实现方式）。实际上，它仅涉及通过 API 与服务器通信。然而，考虑到所有密钥不仅存储在特定服务器上，还在其上进行处理，在某个特定时间点，它们将以明文形式存储在内存中，甚至可能存储在硬盘上。这类服务器的安全要求非常高：你需要尽可能地保护服务器免受外部访问、入侵等的可能性。

**_密钥在服务器上，但只有客户端才能访问_**

另一种方法是将密钥存储在服务器上，但密钥管理是在客户端应用程序中进行的。在这种情况下，用户相比于前一种方法更多地控制其加密货币（见图  3–20）。服务虽然存储其客户的私钥，但不能直接访问这些私钥。


![alt_text](images/image20.png "image_tooltip")


图 3–20

当用户在此类服务中注册时，他会在设备上生成一个私钥（在移动钱包或 Web 钱包中），使用密码对其进行加密，然后以受保护的形式发送到服务器。以后，当用户需要获取私钥时，他需要进行身份验证，并请求服务提供带有私钥的加密容器。钱包接收此容器，解密私钥，并在设备上直接处理。

这种方法的优点是什么？与之前的情况一样，用户可以轻松从多个设备访问自己的账户。在这种情况下，用户直接控制他们的密钥（因此也控制着硬币），但是还是会有一定程度的依赖于服务。如果一个集中式服务不可用，用户将失去对他的硬币的访问权限（如果他没有私钥备份）。

开发过程中的特殊性是处理密钥和签署交易的算法必须在用户的应用程序中实现。这可能相当困难，特别是当服务支持多个不同平台的应用程序时，例如 Android、iOS、Web 应用程序等。尽管用户的私钥以加密形式存储在服务的服务器上，但对安全性的高要求仍然存在。毕竟，工程师仍然可能发现保护敏感数据与验证此类服务客户的算法中存在漏洞，并以恶意使用它们。一些集中式在线钱包采用这种处理并存储密钥的方式。

**_密钥存储在用户的设备上_**

在下一种方法中，私钥的存储和管理是在用户的设备上进行的。在这种情况下，用户不需要后端或 API。用户完全控制其数字货币，因此更不依赖外部服务。例如，即使没有网络访问，用户还可以访问其钱包并创建交易，一旦恢复访问权限，该交易将被发送到网络（图 3–21）。他可以将此交易转移，甚至无需从他的设备访问网络，可以将交易转移到另一台设备上，这台设备可以访问网络，然后从那里将其发送到网络。


![alt_text](images/image21.png "image_tooltip")


图 3–21

这种方法同样并不完美。其主要缺点是需要把密钥持续地在一个设备上存储。一旦丢失或损坏该设备，就会导致无法访问密钥。此外，如果用户忘记了加密私钥的密码，就无法重新获取它们。在这种情况下，你应该始终备份私钥并将备份文件单独存储。如果需要将密钥从一个设备转移到另一个设备，你将不得不手动执行此操作。

这类钱包的开发方式略有不同。与之前的情况类似，密钥处理逻辑仍在客户端进行。如果尝试创建跨平台应用程序，问题将保持不变，因为所有数据存储在客户端设备上，事实上，用户可以直接与网络通信以获取余额状态并发送和接收交易。密钥存储的安全要求更高。在使用不同平台时，通常会采用所谓的平台相关方法。例如，iOS 设备使用 KeyChain 可以安全地存储敏感数据。为了能够将密钥从一个设备转移到另一个设备，这类钱包提供了手动导入和导出密钥的功能。在最简单的情况下，它只是一只包含一个私钥的钱包，具有查看和输入采用着 WIF（钱包导入格式）编码私钥的功能。

这种方法的一个示例是 Bitxfy 钱包，它在用户的设备上存储并处理私钥。实际的交易数据通过由开发团队支持的可信节点接收。

**_使用多重签名的密钥存储_**

最后一个要考虑的方法是使用多重签名的密钥存储混合模型。这不是一个独立的方法，而是几种先前方法的组合，用于提高安全级别。在使用多重签名发送硬币时（图 3–22），需要几个不同私钥的签名；每个密钥可以独立于其他密钥在不同设备上存储和处理（我们将在第4.5节中更仔细地描述此机制）。


![alt_text](images/image22.png "image_tooltip")


图 3–22

例如，你可以实现“2-of-3”多重签名。在这种情况下，有三个密钥。其中一个密钥的存储和管理将由服务器执行，其余的将使用智能手机进行管理。为了确保交易的有效性，只需用其中任意两个密钥对其签名即可。不需要在设备之间传输密钥，你可以在一台设备上签署交易，然后将这个半签名交易发送到另一台设备上，用第二个所需的密钥进行签名。

根据对手模型（参见第3.1节），确保加密货币安全访问的最先进方法是将密钥保存在来自独立硬件供应商（如苹果、三星、华为等）的不同设备上，并使用独立开发人员的软件钱包。

使用多重签名的钱包示例包括 Bitgo 服务和 Electrum 钱包。然而，截至2018年撰写本文时，这些解决方案并不完美，因为它们使用起来比较困难。我们希望未来这些实现会变得更好，并且会基于它们开发出替代性的应用程序。

**_冷钱包、温钱包、热钱包_**

我们已经考虑了责任划分为数字钱包存储和处理密钥的基本选项。现在，让我们看看负责方又如何组织存储私钥和签署交易的流程的选择。有三种主要方法（图 3–23）：



* 热存储钱包
* 温存储钱包
* 冷存储钱包

_热存储钱包是指私钥存储和处理在与全球网络保持持久连接的设备上的数字钱包。_

_冷存储钱包是指私钥仅存储和处理在无法直接连接到全球网络的设备上的数字钱包。_

_温存储钱包是指私钥仅存储在支持连接到全球网络但不是持续连接的设备上，只在用户决定时才连接（例如，用于发送交易或更新状态）。_


![alt_text](images/image23.png "image_tooltip")


图 3–23 \


智能手机上的钱包应用程序以及许多个人计算机的数字钱包都可以归类为_热存储钱包_组。这些是最方便的钱包。然而，理论上，具有特殊能力的工程师可能会在这些钱包中找到漏洞。在这种意义说，冷存储钱包被认为是更安全的选择。

根据安全，介于热钱包与冷钱包之间，还有_温存储钱包_。此类钱包的开发者试图最大程度地减少钱包与其他数字世界的交互，但同时保留热钱包的某些便利性。

*****常见问题*****

_“把硬币存储在闭源代码钱包中的用户可能有一天发现他们的硬币不见了，这是真的吗？”_

是的，这是可能的。理论上，钱包开发者可以利用程序代码中的后门窃取用户密钥，这种情况不太可能被普通用户注意到。然而，值得注意的是，即使使用开源解决方案，这种情况在理论上也是可能的，但概率较低。

_“如果数字钱包的源代码是开放的，后门的可能性是否较低？”_

理论上是的。然而，你不应忘记，如果源代码是公开的，这并不意味着用户在安装前已经对其分析了。即使用户做了代码审计，也必须将其编译并安装到设备上，并禁用自动更新，否则他将不得不再次进行代码审计。总的来说，用户需要信任应用程序的开发者，特别是在涉及存储敏感数据的情况下。

_“与客户钱包连接到的比特币网络多少个节点？它是否始终连接到相同的节点？”_

这完全取决于钱包的具体实现和和其设置。一个钱包可以始终连接到网络上的一个可信节点，并且可以与多个它甚至不信任的网络节点通信，并对所有数据进行完整的扫描，以确保其符合协议规则。例如，Bitcoin Core 钱包的实现总是连接到不同的节点。这种实现的钱包甚至可以根据节点的总数、响应时间、网络延迟以及从节点接收错误数据的频率来偏好特定的节点。

_“将钱包文件存储的最佳方式是什么，以尽量减少与机密数据和用户私钥被盗的风险？”_

有很多种方法。为了提供最基本的防止黑客入侵的保护，以确保用户可以安全地存储资金（如果不涉及数百万美元），只需使用密码（如果可以设置密码）。然后，通过从密码获得的额外密钥，将加密机密数据，因此不会在设备上打开存储。

_“如果一个人在他的个人电脑上使用软件钱包，其他程序能窃取他的数字货币吗？”_

总的来说，它们是可以的。风险相当高，因此对于大额资金，建议使用更可靠的方式来存储和处理私钥。

_“如果私钥已经被泄露了怎么办？”_

在这种情况下，你应该停止使用私钥被泄露的钱包。如果违反保密性的原因不清楚，那么甚至应该拒绝使用适当的应用程序或设备 [39]。
