# [3 密码学与密钥管理](/chapters/volume-1/cn/3-密码学与密钥管理.md)

# 4 比特币运作的技术细节


## 4.1 比特币交易是如何运作的？

比特币中用户无需注册的特点大大影响了交易的格式，存储和处理与现有金融系统中的交易有很大不同。因此，比特币交易的独特格式旨在保持用户和验证者的匿名性。主要的区别在于交易如何相互关联（所谓的三重账务）、未花费输出的概念以及零钱（交易后所剩的钱）是如何形成的。我们将研究这些机制的运作方式及原因。


### 交易结构

从图 4–1 的示意图来看，一笔交易包括三个组成部分：标题、输入硬币和输出硬币。

进一步说，每笔交易在结构中可以包含多个输入和输出；它们的数量没有限制。在比特币中，受限的仅是交易的整体大小，它是最大区块大小的25%。例如，如果最大区块大小为 1 MB，那么最大交易大小为 250 kB。

正如图 4–1 所示，每笔交易包含一个输入与一个输出。输入包含对某些先前交易的引用（硬币来源）。输出是在当前交易中创建的，以用于花费硬币。

![图 4–1](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.1-simplified-structure-of-tx.png "图 4–1")

每个输入包含一个交易的创建者拥有他想要花费的硬币的证明。在比特币中，硬币并没有记录在任何余额中。相反，有一个指向收到硬币的交易的参考。这创建硬币所有权的链条，使得追踪硬币转移的历史变得容易。

每个输出包含支付金额和 _硬币使用_ 的条件，接收方必须满足这些条件，通过 _硬币所有权证明_ ，才能够进一步发送这些硬币。

让我们考虑曾经在比特币网络中确认过的一个特定交易的主体。图 4–2 以 JSON 格式呈现了该交易。

![图 4–2](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.2-example-of-tx.png "图 4–2")

> * _ScriptPubKey：包含币花费条件的字段_  
> * _ScriptSig：包含硬币所有权证明的字段_  
> * _比特币脚本（Bitcoin Script）：一种用于填写这些字段的特殊语言_

头部包含两个字段：交易版本和locktime参数（稍后将详细介绍）。交易还包含两个输入和两个输出。其中输入字段的体积最大。在输入字段中，字段 scriptSig 是最大的，因为它包含一个占用 64 字节的签名和一个占用 33 字节的压缩公钥。以序列化形式，整个交易占据 373 字节（网络传输的交易就是以这种形式）。

> **_注意：_** _序列化是将某些数据结构为位序列的转换过程。_

大多数情况下，硬币的使用条件会被编码成可读的比特币地址，在创建交易时，会被解码并在 _scriptPubKey_ 中指定。

如果你仔细研究交易输入（ 英文： _Transaction input_ ）结构（vin），你会看到图 4–3 所示的字段。在 _hash_ 字段中，指定了先前收到币的交易的标识符。 _Index_ 是前一笔交易的输出序号，其中将花费硬币。

![图 4–3](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.3-structure-of-in.png "图 4–3")

_ScriptSig_ 包含对币的所有权的证明。这个字段之所以被称为这个名字，是因为它通常包含一个数字签名，也可以包含一个用于验证这个签名的公钥。

下一个字段称为 _sequence_ 。它表示交易的版本，并由发件人设置。通过sequence可以替换已发送到网络但尚未确认的交易。假设用户创建了一笔交易，但出于某些原因尚未包含在区块中（例如，时间尚未到来或费用设置得太低）。用户决定修改此交易（例如，更新硬币接收者地址，指定别的接收者，添加更多费用，更改付款金额等），因此他创建了一个新的替代交易，用于支出与上一个相同的硬币，并且具有相同的输入。不同之处在于输入中指定的 _sequence_ 值增加了一。根据协议规则，确认此交易的验证人可以替换旧交易。之后，新交易很可能会被确认。

交易输出（vout）的结构包含两个字段：value表示用于接收者的硬币数量；而 scriptPubKey 则指定了硬币消费的条款（见图 4–4）。第二个字段 scriptPubKey 之所以有这个名称，是因为它通常包含公钥或公钥的哈希值。

![图 4–4](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.4-structure-of-out.png "图 4–4")

这样，传统支付系统中交易跟比特币交易的设计不一样。传统支付系统基本上传递一个主要信息，即从余额A到余额B的特定金额转移。而比特币交易是一组复杂的数据，其中包含了交易发起者拥有转移的硬币的证据。这种方法在特定情况下可能更可靠，但在容量方面要求更高。

比特币作为支付系统的有限容量成为需要解决的问题；随后被提出协议改进（隔离见证升级）。提议是将交易的 _硬币所有权证明_ 排除在外，并放入一个单独的 _见证数据结构_ 中（图 4–5）。通过这种方式，数据就无需添加到每个交易输入中，可以释放大量内存。因此，交易包含了所有必要的数据，包括硬币的来源和分配位置，但拥有权的证明存储在交易之外。在某些情况下，可以使用交易的主要部分，不需要见证数据（参见4.6）。

![图 4–5](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.5-simplified-tx-with-seg-witness.png "图 4–5")


### 未使用的输出

_未使用的交易输出_ （英文： _unspent transaction output_ ； _UTXO_ ） _是指包含未花费硬币的输出；这些硬币只能在新交易的输入中指定时才能被使用。_

我们已经考虑了交易的结构，正如所见，在比特币的协议级别上，没有传统的账户或余额；只有具有其输入与输出的交易。每个输出可能有两种状态：已花费和未使用。

未使用的输出可以跟现金相比。拥有比特币（BTC）就像拥有普通的货币钞票一样，你收到了但还没花出去。在打开并计算所有货币纸币之前，你无法确切知道你的钱包中有多少钱。当你拥有比特币钱包时，你应该计算所有发送给你的交易中的未花费输出，将它们相加，然后你才会知道你的余额。当然，大多数比特币钱包会自动为你完成这一操作，但形成“余额”的原则就如上所述。比特币输出与货币纸币的类比实质在于，当你支付的金额低于其面额时，你无法分割一张纸币；你需要支付特定面值的纸币，并且会收到一些面值较小的纸币作为找零。

尽管在比特币协议级别上没有余额，但地址的当前余额是所有发送到该比特币地址的未花费交易输出的硬币总和。应该理解的是，通常每个地址有两种余额：一种是有条件（很可能）确认的余额，另一种是未确认的余额。

在完整的比特币网络节点实现中，有一个单独的硬币数据库模块，用于存储和处理整个 UTXO 的实际状态。


### 收到找零与设置费用

假设用户曾经接受了 10 枚硬币的支付，现在想要只花费其中的 3 枚。事实上，在比特币中，你不能只花费部分硬币；你必须使用全部金额。

这个问题介绍了“找零”的概念。用户不能花费接收到的 10 枚硬币的部分，但可以向交易中添加多个接收者。因此，解决方案是用户向接收者发送 3 枚硬币，而将剩余的 7 枚硬币发送给自己；因此，“找零”是一个发给自己的输出（ _找零输出_ ）。用户得到了新的未花费的 7 枚硬币。

现在有必要澄清一下费用是如何工作的，因为上面描述的情况只有在交易最终确认后才是合理的。因此，有必要以某种方式激励完整节点的所有者来验证你的交易。这本质上就是费用的作用。

我们已经观察了交易结构，但您可能已经注意到，它并没有包括任何特殊字段来指示费用。然而，在比特币中，每个用户都有能力自行在交易中指定费用。

比特币协议中有一个非常简单和合乎逻辑的规则：所有交易输出的总和不得超过 _所有输入的总和_ 。交易前后的硬币数量保持不变；只是它们可以在不同的地址之间分配。

在比特币中，交易的费用由输入总和与输出总和之间的差异确定。想象一下你有 5 个硬币，并想花费其中的 2 个硬币。你创建了一笔交易，在交易中指定了一个输入，你之前收到5个硬币的特定交易的输出，并指定了两个输出。第一个输出将 2 个硬币作为某项服务的支付，而第二个输出将 2 个硬币作为找零发送到你的另一个地址。因此，你的交易中有 5 个硬币的输入和 4 个硬币的输出。因此，1 个硬币将被视为交易费用。

剩余的差额在交易确认并包含在区块中之前不属于任何人。当包含该交易的区块被创建时，创建者将能够以此作为奖励收取费用。


### 硬币转移的示例

假设鲍勃有一个未使用的交易输出（UTXO）拥有 100 比特币：他收到它们作为生日礼物。他决定使用这些硬币支付给爱丽丝和查理，这在图 4–6 中以示意图呈现。

![图 4–6](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.6-transfers-within-tx.png "图 4–6")

鲍勃创建了一个交易，其中有一个输入，他指的是他收到这 100 个比特币的交易，并且在交易中添加了两个输出：一个输出将 45 个比特币发送给爱丽丝，另一个发送 50 个比特币给查理。请注意，输入总和与输出总和之间的差额是手续费，在我们的例子中是 5 个比特币。

爱丽丝和查理可以随意支配这些比特币（图 4–7）。爱丽丝支付给园丁 20 个比特币。她指的是她收到 45 个比特币的交易（鲍勃的交易）并在当前交易中全部使用了这些比特币，将园丁的地址作为第一个收款人（20 个比特币，如下图所示），将自己的地址作为第二个收款人（同样是 20 个比特币）。5个比特币作为手续费。收到 50 个比特币的查理也花掉了他的钱：10 个比特币买新窗户，35 个比特币修车，并支付了 5 个比特币的手续费。

![图 4–7](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.7-using-tx-to-make-payments.png "图 4–7")

现在让我们想象一下，玻璃工和车间老板是朋友，并且同意给他们的共同朋友送礼物。他们决定每人花费 10 个比特币，并从当地艺术家那里购买一幅画。为此，他们需要创建一个共享交易，有两个输入：10 个和 35 个比特币，和两个输出：20 个比特币给艺术家，另外 20 个比特币作为车间老板的找零（图 4–8）。剩余的 5 个比特币作为手续费，我们假设由车间老板支付（比方说他对玻璃工买了一扇新窗户）。

![图 4–8](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.8-creation-tx-from-diff-senders.png "图 4–8")


### 比特币钱包中的交易创建

比特币钱包是如何运作的？在其运行过程中都发生了哪些典型的流程？典型的流程包括密钥对和比特币地址的生成，以及交易的生成、存储、签名和发送。为了获取关于新区块（即新确认的交易）的最新信息，比特币网络中的所有节点都同步。钱包显示当前余额并列出已完成的交易列表。此外，正确实现的钱包软件在生成交易时遵循特定的规则。

> **_创建交易的常见规则_**  
> * _为每笔收款和找零创建一个新地址_  
> * _为目标支付金额选择最优的UTXO_  
> * _按照通用规则对交易的输入和输出进行排序_  
> * _不考虑交易大小，都要包含最低手续费_  

抽象的旅行者手中有一组比特币未使用交易输出（UTXO）：1 BTC，3.5 BTC，0.3 BTC 和 0.4 BTC。这位旅行者准备开启新的旅程，唯一缺少的是支付交通费用（图 4–9）。已知单程车票价格为 0.5 BTC，而旅行者手中没有合适面值的硬币。因此，钱包软件使用一种算法，在旅行者的钱包中寻找最佳的 UTXO 组合：0.3 BTC 和 0.4 BTC，并创建一笔新交易引用这些硬币。

![图 4–9](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.9-choosing-proper-outputs.png "图 4–9")

新交易将包含两个新的输出：零输出将支付 0.5 BTC 的车票费用给售票员，第一个输出将 0.1 BTC 作为找零返还给旅行者。显然，交易费用为 0.1 BTC。

交易创建并由钱包签名后，应在网络上传播。为此，比特币网络中有一个默认机制，类似于在现实世界中通过口口相传传播有趣的新闻。

考虑比特币网络的图表（图 4–10）节点之间是随机连接的。因此，某个网络节点接收到旅行者的交易，他想用一些硬币支付车费。节点独立验证交易，将其添加到其内存池中（如果交易被认为是正确的），然后将其传输到最近的节点。每个最近的节点都会执行相同的操作（也就是说，在验证交易后，它们都将交易传递给它们最近的节点）。结果，交易最终在整个比特币网络中传播。

![图 4–10](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.10-propagation-of-tx.png) "图 4–10")

然而，这个过程不能永远持续下去。请注意，每个交易都用其哈希值进行标识。使用这个值，每个节点都可以确定它是否已经验证了某个交易。如果一个节点接收到一个已经在其池中的交易（即该节点已经验证过的交易），它就不会将该交易转发给其他节点。这种方案可以避免无限的交易传播循环。

我们已经提到，使用特定的地址，你可以追踪比特币中所有支付的整个历史——硬币来源的历史。就像在上面的例子中（参见“硬币转移的示例”部分）：有 100 个硬币，在不同的地址之间以某种方式进行了转移。拥有完整的数据库副本，你可以追溯交易历史，直到获得硬币的那笔交易。

为了防止你在比特币中的整个财务历史被完全披露，你应该怎么做？想象每个比特币用户只有一个地址，用于接收和花费硬币。一旦披露了该地址与特定用户身份之间的关联，就可以追踪他在比特币中的整个财务历史。

图 4–11 基本上展示了区块链中不同交易之间的关系。恢复硬币来源的历史并追踪整个用户获得了支付的交易链是一件并不困难的事情。

![图 4–11](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.11-link-between-txs.png "图 4–11")

> **_注意：_** _在图 4–11 中，按顺序为零的交易是 coinbase 交易；它包含了由协议规则提供的奖励，这是给创建此区块的验证者的（更多细节请参见4.3）。Coinbase 交易包含一个名为 coinbase 成熟度的特殊参数，根据比特币协议规则，这个成熟度为 100。这意味着在具有 coinbase 交易的区块之后，必须再添加 100 个区块到主链中，这样挖掘该区块的参与者才能花费 coinbase 交易输出中的硬币。在上述方案中，coinbase 成熟度等于1。_

在大多数情况下，未经授权的人追踪财务历史对用户来说是不可接受的。因此，有一种方法可以大大复杂化解开所有交易链、追踪支付历史并确定特定用户拥有特定硬币的所有权：大多数比特币钱包会自动为每次新的收款以及收到找零创建一个新的地址。


### 锁定时间机制

有一种方法可以通过时间限制比特币交易的确认，即使它已经在网络上发布，验证者也无法确认它直到某个特定时刻。为此，使用了特殊参数 _锁定时间_ （ _locktime_ ）。它是比特币每个交易标题中包含的 4 字节值。该值允许指定延迟交易确认的时刻。 _锁定时间_ 参数可以设置为两种数据类型中的一种：Unix 时间戳格式的时间或区块高度。根据协议规则，如果设置了锁定时间参数，验证者在特定的时间点或出现特定高度的区块之前，无法将该交易包含在自己的区块中。

这就是延迟交易机制的实现方式，如果你假设你潜在地将不使用未使用的硬币（例如，密钥将丢失或用户无法达成共识并且无法满足硬币花费的条件）。在这种情况下，你创建所谓的备用交易，一旦经过了指定的时间间隔，这些硬币将被转移到“备用”地址；在那个时刻之前，你仍然可以像往常一样使用这些硬币。图 4–12 中以示意图的方式展示了这个过程。

![图 4–12](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.12-tx-with-delayed-confirmation.png "图 4–12")

假设在第十八个区块中创建了一个特定的未使用输出（UTXO）。如果花费此UTXO的交易具有参数 locktime 等于 404（并且已经通过了预先的验证），它将作为未确认的状态保留在 mempool 中。它可以保留在那里，直到超过 404 的区块高度进行确认，或者它可以被具有更高手续费的相冲突交易替换（例如，使用相同 UTXO 的交易且包括更高的手续费）。

> **_注意：_** _用户还可以将交易以打印形式存储在纸张上。例如，他没有互联网连接，无法进行恢复。在这种情况下，用户可以离线创建并签署交易，然后将其打印在一张纸上。接下来，他将打印出来的交易发送给一个有互联网连接的值得信赖的方（也可以是硬币的接收者），后者将把纸上的数据（已经签署的交易和接收者地址）转移到自己的设备上，并在网络上传播交易以确认。_


### Off-chain协议

可以创建一系列随后可以确认的硬币支出链。在图 4–13 中的右侧，可以看到已经创建并包含在链上的区块链。在左侧，可以看到链下交易——已经引用了特定链上交易的 UTXO，但尚未添加到主链（例如，由于设置了锁定时间参数）。此外，你还可以创建任意数量的交易，相应地引用离链交易的输出。这将导致一个或多个替代的硬币支出链。但是，在前置交易（引用它的输出的交易）被添加之前，任何离链交易都不能被添加到主链的区块中。

![图 4–13](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.13-how-off-chain-protocol-work.png "图 4–13")

链下交易链中哪一个会获得确认取决于验证者。其中一些将创建一个新的区块，其中一个替代链将被部分或完全确认。因此，即使交易未被确认，也不会阻止硬币的使用，这意味着您可以基于此构建其他交易链。这是离链协议的主要原则。


### Signature hash types

比特币交易签名过程可分为两个步骤。第一步是创建待数字签名的消息。第二步是计算数字签名。

事实上，用户可以仅签署交易的一部分，以便稍后进行修改。通常情况下，当交易包含多个输入时，这种操作是有意义的，而这些输入属于独立的用户。

我们来看一下哪些交易部分可以由签名覆盖，如何为每种签名类型生成交易模板，以及何时应使用特定的签名类型。有三种基本的签名类型： _SIGHASH\_ALL_ 、 _SIGHASH\_NONE_ 和 _SIGHASH\_SINGLE_ [40]。

_SIGHASH\_ALL_ 是最常用的类型。它涵盖了交易的所有输入和输出，并意味着除了签名脚本（scriptSig）之外，交易的任何元素都不能进一步修改。

_SIGHASH\_NONE_ 允许签署所有输入但不签署任何输出。在这种情况下，任何人都可以在交易输出被另一种类型的签名锁定之前修改交易输出。创建一个只有一个输入并使用 _SIGHASH\_NONE_ 签名类型的交易是没有用的，因为验证者可以简单地重写交易的输出，导致硬币被转移到错误的地址。这种方法很方便如果你创建一个带有多个输入的共享交易，并且只有一个签名者使用 _SIGHASH\_ALL_ 就足够了。

_SIGHASH\_SINGLE_ 允许签署所有输入与只有一个输出，其索引与包含签名的输入的索引相匹配。这种情况意味着只有当其他所有交易参与者也使用他们的比特币时，用户才准备支付相应输出地址的费用。这种情况什么时候会有用呢？例如，夫妻想支付5比特币供孩子上学。假设丈夫有一个未使用的3 BTC输出，妻子有一个未使用的 2.5 BTC 输出。他们达成一致并创建一个共享交易。首先，丈夫提交他的未使用交易输出（UTXO）到输入中。然后，他签署了所有输入和输出，其中指定了 5 BTC 的金额和教育机构的地址。妻子同意丈夫设定的条件，所以她可以签署交易（使用 _SIGHASH\_ALL_ 类型或 _SIGHASH\_SINGLE_ ），但在此之前，她需要指定另一个输出，支付 0.5 BTC  到她的地址作为找零。


### 写入任意数据到区块链

随着比特币会计系统越来越流行，其用户开始思考如何利用它来记录不仅仅是币的记账数据，还有完全任意的数据。

更深入一点，比特币区块本质上包含两个部分：区块头和交易数据。区块的标题包含严格的80字节数据，并且每个字段都经过验证，这意味着你不能在这里添加任意数据。然而，比特币交易的结构允许你在其中写入数据，即在其字段中。所以，让我们更详细地考虑这一点（见图 4–14）。

![图 4–14](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.14-arbitary-data.png "图 4–14")

在 _交易标题_ ，有 4 字节的数据用于表示交易的版本。

还有一个名为 _lock\_time_ 的字段，可以任意设置交易不能被添加到区块中的时间点。在这种情况下，需要记住这会严重限制交易的确认时间。不过，你实际上可以通过指定一个已经过去的时间来操纵这个值。这样一来，你只能输入大约 1 字节的任意数据，与交易的大小相比，这很少。因此，这种方法被认为是低效的。

_交易输入_ 包含先前交易的哈希值，这些值必须与已存在的交易相匹配；先前交易的输出索引也必须相同。

拥有硬币 _所有权的证明_ 的数据必须是完整的，因此无法修改它们。

关于 _交易输出_ ，情况更为有利。接收方有一定数量的硬币，是在一定的可接受范围内任意设定。换句话说，可以通过调整输出金额来输入任意数据。此外，还有一个地址，而在交易验证期间，并不会检查该地址是否已正确生成；它只是尚未发布的数据的 20 字节哈希值。因此，可以任意设置它们。有很多实际的例子，其中冗余输出被添加到交易中，并且注入任意数据而不是地址； 这些任意数据与某些第三方应用程序相关（例如交易者的匿名信号以及歌曲、诗歌等）。这些第三方应用程序又能够验证这些数据确实存储在比特币会计系统中。

比特币协议开发者注意到了对于写入任意数据的需求，因此他们添加了一项特殊的操作。它可以用来指定硬币的使用条件，允许将任意数据注入输出中。然而，带有这种操作的交易输出始终被验证规则视为无效。这意味着带有此类未使用交易输出（UTXO）的硬币无论数量多少都无法被花费。这个操作被称为 OP\_RETURN，在其输出验证函数中会立即返回 FALSE 值。使用此操作的输出允许添加多达80字节的任意数据[42]。因此，许多构建在比特币之上的应用程序，包括实现匿名数据传输的应用程序，都在专门使用这个操作。

其中一个是 Colored Coins 协议，这个协议是一种比特币钱包的附加逻辑。通过 Colored Coins 协议，您可以用额外的（比特币冗余的）数据来补充交易，这些数据为硬币“着色”并表明它们的附加功能。这些颜色与特定逻辑相关联：首先是交易验证的特点，当然还有在这个交易中转移的硬币的目的。这个行动的想法是一旦一些小额比特币被着色，它们开始代表的价值不仅是比特币，还可能代表公司的股票等。如果保存这些额外数据，支持 Colored Coins 协议的修改过的钱包将检测到特定硬币的额外目的，并显示它们不同的价值。与此同时，这样的硬币可以像“普通”的比特币一样被转移。

有些协议，比如 Omni Layer 与 Counterparty，运行在比特币协议之上，允许其用户发行自定义代币（并进行交换和交易）。这些协议支持它们自己的交易逻辑、共识机制、交易数据结构和验证规则。它们的特点是这些协议中的交易被序列化并分成 80 字节的数据集。这样做是为了把这些交易放入比特币交易中。然而，使用这些协议的用户需要支付额外费用为他们的交易存储在比特币中，因为这类交易通常“绑定”到多笔比特币交易中。因此，在 Omni Layer 或 Counterparty 协议中，交易价格会比比特币更中高。


### 摘要

一个钱包可以生成和处理无限数量的地址。这通过增加外部追踪交易历史的复杂性来提高用户的隐私。值得注意的是，收到在一个钱包或地址上的硬币并不合并，并且不记录在数据库的一份余额中，它们是单独使用的。你可以在一个钱包中有不同的硬币：每个硬币都将与其自身的历史相关联。你可以为不同的目的使用它们，并且不向任何用户透露有关硬币所有权的信息。

每个交易输出都与特定的地址相关联。换句话说，硬币根据其支出的特定条款被锁定。例如，硬币不仅可以发送到普通地址，还可以发送到只有在满足特定条件时才能使用硬币的地址。你可以指定你的硬币可以由提供方程解的人使用（例如，如果方程是 5 + 7，那么在 _scriptSig_ 中写入 12 的人将能够使用硬币）。这些条件可以是别的：提供一个数字公钥、一个哈希函数的原像，或者一个特定数学问题的解答（更多细节请参见4.5）。

### \*\*\*常见问题\*\*\*

_“未确认的交易锁定了账户上的金额吗？”_

不会。在交易确认之前，你可以创建另一个交易，其中包含不同的条件来花费相同的硬币。在所有备选交易中，只有一个交易会被视为有效，并最终被包含在一个区块中。将特定交易包含在一个区块中的决定是由创建区块的验证者做出的。如果相应的区块被其他验证者接受，那么包含在区块中的交易将被视为已确认。

_“收款方是否能增加交易费以促进其确认？”_

接收方无法在收到硬币的交易中增加交易费，但他可以创建一笔使用来自该未确认交易的硬币的交易，并在这个交易中指定更高的费用，这将促使验证者确认这两笔交易。这个功能已经实现，并被称为 child-pays-for-parent(CPFP；中文：“子付父交易”）（见4.7）。一些钱包与大多数验证者支持此功能。你可以用新交易支付旧交易，以便这两笔交易都被包含在区块中。

_“如何把费用更明智地计算？”_

在比特币中，费用不是根据交易的出价或支付金额的百分比来计算的；它取决于比特币网络的活跃程度，也就是网络中的交易数量和交易的字节大小。首先，你应该关注将1字节数据添加到比特币数据库的成本，然后将这个成本乘以您交易的字节数。有很多互联网资源可以计算添加数据的价格。通常，根据网络的当前负载，这个价格在 10 到 500 聪每字节之间浮动。在某些情况下，钱包会使用此价格的动态值，而在另一些情况下，它们使用固定值。有时，用户可以自行指定费用的值。

_“验证者是否可以不管考虑费用的大小还确认交易？”_

验证者可以自由选择要确认的交易。他们可以过滤小额交易，只添加较大的交易，或者只添加他们朋友的交易，甚至选择费用较低的交易——这都取决于拥有者的能力与偏好；拥有者独立使用自己的软件。最多的，验证者追求利润，只确认为其数据单元支付最高费用的交易。然而，如果你是一个验证者，并且想确认没有支付费用的交易，可以自行确认那些不支付费用的交易。最好在网络上不传播这样的交易，而是仅将它们添加到自己的区块中。

_“为什么钱包不包含与一笔交易把硬币发送给多个接收者这个功能？”_

事实上，钱包通常允许创建两个输出的交易：用于支付和找零。钱包很少实现一次性在单个交易中包含多个接收者的功能，因为这种情况很少见。但是，在比特币核心、Electrum 和其他一些桌面钱包中，实现了这种功能，所以你可以向交易中添加尽可能多的接收者。你还可以选择以前收到的比特币并决定要使用哪一笔进行支付。因此如果你需要一种灵活的创建交易的方式，那方式是实现的。

_“如果可以把交易链的追踪弄复杂，那么混合器的目的是什么呢？”_

事实上，生成新的地址有效地增加了链路追踪的复杂性，但并未完全排除这种可能性。有一些方法在一定概率下可以恢复用户之间的实际币分配情况。集中式的混合器只是其中的一种选择，但与其他选择相比，它被认为是不可靠的，因为它不是无需信任的（有关更多详情，请参阅7.2）。

_“我可以创建两个不同的交易来使用相同的比特币吗？”_

可以的。在这种情况下，会出现两个相互冲突的交易。你可以使用着参数 sequence 指定规则其中一个交易有更高的优先级为被添加到区块中。如果没有设置这些规则，验证者将自行决定将其中之一添加到区块中。

_“如何最优地创建交易以减少费用？”_

需要优化地选择输出：你可以手动选择或使用具有特殊算法的钱包。类似于人们在商店购物时选择现金纸币。使用两张（价值 20 美元和 10 美元）纸币支付 30 美元要比使用 30 张价值1美元的纸币更方便。同样地，使用比特币时，需要优化地选择未使用的输出。如果你想一次支付多人，最好是通过一笔交易而不是分开的交易。在这种情况下，一笔交易的大小将小于单独交易的总大小，即使它们使用相同的UTXO集合。这是因为找零输出只会被包含一次。通过优化数据，可以节省交易费用。


## 4.2 比特币中的挖矿

比特币的创造者面临的任务之一是确保在一组无法识别且彼此不信任的参与者之间实现数据同步。现有的共识建立方法不太合适，因为攻击者可以创建虚构的参与者并代表他们行事，向诚实参与者强加他自己的交易历史版本（即所谓的 Sybil 攻击）。因此，这个任务是通过一种方式解决的：虽然并不保证交易历史的最终性，但在正常情况下使攻击经济上不划算。这个想法是，与其由大多数参与者对交易进行简单投票，不如要求投票者提供对实物资源所有权的证明（即工作的证明），这代表了实际金钱的直接成本。

因此，要使其观点占据主导地位，攻击者需要的资源比所有其他诚实参与者加起来的更多。从某种意义上说，挖矿扮演了一个完全诚实的轮盘的角色，它指向了（提供工作证明的参与者中）获得创建新区块权利并获得其工作奖励的人。

在本小节中，我们将考虑比特币中的挖矿机制及其在分散环境中的作用，以及它解决的特征和任务。


### 比特币中挖矿的目标

_比特币中的挖矿是创建区块并确认交易的过程，这将获得一定数量的硬币奖励_ [43]。比特币的挖矿有几个目标。其中一个目标是激励用户运行网络节点，支持支付网络的正确运行。另一个目标是保护比特币的交易历史免受更改。成功创建区块的用户将根据协议规则获得一定数量的新比特币。挖矿还解决了比特币在用户之间公平分配的问题：任何拥有电脑的人都可以参与。

> **_问题挖矿解决了_**  
> * _分散环境下的决策制定_  
> * _选择交易历史的主要版本_  
> * _交易确认_  
> * _发行量_


### 网络节点的分类

比特币网络可以如图 4–15 所示的图表为表示。独立的个人与组织维护着全节点，但其中只有少数参与挖矿（也被称为节点验证者）。

![图 4–15](/resources/img/volume-1/4.2-mining-in-bitcoin/4.15-scheme-of-bitcoin-network.png "图 4–15")

网络上有许多用户，每个人都有自己的目标。有些人部署了全节点并进行挖矿，从而积极支持网络；有些人只是存储与处理所有交易；有些人作为支付网关的运营商工作，还有一些人没有节点，只是使用钱包，不直接参与交易的确认。因此，比特币网络的所有节点至少可以分为三组（见图 4–16）。

![图 4–16](/resources/img/volume-1/4.2-mining-in-bitcoin/4.16-classification-of-nodes.png "图 4–16")


### 资源密集型问题的概念

比特币中 _资源密集型问题_ 的本质在于找到经过SHA-2算法得到的256位长度哈希值的原像。问题的解决只能通过暴力破解找到，因此需要大量资源。换句话说，它需要对输入值进行排序，直到找到哈希后得到某种模式的结果（见图 4–17）。

![图 4–17](/resources/img/volume-1/4.2-mining-in-bitcoin/4.17-brute-force-search.png "图 4–17")

此外，该哈希值必须满足一定的难度参数。根据比特币协议的规定，最终哈希值中前导零高位十六进制数字数量以及随着难度参数增加。

难度参数每 2016 个区块重新计算一次，同时对最大变化施加了一定限制（这是为了防止短时间内难度激增）[44]。难度重新计算算法会将最近 2016 个区块的创建时间与两周的时间进行比较，即 1,209,600 秒。如果创建区块的时间少于过去两周的时间，则难度参数会相应增加；反之，如果时间超过两周，则难度会相应减少。

> **_注意：_** _难度参数不能增加或减少超过 4 倍。_
> 
> _每个区块的资源密集型问题是独一无二的，因为区块中的数据是创建新问题的输入。_

> * _无法窃取有人的问题解决方案并应用到你的区块上。_  
> * _无法在没有上一个区块的数据的情况下创建新的区块。_

在比特币的背景下，资源密集型问题也被称为 _工作证明_ (Proof-of-Work problem，PoW） _问题_ ，因为其解决方案是证明区块的作者已经完成了符合指定难度参数的特定工作。

> **_PoW问题的要求_**  
> * _能够独立设置任务_  
> * _解决方案的验证必须非常快速_  
> * _网络内的任何人都可以验证解决方案_  
> * _无法预测未来问题的设置_  
> * _每个参与者的区块任务都不同_  
> * _任务的难度对所有参与者都是相同的_  
> * _解决任务的成本与难度参数成正比_

基于上述信息，可以公平地说任何人都可以最先创建新的区块；只是每个人的概率不同，这主要取决于参与者所拥有的计算能力。

由于每个参与者形成自己的下一个区块版本，因此每个参与者的任务都是独一无二的。然而，这个任务的难度对所有人来说是相同的。鉴于问题只能通过暴力破解技术解决，每个人首先解决它的概率将随着其计算能力份额在网络中所占比例的增长而增加。

挖矿获得比特币，这实际上是为了维护分散系统的安全和可靠运行而收取的费用。原则是提供复杂问题解决方案证明的参与者有权确认交易并获得奖励。有越多独立和诚实的验证者参与网络，比特币就越可靠[45]。

因此，这种简单的激励人们挖矿的机制会产生赚取更多收入的欲望，从而刺激企业家购买和推出更多挖矿力。他们在竞争奖励，因此资源密集型问题的复杂性也会增加[46]。


### 区块创建的频率限制

协议规定一个平均区块创建时间为 10 分钟的规则。为了确保这一点，对于区块创建的难度参数将每 2016 个区块重新计算一次（考虑到每个区块的创建时间大约为 10 分钟，创建 2016 个区块将大约需要2周的时间）。因此，如果网络容量因某种原因急剧增加，以至于 2016 个区块的发现比 2 周要早得多，那么难度参数会增加以规范区块创建的频率。这是为了保持区块创建的平均时间接近指定的 10 分钟，这对于比特币可以减少出现孤立区块的数量是非常重要。


### Orphan blocks

在创建新区块的众多验证者遍布全球[47]。由于数据传输通道中的消息传递分布并非瞬时完成，网络节点之间可能存在一定的同步延迟。简单来说，位于同一大陆的节点比其他大陆上的节点更快地同步其数据库状态（即新创建的区块），导致出现延迟问题。因此，可能出现不同大陆的本地节点数据库存在不同的结束状态的情况（类似于我们在第2.5节描述的杰克·斯帕洛船长与他的船员的欺骗情景）。

如你所知，每个验证者选择他认为正确的区块（例如，先收到的那个），将其添加到自己的数据库副本中。接着，基于最后添加的区块，他开始创建一个新的区块。高度相同的区块彼此竞争，以成为主链的延续。哪条链“获胜”取决于创建它们所消耗的计算能力。最终，“获胜”的链会延伸主链，而备选链中的所有区块都成为 _孤儿块_ 。 _Orphan blocks_ （中文： _孤儿块_ ）是有效的区块，但它们无法进入主链。孤块中的交易是正确的；它们可以被确认并添加到一个区块中（随后加入主链）。

有时 orphan blocks 的出现会带来不良影响。其中之一是，创建了后来成为孤块的区块的验证者将失去他的挖矿奖励（图 4–18 显示了从 2014 年 3 月到 2017 年 7 月期间产生的孤块数量[48]）。

![图 4–18](/resources/img/volume-1/4.2-mining-in-bitcoin/4.18-orphan-blocks-freq.png "图 4–18")

此外，大量 orphan blocks 的出现可能增加了 51%攻击的可能性。这是因为网络的全部计算能力分布在相互竞争的替代链之间，从而使恶意行为者更有可能控制超过一半的处理能力。正如我们在2.5节中提到的，51%攻击的结果可能是双重支付（也就是说，对手可能能够多次使用相同的硬币）。值得注意的是，比特币中难度参数每 2016 个区块重新计算的目的之一是平衡验证者的力量，从而减少出现孤块的数量。

> **_注意：_** _有时人们会混淆以下两个概念：orphan block 与 stale blocks（中文：陈腐区块）。实际上，这些术语是不同的。Orphan blocks是正确创建的块，但它们存在于被抛弃的链中。Stale blocks 是不完整的块，甚至没有进入链；这些块的创建者没有完成它们，因为另一个验证者创建了一个正确的块（是第一个解决了特定的资源密集型问题）。_


### 双花攻击

我们可以指出一种任何财务会计系统都必须防范的攻击方式，即所谓的 _双花攻击_ （英文： _Double-spending attack_ ）。其核心是不良行为者将相同的资金花费两次（或更多）。在加密货币的背景下，这意味着用户将相同的硬币发送给两个（或更多）不同的接收者，以便它们都接受支付。当然，并不会有两倍的硬币，但发送者可以试图欺骗接收者，让他们相信已经拥有这些硬币。

在比特币的背景下，敌对方可能会采用几种方法实施双花攻击。其中最常见的一种方式是一个人有可能在维护比特币网络的节点软件中找到漏洞，从而在技术上允许他双重支付他的硬币。另一种可能性是当至少 51%的挖矿算力属于一个方（组织、团体等）时。在这种情况下，这一方可以轻松通过其多数的计算能力对交易进行审查。

作为双重支付攻击的一个例子，想象一下一个名叫塔拉斯的用户。他想在E1互联网商店购买一台价值4比特币的电脑，同时还想在E2互联网商店购买一部同样价值的手机。问题在于塔拉斯只有4个比特币。由于他是一个狡猾的人，他决定执行一个双重支付攻击。（图 4–19）。

![图 4–19](/resources/img/volume-1/4.2-mining-in-bitcoin/4.19-conflicting-txs.png "图 4–19")

所以，塔拉斯创建了两笔交易。在第一笔交易中，他将硬币发送到E1的钱包，而在第二笔交易中，同样的硬币被发送到E2的钱包。这些交易显然是冲突的，不能同时被确认。因此，塔拉斯将第一笔交易传播到网络中，并保密第二笔交易。

当E1等待第一笔交易完全确认时，塔拉斯迅速创建一个区块，其中包含了他的第二笔冲突交易（以及可能的其他用户未确认交易）。为了使具有冲突交易的区块按照比特币协议正确，塔拉斯在这个区块中指向的是他仍然拥有4个比特币时的链状态。

接着，塔拉斯立即开始挖矿，以创建基于包含 E2 交易的那个区块的新区块。他的想法是秘密构建一个替代链，将同样的 4 个比特币发送到另一家名为 E2 的网上商店。显然，在第一家网上商店 E1 接受计算机款项之前，他不会在网络上公布这个替代链（见图 4–20）。

![图 4–20](/resources/img/volume-1/4.2-mining-in-bitcoin/4.20-acceptance-of-payment-by-the-shop.png "图 4–20")

当 E1 网上商店确保支付已提交（交易已获得足够的确认），它将计算机发送给塔拉斯。不浪费时间，塔拉斯发布了他的替代链。如果此链超过其他验证者的链，所有节点将切换到它，并将其视为主链（见图 4–21）。这只有在假设塔拉斯控制比特币网络中超过一半的计算能力时才可能发生。

![图 4–21](/resources/img/volume-1/4.2-mining-in-bitcoin/4.21-doublespending.png "图 4–21")

根据这个替代链，现在 4 个硬币属于向塔拉斯发送智能手机的 E2 网上商店。由于前一个链条中的第一笔交易现在被视为无效，这意味着 E1 将不再拥有塔拉斯最初的付款，因此将失去这笔钱（见图 4–22）。如果情况是这样的话，我们可以确定塔拉斯进行了 51%攻击，结果使他对硬币进行了双重花费。

![图 4–22](/resources/img/volume-1/4.2-mining-in-bitcoin/4.22-result-of-attack.png "图 4–22")
 

### 特定设备的出现

随着时间的推移，人们逐渐意识到专门的设备可以帮助更有效地进行挖矿[49]。在币价快速增长的时期，挖矿成为了一项有利可图的活动。人们竭力获取尽可能多的计算资源，以便在解决特定 PoW 问题的同时与其他人竞争获得奖励。很明显，在传统计算机的中央处理器上解决这个问题并不高效。因此，在比特币的最近历史中，我们看到了其他方法的采用。

> * _CPU—(英文：central processing unit）中央处理器（2009–2010）_  
> * _GPU—(英文：graphics processing unit）图形处理器（2010–2012）_  
> * _FPGA—(英文：field-programmable gate array）现场可编程门阵列(2011–2013）_  
> * _ASIC—(英文：application-specific integrated circuit）专用集成电路（2012–至今）_

后来人们想到在 GPU 上进行计算，因为这样可以并行地进行多个流的搜索，并且能耗较低。为了实现这一点，资源密集型任务的源代码被调整以适应 GPU。从那时起，对更节能的采矿设备的需求逐渐增长。因此，出现了专门设计与生产用于解决统一任务的优化芯片（ASIC）的公司（图 4–23）。

![图 4–23](/resources/img/volume-1/4.2-mining-in-bitcoin/4.23-mining-equip.jpg "图 4–23")

首批这类芯片于 2012 年开始出现。它们的处理能力大大超越了普通计算机（高出数千倍）。财务上的好处吸引了许多参与者，他们的目标是增加自己的运算能力（哈希率）。慢慢地，这个趋势开始类似于算力的竞赛。下面的图表（图 4–24）显示了比特币网络中哈希率随时间增长的情况[50]。

![图 4–24](/resources/img/volume-1/4.2-mining-in-bitcoin/4.24-hashrate.png "图 4–24")

鉴于比特币中的难度参数是永久性调整的（图 4–25）[50]，所有参与者必须不断改进他们的采矿设备，以更节能地解决他们的任务。

![图 4–25](/resources/img/volume-1/4.2-mining-in-bitcoin/4.25-difficulty.png "图 4–25")


### 矿池及其任务

假设网络上有百万台相同的计算机。在这种情况下，一个计算机找到区块的概率将是 0.000001。因此，具备这样算力的设备所有者平均每一千万分钟（略大于 19 年）才能创建一个区块。

显然，没有人对于这个长达 19 年的怀疑性投资周期不满足。因此，人们将结合他们的挖矿算力，以更快地解决一个共享的问题，然后分配奖励。因此，比特币矿工开始在矿池中合作。

_矿池是一组挖矿设备所有者共同解决一个共享问题的集合体，通常有一个领袖来代表该池。_ 领袖是创建区块并为组内所有参与者分配任务的人。如果其中一位参与者找到了解决方案，奖励将按照他们各自参与设备的算力比例分配给所有成员。因此，挖矿池的成员获得的奖励规模较小，但频率更高，比起独立工作，他们可以更经常地获得奖励（图 4–26）。

![图 4–26](/resources/img/volume-1/4.2-mining-in-bitcoin/4.26-comparing-solo-and-pool-mining.png "图 4–26")

在这种方式中，我们需要注意一个重要的细节：矿池的参与者都不决定要将哪些交易包含在区块中。他们所做的只是解决那个资源密集型任务。因此，如果有参与者注意到领袖以可疑的方式确认交易（或者可以说是主观的），他唯一能做的就是连接到另一个他认为更诚实和独立的矿池，并且进一步与后者合作。矿池参与者面临的另一个风险是，他们的领袖可能会简单地忽略支付他们应得的奖励份额。

下面的两个图表显示了比特币网络中验证者之间计算能力的分布[51]。一些验证者透露了他们的身份，而另一些则没有（“未知”）。在理想的情况下，就 _分散化和独立决策而言_ ，验证者应该保持匿名（这并不能被视为一种确保的方法；然而，下面我们会解释为什么）。让我们分析一下在短时间内情况的变化。

当从图表（图 4–27）中看到时，匿名验证者的总处理能力实际上并未超过 1%（提供的数据截至 2018 年 8 月底仍然有效）。大多数区块由公开知名的节点验证者创建，这些节点领导着矿池。还可以看到，像 BTC.com、AntPool、SlushPool 和 BTC.TOP 这样的矿池积累了超过一半的总处理能力。虽然迄今为止没有阴谋问题，但当前的情况并不是应用分散原则的完美范例。

![图 4–27](/resources/img/volume-1/4.2-mining-in-bitcoin/4.27-distributing-the-mining-capacities.png "图 4–27")

从技术上讲，它们可以联合进行51%攻击，但如果发生攻击，它会立即在网络上显露出来。这很可能会激起社区的愤怒，这些矿池的参与者会转向另一个有另一位领导者的群体。矿池将失去声誉、客户与业务。

十分有趣的是，在 2018 年 12 月初（图 4–28），匿名验证者的份额从不到 1% 增长到了 22.6%。一方面，从分散系统的角度来看，这种情况可能看起来有利。但是，分析可能的威胁后，你会意识到验证者是匿名的并不一定意味着它们彼此独立。因此，从技术上讲，它们有可能组成匿名矿池，这些矿池难以去匿名化，并且在达到一定规模后可能进行双重支付攻击。这样的矿池可以由一组验证者或者甚至是一个人拥有。

![图 4–28](/resources/img/volume-1/4.2-mining-in-bitcoin/4.28-distributing-th-mining-cap-december.png "图 4–28")


### 挖矿统计与能源消耗评估

2018 年 4 月份的时候，挖矿消耗的电力估计为每天 110 GW，而参与挖矿的企业家们的总日利润为 32 百万美元[52; 53]。这些利润中，手续费占了 21% ，即大约五分之一。在前一年，平均交易手续费的范围在0.1美元到 40 美元之间。目前比特币区块链中所有数据的大小超过 175 GiB。

截至 2018 年 8 月 31 日，比特币挖矿消耗的电力估计为每天 200.3 GW，即每年 73.1 TW。

为了让这个数字更具体化，我们来看一下当时（2018 年 8 月）世界上最强大的发电厂能产生多少电。到2017年为止，中国三峡大坝[113]的发电量指标为 97.6 TW。图 4–29 中的图表同样生动。 它显示了比特币与一些国家的能源消耗指标的比较。你可以看到，比特币所需的总能量超过了捷克共和国、智利或奥地利的国家需求[51]。

![图 4–29](/resources/img/volume-1/4.2-mining-in-bitcoin/4.29-energy-consumption.png "图 4–29")

根据这些数据，计算得出比特币中一笔交易的确认大约消耗 921千 kW 时的电能。相当于为 30 个美国普通住宅供电一天所需的电量。在图 4–30 中，可以看到比特币中一笔交易消耗的电能与 Visa 的 10万笔交易进行对比。根据图表的数据，可以得出一笔比特币交易的成本超过了 50万笔 Visa 交易。

![图 4–30](/resources/img/volume-1/4.2-mining-in-bitcoin/4.30-bitcoin-vs-visa.png "图 4–30")

实际上，比特币的能源消耗并非总是增加。如果你观察从 2018 年 8 月到 12 月的数据变化[54]，会发现从 11 月中旬开始急剧下降，降至每年 53.04 太瓦时（图 4–31）。

![图 4–31](/resources/img/volume-1/4.2-mining-in-bitcoin/4.31-energy-in-bitcoin.png "图 4–31")

尽管比特币看似浪费能源，但可以说这种成本并非毫无来由。从本质上讲，这是我们为了比特币的一个主要特性付出—— _防止交易审查所的代价。_ 同时，有一个不断支持与发展协议的社区，并提供新的改进和优化比特币网络运作的方法。

### \*\*\*常见的误区\*\*\*

_挖矿将于 2140 年终止。_

在 2140 年之后，挖矿不会被暂停，验证者将继续获得区块创建的奖励。然而，在 2140 年之后，奖励将完全由交易费组成，不再包括新发行的比特币。

_比特币的价格完全取决于挖掘的成本。_

实际上，硬币的价格与挖掘成本之间没有直接的相关性，就像黄金的价格在 USD/XAU 上并不直接由实际开采黄金的成本所决定一样。然而，它们存在间接关系：如果比特币价格上涨，可能会有更多人愿意进行挖掘。同样地，如果全球电力成本上升，应该会对比特币价格产生连锁影响。

_如果你购买了大量的设备，你可以比网络中 2140 年更早地挖掘出所有将来发行的硬币。_

如果你使用更多的计算能力，你可以增加你获得的奖励份额，但是无法获得超出协议规定数量的硬币。发行速率并不取决于网络当前的计算能力。

_挖矿的难度一直增加。_

实际上，它并非总是增加。也有可能会减少。挖矿的难度一直在增加是因为比特币变得更加昂贵，导致了对奖励的竞争加剧。但是，如果以美元计算的奖励减少了，那么愿意进行挖矿的人就会减少。甚至可能会有一部分目前正在运行的设备需要被关闭，因为奖励已经不足以支付电费和其他维护费用。

_如果你使用超级计算机进行挖矿，你总是首先创建新的区块。_

世界上最强大的超级计算机也无法达到比特币网络总处理能力的百分之一。原因非常简单——超级计算机使用常规通用处理器，这些处理器并不是为比特币中的 PoW 问题而设计的。因此，像谷歌或 IBM 这样的公司无法利用他们的数据中心来干预或审查已确认的交易。

### \*\*\*常见问题\*\*\*

_“如果你能够比其他人更快地计算哈希值，你能够重写现有的区块吗？”_

理论上是可能的，但有一些特殊情况需要考虑。需要考虑可用计算能力在网络中所有其他计算能力中所占的比例，设备维护成本以及所需时间。因此，你需要首先计算重写最近几个区块历史记录的经济可行性，因为挖矿的关键因素是能源效率。从理论和实践上看，试图重写现有区块攻击的成本超过了可能的收益。

_“最后一个比特币的挖掘日期是如何计算的，如果区块创建的频率是可变的？”_

区块创建的频率可以变化很大，但时段不会变化。通常来说，在比特币历史上，区块创建时间几乎是相同的。根据协议规定，网络努力确保平均区块创建周期为 10 分钟。这是通过调整PoW问题的难度参数来实现的。

_“为什么比特币挖矿计算机的生产竞争如此少呢？”_

与 2018 年，有5家主要公司设计挖矿设备，还有2家大型公司生产专用芯片。这种生产相当复杂，因为需要投资（实际上是许多百万美元）来开发芯片并进行生产。生产周期可能超过一年，同时该行业风险较高，因为这些芯片只能销售给比特币挖矿者，因此新进入者不愿意涉足这个设备行业。然而，尽管如此，挖矿硬件生产商之间的竞争仍然存在。

_“比特币中的矿工和验证者有什么区别？”_

有些人混淆了这些术语。 严格来说，验证者是系统参与者的角色，即配置自己的设备并维护其正确运行的企业家。 矿工解决的是资源密集型问题，即设备本身。


## 4.3 比特币中是如何实行区块链的？

以相互关联方式存储数据的方法并非新鲜事物。即便如此，比特币彻底改变了整个会计系统数据库的组织方式。事实上，这并不是出于某种科学发展的结果，而是为了应对匿名分布式网络参与者可能带来的安全威胁。现有系统的安全性通常基于保护信息和解决冲突的组织方法。在一个非匿名的环境中维护会计系统是可能的，那里你有预先确定的各方，如法庭、警察等来调节冲突情况。像中本聪这样的工程师尝试创建一个 _财务会计系统_ ，在其中每个人都是平等的，并且能够保持隐私。在这种情况下，不可能依赖于一个仲裁者，例如法庭协助（根据情况与用户的目标，这可能是优势或劣势）。

一个抗审查的匿名分布式网络需要完全不同的方法来解决这个问题。在现实世界中，许多不良事件（犯罪）通常不太可能发生，因为存在着它们会被曝光导致声誉损失甚至监禁的风险。因此，许多攻击形式缺乏保护——一个法律有效执行的社会根本不需要这种保护。例如，在美国如果你丢失了银行卡或PIN码，银行可能会返还被盗的钱，因为一般这些情况都有保险。即使银行利润的几个百分点被用于保险，也比提供对所有可能的欺诈情形进行直接保护更为经济。而在比特币的情况下，没有人来解决大部分冲突。因此，它被设计成可以 _避免冲突的本质_ ，而无需创建处理这些冲突的机制。在比特币中，无法发送不存在的硬币（然而，存在所谓的成功的双花攻击的风险 [55]）。本节的研究将解答区块链技术是如何在比特币中实施的以及为何要这样做的问题。

首先，让我们在比特币的背景下定义区块链的概念。区块链是一个数据库，其中包含了交易，且是所有涉及比特币系统的节点共享的。其特点在于每一个后续的区块都确认了前一个区块的完整性，而前一个区块又确认了前一个区块的完整性，依此类推，直到创世区块；通过这种方式，形成了区块的单向通信（即特定区块在前一个区块之后创建的事实）。这种数据组织方法确保了每个区块仅在对比特币存在期间的完整交易历史的确认下被创建。

现在让我们稍微扩展一下区块链中数据结构的概念（图 4–32）。回想一下，每个区块由两部分组成：区块头与包含的交易。

![图 4–32](/resources/img/volume-1/4.3-how-is-blockchain-implemented-in-bitcoin/4.32-structure-of-the-chain-of-blocks.png "图 4–32")

_创世区块是区块链中的第一个创建的区块，随后所有参与者可以创建后续的区块。_ 它的特殊之处在于，在节点相互同步时不会传播，因为它是网络节点软件中内建的，并具有序号 0 [56]。

为了进行系统的基本验证，节点只需下载区块头即可；这已经可以让它们检查区块的创建时间、前一区块的哈希值以及难度参数随时间的变化。然而，为了进行更深入的验证，比如双花攻击，节点需要下载包含交易内容的区块主体，换句话说，需要下载整个区块。


### 区块结构

让我们仔细看一下通过比特币网络传输的区块结构。相应的数据顺序如表 4–1 所示。

表 4–1 比特币中的区块结构  
| 字段 | 值 | 大小 |
|---|---|---|
| MagicNo | 0xD9B4BEF9 | 4字节 |
| BlockSize | 字节总数直到末尾区块 | 4字节 |
| BlockHeader | 由6个项目组成 | 80字节 |
| TxCounter | 正整数 | 1–9字节 |
| Transactions | （非空）交易列表 | N/A |

区块的结构包括几个字段。第一个是 _magicNo_ ，是一个特殊的常数。对于比特币协议，它始终具有此值并占用4个字节的空间；它用于识别数据流。例如，如果存在里面转移从不同协议的数据的数据传输通道，则可以通过此特定值搜索和识别在某个特定时间开始的比特币区块（对于不同的协议此值不同）。

之后是 _blockSize_ 字段，也使用 4 个字节，表示此区块中包含的字节数，包括交易数据。接下来是区块头，由六个字段组成，总共为 80 字节。

然后有 _txCounter_ （交易计数器）。区块中的交易数量可能非常大，因此交易计数器的大小可以是1到9个字节。之后是交易数据——大小未定义。实际上，一个区块可以是 100 字节甚至高达 1 MB：区块中包含的交易数量也可能不同。

区块的关键组成部分是其头部。 _blockHeader_ 字段包含六个字段。所有节点（包括轻量级客户端）都对这些字段进行验证。每个字段的验证都根据严格定义的规则进行，其中主要规则未来也许不太更改。所有字段的特征见表 4–2。

其中一个称为 _nonce_ （仅能使用一次的任意数字），它包含解决资源密集型问题的尝试次数。还有一个困难参数，表示挖矿难度，并位于位字段（在区块头中存在）。它大约每两周变化一次（创建 2016 个区块的时间周期）。

表 4–2 比特币区块头的结构  
| 字段 | 大小 | 更新值 | 大小 |
|---|---|---|---|
| Version | 区块版本号 | 你升级软件并指定了一个新版本 | 4字节 |
| HashPrevBlock | 前一区块头的256位哈希值 | 每生成一个新的区块 | 32字节 |
| HashMerkleRoot | txes的256位哈希值 | 接受一个交易 | 32字节 |
| Time | 当前时间戳 | 每隔几秒 | 4字节 |
| Bits | compat格式中的当前目标 | 调整难度 | 4字节 |
| Nonce | 32位数字（从0开始） | 在检查每个哈希之后递增 | 4字节 |

这个字段包含了区块版本，使用了 4 字节。它对应着验证者（区块的创建者）正在使用的协议版本。接下来是 _hashPrevBlock_ ，它是来自上一个区块头的 256 位哈希值。请注意，该哈希值是通过双重哈希运算获得的，使用了 SHA-2 哈希函数。这个字段包含了 32 字节的数据。然后是特殊提取的哈希值（哈希树），来自区块中的所有交易，同样占用了 32 字节。接着是 timestamp （Unix 时间戳），通常设置为区块创建时间，占用了 4 字节。之后是一个压缩的复杂性参数，所谓的 _bits_ ，同样占用了 4 字节。最后一个参数是 _nonce_ ，它是特定区块的 PoW 任务的解决方案。它也占用了 4 字节的大小。因此，在比特币中，区块头总共占用了 80 字节。

因此，我们已经观察了区块的结构，并弄清楚了区块可以分为两种类型：创世区块，它是链中的零区块，以及所有后续的区块，这些区块由网络节点的软件下载并处理。


### 比特币中区块的例子

让我们来看一些特定的比特币区块。表 4–3 显示了比特币的创世区块[56]。它的特点是前一个区块的值为零，意味着所有 256 位都是零。

表 4–3 比特币的创世区块  
| Version | 01000000 |
| Previous block hash | 0000000000000000000000000000000000000000000000000000000000000000 |
| MerkleRoot | 4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b |
| Timestamp | 1231006505 |
| Bits | 486604799 |
| Nonce | 2083236893 |
| Transaction count | 1 |
| – | Coinbase transaction (reward) |

创世区块是在2009年1月3日创建的。最初安装的难度参数是由中本聪计算的，以使挖矿的复杂性与普通台式计算机的能力相对应。创世区块和随后的所有区块都是通过挖矿创建的，即通过找到某种类型哈希函数的原型来实现。该区块仅包含一笔交易，其中根据协议规定，中本聪向自己发送了第一个50个比特币。事实上，此区块所有交易的哈希值（哈希根节点）即是coinbase交易的哈希值。

表 4–4 显示了另一个区块，它指向已附加到共享的比特币数据库中的先前区块。与上述示例相比，前一个区块的哈希值已经设置好。此区块包含了2702笔交易（其他区块可能包含更多交易）。这里的版本不一样的，还包含了相应的时间戳，难度参数增加了，并有一个新的随机数值。

表 4–4 比特币中区块的例子  
| Version | 613687296 |
| Previous block hash | 00000000000000000007c0fb40d7d6225edaa5da8f43490cc56e60c34082e39b |
| MerkleRoot | 167167cde7164fe0005a71e8b75a8da1e760deb546a944d67d7e3f15dcb60d45 |
| Timestamp | 1671542973 |
| Bits | 386397584 |
| Nonce | 971790600 |
| Transaction count | 2702 |
| – | … |

让我们更详细地考虑时间戳。每个区块头都包含一个根据Unix时间戳标准的时间戳。Unix时间戳是一种时间表示格式，它显示的是自1970年1月1日午夜（00:00:00 UTC）以来经过的秒数。

比特币有自己的规则来验证时间戳。这些规则特别描述了区块验证的时间戳限制。下限被计算为在此区块之前找到的最后十一个区块的中位数。上限的计算方法如下：当节点接收到一个新区块时，软件会验证该时间戳是否小于所有连接到此节点的这些节点的当前时间中位数，再加上2小时。

因此，网络节点加载的每个新区块的时间戳都有一个相当宽的窗口。这可以避免在不同机器之间存在时间差时产生交易历史冲突，并确保已接受的正确区块的特定顺序。理论上，上一个区块的时间戳可以超过下一个区块的时间戳，但在较小的范围内这是可以接受的。比特币仅在长时间内使用这些时间戳来更新挖矿难度参数，在短时间内，时间戳并不起特别作用。

_Coinbase 交易是区块链中序号为零的交易_ ；它出现在每个区块中。在这个交易中，发现解决方案并创建新区块的验证者会指定他的工作奖励，并从他在该区块中包含的所有交易中收取费用。

一笔 coinbase 交易没有输入（它们填充着其他数值），而输出只包含给验证者的奖励。比特币使用 coinbase 成熟度参数，该参数确定 coinbase 交易必须获得的确认次数，以允许其创建者使用所赚取的硬币。中本聪将此参数的值设定为 100。


### 内存池的概念

_内存池_ 是比特币协议中的另一个关键概念。这是每个完整网络节点中的一个独立模块，用于存储和处理未确认的交易。每个比特币网络节点都有自己的内存池，在这里它存储着已检查并视为有效的交易队列。大体上说，内存池是一个有组织的队列（见图 4–33），在交易被添加到新创建的区块之前，它们被存储和排序在这里。

![图 4–33](/resources/img/volume-1/4.3-how-is-blockchain-implemented-in-bitcoin/4.33-operation-of-mempool.png "图 4–33")

内存池直接显示了网络容量的状态（在内存池中的交易队列越大，网络的容量利用率就越低）。在 2017 年，交易队列的平均负载大约是 30,000 笔交易，大小约为 40 MB。如果考虑到每10分钟创建一个确认大约 1500 笔交易的 1 MB 区块（更多详细信息请参见第4.7节），这个数字相当可观。


### 区块的生命周期

> * _形成_  
> * _创建_  
> * _传播_  
> * _验证_  
> * _连接_  
> * _断开连接_

_区块形成。_ 验证者从内存池中选择交易，计算 MerkleRoot 值，设置前一个区块的哈希值，指定时间戳、交易计数器和区块大小，然后将这些数据组合形成一个区块。

_区块创建。_ 区块创建过程实质上就是挖矿，具体内容在第 4.2 节中有详细描述。

_区块传播。_ 在节点验证者创建新的区块之后，它将在比特币网络上传播。区块的创建者将其传输到直接连接的附近节点。每个节点在接收区块后会验证该区块是否符合协议规则。如果接收到的区块有效（不违反比特币协议规则），节点将其添加到自己的数据库中，并在网络中进一步传播。此外，该节点停止创建在相同高度的自己的区块，删除冲突的交易，将剩余的交易传回内存池，然后基于刚刚在网络上传播的区块开始形成下一个区块。

图 4–34 显示了区块是如何在网络中传播的。这个过程不是瞬时的；这就是为什么在某个特定时间点，当一些节点尚未收到最后创建的区块时，数据库的状态似乎不明确。

![图 4–34](/resources/img/volume-1/4.3-how-is-blockchain-implemented-in-bitcoin/4.34-block-propagation.png "图 4–34")

图 4–34 显示了区块是如何在网络中传播的。这个过程不是瞬时的；这就是为什么在某个特定时间点，当一些节点尚未收到最后创建的区块时，数据库的状态似乎不明确。

_区块验证。_ 为了验证特定的硬币没有被双重支付，每个比特币网络节点都使用一种与主要数据库分开且由其维护的单独数据库。这个数据库称为“币数据库”。它存储了所有未使用输出的当前状态，这意味着在所有现有的交易中，有许多输出：其中一些已经被使用，而另一些则没有。尚未使用的输出被软件单独存储和索引。当接收到一个新的经过验证的区块时，经过先前的验证区块的结构是否相同，挖矿复杂度是否正确，PoW 问题是否已解决，数字签名是否正确等（事实上，还有许多其他检查，但这些是主要的检查），每个网络节点在将区块添加到其本地数据库副本时，会验证每笔交易，以确保它们花费的是来自该币数据库的现有硬币。因此，双重支付的保护得到了保证。此外，整个流程经过了优化：无需访问每笔交易的输入，监视正在花费的交易并检查其是否存在双重支付。相反，未公开的硬币被索引，这样加快了对新区块进行检查的过程。

_区块连接。_ 这是一个重要的过程，它定义了如何在每个节点的本地区块链副本中验证和存储区块。为此，节点选择一个（在其已接收且认为正确的区块中），以及相应的链，并将其附加到其本地数据库的副本中。

_区块断开连接。_ 与连接区块相反的过程本质上是断开区块的过程。让我们考虑可能发生这种情况的情形。

当节点验证者引用区块（如图 4–35 中的箭头所示）时，其数据库的当前状态对应该区块；与此同时，节点验证者正在创建下一个区块。假设由于某种原因（可能有很多原因），在网络上发布了另一个替代区块。过了一段时间，又出现了另一个区块，它是基于这个替代区块创建的（下图显示了这个分支）。当知道哪条链更长时，根据协议规则，节点验证者必须断开较短的链并切换到最长的链。然而，这个过程的组织并不像乍一看那么简单。

![图 4–35](/resources/img/volume-1/4.3-how-is-blockchain-implemented-in-bitcoin/4.35-switching-between-blockchains.png "图 4–35")

有一个被称为“重新组织”的过程。它允许用户取消特定版本的事件历史并切换到另一个版本。它是如何工作的呢？重新组织包括区块断开的过程，这暴露了一些关键的复杂性。网络节点应该将在断开的区块中花费的所有币退回，并重新标记为未花费（即将它们返回到其币数据库）。此外，所有在该区块中确认过的交易都必须返回到内存池，重新获得未确认交易的状态。只有在那之后才可以连接后续的区块，其中相同的交易将被确认并花费相同的硬币。所有网络节点都有责任严格执行此过程，以确保其本地数据库的最终状态与其他诚实节点相同。


### 初始节点同步

我们已经讨论了比特币中区块的概念，以及这些数据结构如何最终形成整个链条，并在独立的参与者之间进行同步。现在，有趣的是定义一下这个数据库在本地用户计算机上的“外观”（存储与组织方式）。

各种的钱包软件开发者之间，组织区块链的方法也可能不同。例如，比特币核心开发者使用 LevelDB 数据库，该数据库支持键值关系以构建数据结构。此外，这还取决于你的文件系统：如果使用 Windows 操作系统，则你的区块链将位于 "%APPDATA%\bitcoin"；相应地，如果使用 Mac 操作系统，则位于 "/Library/Application Support/Bitcoin"。

无论使用何种软件，最基本的要求始终是相同的：在网络用户之间达成有关最终数据库状态的共识。最重要的是，例如爱丽丝向鲍勃发送7个比特币的交易，在所有计算机上都能得到正确处理，不管受它们对区块链的特定实现的影响。想象一下，一个用户决定启动一个比特币网络节点。显然，在将数据库存储在有人自己的节点之前，他必须下载整个区块链，并确保所有未使用的输出都是最新的。这个过程被称为初始节点同步。在同步期间，用户面临着一定的风险。 恶意人士可以利用某些漏洞（例如与网络连接有关的漏洞）进行一系列攻击。

这种攻击之一是攻击者把他的链垃圾邮件的攻击。在下载区块链的过程中，你可能会受到替代版本数据库的潜在影响。在这个版本中，攻击者可能控制了你所有的比特币。值得注意的是，你的软件可能无法检测到这种欺骗，因为这个版本（就像你没有下载的诚实参与者的链路一样）在协议方面仍然是正确的。

问题是如何防止你的节点与网络中其他诚实的节点隔离开来？如何确保你下载的是一个确实长期存在且正确的链路？

在比特币协议中，存在一种特殊的检查点机制，它作为一种安全措施防止类似的情况发生。


### 检查点

_检查点是一种将区块高度与相同高度的区块正确哈希值进行匹配的机制。_ 这种匹配用于验证某个节点在与网络进行初始同步时从其他节点接收到的区块的正确性。

这些检查点已经嵌入到节点软件的核心中。在初始同步期间，节点检查接收到的哈希值与内置在其软件中的检查点数值之间的匹配。

在图 4–36 中，可以看到节点下载的所有区块中只有一些被检查[57]。如果数值匹配，则软件会继续正常运行；如果不匹配，则会通知用户。此通知表明要么检查点是不正确的，要么用户被强加了不正确的交易历史。

![图 4–36](/resources/img/volume-1/4.3-how-is-blockchain-implemented-in-bitcoin/4.36-checkpoints.png "图 4–36")

这些检查点的作者是社区，也就是说软件开发人员。因此，你必须相信他们已经从正确的区块（已经获得足够确认的区块）中选择了哈希值，并且这个历史后来被预定在协议中的方式重写的概率是极低的。

检查点不能与尚未创建的区块以及最近发布的区块关联，因为新区块存在被重写历史并随后创建替代链的可能性更高。由于区块链持续增长，每个新版本的软件包含更多检查点。


### 共享比特币数据库的特点

鉴于比特币实施了一个由数万个独立节点支持的分散会计系统，其数据库已经获得了真正有价值的特性。

> * _能够验证交易的完整性_  
> * _实时同步与备份_  
> * _能够实时进行审计_  
> * _关于交易的合作决策_  
> * _会计的透明度_  
> * _无须信任性（最低限度的信任要求）_  
> * _不可变性_

具备数据的 _完整性_ 与 _可用性_ 的数据库对需要确保数据的应用程序非常有价值（时间戳、添加重要文档的哈希值等）。这是由确保特定数据在指定时间间隔内添加的无可争议的证据的必要性驱动，而不是在之后或之前添加。

确实，利用共享数据库（即由多个参与者存储的数据库）的想法还有很大的需求：完全摧毁数据库或回溯其中的数据是极其困难的，因为它存储在遍布全球的大量计算机上。我们已在第 4.1 节中描述了将任意数据写入比特币区块链的技术方面。

正确使用区块链技术可能有助于实现以下特性。

> * _决策过程的分权_  
> * _系统更高的容错性_  
> * _增加欺诈的复杂性_  
> * _用户对系统的更高信任度_  
> * _交易的不可变性与不可逆性_

这些因素是人们开始讨论区块链与加密货币分开的主要原因。有许多猜测关于区块链技术是否适用于比特币之外的领域。我们将在5.1和5.2中广泛涵盖这个主题。

### \*\*\*常见的误区\*\*\*

_如果网络中没有交易，下一个区块就不会被创建。_

的确，这种观点颇为普遍。问题在于，当网络中没有交易时，挖矿是否有意义？是的，是有意义的。新的区块将会被创建，因为仍然有相应的奖励。每个区块至少包含一笔交易，即 Coinbase 交易。用户可以投票支持某些现有交易，甚至支持交易的缺席。无论用户投票支持何种情况，他的投票总会被记录。验证者可以创建一个区块并获得奖励，而不必在其中添加任何交易（除了 coinbase 交易）。

_如果验证者没有足够强大的硬件，那么他将创建只包含少量交易的区块。_

这是不可能的。无论设备的容量如何，验证者都可以选择任何要确认的交易。为了创建一个区块需要解决寻找哈希值的原像的问题。此任务将考虑复杂性参数地建制，这对于所有网络参与者都是相同的。因此，使用特定设备创建区块的概率与其在网络总处理能力中的份额成正比，而不依赖于区块大小。

### \*\*\*常见问题\*\*\*

_“区块版本1和版本2之间的区别是什么？”_

在比特币协议的一次更新中，区块版本递增了一。在此版本中，有关区块头中版本化字节形成的规则与之前不同，并且根据BIP9 [58]规定实施。

_“验证者能否在coinbase交易中指定高于协议规定的奖励金额？这样的区块会被网络接受吗？”_

验证者可以指定这个金额。他甚至可以通过解决PoW任务创建这样的区块并通过验证者的网络连接分发它。然而，其他节点会立即验证该区块，并发现与协议不匹配的情况。这个区块会被诚实的参与者丢弃，并且不会通过网络进一步传播。

_“当你启动新的网络节点时，如何获取其他节点的网络地址以便进行初始同步？”_

你需要知道信任的节点地址。可以是朋友或特定值得信赖的服务。在启动新节点时，需要打开一个配置文件并手动输入这些地址。此外，可以使用所谓的比特币种子。这些是比特币核心开发者的地址，默认情况下包含在节点软件中。

_“最大的硬币数据库条目数量是多少？”_

硬币数据库的记录数量没有限制。否则，输出数量超过输入数量的交易甚至无法进入内存池，更不用说进入主链了。

_“硬币数据库是否随着交易确认而增长？”_

它既增长又减少，因为会产生新的未花费输出，同时也会产生花费的输出。随着用户数量的增加，这个数据库应该会增加。用户数量越多，每个用户的未花费输出越多，数据库也就越大。然而，它没有限制。

_“全节点对网络状态的影响与节点验证者的影响程度相同吗？”_

不参与交易确认的全节点不会影响网络状态。它们可以验证交易以满足自身需求或向其他用户传输数据。然而，对于共享数据库最终状态的实际影响取决于验证者节点。

_“比特币区块大小超过1 MB的背后故事是什么？”_

在 2017 年 8 月，发布了一项允许将硬币所有权证明与主要交易数据分开的协议更新。这就是所谓的隔离见证（英文：Segregated Witness）。区块的最大基础大小仍限制在 1 MB，但证据调整后的大小可以超过这个值，因此最高可达 4 MB（参见第4.6节）。


## 4.4 网络同步方法与SPV节点

比特币的安全性主要基于交易历史的透明性。任何人都可以查看并确保其可靠性。事实上，在这种条件下确保数据的可靠存储和真实性既是一个雄心勃勃的目标，也是一个复杂的任务。为了实现这一目标，需要有真正独立的模块相互验证彼此的工作。用户软件与网络上其他节点的互动是一个至关重要的功能，在本节中我们将对此进行探讨。

在早些时候，我们注意到比特币网络中的节点不断验证其本地数据库副本与网络其他节点的一致性。如果这些版本不一致，每个节点都会独立做出决策。这种方法使每个用户都能确信他接收到的数据的相关性和存储可靠性。尽管这个过程乍看起来相当简单，但实际上它很复杂，并涉及许多复杂因素，在开始与网络节点同步之前必须考虑这些因素。恰恰在这个阶段，恶意行为者可以利用漏洞，通过广播虚假交易等方式将用户排除在共享网络之外。接下来，我们将探讨钱包与比特币网络同步的主要方法以及各种方法的特点。

如果回顾数字钱包的基本功能和组织方式，就很容易看出钱包需要多频繁地与网络通信以同步当前数据。

> **_数字钱包的基本功能包括_**  
> * _备份私钥_  
> * _接收支付_  
> * _显示余额_  
> * _显示交易历史_  
> * _发送支付_

第一个功能（备份私钥）不需要与比特币网络连接——你只需要一个负责存储和管理密钥的模块。相反，为了执行所有其他功能，你的钱包需要与网络进行交互。为了访问交易的共享数据库并具有更改它的能力，你必须是比特币网络的一个节点，并遵循其处理与通信规范（协议）。

为了正常运行，钱包需要拥有其地址所涉及的所有交易的数据。请记住，交易的输入立即与先前交易的输出相关联；因此，确保把这些输出的硬币一定可以使用至关重要。在未确认旧交易状态之前发起新交易并进行支付是极为异常的。在接收和发送支付时最重要的信息是你的交易状态。如果一笔交易尚未获得足够的确认，收款方不能将支付视为完全确认的交易，并且，例如说，不能无风险地将商品交给买家。


### 分布式网络工作的挑战

与分布式网络通信是一个相当复杂的话题，通常会出现几个固有的问题。如上所述，网络上的所有节点定期检查其数据库状态与其他节点的状态，并在不符合情况下进行同步。有两个问题需要解决。首先，如何检查来自分布式网络的数据？其次，如何优化存储这些数据？困难源于这些要求在某种程度上相互冲突。更进一步复杂化，没有完美的解决方案，因为无法尽可能可靠地验证交易，同时又尽可能地减少问题所需的资源。用户拥有的完整数据越多，其获得的验证结果就越真实可靠。因此，在简单性与安全性之间需要权衡取舍。

进一步的问题在于：如果完整网络节点的所有者要获取特定地址的交易历史并进行检查，那么他将不得不遍历整个区块链（从创世区块到最后一个已知区块），这是非常耗时的。暴力是无效的，因为涉及的数据量很大。为了优化查询，存在一些替代方法。例如，网络节点应用特殊的附加模块。这反过来帮助索引所有区块的数据并缓存其中一些，以加快对常用指标的搜索速度。任何区块链浏览器都是按照这种原理工作的，即使是那些为通用用途实现公共接口的浏览器，也能迅速返回几乎任何区块、地址或交易等的数据。

现在让我们考虑一下与分布式网络交互和同步数字钱包的几种根本不同的方法。


### 同步钱包与支付网络的方法

还有三种与支付网络同步钱包的主要方法（图 4–37）。第一种假定钱包本身是比特币网络的全节点。第二种使用所谓的受可信节点（通常是钱包用户信任的其他人的网络节点）。第三种方法是简单支付验证（英文：Simplified Payment Verification；SPV），以简化的方式直接与其余网络节点进行交互。它允许在不启动完整网络节点的情况下验证交易的有效性，并且具有足够高的可靠性。让我们更详细地看一下每种方法。

![图 4–37](/resources/img/volume-1/4.4-approaches-to-network-synchronization-and-spv-nodes/4.37-approaches-for-wallet-synch.png "图 4–37")


### 使用全节点

使用节点的情况相对简单。一个钱包实现了存储和处理整个区块链的机制，包括与比特币网络中其他节点进行网络交互（p2p 消息传递）的模块。用户可以随时检查新收到的交易，验证其是否符合协议规则，或者是否存在双花的情况，等等。全节点的所有者可以对所有数据进行详细验证。

不过，为存储所有交易的完整且不断增长的历史记录需要大量的磁盘空间，这可能是一个不利之处。此外，全节点需要保持网络的不间断运行。因此，它必须不断与其余节点同步，并在需要时更新软件。

接受与发送高价值支付的用户需要更高级别的可靠性（交易状态的真实性），因此这种方法对他们来说更为理想。此外，所有主要的服务提供商（钱包服务、大型商家等）都不可避免地采用了这种方法，因为他们对与比特币相关的安全性和独立性要求极高。

因此，维护一个全节点（甚至是几个具有协议替代实现的全节点）是与网络中其他节点同步的最可靠方法。比特币社区旨在让运行普通个人电脑的普通用户可以使用这种方法：只需获取准备好的二进制文件（例如比特币核心的文件）并运行它们即可。有经验的用户可以利用公开可用的源代码。基本上，唯一的缺点就是对大量磁盘空间的要求较高。


### 使用可信节点

这种方法与先前的方法之间的区别在于钱包逻辑和交易验证逻辑被分离。这种方法涉及到一个可信赖的节点，通常是用户信任的普通全节点，用于验证他们的交易。特别是，它可以是由用户朋友维护的网络节点。

这种方法经常被用在数字钱包的移动应用中。例如，一个开发此类应用的公司支持可信赖的节点并承诺确保交易验证的正确性。在这种情况下，使用此类数字钱包的用户相信公司的开发者，也就是相信他们的承诺。用户有选择将私钥独立存储并在其设备上验证交易。然而，交易确认的状态是由可信赖的节点提供的，并非由用户独立验证。

这种方法的优点与缺点是什么？优点是使用户不必在自己的设备上存储整个区块链。然而，缺点是依赖于可信节点，因为如果节点出现故障，用户将无法迅速切换到另一个可信节点。

在实际操作中，曾出现过一个案例，即私人公司 Blockchain.com 的一个节点由于 DNS 问题遭受了长达两天拒绝服务攻击（见图 4–38）[60]。使用该节点作为可信主机的应用程序无法与比特币网络同步并保持正常运行。

![图 4–38](/resources/img/volume-1/4.4-approaches-to-network-synchronization-and-spv-nodes/4.38-dos.png "图 4–38")

由于交易验证是在远程服务器上进行的，你需要能够验证钱包和执行验证的服务器之间数据传输通道的可靠性。这种方法还有 _中间人攻击_ 的风险，导致用户收到扭曲的交易历史版本。

由于处理私钥的是用户的钱包而不是受可信节点，钱包软件必须定期向节点传输地址列表，以获取实际的交易历史和交易状态。换句话说，用户在很大程度上依赖于受可信节点，而这种依赖性为用户带来了几个风险。用户只接收受信任的的节点向其广播的数据，因此有节点可能向钱包发送虚假数据的可能性。此外，钱包向节点所有者披露其所有交易的事实表明用户交易的隐私受到了威胁。如果用户无法访问受可信节点（例如，节点拒绝服务），则他既无法接收也无法发送任何付款。

为了降低对单个可信节点依赖性的风险，可以选择使用多个可信节点。实际上，这意味着在正常情况下，用户连接并与一个可信节点一起工作。但是，如果连接断开并且失去了访问权限，数字钱包会自动连接到另一个可信节点。事实上，每次连接时，钱包都会从可信节点列表中随机选择一个节点。

这种方法主要被移动钱包所使用，因为它允许验证交易并简化移动应用程序的操作。比特币的此类移动钱包示例包括 Mycelium 与 Coinomi。Distributed Lab 开发并支持 Bitxfy 钱包，该钱包也采用了这种方法。


### 使用 SPV 节点

第三种常用的数字钱包与比特币网络同步的方法是使用轻量级网络节点，也被称为 SPV 节点。这种方法可能不需要用户运行自己的全节点或选择可信节点。它假设数字钱包直接与网络中的其他节点进行通信：钱包选择数十个其他全节点并与其保持连接。不同之处在于轻量级节点与其他节点平等通信。它进行点对点的信息交换，但不需要存储整个交易历史。在这种方法中，SPV 方法用于验证传入的交易。与全节点不同，轻量级节点只执行几项重要的检查。

所以，在这种情况下是如何完成工作的呢？与全节点接收区块不同，SPV 节点只接收远小于其的区块头（80 字节）。这些区块头包含必要允许验证块中特定交易是否已确认的数据，而无需要了解此块中其他交易的详细信息。通过这种方式，数字钱包可以确保特定块中的特定交易确实已经被确认。

为什么这不能被视为完整的交易验证呢？毕竟，用户仍然获得了摆脱特定网络节点的独立性，并且仍然可以直接与分布式网络通信，但无需存储整个交易历史。然而，其缺点在于轻量级客户端没有能力自行进行完全验证交易，因为这笔交易没有所有必要的数据（例如未使用的币数据）。它只验证了交易已被验证者确认；也就是说，它验证了其他节点和大多数网络处理能力的所有者（验证者）已经完全检查了这笔交易。在这种情况下，可靠性再次归结为对大多数算力由诚实验证者控制的信心问题。换句话说，你不是自己验证交易，而是将信任交给其他人来完成。

SPV 节点方法的一个特点是钱包需要与大量全节点保持网络连接。这是为了减少节点连接并仅从恶意节点接收数据的可能性，这情况可能允许攻击者向用户强加一种替代（虚假）的交易历史状态。结果是受害者可能收到根据攻击者版本确认的付款，但实际上并非如此。为增加获取有关网络状态的真实数据的机会，用户应尽量最大化可用于与其进行通信的独立节点数量。可用节点越多，这些节点相互串通针对用户的可能性就越低。

SPV 节点对于网络连接的稳定运行要求较低，通常用于移动应用程序。这种与系统同步的方法相当普遍，被应用在一些流行的比特币钱包中，例如比特币钱包、Electrum 和 Bread Wallet。


### SPV节点的运行

这种方法的主要思路已经描述过了，采用 SPV 机制进行初始同步的客户端只需要下载主链上所有区块的区块头；鉴于区块头的大小为 80 字节，可以轻松计算出所需下载的数据大小。通过简单地将最后已知区块的高度乘以其区块头的大小即可实现。考虑到 201 8年 8 月中旬生成了高度为 537,000 的区块，按照这个逻辑可以推断整个链中区块头的总大小不超过 43 MB。相比之下，比特币数据库的本地副本大小为 179,000 MB。为了进一步与网络进行同步，SPV节点只需要后续区块的区块头（大小为 80 字节）[61]。图 4–39 展示了SPV节点的工作原理。

![图 4–39](/resources/img/volume-1/4.4-approaches-to-network-synchronization-and-spv-nodes/4.39-spv-node.png "图 4–39")

为了让 SPV 节点认为交易已经被确认，必须满足以下两个条件：  
* 一笔交易必须被添加到区块中。  
* 包含该交易的区块必须被加入到主链中。

为满足第一个条件，你需要一个默哈希根，该根位于区块的头部。默克尔根的值计算如下所示（见图 4–40）。首先，每个交易的哈希值被计算了，然后将它们连接成一对，将结果再次哈希。这个缩小的输出再次成对连接，然后输入哈希函数。这个过程重复进行，直到剩下一个哈希值，即为哈希根。如果你形象化地想象一下，中间的哈希值被迭代地添加到一个树状结构中，即哈希树，其中包含了哈希根的值。

![图 4–40](/resources/img/volume-1/4.4-approaches-to-network-synchronization-and-spv-nodes/4.40-merkle-root.png "图 4–40")

这里的优势在于，为了验证交易是否包含在一个区块中，你不需要整个区块，只需要进行成对哈希的数值即可，这样可以让你达到哈希树的根部。

得到哈希根值后，SPV 节点只需要向一个全节点请求特定交易的验证所需的哈希值（哈希分支）。获得这些数值后，用户可以独立计算哈希根的数值，并将其与区块头中存储的值进行比较。如果接收到的和可用的哈希值相匹配，那么该交易很有可能被包含在该区块中。

第二个要满足的条件是用户必须确保区块实际存在于主链中。这个判断非常简单：SPV 节点的用户拥有主链所有区块头的数值；每个区块头都包含指向前一个区块的链接作为其哈希值，所以用户只需要检查后续的区块是否有引用到已验证的区块。

SPV 节点的操作可以总结如下。它只验证整个区块链中的区块头，而不是整个交易块。为了验证交易的正确性，节点只需要向全节点请求一些数值，以便验证交易是否真的在该区块中。只有在节点验证了每个区块属于主链之后，它才能验证特定交易是否属于这个区块。


### 摘要

考虑了与网络同步的三种主要方法后，可以分别评估每种方法的优缺点。对于比特币运作来说，最可靠但资源需求最大的方法是全节点。另一种是通过可信节点与网络互动，不需要太多磁盘空间来存储数据，但只有在用户愿意将其交易的匿名性委托给可信节点的所有者时才可行。对于不接受第一种或第二种方法的用户，存在一种简单支付验证（SPV）方法，允许用户独立检查相关交易的当前确认状态，而无需加载整个区块链的内容。这种验证也需要信任，但在这种情况下，是信任大多数网络参与者。需要注意，当使用全节点时也需要对大多数人的信任，但 SPV 节点所有者只能验证特定区块（其中包括的交易）是否在主链上，而不是交易与区块的数据。

理论上存在一种威胁，即如果大多数参与者相互串通，他们将能够向 SPV 钱包用户广播虚假的交易历史。因此，在处理数字钱包时，非常重要考虑到安全同步的重要性。

### \*\*\*常见问题\*\*\*

_“我可以在三台不同的计算机上同时运行相同的钱包并开始同步吗？”_

很可能我们在谈论某种类型的网络节点，它可能是一个 SPV 节点或一个全节点。情况是关于几台不同的计算机和同一个钱包，也就是相同的私钥。有几个实现钱包功能的全节点。在这些节点上，我们插入相同的私钥并开始同步。很可能在与网络进行完整同步期间，每个节点显示的余额都是一样的。如果用户在一个节点上看到了变化，那么在与网络同步后，他将在所有其他节点上看到完全相同的变化。交易并不会保密。它被分发给所有验证它的节点，并显示相应的更改（如果涉及到它们的地址）。你可以在多个节点上使用同一个密钥，但所有的交易也会自动同步。比特币当然不会因此翻倍，更不会翻三倍。

_“在哪里可以找到我可以信任的全节点？”_

很难确定哪些节点是可信赖的。这是个人喜好的问题。有一些服务提供对其节点的开放访问，但它们很少受到信任，特别是涉及到进行高价值支付时。在选择可信赖的主机时需要非常谨慎，因为它是你与分散式账务系统之间的中介。在这种情况下，没有一个通用的可以被信任的服务。这更多是一个社交信任的问题。如果主机属于用户的朋友，那么对这个问题的回答很大程度上取决于对这个朋友的信任程度。使用自己的全节点作为其他设备（例如移动钱包）的可信节点被认为是最可靠的选择。

_“特定的开发团队提供什么保证？ 它负责什么？”_

这取决于供应商可能提供的个别服务，属于法律性质而非技术性质。任何软件分发商都有他们的使用条款，定义了责任和用户在遇到特定问题时可以提出哪些索赔。各种应用的使用条款各不相同。在使用其产品之前，用户始终可以自行决定是否信任开发人员。

_“我可以选择多少可信节点？”_

你可以选择任意数量的可信节点，以最小化网络访问丢失的风险，例如三个节点。如果访问第一个节点出现问题，可以连接到第二个节点，并以相同的方式继续使用。

_“如果存储硬币的服务器被地震完全或部分摧毁，那么对硬币会发生什么情况？”_

首先，这不是关于硬币的问题，它们并不存在，而是与用于访问这些硬币的密钥有关。如果提供对比特币网络访问的服务器被销毁，这不会以任何方式影响数字钱包的运行。用户会暂时失去对分布式数据库的访问权限，但他拥有的密钥可以让他使用硬币。如果存储用户密钥的服务器被销毁，并且用户没有备份这些密钥，他将无法访问自己的硬币。

_“如果安装软件钱包，发币，在纸上写下助记词，然后删除应用程序，还能获得币吗？”_

事实上是的。将助记词短语安全地保存好是已经足够了。共享数据库存储了有关向相关地址发送了多少硬币的信息。简而言之，为了证明对硬币的所有权并将其发送到另一个地址，只需知道私钥，这种情况下，有一张带有助记词短语的纸就足够了。

_“是否有可能在分散的会计系统上本地放置一个上层建筑，以便能够实时详细地分析实际数据？”_

是的，可以。任何具备必要软件访问权限的人都可以进行这种类型的分析。这可以是用户自己编写的软件，也可以是现成的解决方案。这取决于特定用户的动机。如果用户需要优化查询以查找与特定地址相关联的特定交易，就像区块链浏览器一样，他可以应用软件来索引所有区块并缓存某些数据。BitCore（由 BitPay 支持）就是这样一种软件的例子。BitCore 具有开源代码，并且可以很容易地与完整网络节点配合使用。


## 4.5 多重签名机制和比特币脚本

可编程交易条件（ _程序化货币_ ）的可能性长期以来一直困扰着研究人员，其中尼克·萨博是智能合约概念的最初提出者[62]。然而，几乎在比特币出现之后，就很明显地意识到密钥被失密的风险远高于最初看似的情况。在进一步实施新功能之前，必须解决密钥问题。解决方案已被找到，并且被证明非常巧妙。

作为一种现象，多重签名已存在数个世纪。对于纸质文件，习惯上在合同上放置多个签名以使其具有法律意义。然而，对于数字交易的签署，这却是一种新事物（银行系统中的集体签名不计算在内，因为它在密码上并未得到实现）。在密码学家中，Shamir 的秘密分享方案（英文：Shamir's secret sharing scheme；SSSS）[63] 颇受欢迎，该方案假定密钥在数学上被分为几部分：这些部分的某个子集可以恢复原始密钥。该方法需要一个信任的方来提供份额的初始生成和分发；因此，它并不适用于匿名环境。然而，比特币提出了最简单的方法：一笔交易必须由多个签名进行验证。这种方法还有助于解决可靠存储货币的问题，并使得相互管理钱包的余额成为可能。随后， _多重签名_ 的概念被广泛用于智能合约中。

我们将讨论在比特币协议中实现的多重签名机制。请注意，在其他数字货币的情况下，这些机制可能会以不同的方式实现，因为很多事儿取决于交易模型。

_多重签名地址（MultiSig 地址）是一个比特币地址，与之关联了多对密钥。_ 每一对包括私钥与公钥；使用这些密钥的组合可以是不同的。此外，可以设置条件，并要求必须使用多个签名才能从一个地址中花费比特币。


### 比特币多重签名交易

回想一下，常规比特币地址是通过对公钥进行双重哈希生成的（参见 3.2）。一般情况下，多重签名地址的生成方式相同，但是在这种情况下，有多个公钥被连接在一起后再进行哈希。在图 4–41 中，你可以看到一个从多重签名地址使用比特币的交易的示意图。

![图 4–41](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.41-multisig-tx-structure.png) "图 4–41")

上面（图 4–41），有一个标题区域包含两个字段。左边有两个输入，右边也有两个输出。第一个输入包含填充字段：使用比特币的上一个交易的哈希值，一个输出编号等等。字段 _scriptSig_ 包含一个公钥和一个签名，这对于常规交易是典型的。

让我们观察交易的第二个输入。字段 _scriptSig_ 包含另一个数据组合：两个公钥和两个签名；它们应该按适当的顺序使用这些公钥进行验证。这个组合本质上是一个从多重签名地址花费比特币的交易输入，基本上就是证明拥有比特币所有权的证据。

在下面的图中（图 4–42），你可以看到一个真实的多重签名交易示例，请注意这个交易中的 _script_ 字段。这个字段包含了将比特币发送到 MultiSig 地址持有者的签名和公钥。与普通比特币交易的 _script_ 字段相比，多重签名交易的 _script_ 包含更多的数据，因此占用了更多的空间。这是因为可以有至少两个签名者，甚至多达 15 个签名者。

![图 4–42](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.42-real-multisig-tx.png "图 4–42")

不同的密钥组合在使用多重签名地址时是可能的，因此根据情况，任何组合都可能是有价值的。值得注意的是，使用最多强制签名和公钥的方案是15-of-15。我们将考虑一些最常见的选项：2-of-2、2-of-3 和 3-of-3。


### 2-of-2 多重签名

2-of-2 的组合是最简单的情况。它意味着有一个特定的多重签名地址，附有两对密钥。实际上，将两个公钥连接后进行哈希运算，得到相应的地址。为花费该地址的比特币，需要两个签名；这些签名将与两个公钥进行验证，当这些公钥按正确顺序连接并进行哈希运算后，必须返回相同的地址。总结以上描述的事实，有两个预定密钥和两个相应验证的强制性签名。

请想象一对夫妇（图 4–43）决定共同管理一个预算。他们一致同意，只要双方同意，预算中的资金就能使用。在比特币中，这可以很简单地实现。他们创建一个多重签名地址，其中一个密钥由妻子控制，另一个由丈夫控制。所有家庭的收入都将被转移到这个地址，只有在他们达成共识的情况下才能使用这些比特币。

![图 4–43](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.43-h-and-w.png "图 4–43")

请想象一下，妻子认为有必要购买洗衣机，因为她厌倦了手洗衣物，而丈夫则认为把所有的钱都花在新的 PlayStation 上更明智。她对丈夫感到生气，毁掉了携带她的私钥的纸张，因此完全无法从他们共同的地址支取资金。如何避免这种情况，以免最终失去比特币呢？

有一种方法可以创建交易，即使事先并不知道金额，也能从正确的地址中支取所有比特币。交易的签名可以提前创建，而缺失的数据可以稍后填入。换句话说，如果你不知道输入时应指定的数据，你可以稍后在已经签名的交易中输入。你甚至可以创建一笔交易来支取现有交易中的比特币，为其添加所有必要的签名，然后将其推迟。当时机成熟（例如出现所需的交易）的时候，你需要填写必要的数据，并将其发送到比特币网络进行确认。


### 2-of-3 多重签名

2-of-3 方案意味着在两个特定的密钥中，必须有任意两个被用来验证提供的两个签名，作为支取比特币所有权的证明。因此，为了支取硬币，需要提供两个签名。这些签名将与三个预定的公钥中的两个进行验证。

假设有一群人共用一个预算。他们创建了一个包含三个密钥的多重签名地址，只要两个签名就足以签署交易（图 4–44）。这些硬币可以在组成多数的参与者同意的情况下支取；在这三个参与者中的任意两人都可以决定支取硬币。他们只需将交易传播到网络上即可。

![图 4–44](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.44-2-of-3-multisig.png "图 4–44")

更有趣的 2-of-3 组合方式是涉及到钱包服务的情况。在这种情况下，你不应将钱包服务与用户自行监控的比特币钱包混淆。该服务不提供完整的比特币存储，也不拥有比特币，而只是提供便捷的工作服务。它的示意图可以如下所示（图 4–45）。第一个私钥直接属于服务；第二个由用户生成（只有用户知道），第三个私钥也由用户生成，但是存储在不同的地方并且不经常使用。然后，公钥把从私钥计算，并创建一个多重签名地址。

![图 4–45](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.45-2-of-3-with-involved-wallet.png "图 4–45")

把我们想象成是在处理一个网络服务，该服务允许客户在网页浏览器中接收和发送比特币。浏览器加载了一个代码，仅实现了比特币钱包功能的一部分：接收未使用的交易输出（UTXO），生成交易并使用数字签名验证。如果用户想要花费比特币，他可以在浏览器中创建交易并使用自己的签名（其中之一必须的签名）进行签名。

需要注意，用户可以通过密码或随机序列生成器获取私钥。之后，用户使用密码对接收到的私钥进行加密，并以加密形式将此密钥存储在服务端。在后一种情况下，用户向网络服务发送请求，接收包含加密密钥的容器，使用密码（或密码的哈希值）作为密钥对其进行解密，从而获得对私钥的访问权限。

用户签署交易后，交易将被发送到服务端，以便服务端放置第二个必要的签名并将交易发送到网络上。服务端可以通过事先设置的第二身份验证渠道来确认用户的操作：电话呼叫、短信、电子邮件或其他替代的沟通方式（甚至包括个人访问，如果安全级别要求）。服务端验证请求签署交易的行为是否由注册用户发起后，使用自己的密钥添加缺失的签名。此后，交易变为有效状态，并可以通过网络进行确认。

通常第三个密钥在服务拒绝时才会被使用。用户通常将此密钥存放在安全的地方。如果服务未响应，用户可以使用自己的密钥（第二个与第三个密钥）对交易进行签名。如果第二个密钥存储在服务端，保护该密钥的容器将提前通过替代通信渠道（例如电子邮件）发送给用户。该密钥会进一步进行解密。用户获得两个必要的私钥并输入到事先由服务提供的特殊软件中。之后，该软件在用户的计算机上独立运行（即不涉及服务端）。这个软件应该只在极端情况下使用，比如服务被黑客攻击、损坏或暂停等情况。然后用户使用自己的密钥对交易进行签名，并将比特币发送到目标地址。


### 使用 2-of-3 多重签名的钱包服务的优点

这是一种可靠的存储方式，因为服务商并不拥有所有必要的密钥。服务商仅存储其中一个密钥，这一个密钥并不足以取得客户的货币所有权。因此，无论是服务商还是潜在的黑客都无法访问这些货币。

这种方法的便利之处在于用户无需对该服务有安全访问。用户可以使用普通的个人电脑或智能手机，即使可能受到病毒感染或被骗子控制，数据可能被破坏或替换；也不会有问题，这是因为如果攻击者访问了设备，他只能获得两个必要签名中的一个。另一个优点是即使服务被拒绝，用户也不会失去对他的硬币的访问权。

我们只描述了一些可能使用多重签名地址的方案。现在让我们来了解一下比特币脚本是什么。


### 比特币脚本

比特币脚本是一种基于栈的非图灵完备语言，用于描述硬币支出场景。非图灵完备的语言功能有限，而且无法执行无条件跳转、循环与递归；也就是说，脚本无法无限执行。这个原则可以限制恶意方创建复杂的交易，从而减缓整个系统的速度。

比特币脚本的目是验证希望花费硬币的一方是否拥有这些硬币的所有必要所有权证明。每个交易包含 scriptSig 和 scriptPubKey 字段。scriptPubKe y字段包含了使用硬币的条件，而 scriptSig 字段包含了解锁硬币所需的数据。在脚本执行之前，这些字段会被连接在一起。

脚本的执行意味着对堆栈中包含的特定数据顺序执行操作。在执行每个操作时，会从堆栈中获取这些数据，并执行由相应操作码（或简称为 opcode）确定的特定动作。执行结果将推送到堆栈中。只有当整个脚本在堆栈上运行的结果为真时，硬币才被认为已解锁。此外，使用比特币脚本时，堆栈的最大容量限制为 520 字节。

操作码构成比特币交易的某种命令式编程语言[64]。每个操作由一组位表示，这组位由虚拟处理器读取并执行。每个操作码包括两部分：前缀“OP\_”和操作本身的名称。最常用的操作包括 OP\_SHA256、OP\_HASH160、OP\_EQUALS、OP\_CHECKSIG、OP\_CHECKMULTISIG、OP\_CHECKLOCKTIMEVERIFY [64]。


### P2SH 地址的概念及其好处

BIP16 [65] 在比特币协议中引入了一个新概念——所谓的 _支付脚本哈希_ （P2SH）。它使得设定花费比特币的规则不再使用简单的脚本，其中连续写入随后按照上述方式执行的操作数和某些数据，而是使用所需脚本的哈希值，这是这些操作数的校验和。现在可以在交易输出中指定大型和复杂的条件来使用比特币，而无需扩大输出量。

为了从这样的输出中花费比特币，用户需要证明他知道花费的条件，并且当然需要满足这些条件。因此，用户公布这些条件，这就是整个脚本以及脚本的哈希值。现在，通过比较从脚本获取的哈希值与用户公布的哈希值，任何人都可以确定这些条件是否正确。如果满足了条件，对参与者来说，用户只好根据协议规则验证交易。

这项比特币改进提案于 2012 年 1 月 3 日获得了通过。目前，P2SH 正在积极应用并用于实现多重签名地址。

让我们看一个示例，了解 P2SH 如何运作。为了弄清楚如何创建带有 P2SH 的交易，我们将描述 _赎回脚本_ （ _redeem script_ ）、 _锁定脚本_ （ _locking script_ ）和 _解锁脚本_ （ _unlocking script_ ）的概念，以及填写相应字段的规则。

_赎回脚本_ 包含将附加到多重签名地址的公钥。在这种情况下，我们考虑的是2-of-5密钥组合。首先是值2，这意味着需要提供两个签名以与相应的公钥进行验证。然后记录5个公钥。接下来指定公钥的数量（即值5）；当数据按逆序读取时，此值将有助于了解必须读取多少个密钥。然后指定了OP\_CHECKMULTISIG，即多重签名验证操作。

_锁定脚本_是在进行支付到多重签名地址的交易输出中指定的脚本。在这里，执行哈希值接收操作（例如OP\_SHA256或OP\_HASH160）。接下来是赎回脚本的哈希值，该哈希值在此情况下为20字节。然后执行为了验证数据与实际哈希值的匹配的操作。

_解锁脚本_ 是交易输入中脚本与进行支付到多重签名地址的交易输出中脚本的串联。它表示两个用于使用硬币的签名和完整的赎回脚本，后者随后将被送到哈希函数的输入中，并进行与发送硬币的地址匹配的检查。然后，整个脚本会被执行，甚至用于多重签名的验证。

重要的是，每个列出的脚本都有最大 520 字节的限制。这个数字是根据解锁脚本最多可以包含15个签名、15 个相应的公钥和一些用于验证这些数据的操作码而计算得出的。将其四舍五入，最终的值就是 520 字节。然而，这个值是基于假设 15-of-15 多重签名地址是实际应用的合理限制。随着大量的签名，赎回脚本也会相应地变得非常庞大。从多重签名或其他 P2SH 地址使用硬币可能会对用户产生相当大的成本。

让我们看一下 P2SH 的优点。第一个优点是这些地址可以使用base58编码成习惯的形式，其长度为 34 个字符。根据规定使用 base58Check 编码比特币地址[66]的版本字节的BIP，地址以特定的版本字节“3”开头。以下是一个 P2SH地址可能的样子的示例。

**3P14159F73E4gFr7JterCCQh9QjiTjiZrG**

这并不一定是一个多重签名地址。赎回脚本可以描述其他的硬币花费条款，包括更复杂的条款。然而，P2SH 并不是在比特币中实现多重签名的唯一方法。

另一种方式是在支付到多重签名地址的输出中，不指定脚本的哈希值，而是直接指定脚本本身；也就是说，在输出中直接列出所有的公开密钥，并添加多重签名检查操作。然而，这种方法也存在其缺点。首先，控制用户存储比特币的地址的公开密钥将会公开可见——当向地址发送硬币时，用户会将它们公开。另一个缺点是对于较大的交易大小，发送者将不得不支付较高的费用，以便将硬币发送到多重签名地址。发送者不太可能愿意支付过高的费用，仅仅是因为接收者要使用复杂的硬币花费条款，这些条款占用了大量的数据。

P2SH允许将这些费用转移给接收方。因此，如果接收者希望将硬币发送到多重签名地址，他将为确认大额交易支付费用，这是一种更公平的方法。P2SH 还允许实现不同的多重签名组合（2-of-2，2-of-3 和其他组合）。


### 使用P2SH作为多重签名地址的示例

想象一下，爱丽丝想向鲍勃支付款项，而鲍勃只使用多重签名地址（实际上，任何两个机构都可以顶替）。为了实现这一点，鲍勃在本地计算机上生成了几个私钥，并获得了相应的拼接公钥（图 4–46）。通常情况下，公钥首先使用 base58Check 进行加密，然后按字母顺序排序，最后进行解密与拼接，最终形成赎回脚本。

![图 4–46](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.46-using-of-p2sh.png "图 4–46")

当你需要根据私钥重新计算公钥时排序是有意义的。它们需要按照完全相同的顺序进行拼接，因为接下来要创建赎回脚本并对其进行哈希运算；如果完全相同的密钥以不同的顺序进入赎回脚本，你将得到另一个哈希值和不同的地址。这可能会导致误解。因此，在进行拼接之前，公钥必须按照一定的规则进行排序。最常用的是按照 base58 字母表顺序排序。

因此，鲍勃已经从赎回脚本计算出了哈希值。他可以将其表示为20字节并将其发送给爱丽丝，并表示这是一个 P2SH 多重签名地址。此外，鲍勃可以使用版本字节对此哈希值进行加密，就像对常规地址一样，然后将其简单地发送给爱丽丝。爱丽丝看到版本字节时会知道这是一个多重签名地址，因此她将创建一笔交易，并相应填写其输出，以便鲍勃获得他的硬币。然后，她将交易传播到网络中。他们都等待确认；鲍勃接受了爱丽丝的付款，并提供服务，例如释放货物。

现在，让我们假设鲍勃要花掉爱丽丝给他的货币。当货币在鲍勃的多重签名地址上时，完整的赎回脚本尚未公开。甚至爱丽丝也不知道鲍勃使用了什么样的公钥，以及使用了多少个公钥。她并不知道构成这个 P2SH 地址的规则，它是否是一个多重签名地址等等。因此，对数字签名（在椭圆曲线上）的攻击仍然是不可能的。

假设鲍勃要向伊娃发送付款（图 4–47）。在这种情况下，伊娃生成一个新地址并将其传递给鲍勃。他创建了一个交易原型。在这个交易的输入中，鲍勃指向他从爱丽丝那里收到的硬币的交易。在输出中，他指定了伊娃的地址。现在，他必须提供他花费的硬币的所有权证明，所以他从他的私钥中取出所需数量（如果他的多重签名地址意味着 2-of-5 的情况，则取2个私钥），用来计算为交易两个签名。然后，他将完整的赎回脚本添加到交易输入中。

![图 4–47](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.47-bob-proves-the-ownership.png "图 4–47")

注意鲍勃应该在他的计算机上完整地存储这个赎回脚本；无论如何，他都必须记住他用于构成此脚本的公钥的顺序。他还应该记住他所应用的排序规则（如果他使用了排序规则），以及与特定私钥相关联的多重签名地址。如果不知道这些信息，鲍勃将不知道他需要操作哪些私钥以及它们需要以何种顺序输入到哈希函数的输入中，以便他获取所需的地址。

最后，鲍勃获得了两个签名和一个完整的赎回脚本。交易被认为是正确的，鲍勃将其分发到网络并等待确认。这些是从多重签名地址花费硬币的基本原则。


## 4.6 隔离见证更新的特点

Segregated Witness（隔离见证）更新或许是比特币协议十年历史中最期望的，同时也是最难实现的更新之一。它引发了社区的第一次分歧，向整个世界展示了在一个参与者往往持有相互冲突的利益的分散化匿名的环境中实施治理的非平凡性。当比特币社区面临有限的交易处理能力问题（每秒仅能处理3到4笔交易）时，他们就开始寻找解决的方案。关于谁最终负责采用新规则（开发者、验证者还是用户）的意见也存在分歧。值得指出的是，许多在比特币之后的项目（尤其是 Dash、Cardano 与 EOS）最初就在点对点协议中包含了治理机制。然而，幸运或不幸的是，在设计比特币时，中本聪并未提供解决此类争议的机制。

> **_比特币原本架构的问题_**  
> * _系统容量低_  
> * _交易可塑性（未确认交易的可变性）_  
> * _将业务逻辑与币拥有权证明结合_  
> * _实施链下协议的限制_

隔离见证对协议带来了重大变化，并显着改善了交易的格式。在本节中我们将涵盖交易和地址的新格式，将硬币所有权的证明数据分离的可能性，输入和输出脚本的新格式，以及此更新对系统容量的影响。

你可能希望了解隔离见证实际上是什么样子，以及与平均序列化比特币交易的区别。该区别在图 4–48中展示。

![图 4–48](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.48-serialized-tx.png "图 4–48")

图 4–49显示了隔离见证交易。与此交易的不同之处在于图中分离的见证数据可以被拆分。更新的节点接收有关交易的完整数据，包括见证数据，而对于未更新的节点，见证数据是不可用的，它们默认情况下将认为此类交易是正确的（即使所有权证明不正确）。我们将在后续章节中描述其中的原因。

![图 4–49](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.49-serialized-sewit-tx.png "图 4–49")

基本上，这就是隔离见证更新的主要思想——即将硬币所有权证明与主要的交易数据分开保存（图 4–50）。

![图 4–50](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.50-segregation-of-coin-ownership.png "图 4–50")

此外，隔离见证更新还包括许多其他改进。它允许增加网络容量，将硬币所有权的证明与其余交易数据分开，并消除与签名交易中修改数据相关的交易格式的缺点（交易可塑性），同时保持与先前协议版本的向后兼容性。这一更新的最大价值在于它允许在比特币协议之上实施许多重要的链下解决方案（更多详情请参见 4.8）。


### 向后兼容性和增加容量

由于区块大小受限，能够包含在一个区块中的交易数量也受到限制；这是系统容量取决的因素。当增加容量的问题出现时，首先考虑到的是增加最大区块大小的方法作为解决方案。然而，这个想法并未得到大多数网络参与者的支持。

比特币协议团队对任何提案都进行了深入的检查与测试。只有在社区达成共识并决定在协议中实施提案时，才会发布更新。让我们考虑如何解决会计系统容量增加的两种基本方式。

_硬分叉。_ 更新的最简单方法是直接增加区块大小。假定一个区块包含更多的交易，从而提高了容量。然而，这样一个区块将不会被按照旧协议规则操作的节点所接受，根据旧规则，最大区块大小不能超过1MB。这种变化需要进行硬分叉，这在组织上比软分叉更复杂。

_软分叉。_ 隔离见证允许通过软分叉解决这个问题。它允许将一个区块分为两部分：第一部分是交易，第二部分是硬币所有权证明。网络的新节点接收到两部分，而旧节点只接收到交易 1 MB的部分。旧节点无法接收到具有证明的数据，因此无法完全验证新格式的交易（他们所看到的是，根据通用规则，区块是正确的，因此可以添加到主链）。这种解决方案允许旧节点参与达成共识，同时不需要进行硬分叉；此外，该解决鼓励旧节点逐渐转向新软件。

根据旧规则，最大区块大小被限制为 1 MB，并且区块中的交易包括内置的证明。新规则也意味着最大基本区块大小为 1 MB；但在区块之外，还有一个包含证明的附加数据结构，因此新格式区块的总大小超过 1 MB。

为了保持向后兼容性，协议规则允许旧节点使用新区块；不同之处在于，它们接收基于其最大大小为 1 MB的基本配置的区块，并且无法看到见证结构（硬币所有权的证明）。然而，新节点接收包含交易与证明的完整区块（参见图 4–51）。

![图 4–51](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.51-result-of-segwit-update.png "图 4–51")

在左边，你可以看到隔离见证激活之前比特币协议的运行方式。区块的最大大小为 1 MB，并以相同形式分发给网络中的不同节点。


### 隔离见证的创新

隔离见证的首要和最重要的创新是新的交易结构。除了已知的字段外，新交易现在包括三个额外的字段： _marker_ （中文： _标记_ ）和  _flag_ （中文： _标志_ ），这些两个用于版本控制（在这种情况，它们是严格指定的，但在进一步的协议中可能会改变），还有  _witness_ （中文： _见证_ ）字段。 _见证数据是一组排除在主要交易部分之外的硬币所有权证明。_ 在结构上，它看起来像一组输入，其中每个见证数据元素对应于一个特定编号的输入。这样可以将证据与特定的花费硬币进行比较。

每个交易都有其独特而通过它可以进行追踪的标识符 _txid_ 。要获得它，你需要将交易转换为单个数据序列，然后从此数据序列中获取哈希值。隔离见证的引入带来了新的标识符 _wtxid_ 和新的序列化格式。对于旧交易（在不使用隔离见证花费硬币）， _wtxid_ 与 _txid_ 相同。图 4–52 显示了参与生成 _wtxid_ 的交易字段（分别是默认交易和隔离见证交易）。

![图 4–52](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.52-diff-between-txs.png "图 4–52")

_Wtxid_ 用于构建证明的备用哈希树。它的构建方式与平均交易几乎相同，但这里使用 _wtxid_ 值代替交易哈希。交易的 _wtxid_ 值进行成对哈希运算，因而生成哈希根。

哈希根被插入到 coinbase 交易中，而不是到块头。否则，块的结构会改变，以至于支持旧协议的节点无法处理新格式的区块，并且会阻碍保持向后兼容性。因此，哈希根被插入到 coinbase 交易的一个输出中。一旦所有节点都转换到隔离见证，这种情况可能会改变，并且可能会考虑新的方法。

让我们更详细地观察 _交易可塑性_ 问题。在比特币中，有可能修改某些交易数据，同时保持交易本身的正确性（硬币将从同一个地址发送到同一个地址）[67]。尽管这些修改可能看似微小，但足以导致散列结果的改变，使其成为完全不同的交易（即使它从与原始地址相同的地址发送硬币）。这些修改只能应用于未确认的交易，这本身可能看起来并不具威胁性。然而，对于未确认的交易，数据的不可变性同样重要：这种对交易数据的未定义概率干扰了基于构建未确认交易链的离链协议的实施。

它是如何工作的？当创建比特币交易时，并非所有数据都被哈希和签名：也就是说，你不能签署 scriptSig 字段，因为它包含用户生成的数字签名数据。这种漏洞允许在比特币中进行几种类型的攻击。让我们考虑其中一些基本的攻击类型。

第一种攻击方式之一允许修改签名格式。在比特币协议中，放置在 scriptSig 中的签名格式是非严格的，并且取决于 OpenSSL 的实现，后者也不提供严格的格式。外部人员可以截取交易并轻微修改它，同时保持其有效性。交易的哈希值将更改，使其成为完全不同的交易。

第二种攻击直接影响 scriptSig。由于 scriptSig 是用户证明拥有硬币所有权的一组命令，它允许指定额外的操作次数。可以向 scriptSig 的原始数据中添加几个无意义的操作，这些操作不会影响脚本的结果，但会改变交易的哈希值。

更改交易哈希值有什么问题？这个问题很重要，因为有人可能认为未经确认的交易不可信，最好不要依赖它，直到它得到确认。然而，交易篡改的问题比起初看起来更为重要。首先，它使得可以创建一个与原始交易完全相同的交易，但由于哈希值发生了变化，网络节点会将其视为不同（新的）交易。因此，原始交易将与另一个交易发生冲突，这意味着永远无法确定你的已确认交易是否具有原始的哈希值。其次，解决交易篡改问题对于基于未确认交易链构建的协议的实施至关重要。如果此链中至少一笔交易的哈希值发生变化，那么整个后续交易链将变得无效。因此，事实证明，任何交易的哈希值都可以被外部人员更改，因为你不必具有私钥即可更改哈希值。

SegWit 更新解决了与交易篡改相关的问题，特别是针对新格式交易，在这些交易中，现在的字段填充按照严格的规则进行。它规定了明确设置和序列化数据，消除了二义性。


### SegWit 交易示例

为了理解存储在相应交易字段中的内容，我们来看一个在比特币网络上确认的 SegWit 交易示例，该示例以 JSON 格式呈现（图 4–53）。

![图 4–53](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.53-real-segwit-tx.png "图 4–53")

首先，让我们注意到 _scriptSig_ 字段为空。在这种情况下，相应的 _硬币所有权证明_ 被放置在额外的字段中：witness。就像在普通的比特币交易中一样，这些字段由数字签名与公钥组成。唯一的区别在于，scriptSig 字段包含在交易的基本结构中，而 witness 字段则不包含在其中。这样可以在不需要时，不必在网络上传输此数据，也不必进行验证或在内存中存储它，因为硬币的所有权证明已经被验证。

事实上， _见证数据_ 是交易的一个单独部分，在某些情况下可能不被使用，甚至完全不存在，而不改变交易的基本结构和其哈希值。然而，在屏幕上或 JSON 格式中显示交易时，将 _见证数据_ 显示在交易输入中是方便的。


### 新的权重和大小概念

隔离见证更新引入了交易权重和区块权重的概念。在此更新之前，只是交易大小和区块大小等概念。与此相关的所有内容（例如交易费用）都是根据大小来确定的。区块大小被限制在 1 MB。隔离见证引入后，需要处理旧格式的交易（使用“旧”大小）以及新格式的交易。

另一个需要解决的重要问题是降低处理区块的额外部分（见证数据）的成本。为了解决这个问题，引入了交易权重的概念以及相应的权重单位。现在，交易的主要部分的大小以系数 3 计算，见证数据的大小以系数 1 计算。你可能猜到，任何包含在见证数据中的数据所需的费用比交易的基本数据少 3 倍。这种方法允许验证者确定更有利可图的交易，即在占据区块空间和获得奖励之间的关系上。交易权重可以使用以下公式计算。

**交易权重 = 基本大小 * 3 + 总大小**  
* 交易权重（transaction weight）以权重单位计量；  
* 基本大小（base size）以字节计量；  
* 总大小（total size）以字节计量。

在这个公式中，基本交易大小（即按旧规则序列化时的交易大小）乘以三，然后将结果加上按照新规则序列化的交易大小。这样，我们就得到了交易权重。

无论是按照旧规则还是新规则序列化的旧格式交易，它们的大小始终保持不变，而相应的权重则会增加到正好四倍。对于 SegWit 交易，其权重稍小，因为它们不包括硬币所有权的证明。

随着权重的引入，还引入了 _虚拟大小_ 的概念；虚拟大小计算方法是重量除以 4。虚拟大小用于计算交易费用，并使验证者能够理解将特定交易包含在其区块中的盈利性，同时使用以聪每字节（spb）单位衡量的记录的常规价格。

**虚拟大小 = 权重单位 / 4**

由于旧格式交易的权重是其大小的 4 倍，因此交易的虚拟大小等于其通常大小。于是对于旧格式交易，费用计算保持不变，而对于新格式交易，费用会略低，因为签名放在一个单独的结构中。这就是隔离见证交易如何让用户支付更低的费用，但仍具有与旧交易相同的优先级，以便让验证者将其纳入区块。同时，不包括见证数据的最大区块大小（基本大小）仍为 1 MB，而最大区块权重可达 4 MB。

现在，你可能会问一个合理的问题：带有见证数据的区块的最终大小是多少？答案显然在从1 MB到4 MB（条件权重单位）的范围内，但你实际上无法精确地判断，只能做出近似值，大约为 1.8 MB。这是如何得出的呢？通过精确的理论评估。当前典型的交易区块包含大约 60% 的币权证明。让我们计算一个由60%币权证明组成的 1 MB 区块的权重。

**400,000 字节 * 4 = 1,600,000 条件权重单位**  
**600,000 字节 * 1 = 600,000 条件权重单位**  
**1,600,000 + 600,000 = 2,200,000 条件权重单位** （该值与实际的 1 MB大小相匹配。）

现在，考虑到协议规则定义的 4,000,000 条件单位的最大块权重，可以确定这将如何增加包含见证数据的最终块大小。

**4,000,000 / 2,200,000 = 1.8** （因此，块大小将为 1.8 MB。）

因此，平均有效块大小可以假定为大约 1.8 MB（不要将块的实际大小与其权重混淆）。实际上，这个值在实践中完全取决于特定块中的交易集合。


### SegWit 采用统计

2018 年 11 月，SegWit交易数量超过比特币网络总交易数量的 40%。此外，如果考虑在比特币网络上转移的总硬币数量，SegWit 交易占了 55-60%。同时，数字钱包（例如Electrum、Bitxfy）和其他与比特币相关的重要服务在2018年之前不久已经实现了隔离见证支持。

在更新采用之后，最终区块大小的动态也很明显（见图 4–54）。当新交易流增加时，几乎所有的区块都超过了 1 MB（有时甚至超过 2 MB）。显然，在 SegWit 激活后，比特币低容量的问题似乎不再像更新之前那样紧迫了。[68]

![图 4–54](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.54-block-changing-after-adoption.png "图 4–54")

如果观察新格式交易数量与平均交易费用之间的相关性，你也会发现这些值之间存在非常强的相关性（图 4–55）。

![图 4–55](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.55-average-tx-fee.png "图 4–55")

此外，我们不应忘记隔离见证为比特币协议打开了超链解决方案的发展大门。提前了解这一情况，我们想指出闪电网络（英文：Lightning Network；LN）的采用比隔离见证的实施要困难得多。然而，朝着LN采用的工作正在稳步推进，并已经取得了重大进展（请参阅 4.8）。

### \*\*\*常见问题\*\*\*

_“声称 RBF（replace-by-fee）对隔离见证交易无效是正确的吗？”_

不正确。RBF 将对隔离见证交易起作用，因为其基础不在于支出规则，而在于使用相同的硬币并指定交易输入的顺序号。如果使用相同的硬币增加输入值并指定正确的硬币所有权证明，那么可以替换之前的交易。

_“我该如何更改未确认交易的哈希值？”_

交易哈希是计算存储在交易中所有数据的哈希函数结果。ScriptSig 是交易中包含的一个部分，它参与哈希计算但无法被签名。对这一字段的不会改变签名验证规则微小更改会导致交易哈希值的变化。这意味着当签名和交易仍然有效，交易哈希值将变化。

_“见证数据如何存储在交易中？”_

如前所述，隔离见证交易具有新的结构：输入集、输出集以及分别存储见证数据的证明。简单来说：用户具有描述交易中两个输入（第一个输入的字节与第二个输入的字节）、两个输出以及另外两组见证数据的数据集，其写入方式类似字节序列。


## 4.7 比特币中的费用机制

在这一部分，我们将描述比特币中费用的主要目的，即它们的运作方式以及对其影响的方面。我们将涵盖费用波动的原因、确认交易的延迟以及解决这些问题的方法。此外，我们还将触及隔离见证更新如何降低交易成本的话题。最后，我们将提出一些思考，考虑与验证者建立友好关系如何将费用降低至零，并思考这种趋势可能在未来引发的影响。

根据比特币协议规则，要确认一笔交易，大部分计算能力的所有者必须创建一个包含该交易的区块，并基于该区块扩展区块链。换句话说，必须基于交易获得第一次确认的区块构建多个区块（见图 4–56）。重要的是这条链是最长的，并且不应该有任何竞争性的链。接收者自行决定所需的后续区块数量（交易确认数）。接收者使用以下规则： _交易确认数越多，交易被取消的可能性就越小_ 。

![图 4–56](/resources/img/volume-1/4.7-fees-mechanism-in-bitcoin/4.56-inclusion-the-transaction-in-the-block.png) "图 4–56")

随着比特币的普及，网络上新交易的流量显著增加。比特币的最大区块大小为 1 MB，这是由协议规则严格定义的。区块的创建时间平均为 10 分钟，因此，其容量受限（每秒 1.7 KB）。如果新交易的流量超过了网络的容量，一些交易将无法被处理（这种情况并不罕见）。哪些交易将首先获得确认，哪些将等待——这些问题需要明确的答案。基本思想是交易互相竞争。

比特币中的手续费机制是一种必要工具，它允许你为分布式网络的服务付费，而这项服务本质上是可靠的数据存储。实际上，比特币用户为添加到共享数据库的每个字节数据支付费用。由于这个数据库的容量有限，用户相互竞争以获得记录的优先级。

在创建交易时，用户会设定每字节数据一定数量的聪手续费。每个节点验证者将所有未确认的交易按照支付的手续费与其大小（权重单位）的比率排入队列，因此那些支付更高手续费的交易会被优先确认。这意味着排在队列末尾的交易可能会长时间未被确认（见图 4–57）。

![图 4–57](/resources/img/volume-1/4.7-fees-mechanism-in-bitcoin/4.57-competition-for-the-space.png "图 4–57")

费用机制解决的另一个重要问题是所谓的 _公地悲剧_ （英文： _tragedy of the commons_ ）。在比特币的背景下，这指的是交易垃圾邮件保护。强制性费用的存在意味着为攻击者长期向网络发送虚假交易将会变得昂贵。


### 数据记录价格的波动性

有时，比特币网络的用户会面临异常高的费用波动问题。例如，于 2017 年，向比特币数据库添加一字节数据的平均价格在 1 到 500 聪之间波动。未确认交易队列的大小从几千字节到数十甚至上百兆字节不等。

由于数据记录价格容易出现剧烈变化，用户几乎不得不在盲目竞争中相互竞争。这是因为交易平均需要大约8分钟才能得到确认，而处理费必须在交易签名之前确定。因此，恰当确定费用的问题仍然很重要——每个人都希望自己的交易能够快速确认，而且成本要尽量少。于 2017 年，将平均交易添加到比特币数据库中的费用高达 50 美元。支付这样的费用显然不是最佳选择，特别是在通过智能计算费用与传播时间可以节省多达 90% 的情况下。

因此，新交易流量急剧增加的后果是因为存存在一个庞大的交易队列等待被添加到区块中。在其中，有些交易是发送者在价格急剧上涨之前刚创建的交易，或者仅仅是没有注意到记录价格的飞涨。通常情况下，主要问题不是因为用户，而是由于钱包软件或管理比特币的服务。此外，许多用于处理比特币的软件甚至将费用管理隐藏在用户视线之外。


### 解决费用波动问题

与使用固定或手动更新数值不同，比特币钱包可以使用特殊机制来估算数据记录当前的价格。这些机制被实现在钱包软件中，并允许用户智能地管理数据记录的优先级。

值得注意的是，可以预测数据记录的价格。然而，这类预测通常仅适用于非常短的时间段（通常为几分钟）。如果预测过时且交易未被确认，那么你很可能需要等待很长时间（几个小时，甚至一整天）才能得到确认。

**交易费用 = 交易大小 * 字节价格**

动态（或自适应）费用计算意味着自动估算未来几小时内交易的最终大小（以字节为单位），以及向比特币数据库添加一字节数据的价格。针对这两个估算，有专门的算法用于分析交易和网络上的活动。在获取到交易大小和向比特币数据库添加一字节数据的价格的估算后，将这两个值相乘，结果将是您需要作为交易费用添加到您的交易中的比特币数量。

自适应计算的优势在于你包括的费用更加精确；它将高于最低阈值，但不会太高。此外，该交易到达未确认交易队列末尾的概率很小。然而，也有例外情况，因此我们将更详细地考虑在紧急情况下可以采取的措施。


### 增加交易费用在交易发送后

比特币协议目前在费用方面相当灵活。有两个协议改进允许你即使在交易已经创建并发送到网络之后仍然增加费用：_取代式费用 _ （ _replace-by-fee_ ）[69] 和 _父子支付_ （ _child-pays-for-parent_ ）[70]。不幸，只有少数钱包支持这种功能，但随着时间的推移，支持此功能的钱包越来越多。

_RBF（replace-by-fee）_ 允许用费用增加的替代交易替换未确认的交易。这意味着用户可以再次创建一笔交易，使用与第一次尝试相同的硬币，但这次为交易设置更高的费用，然后再次提交到网络。有一套规则确定如何创建这样的交易以及网络节点应该如何进行替换。这两笔交易互相冲突，最终只有一笔会获得确认。

_CPFP（child-pays-for-parent）。_ 在这种情况下，需要创建一笔尝试花费你未确认的父交易的比特币新的子交易。在这笔子交易中，你包含了对验证者有利的费用。但是为了确认它并获取费用，验证者首先应该确认父交易，并最终将它们两个都添加到自己的区块中。这种方法是于2016年8月提出的[71]。这种方法有一些技术上的细微差别和对其正确使用的组织要求。其中一个要求是用户（或者软件以自动模式）应重新计算交易的费用，创建并签名一笔新的替代交易，将其分发到网络，并持续监控这交易的状态。

把交易用着 child-pays-for-parent 方法确认的示例如图 4–58 所示；在那里可以看到两笔相应的交易（父交易与子交易）在一个区块中被确认。

![图 4–58](/resources/img/volume-1/4.7-fees-mechanism-in-bitcoin/4.58-child-pays-for-parent.png "图 4–58")

正如所见，提高费用的问题是可以解决的，但还有一定的不便之处。尽管 RBF 和 CPFP 选项已经支持比特币钱包软件协议相当长的时间，但它们在比特币钱包软件中的采用速度比较缓慢。


### 隔离见证如何帮助降低费用？

请回忆一下，随着隔离见证（Segregated Witness）更新的实施的协议改变引入了之一，是新的交易格式和其 _权重（交易权重）_ 。在隔离见证出现之前，通常在计算费用时只考虑了交易的大小，而现在交易的大小和权重都变得重要。新的交易包含了一个单独的结构（见证数据）来硬币所有权证明。为了将 _交易大小（总大小）_ 转换为其权重，见证数据的大小乘以的系数比其他交易数据小。交易的权重使用以下公式进行计算。

**交易权重 = 基本大小 × 3 + 总大小**

在这种情况下， _基本大小_ 是指不包括见证数据大小的交易大小。见证数据中包含的任何数据所需的费用比其他交易数据要少四倍。这种方法允许验证者确定在区块中所占空间和收到的奖励方面更有利的交易。

大约 60% 的所有交易数据都是硬币的所有权证明（这些数据可以包含在见证结构中）。因此，新格式交易的权重显著减少，因此用户支付的确认交易的费用也减少了。此外，对于验证者这些交易与支付更高费用的旧交易具有相同的优先级。

图 4–59 显示了在共享比特币数据库中添加一字节数据的价格与负载（未确认交易流）的依赖性，作为字节每秒（byte per second）表示。结论很简单：如果新交易的流量低于或等于比特币的容量，那么记录的价格几乎为零。如果新交易的流量超过了比特币的容量，则价格会急剧上涨。

![图 4–59](/resources/img/volume-1/4.7-fees-mechanism-in-bitcoin/4.59-dependence-of-fees-and-capacity.png "图 4–59")


### 朋友矿工案例

想象一下，你有一个朋友参与比特币的挖矿，并控制着整个比特币网络的 10% 的处理能力。这意味着他平均每 100 分钟生成一个区块。如果你们的友谊足够牢固，你可以创建一笔零费用的交易并为了确认发送给你的朋友（图 4–60）。

![图 4–60](/resources/img/volume-1/4.7-fees-mechanism-in-bitcoin/4.60-friend-miner-case.png "图 4–60")

平均来说，你的交易将在 100 分钟内以 100% 的概率获得第一次确认，全面的确认将在第一次确认后的 50 分钟内完成。因此，你的交易将在 150 分钟内获得全面的确认。如果你没有这样的朋友，交易的全面确认大约需要 60 分钟，但你需要支付费用。

因此，如果问题涉及节省费用，拥有掌控比特币中相当一部分挖矿能力的矿工朋友是一种幸运。不过，即使你没有这样的朋友，也有其他支付区块空间的替代方式。


### 卖出确认队列中的位置的选项

通常情况下，验证者按照一种标准方案运作，并根据添加每字节数据的价格对交易进行排序，似乎每个挖矿软件都是这样组织的。然而，验证者可能有一种更好的激励方式：他们可以自行制定一种货币化其活动的策略（即利用一种另类的方法将交易加入到区块中）。如果验证者发现更有利或相关的方法，他们很可能会考虑改变其策略。这种方法假设用户可以向验证者直接支付其交易的确认费用，但不使用预先确定的费用，而是根据其自己的业务逻辑来进行支付。

在实践中，任何足够大的挖矿池都可以开展活动，以增加其盈利能力，并使用简单的机制，例如：  
* 确定交易排序的优先级  
* 与特定服务（交易所、商店、浏览器等）建立合作关系  
* 出售未来区块中特定空间的保证

此外，挖矿池甚至可以预售其区块中的空间证书，作为在未来提供一定系统容量的义务（有关代币化的更多细节，请参阅 6.4）。

### \*\*\*常见问题\*\*\*

_“如何向矿工朋友发送零手续费的交易？”_

作为普通交易，它不太可能在网络上传播，因为节点配置具有默认参数 _minRelayFee_ ，不等于零。这意味着交易必须有一个大于某个阈值的费用。只有这样，节点才会对交易做出反应并将其传递。这样做是为了防止垃圾邮件。因此，在这种情况下，用户可以采用不同的方法将这种“异常”的交易传输给矿工朋友。其中一个选项是通过在用户节点的配置文件中手动输入网络地址，强制将用户节点连接到矿工朋友的节点验证器，并将节点验证器的 minRelayFee 设置为零。但是有一个问题：朋友节点必须区分“异常”交易和其他用户的交易。因此，另一种解决方案是用户钱包和朋友节点验证器使用自己的 API。

_“如果验证者可以接受更少比特币，就通过出售证书收取较少的费用有什么好处？”_

这样做的好处在于验证者可以提前出售区块中的空间。例如，他可能需要比能够创建区块的时间更早的资金。此外，固定的价格对比特币钱包用户可能很重要；有时他们需要提前几个月了解成本。另外，这为用户提供了一定的保证，即未来的区块中将以预先确定的价格为他们的交易提供位置。


## 4.8 支付通道与闪电网络

这种 _支付通道_ 的概念（及其在 _闪电网络_ 中的发展）无疑已经对数字支付领域产生了革命性的影响。这种概念的应用不仅限于加密货币。对于任何数字会计系统来说，容量限制以及用户隐私的关切都是重要问题。在数字通信系统出现之前，这些问题并不相关。从一只手到另一只手传递纸币显然不需要访问服务器，也不会被跟踪或审查。数字会计系统的出现使得可以快速转账资金，而不受黄金或纸币交付的物理限制。然而，在数字系统中，每一笔新交易都应尽快添加到数据库中，发送方与接收方都可以访问该数据库，以便双方都能验证付款是否已完成。此外，拥有所有交易历史记录访问权限的一方（例如政府）通过分析这些历史记录并跟踪公民的活动，对影响人们生活有着巨大的影响力。

出现的链下支付通道和闪电网络（LN）[72]允许为创建可扩展、安全、廉价且真正以点对点方式工作的支付网络避免侵犯隐私。下面我们将讨论这两种机制的原理，它们在比特币环境中的特点，并了解它们的工作方式。


### 支付通道是什么？

第一次提出支付通道的概念多年前是中本聪在给协议的一位活跃开发者的私人信函中描述的。那时，比特币尚未获得足够重要的更新来实现可靠的支付通道。然而后来这变得可能，于 2013 年开发者们回头重新考虑了这个真正有前景的想法。我们将考虑实施支付通道的主要方法。

_支付通道是一种允许进行多次支付，而无需为每笔支付都添加到区块链中的方法。_ 为了打开和关闭支付通道，交易双方需要执行两笔链上交易，分别是开启和关闭。通道成员仅相互交互 [73]，不需要额外的验证者或可信任的第三方的存在。

使用支付通道的过程类似于在日常水平（纸质记录）上记录贷款。不同之处在于通过支付通道，各方有保证能够履行义务，而纸质记录无法提供这种保障。

接下来，我们将讨论支付通道的原则以及允许开发和应用此概念以改进比特币的协议，即闪电网络。


### 为什么需要支付通道？

比特币的主要限制是交易确认时间长以及不可预测的费用，这使得微支付（例如，零点几美分的支付）变得不切实际。与常规交易相比，支付通道有哪些优势？在支付通道中，参与者在彼此之间进行支付，而无需在比特币网络上发布交易。接收方进行快速独立验证并接受支付。由于仅涉及少数各方，费用默认不存在。由于这一特性，支付通道也被称为 _微支付通道_ [74]。

支付通道成员之间的交互默认是私密的。每笔微支付的详细信息将对其他人保密，只有使用支付通道的事实会为公众所知，即建立支付通道的特定比特币地址。

值得注意，支付通道的参与者不一定需要互相信任。支付通道中的安全机制可以防止交互各方的欺诈行为。其理念在于，在欺诈情况下，恶意方不仅会失去他试图非法占有的硬币，还可能会根据实现方法失去他开通通道时的所有硬币。


### 支付通道：一步步的例子

在简化的版本中，支付通道的操作如图 4–61 所示。爱丽丝和鲍勃拥有带有额外模块的比特币钱包，用于处理支付通道。这些模块交换用于进行支付的数据（例如，有关硬币分发的数据，与签名相关的相关数据等）。

![图 4–61](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.61-operation-of-payment-channel.png "图 4–61")

这将是很有趣仔细地认为并看到硬币在支付通道怎么分发的方法（图 4–62）。

![图 4–62](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.62-interaction-within-payment-channel.png "图 4–62")

_步骤零_ ：为了开启通道，爱丽丝和鲍勃创建了一个多重签名地址，然后各自将他们的比特币转移到这个地址，假设是每人5比特币（BTC）。因此，这个多重签名地址现在存有10比特币，每人“拥有”5比特币（下面我们会解释“拥有”是什么意思）。

_步骤一_ ：现在，假设爱丽丝想要支付鲍勃 2 比特币作为某项服务的费用。为了实现这一点，爱丽丝创建了一笔链下交易，在支付通道的价值分配，使得爱丽丝现在拥有 3 比特币，鲍勃拥有7比特币。

_步骤二_ ：爱丽丝需要再次支付鲍勃，比如1比特币。为了将其转移给鲍勃，爱丽丝再次创建了另一笔分配规则分发硬币的链下交易，使得爱丽丝现在拥有 2 比特币，鲍勃拥有 8 比特币。

_步骤三_ ：现在鲍勃决定支付爱丽丝 7 比特币，因此他创建了一个新交易，并相应地分配了硬币：爱丽丝拥有 9 比特币，鲍勃拥有 1 比特币。

_步骤四_：爱丽丝和鲍勃进行了所有必要的支付后，他们关闭了通道。为此，他们在比特币网络上发布了最后一笔交易（就是鲍勃在步骤3中创建的交易）。这笔交易的输入是存储在多重签名地址上的 10 比特币；这笔交易将支付 9 比特币给爱丽丝，1 比特币给鲍勃。

值得注意的是，所有交易中只有两笔发生在比特币网络上，即开启通道的交易（步骤零）和关闭通道的交易（步骤四）。其余的交易都是链下进行的，因此并未给比特币网络增加负担。因此，爱丽丝和鲍勃无需为这些交易支付任何费用。在支付通道内，他们只是相互交换着相同的交易，具有相同的输入，但输出字段已更新。当时机成熟时，他们中的一人将最后更新的交易发布到比特币网络上。


### 支付通道的特点

支付通道（作为概念）与普通交易相比并没有什么值得注意的缺点，但它们确实具有某些特点。

支付通道必须开启，并且迟早需要关闭。这些过程是通过单独的链上交易来完成的。对于这些交易，不可避免地需要等待确认并支付手续费。需要注意的是，在开启交易时最好等待完整的交易确认，因为你必须确保您开启通道的代币确实被锁定在一个多重签名地址上。

在特定通道内，支付仅限于预定义的金额（按照我们上面的例子，这意味着爱丽丝和鲍勃只能在预定义的 10 BTC范围内进行交互）。这个金额是参与者在彼此共同的多重签名地址上的存款总和。

支付通道可以是 _单向的_ ，也可以是 _双向的_ 。这取决于通道实施的方法。

通道的生命周期和通道内最大支付次数可以是无限的。然而，根据技术的不同，可以设置通道参数的限制。因此，通道可以在特定时间到来时或预定时间之前关闭。此外，通道既可以由参与者相互同意关闭，也可以根据其中一方的要求关闭，但需要满足特定的要求。


### 支付通道的实现方法

正如我们在爱丽丝和鲍勃的例子中提到的那样，用户拥有一个特殊允许他们在支付通道内进行交互的模块。根据实现方式，这些模块可以支持不同的支付通道运作方法。我们将列举一些最流行的方法。

_Spillman 风格支付通道_ 是具有有限寿命并无限次数支付的单向通道的最简单版本。

随后，比特币协议进行了另一次改进， _CLTV 风格支付通道_ 变得可用，这是对以前方法的改进。

_Poon–Dryja 支付通道_ 是具有无限运行时间的双向通道的一种方法。它们需要比特币协议的几次更新，最近已经采纳：这些通道被用于闪电网络的设计中。

_Decker–Wattenhofer 双工支付通道_ 是同时使用两个单向通道的选项。它可以改善通道的属性，因为它形成了一整个替换交易的树，而不是一个连续的可替换链。

我们将详细讨论 Spillman 风格的实现，因为它是最简单和最容易理解的方法之一。


### Spillman 风格支付通道

_Spillman 风格支付通道_ 是创建单向支付通道的方法，在这里有发送方和接收方的角色。该通道的运行时间由发送方任意设置，而接收方可以提前关闭通道。该通道的基本操作步骤如下图所示（见图 4–63）。

![图 4–63](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.63-spillman-style-payment-channel.png "图 4–63")

为了更好地理解，假设有一项服务可以交换对 Wi-Fi 接入点的访问权，还有一个想获得 24 小时 Wi-Fi 接入的客户；假设该服务的费用是一枚硬币。客户不信任该服务，因此希望按秒支付流量费用。

服务提供方和客户决定打开一个为期24小时的支付通道，支付金额为一枚硬币。服务提供方生成了一个新的数字签名密钥对，并将公钥传递给客户。客户随后生成了一个新的密钥对，使用自己的公钥与服务提供方的公钥创建了一个 2-of-2 的多重签名地址。然后，客户创建了一笔交易编号为一的交易，通过这笔交易将1比特币发送到多重签名地址。客户已签名该交易，但尚未将其发送到比特币网络，因为服务可能会欺骗客户并拒绝签署任何进一步转移1比特币的交易。

因此，客户创建了交易编号为二的交易，从多重签名地址向他自己控制的地址发送了 1 比特币；同时，他设置了 nLockTime 字段，使得交易只能在24小时后确认。客户没有签署此交易，而是将其发送给服务提供方，后者同意客户可以取走整个硬币，但不得早于一天后，然后用其密钥签署该交易。服务提供方将签名传递给客户，客户检查该签名。现在客户有机会用自己的密钥签署交易，在公司决定拒绝服务的情况下，有保证地取回硬币。因此，第二笔交易实际上是对欺诈行为的一种保险，甚至在资金发送给服务提供方之前也必须签署。这种保险方法是通过正确使用锁定时间机制实现的。也正因为如此，我们可以断言用户在为多重签名地址进行资金投入后就实际“拥有”了一定数量的硬币。

下一步是将第一笔交易分发到比特币网络或者发送给服务提供方，以便在客户没有连接时进行分发。一旦第一笔交易确认完成，支付通道即被视为打开。

在这种情况下，交易 1 被称为资金交易，交易 2 被称为 _退款交易_ 。

支付通道内的支付结算是如何工作的？请看下面的示意图（图 4–64）。

![图 4–64](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.64-coins-settlement.png "图 4–64")

为了发送第一笔付款，客户请求服务的比特币地址，这个地址是由服务自己控制的。接下来，他创建了一个交易 3，其中来自多重签名地址的代币被分配到两个输出。第一个输出是支付给服务地址的费用，比如说，用于其 Wi-Fi 接入点操作的 1 秒。第二个输出是转移到客户的地址。客户用自己的密钥对交易3进行签名，并将其传递给服务。服务检查交易和签名的有效性，然后接受支付；如果最终在 24 小时内签署此交易，它可以确保获得第一个流量的支付。如果服务打算继续向客户提供服务并在通道中收取支付，那么它只需将交易3本地保存，直到通道关闭为止。

为了发送下一笔付款，客户更改交易 3 的输出值，重新签名，并且他需要传递给服务的只有他的签名与付款变动的金额。服务也检查收到的数据并保存交易 3 的新版本，在这个版本中，服务会收到更多的代币（参见图 4–65）。

![图 4–65](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.65-publication-to-the-bitcoin.png "图 4–65")

如何关闭通道？图表显示服务必须在通道运行时间结束之前成功在比特币网络上发布交易 3 的最新版本。否则，发送方可能会欺骗，并通过最终签署并发布交易 2 将全部金额提取到自己的地址。

请注意，在通道打开的任何时候，客户都可以发布退款交易，并在其中设置任何在一个比特币内的转账金额（即通道最初开启时的金额）。如果退款交易在主链上发布，并且其锁定时间字段中设置的时间已到，则该交易很可能会被确认。因此，服务始终监视客户是否将退款交易发布到网络上；如果客户发布了退款交易，服务将提前终止与客户的合约，通过发布交易3的最新版本来关闭通道（即锁定时间设置的时间）。第三笔交易可以被视为有效，因为它由客户签名。这样服务就能确信客户无法欺骗和窃取资金。


### 支付通道的应用

有两个把支付通道应用的方法。第一种和基本的方法是将它们用于已经建立好的各方之间的常规支付。第二种方式是通过通道交换，即闪电网络（LN）的情况。

通道交换可以定义为能够在没有直接与对方建立支付通道的用户之间进行支付的能力。在这种情况下，硬币通常通过一系列不相互了解的用户的通道传输。

在 LN 的情况下，存在额外的复杂性和特殊性。这些复杂性与制定通道交换的普遍接受格式以及节点通信协议的发展有关。同样重要特定开发者的钱包应该能够与其他开发者的钱包进行操作。另一个可能是最关键的困难是路由问题。问题在于需要找到最短的传输路径，同时考虑到每个通道中的硬币数量和可能的传输限制。


### 比特币网络的特点与闪电网络的运行

在比特币网络中，完整节点彼此交换有关交易、区块以及网络地址的数据。还有轻量级节点，它们只接收它们所需的信息，而无需处理与存储整个历史记录。因此，达成共识并形成了共享数据库。

_闪电网络_ 意味着通过一系列已打开的 _双向支付通道_ 可靠地将付款从发送方路由到接收方；此外，这些路由集合可以通过外部参与者的通道建立，这些参与者既不了解发送方也不了解接收方的付款。闪电网络节点不交换交易，也不像比特币那样达成共识。因此，闪电网络的每个节点都应该直接从比特币网络节点或者可信任的来源获取有关其交易的最新信息。

LN的概念是随着比特币中支付通道的出现而形成的[73]。大约在首次提出支付通道概念的同时，比特币核心开发者彼得·托德（英文：Peter Todd）和加文·安德烈森（英文：Gavin Andresen）开始考虑在主要会计系统之上创建支付网络。然而，直到2015年，世界才见到了一份名为《比特币闪电网络：可扩展的链下即时支付》的工作 [75]。

LN白皮书发布时，其描述的理念与当前版本的比特币不兼容，因此需要对协议进行一些更改。首先进行的更改是添加了操作码OP\_CHECKLOCKTIMEVERIFY和OP\_CHECKSEQUENCEVERIFY，它们允许将硬币在一段时间内锁定。此外，SegWit更新是必不可少的，它于 2017 年夏季激活（参见第4.6 节）。官方称，闪电网络于2017年1月进入alpha阶段[76]；同时出现了第一个完整的实现[77; 112]。

正如前面提到的，在 2017 年夏天，SegWit 更新发布，并成为引入闪电网络的基础。三个月后，Blockstream宣布通过闪电网络进行了首次成功的交易[114]。11 月份完成了比特币和莱特币网络之间的首次货币转移。12 月，Blockstream、闪电实验室和ASINQ的主要团队宣布他们的实现完全兼容。

图 4–66 中的边表示比特币网络和闪电网络节点之间的网络连接。图中的箭头表示这些节点之间的互动，这对于状态的更新是必需的。闪电网络的节点需要更新彼此的状态信息并交换消息，以支持支付通道的运行。

![图 4–66](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.66-message-exchanging.png "图 4–66")


### 闪电网络如何操作？

要理解LN的基本思想，请考虑以下例子。假设镇上有一家杂货店允许顾客使用比特币付款。此外，这家商店还为常客提供了与其建立双向支付通道的机会，以便双方都可以节省费用和交易确认时间。爱丽丝与鲍勃都是**常客**，并且都与该商店建立了支付通道。

LN 的想法是不仅爱丽丝和鲍勃可以向他们已经建立通道的一方（在我们的例子中是一家杂货店）进行支付，他们还可以通过将这个一方作为中介来相互转移硬币。重要的一点是客户不需要信任这个中介（实际上，这些中介的数量通常不止一个）。

正如我们上面所描述的，特定的支付通道实现是设计成防止根本的欺诈行为的（试图窃取交互方的硬币可能最终导致你失去所有资金）。闪电网络也是基于相同原则运作的。“传递”您资金的中介在技术上被阻止窃取你的硬币的能力。这就是使闪电网络中的支付具有原子性的原因：硬币的转移要么成功而完全进行，要么根本不进行。这种无需信任的互动的基础是将锁定时间机制正确实现到LN协议中（更多详细信息将在本书的下一卷中讨论）。

为了更清楚地了解闪电网络的运作原理，现在考虑一个示例（图 4–67），展示了当爱丽丝向鲍勃转移硬币时，虽然他们之间没有直接打开支付通道。

![图 4–67](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.67-simplified-example.png "图 4–67")

图中以图解方式展示了一个由 6 个用户组成的小网络，每个用户都有一个节点。实际上，实际情况下可能会有数百个节点。假设爱丽丝需要向鲍勃转移 2 个比特币。在这种情况下，她的节点软件将需要找到“传递”硬币的最佳路径。由于网络中的节点不断同步，爱丽丝的节点了解有关其他已打开通道的必要信息，比如硬币数量、通道开启的时间等。

爱丽丝的节点软件确定了可以将 2 个比特币传输给鲍勃的路径。该过程如下：在爱丽丝和肯尼之间的通道中，余额状态为 6|10，这意味着爱丽丝有 6 个比特币，肯尼有 10 个比特币，可以进行价值转移。在肯尼和丹尼斯之间的通道中，余额状态为 1|4，即肯尼有1个比特币，丹尼斯有4个比特币，价值转移（2 个比特币）是不可能的。值得注意的是，如果在肯尼和丹尼斯之间的通道中，余额状态被颠倒（4|1），价值转移就可以完成。

![图 4–68](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.68-sending-the-payment.png "图 4–68")

现在是第二条路径。在爱丽丝和叶娃之间的通道中，余额是 17|43，可以进行价值转移。在叶娃和戴夫之间的通道中，余额是 4|1，可以进行价值转移（正如你所看到的，戴夫在叶娃和戴夫通道中只有1个比特币，并不妨碍爱丽丝的 2 个比特币转移，因为只有发送方需要具备所需金额）。最终，在戴夫和鲍勃之间的通道中，余额为 17|15，意味着可以进行价值转移，爱丽丝能够通过两个中间人叶娃和戴夫向鲍勃转移2个比特币。图 4–69 生动地展示了在爱丽丝将她的 2 个比特币转移到鲍勃后余额状态的变化。

![图 4–69](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.69-state-of-channels.png "图 4–69")

实际上，在同样的情况下，还存在另一种从爱丽丝发送支付到鲍勃的可能途径。爱丽丝可以将支付拆分为两部分，并分别发送硬币：通过叶娃和戴夫发送1个比特币，通过肯尼和丹尼斯发送另外1个比特币（见图 4–70）。

![图 4–70](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.70-sending-the-same-payment.png "图 4–70")

在图 4–71 中可以看到如果以这种方式进行支付（即爱丽丝将硬币拆分并分开发送），每个通道余额的变化情况。

![图 4–71](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.71-end-state.png "图 4–71")

在实际情况中，节点数量与可能的路径要多得多。此外，闪电网络并不像比特币网络那样统一。这意味着存在负载较大和较小的节点，以及活动不一致的节点。在图 4–72 中可以看到 2018 年 12 月闪电网络的相关状态 [78]。

> **_2018 年闪电网络统计数据_**  
> * _预计有 4500 个节点_  
> * _平均打开了 14000 个通道_  
> * _把 479.70 比特币在比特币网络上锁定（在闪电网络中流通）_

![图 4–72](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.72-state-of-ln.png "图 4–72")

为了打开支付通道，你需要冻结一定数量的比特币；因此，在通道中发送和接受支付只能在限定的、预先确定的金额范围内进行。如果普通用户将其比特币分成几部分，并相应地打开了几个通道，那么他只能在每个通道中操作有限数量的比特币。这就是为什么像钱包开发者、中心化交易所或知名商家等大型机构将作为枢纽。他们可以负担不断地维持为大的金额并长时间打开的好多通道。普通用户很可能最多只会与这些枢纽中的一个或两个打开一个支付通道。

基于上述事实，让我们定义闪电网络节点的基本功能。

> * _路由功能_  
> * _开启通道_  
> * _在中间节点之间进行转账_  
> * _关闭通道_

路由是闪电网络节点中最复杂的功能之一。每个闪电网络节点会考虑到诸如特定通道的容量、通道开放的金额、随着支付在网络上传递可能发生的这些参数变化，以及在某些通道突然关闭时的“备用计划”，来确定支付的最佳路径。

此外，每个网络节点都必须确保与其他节点建立了开放通道。对于网络某些通道尤为重要，它们的丢失可能导致网络故障和安全漏洞。为了避免这种情况，每个节点应该尽可能地与尽多节点建立连接。

或许，网络节点的最重要功能之一是进行支付。节点能够直接执行的支付的规模和数量取决于该节点开放的通道宽度。

网络节点的另一个功能是关闭支付通道。在闪电网络中，存在所谓的主导节点（拥有大量已开放通道的节点）。从某种意义上说，这些节点可以通过开放或关闭它们的支付通道来操控资金流动。这个问题可以通过增加所有闪电网络节点之间的通道数量来解决。然而，这种方法对节点所有者可能相当昂贵，因为他们需要支付开放和关闭通道的费用，而且他们还应该有足够的资金来冻结并维护其通道的运行。

### \*\*\*常见问题\*\*\*

_“支付通道中的转账与普通比特币交易相比有多可靠?”_

支付通道中的支付可靠性可以与普通比特币交易进行比较；资金不会被夺走，支付也不会被取消。然而，存在一些特殊性，比如需要准时开启和关闭通道、通道中的金额受限、需要与比特币网络进行持续同步、一定时间内资金被冻结的可能性等。

_“闪电网络的容量是否受限？”_

事实上，并没有限制，但可能会有与通道处理、网络探索和路由规划有关的延迟。这取决于特定网络节点的性能。还应考虑到节点可能会无法预料地离线，这可能会对向其他参与者付款造成一定的限制。

_“通道成员应该互相信任吗？”_

不应该，支付通道的机制根据协议可以防止交互方的恶意行为。

_“发送仅一笔支付的人开通道有什么用？”_

如果一个人想要花掉最后的硬币并且不再计划接受并发送支付，那么开启通道是没有意义的；相反，最好发送一笔常规的链上交易。在其他所有情况下，开启通道都会很有用。例如，它可以减少费用和交易确认时间。

_“侧链和支付通道有什么区别？”_

_侧链_ 是一个独立的区块链，用于记录来自 _主链_ 的代币。侧链的规则可能不同于主链的规则，并由新的协议确定。侧链没有基础货币，但它实现了来自主区块链的硬币转移机制。同时，支付通道不是一个独立的区块链，也不实现来自主链的代币转移。它仅仅是一种进行多次支付的方法，无需由验证者处理交易（为了每个支付通道只确认两笔交易：开启和关闭）。

# [5 区块链技术](/chapters/volume-1/cn/5-区块链技术.md)
