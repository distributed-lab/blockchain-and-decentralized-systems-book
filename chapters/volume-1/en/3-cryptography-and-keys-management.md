# 3 Cryptography and keys management


## 3.1 Introduction to cryptography

In this subsection, without going into a deep dive, we are going to get acquainted with cryptography as a science, its 
tasks, and basic mechanisms. We will consider the specific cryptographic mechanisms and functions applied in the Bitcoin 
protocol. Also, we will pay attention to the working features of a digital signature and the digital keys used for 
operating with it; these aspects are primarily of a practical nature.

*Cryptography is the science of information protection using mathematical methods*. Its role in the development of 
information systems is hard to overestimate. Bitcoin became the world's first payment system where the main processes 
and operations are cryptographically protected.

You will have an opportunity to learn the basic principles of information security and consider the most important 
cryptographic algorithms related to the Bitcoin protocol.

### Principles of cryptographic information security

The development of cryptography began in ancient times. Its history dates back more than four thousand years. Initially, 
cryptography solved only one problem—ensuring confidentiality when transferring and storing data. To solve this problem 
then, such mechanisms as text shuffling, mixing of text symbols, use of alternative alphabets, etc. were used.

At present, cryptography uses a mathematical basis. It involves special transformations which are defined in branches of 
mathematics such as number and information theories, group theory, ring theory, field theory, as well as in some others. 
This kind of mathematics is not well-known to most people since it is not taught in most educational institutions.

Modern cryptography includes symmetric and asymmetric encryption schemes, digital signature schemes, data hashing 
schemes, key management methods, zero-knowledge proof schemes, post-quantum cryptography, etc.

> **Basic security services**
>> * *Ensuring data* ***confidentiality***
>> * *Ensuring data* ***integrity***
>> * *Ensuring data* ***accessibility***
>> * *Ensuring data* ***authenticity***

*Confidentiality* implies that unauthorized persons cannot access the semantic content of a document that is stored or 
transmitted. Most often this service is provided via encryption (symmetric or asymmetric).

*Integrity* implies that unauthorized persons cannot modify data unnoticeably. The task of verifying the integrity of 
data read from a carrier or received from a network is typically solved via hashing and checksum verification.

*Accessibility* implies that the parties having the right to access some information will definitely gain access to it.

*Authenticity* implies the ability to prove that data have definitely been received from a specific author. The task of 
ensuring the authenticity of data is typically solved using a digital signature. We give its simplified definition 
below.

> **_NOTE:_** *Unlike the other above-listed services, accessibility is ensured with other than cryptographic methods 
> (redundancy, usage of uninterruptible power supply systems, and so on).*

### Concept of key

A modern cryptographic key is a *digital sequence of a particular length created according to certain rules using random 
number generators and computed by a special algorithm*. A cryptographic key is the core part of cryptographic operations. 
Security of most cryptographic schemes is generally dependent on the security of keys.

In a general sense, a *private key* in Bitcoin is a large random natural number. There are special software and hardware 
random number generators which form a random sequence of a constant length (in the case of software number generators, 
it is actually more proper to speak about *pseudorandom numbers*). A private key is a natural number generated by this 
random sequence of a constant length. A public key is calculated from a private key by means of mathematical 
transformations (Fig. 3.1).

![Figure 3.1 -  Public and private keys relation](/resources/img/volume-1/3.1-introduction-to-cryptography/3.1-public-and-private-relation.png)

> **_NOTE:_** *When dealing with cryptographic algorithms that are considered sufficiently reliable (according to 
> cryptographic standards), the inverse transformation—obtaining a private key from a public key—cannot be done in 
> practice.*

In the field of cryptanalysis, there are certain methods which allow attacking cryptographic schemes more efficiently 
than by simply iterating over numbers. However, for keys of a long length, a practical implementation of the attack 
requires enormous computational power. This process would take a very long time (billions of years or even longer using 
current algorithms and hardware).

### Generation and processing of secret keys

In practice, it is very important that the schemes of key and digital signature generation work correctly and the 
security mechanisms be reliable. In cryptocurrencies, the *ownership of coins is proved by the knowledge of the private 
key which is required to calculate a valid digital signature*. For the key owner, it is important that no one else is 
able to steal, calculate, or generate the same key data.

What does it mean? Users of Bitcoin and other cryptocurrencies should use reliable random number generators (and truly 
random seeds for them) that produce objectively random sequences that could not be repeated under any other conditions. 
As we have already noted, generators can either be software or hardware. What is the difference?

*Software generators* cannot generate numbers which are random enough. They generate so-called pseudorandom numbers. 
This means that after a certain period, numbers begin to repeat, and it is possible to define this period. Obviously, an 
attacker can take advantage of such knowledge.

*Hardware generators* are usually based on stochastic processes that are hard or impossible to predict. Special sensors 
detect the noise of certain processes (e.g. Zener breakdown diodes, nuclear radiation), digitize it, and produce a 
stream of random bits. Based on the data of the stream, you can generate keys and use them in cryptographic schemes.

We will give you a relevant example. In the early stages of Bitcoin's development, there was only one wallet for Android 
devices—Bitcoin Wallet. The creators of this application had occasionally left a vulnerability in the code of the random 
number generator software. It was generating numbers in a certain narrow range, so it was possible to predict the subset 
of possible keys that belonged to users of this wallet. An attacker could iterate over the keys in the subset and have a 
high probability of finding those to which someone's coins belonged. And that's what happened. This caused a great 
scandal because a significant number of bitcoins were stolen. So, an update eliminating this vulnerability was released 
promptly, but the theft had already happened.

It is vital to pay special attention to the generation of random numbers. Some random number generators can combine both 
software and hardware implementations. Also, in order to improve the randomness, developers have introduced more 
*entropy* (unpredictability) [30] into the process of generating random numbers (e.g., you can use noise from a 
smartphone's microphone, gyroscope, any accelerometer data, etc.).

*Key compromise* is the state when an unauthorized person has access to secret information; it also implies the 
potential of such access or even the suspicion of such a possibility.

A compromised private key is a serious threat to any information security system. Therefore special measures are taken 
to protect private keys (or other confidential data): sensitive data is never written on the hard drive of a computer in 
the form of plaintext but rather stored on a separate medium which is encrypted, password protected, etc.

If keys are suspected of being compromised, they should be discarded and substituted.

### Concepts of one-way function and NP-complete problem

Before getting acquainted with hash functions, let's consider what a one-way function is and what features it has. 
A one-way function is a mathematical function for which:

* Obtaining its output value for any input argument is rather simple 
* Obtaining an input argument for its output value is very difficult (this means solving an NP-complete problem)

A simple example can be a broken cup: it is quite troublesome to pick up all its shards and restore them back to an 
unbroken cup. The same works with one-way functions: it is assumed that you cannot restore the initial message if you 
only have the output data. Theoretically, this is possible, but in practice, this task may prove to be extremely 
difficult (provided that a particular one-way function is sufficiently reliable).   

An NP-complete problem is this specific task of finding the initial message (to be more precise, the object which 
satisfies specific conditions). Following our example, solving the NP-complete problem is equal to restoring the 
unbroken cup. Finding the object is a complex task since it requires searching over a large number of possible options. 
Though, having a ready-made solution, you can check quite easily whether it meets the conditions.

A lack of a fast solution to NP-complete problems is crucial for modern cryptography: if there will be a way to solve 
the problem in a reasonable time (not millions of years), then a vast number of modern cryptographic primitives are at 
risk. Some examples of an NP-complete problem are the task of finding the preimage of a hash function and the task of 
finding a private key matching a specific public key as well as the so-called traveling salesman problem (we will 
discuss it a little more).

The traveling salesman problem is about finding the most advantageous route of all possible ones. According to the 
terms, one is to pass through all the marked cities and, after that, return to the initial city. Moving between two 
cities has a certain cost. To solve this problem and choose the optimal route, a salesman is to look over all the 
possible ways of moving. Note that the complexity of finding such a route grows exponentially as the number of the 
cities increases. If there are 5 cities in the terms of the problem, we will get 12 possible routes, yet given 10 
cities, we will have to look over 181,400 routes.

### Hash functions

*A hash function is a function that converts a set of input data of arbitrary length into an output bit string of fixed 
length that is executed using a certain algorithm.*

A hash function is a one-way function, meaning that having an output value (a number of a certain length), you cannot 
determine the data that has been submitted at the input. It is considered cryptographically secure if it can be attacked 
only with brute force. This means that the only solution to ensure that an output value has a specified value is to 
iterate over all possible input values. Schematically, a hash function is shown in Figure 3.2.

![Figure 3.2 -  Work principle of a hash function](/resources/img/volume-1/3.1-introduction-to-cryptography/3.2-principle-of-hash-function.png)

At the input, the hash function can receive a message of almost unlimited size (any data). At the output, a unique 
identifier (a hash value) is obtained. Having a hash value obtained with a cryptographically secure hash function, it is 
impossible to determine which data was originally submitted to its input. Moreover, Bitcoin uses several different 
hashing algorithms.

The principle of work of a hash function can be understood through the example of a function which sums all the digits 
in an input message and produces the result of one symbol length. The features of this function are as follows. Firstly, 
the result is obtained fast enough because of the simplicity of the counting algorithm. Secondly, this function is 
one-way as the output value contains only the data about the sum in a message but not the position of digits. Thus, the 
complexity of guessing the initial message grows with the length of the message itself (Fig. 3.3).

![Figure 3.3 -  Example of a simple hash function operation](/resources/img/volume-1/3.1-introduction-to-cryptography/3.3-silly-hash-function.png)

However, using this function might be insecure as it is relatively easy to find certain collisions in it: in this case, 
it is possible to substitute an input message (i.e., submit a message with the same digits to the input of the function) 
to get the same result (Fig. 3.4).

![Figure 3.4 -  Example of hash function collision](/resources/img/volume-1/3.1-introduction-to-cryptography/3.4-silly-hash-colision.png)

Now, let's consider what a hash function must feature so that its use would be sufficiently secure.

> **Requirements for a hash function**
>> * *Resistance to collisions*
>> * *Resistance to finding its first preimage*
>> * *Resistance to finding its second preimage*

*Resistance to collisions* means that there is no algorithm that could find collisions in a comparatively short time. A 
collision is a situation when there are several input values that match the same value at the output of a hash function 
(Fig. 3.5). 

![Figure 3.5 -  Hash function collision](/resources/img/volume-1/3.1-introduction-to-cryptography/3.5-collision.png)

*Resistance to finding the first preimage* (*non-invertibility*) implies that knowing the corresponding hash value will 
not allow you to restore an initial message in a realistic timeframe (one life may not be enough).

*Resistance to finding the second preimage* implies that having an initial message and a corresponding hash value, a 
party cannot create another message which would have the same hash function at its output.

Also, a cryptographically resistant hash function must ensure that changing even one input bit will, on average, cause 
the alteration of a half of the output bits. This feature is easily illustrated through the following example 
(Fig. 3.6). Bob creates a transaction in which he sends 10 bitcoins to Alice and then obtains the corresponding hash 
value. If someone would want to substitute the transaction by changing the amount of transfer (say, not 10 but 100 BTC), 
then the transaction counterfeit will be detected immediately.

![Figure 3.6 -  How output value of a hash function changes depending on the input](/resources/img/volume-1/3.1-introduction-to-cryptography/3.6-input-affect-output.png)

Among existing hash functions, one of the good examples is SHA-1 [31], which is considered relatively reliable and with 
a functioning principle that is quite easy to explain. The essence of its functioning lies in the cyclical shuffling 
(80 cycles) and the usage of byte operations (and, xor, rot, add, or) on input data. In Figure 3.7, you can see the 
operation of 1 cycle of SHA-1 (operations can be very simple and be performed on the most primitive hardware devices), 
where

* К<sub>t</sub> is the constant value,
* F<sub>t</sub> is the variable function with input data (which changes every 20 cycles), 
* W<sub>i</sub> is the element of modified input data (4 bytes),
* <<<*x* is the rotate shift of *x* positions to the left.

![Figure 3.7 -  Operation scheme of SHA-1](/resources/img/volume-1/3.1-introduction-to-cryptography/3.7-sha1.png)

### Application of hash functions

Hashing is very useful for obtaining a unique identifier for a dataset. In Bitcoin, a hash function is required to 
achieve *timestamping* and link blocks as well as to provide a particular data identifier (to prove the presence of 
particular data) while not disclosing the exact data. Consequently, hash functions have become widespread. Let's take a 
look at their main applications.

Hash values are used as checksums for data transmission. In order to verify that a message has not been accidentally 
corrupted due to some noise in the data channel, the receiving party can recalculate the hash value from the received 
data and compare it with the existing one.

Additionally, these functions are used to find duplicates of the data stored or to compare big datasets. In order to 
avoid comparing large amounts of data directly, one can store the corresponding hash values and compare them. If hash 
function values for different datasets are the same, the data itself is very likely to match as well. This significantly 
speeds up processes such as, for example, digital signature creation. Usually, when signing the document, it is not the 
message data that is signed but the hash value of this data. It is assumed that this hash value is sent along with the 
message and the signature. In this way, the recipient can verify both the integrity of the message and the correctness 
of the digital signature.

### Merkle trees

Merkle trees are a data structure linking separate pieces of data with a single root value. It allows proving that a 
specific data block matches a particular root value. This concept was published for the first time in 1979 by Ralph C. 
Merkle [32]. One of the first implementations of Merkle trees was used in the BitTorrent protocol.

A Merkle tree consists of the following components (Fig. 3.8):

* Merkle leaves 
* Merkle nodes 
* Merkle root

![Figure 3.8 -  Merkle tree structure](/resources/img/volume-1/3.1-introduction-to-cryptography/3.8-merkle-tree.png)

*Merkle leaves* represent hash values of data blocks that need to be included in the structure. A *Merkle node* is a 
value obtained through concatenation and hashing of either two child nodes or Merkle leaves. A *Merkle root* is also a 
node, the one at the top of the Merkle tree.

> **Features of Merkle trees**
>> * *Modifying at least one data bit in one of the blocks causes a Merkle root value to change completely*
>> * *In the event of corruption of one of the blocks, it is possible to determine fast and with high accuracy which of the blocks has been modified*
>> * *It is possible to quickly prove whether or not a specific block is a part of the Merkle tree structure*

### Symmetric encryption

In simple terms, *document encryption is the modification of document text in such a way that only he who has the 
corresponding key is able to restore the original text*. Let's take a look at how encryption works.

We will start with the most common type—symmetric encryption. Schematically, this process is shown in Figure 3.9.

![Figure 3.9 -  Symmetric encryption scheme](/resources/img/volume-1/3.1-introduction-to-cryptography/3.9-symmetric-encryption.png)

There is a function that performs data encryption: it receives a plain text and an encryption key to the input and 
returns encrypted data, a ciphertext. Data decryption is performed through another function: it takes an encrypted data 
and the same encryption key to the input and returns the raw data (plaintext) to the output. This type of encryption is 
called symmetric because the same key is used for both encryption and decryption.

The key advantage of symmetric encryption and the reason it’s been widely applied is the high transformation rate of a 
plaintext into a ciphertext, compared to other cryptographic primitives.

A striking example of symmetric encryption is the Vernam cipher, also known as a *one-time pad* (Fig. 3.10). The essence 
of this method is in the modular addition of an input text with a one-time key. In this case, an encryption key (which 
is also a key for decryption) and an input text must be equal in their length. This cipher is a good example because it 
is perfectly secure: having the ciphertext, an adversary cannot get any information about the initial message.

![Figure 3.10 -  Example of how Vernam cipher works](/resources/img/volume-1/3.1-introduction-to-cryptography/3.10-vernam-cipher.png)

This encryption method can be considered sufficiently secure only if the key was generated randomly. Generating a random 
key of a long size imposes another limitation because truly random generators are slow (if you compare the capacity of 
channels by which you need to transmit the secret data).

Let's observe the structural scheme of one of the modern symmetric ciphers—Advanced Encryption Standard (AES) [33] 
(Fig. 3.11). An interesting feature of this cipher is that data is presented as the byte matrix, and correspondingly all 
the operations are performed on the elements of this matrix. The basic operations used in AES are as follows:

* *Substitute* is replacing matrix elements with the corresponding table values 
* *Shift Rows* is moving matrix rows cyclically to the left by the corresponding number of elements 
* *Mix Columns* is multiplying matrix columns by the static, predefined matrix 
* *Add Round Key* is adding the state matrix with a round key

![Figure 3.11 -  AES cypher construction](/resources/img/volume-1/3.1-introduction-to-cryptography/3.11-aes.jpg)

Symmetric encryption has certain drawbacks. The main challenge is to provide confidentiality of the secret key while 
transferring it to the intended recipient *before* the secure communication starts; this is required because both the 
sender and the recipient need to have this key. The second drawback lies in the complexity of creating and storing a new 
key for each new participant in the system (where secure communication is based only on the symmetric encryption). The 
complexity of this problem increases quadratically as the number of participants grows (the number of new keys increases 
with the addition of new users). For example, if there are 10 users in the system, then the number of generated keys 
would be 45. And if we assume that the number of users increased tenfold (100 users), then the number of keys generated 
would be 4950 (which is a hundred times more).

### Asymmetric cryptography

Asymmetric cryptography was proposed in the 1970s, and it was a revolution in cryptography. Asymmetric cryptography uses 
the so-called key pair instead of a single key as in the symmetric cryptography. The key pair generally consists of a 
*private key* and a *public key*. The private key must be kept secret, while the public key can be transferred to the 
counterparty with whom to interact.

Suppose Alice wants to receive messages from her friends that only she can read. According to the asymmetric encryption 
scheme, she generates a key pair. She keeps the private key in her secret place and, for example, posts the public key 
on her page in social media or informs her potential counterparty.

When one of Alice's friends wants to send her a private message, he encrypts the document using Alice's public key and 
transmits this document through open data channels. After receiving the message, Alice decrypts it with her private key. 
Any other party that manages to intercept this message will not be able to access the text of the message. The benefit 
of this approach is that the number of keys in the system is proportional (has a linear dependence) to the number of 
participants, and the keys do not require a confidential channel to be transmitted (only the channel providing integrity 
is required which is much easier to achieve). Whilst in the case with symmetric encryption, the number of keys grows 
exponentially, which takes up much more physical memory on participants’ devices.

In Figure 3.12 you can see how asymmetric encryption works. There is an encryption function that receives open data and 
a public key to the input and returns the encrypted data to the output. The inverse function is called the decryption 
function. It accepts the encrypted message and the recipient's private key and returns the plain text of the message.

![Figure 3.12 -  Asymmetric encryption scheme](/resources/img/volume-1/3.1-introduction-to-cryptography/3.12-assymetric-encryption.png)

### Digital signature

Another application for asymmetric cryptography is a digital signature.

How does it work? A person who wants to sign a message, first of all, generates a key pair. The private key which will 
be applied to form a digital signature is kept secret. The public key is disclosed so that the recipient of the signed 
message could verify its authenticity. Now, in order to sign the message, a person uses her private key and sends two 
files: a signed message and an attached signature. Another person who wants to make sure that the document has been 
formed and signed properly can take the public key and the message and verify whether the signature matches them.

> **_NOTE:_** *In a digital signature scheme, a public key is used to verify the signature value regarding the signed 
> document. Hence, a public key must be transmitted securely (unless there is a public key certificate, which contains 
> the data about a specific identity associated with the key) to prevent the signature and the public key from being 
> substituted.*

The function that generates the signature accepts the author's message and private key in its input and generates the 
signature data attached to the message in the output (Fig. 3.13). After that, the message and the signature are sent to 
a recipient. A recipient uses a validation function to verify that the signature is correct. This function takes three 
parameters: a message, the value of the signature, and a public key. It returns a boolean value—the signature is either 
valid or not. The signature may prove to be incorrect if the message has been substituted, the signature data has been 
violated, or if an incorrect (corrupted or substituted) public key has been used for verification.

![Figure 3.13 -  How digital signature works](/resources/img/volume-1/3.1-introduction-to-cryptography/3.13-digital-signature.png)

### Adversary model and threat model

One of the prerequisites for building a reliable information system is the development of a security policy. For this, 
descriptions of the information security threat model and the model of an information security violator are often used.

A threat model is a structured description of possible threats (sources of a threat, information security services 
targeted by a particular threat, possible ways of threat implementation).

An adversary model is a structured description of an adversary (a possible adversary’s category, his goals, technical 
capabilities, and qualifications).

Let’s first consider who can be an adversary in the Bitcoin system. An adversary is a person or a group of people that 
perform actions that violate the security policy of the system (protocol). The following actors can be adversaries in 
Bitcoin:

* Users 
* Validators 
* Community members 
* Bitcoin services’ owners 
* Wallet developers

Noteworthy, each of the possible adversaries is a system participant. She can be involved in its management, influence 
the corresponding equipment in order to modify it, etc. In other words, there are almost no restrictions on how an 
adversary can act to attack the system.

What is a possible purpose of an adversary? Firstly, it is modifying the database to change the state of users’ 
“balances”. Secondly, it is attempting to restrict access of a particular node or several nodes to the current database 
state. In addition, an adversary’s purpose can be deployment of malware or direct modification of user software.

For completeness of an adversary model, an adversary’s technical capabilities and qualifications are also considered. 
Bitcoin is a system where nodes may have capabilities of any level (ranging from a single laptop to a cluster). That is 
why any potential adversary should be supposed to have the newest software and hardware as well as high qualifications.

Let’s try to describe the threat model for Bitcoin. We will consider which information security services the Bitcoin 
accounting system must provide and which ones an adversary may want to violate.

*Confidentiality*. By default, Bitcoin does not provide this security service. That is, the database is publicly 
available, and all transactions and messages between users are transmitted in plaintext.

*Integrity*. The use of blockchain technology in Bitcoin is focused specifically on providing this security service 
(accordingly, it requires maximum attention to all processes related to data processing: storage, transmission, etc.).

*Accessibility*. As mentioned earlier, the Bitcoin database is publicly available. Due to this, each user can 
independently audit all processes within the Bitcoin accounting system.

Depending on the categories and capabilities of adversaries, consider the threats that can be implemented in Bitcoin:

1. An attacker may create a transaction that double-spends coins (that creates funds out of thin air). 
2. An attacker who has a good reputation may persuade the community to adopt an update with some vulnerability. 
3. An attacker may create a fork and inject some vulnerability. After that, he may somehow switch some number of users 
to the target (vulnerable) system. 
4. An attacker may build a vulnerable protocol on top of Bitcoin and persuade the participants of Bitcoin to use the 
newly built protocol. 
5. An attacker may accumulate a lot of computational power and try to create alternative chains. 
6. An attacker may gain access to the other participants’ equipment (thus, she can take control over the major part of 
the computational power). 
7. An attacker may modify the network node software. 
8. An attacker may create fake sites and wallets (provide fake information). 
9. An attacker may modify her equipment (her device) and distribute it. 
10. An attacker may modify his wallet (his software). 
11. An attacker may intercept/substitute any message between system participants (e. g., in order to transmit incorrect 
transaction history or to restrict a particular node from accessing the current database state). 
12. An attacker may mimic any system participant or even the whole network (in this way, she can force an alternative 
history to a particular user or a particular group of users). 
13. An attacker may easily hide her actions (due to the fact that users are not identified within the Bitcoin protocol). 
14. An attacker may identify the participants of a particular transaction by analyzing their internet traffic (it is 
assumed that an internet service provider can trace all the incoming and outgoing traffic of a specific user).

After having mentioned the possible threats, we ought to say how to defend against them. The first 4 threats are the 
most difficult to implement, as this requires a lot of support from system participants. Since the security of users’ 
coins directly depends on the updates proposed, such proposals will be carefully explored and it is quite tricky to 
unnoticeably inject backdoors in them.

The goal of the threats 5 and 6 is to take control over a lot of computational power. These threats are very costly to 
implement, and rarely the benefits of such attacks exceed the expenses of performing them. On the other hand, such 
attacks are very dangerous for users, since in these cases, the attacker cheats on users while avoiding violation of the 
protocol.

The next 4 threats (7–10) are much easier to implement than the previous ones. Most often, they can be implemented by 
software and hardware vendors. Due to the fact that not every user checks the source code of the wallet for 
vulnerabilities, such attacks are more than likely. They can lead to users losing their coins. To protect from such 
attacks, users are advised to check wallet software for vulnerabilities and only use software from trusted sources.

The remaining 4 threats (11–14) are the easiest to perform, since they are implemented at the network layer. Such 
attacks can very rarely entail the loss of coins by users, yet they can restrict a particular user to access relevant 
information and limit his actions on the network. Protecting a decentralized system from such attacks is generally 
harder, but it can be done by increasing the number of connections of each user with other network nodes.

Despite all the above-listed, it is assumed that an attacker **cannot**:

* Guess which public key is used in a particular bitcoin address 
* Gain access to the private key in the memory of a protected device 
* Detect the second (or third) device storing one of the private keys from a particular MultiSig address (see 4.5)

## 3.2 Cryptography in Bitcoin

This subsection explores how the use of cryptographic properties of an elliptical curve helps to set up interaction in 
trustless systems.

## Features of elliptic curves

Elliptical cryptography is the fastest and the most effective method for constructing asymmetric cryptographic 
transformations in 2018 [34]. In particular, Bitcoin uses ECDSA—a standardized digital signature algorithm.

An elliptic curve (EC) over a field of real numbers consists of a set of points on a plane with the coordinates which 
satisfy the equation y2 = x3 + ax + b, where a and b are real numbers, and a so-called infinitely distant point, which 
does not have real coordinates. The specified canonical equation is a special case of the Weierstrass equation. The 
National Institute of Standards and Technology (NIST) recommends the use of 15 elliptic curves in digital signature 
algorithms [35]. Pseudo-random elliptic curves are most commonly used (EC parameters and fields are generated in a 
pseudo-random manner, often using hash functions). However, the curve in Bitcoin is not amongst those recommended by 
NIST and is a special type of EC because the coefficients and the base field were intentionally selected for greater 
efficiency of operations. In Bitcoin, a = 0, and b = 7, so the elliptic curve is defined by the equation 
y<sup>2</sup> = x<sup>3</sup> + 7 [36]. The graph of this curve over the field of real numbers is shown in Figure 3.14, 
and the more detailed curve segment containing inflection points is shown in Figure 3.15.

![Figure 3.14 -  Elliptic curve in Bitcoin](/resources/img/volume-1/3.2-cryptography-in-bitcoin/3.14-ec-in-bitcoin.png)

![Figure 3.15 -  Curve segment with inflection points](/resources/img/volume-1/3.2-cryptography-in-bitcoin/3.15-curve-segment.png)

The main operations on the group of points of an elliptic curve are the following: *addition*, *doubling*, and 
*multiplication by a scalar*. Note that a result of each of the listed operations is also a point that belongs to an 
EC [37].

The sum of the points of the curve defined over a field of real numbers has a simple geometric interpretation 
(Fig. 3.16). The sum of two points A<sub>1</sub> and A<sub>2</sub> is the third point 
A<sub>3</sub>=A<sub>1</sub>+A<sub>2</sub>, which is the inverse (by the Ox axis) of the third intersection point 
(-A<sub>3</sub>) of an elliptic curve and the straight line passing through the points A<sub>1</sub> and A<sub>2</sub>.

*Multiplication by a scalar is a multiple addition of a point with itself*. Figure 3.17 shows how a point is doubled.

![Figure 3.16 -  Addition of elliptic curve points](/resources/img/volume-1/3.2-cryptography-in-bitcoin/3.16-addition.png)

![Figure 3.17 -  Doubling of an elliptic curve point](/resources/img/volume-1/3.2-cryptography-in-bitcoin/3.17-doubling.png)

### Creation of addresses in Bitcoin

An understanding of the main principles of hash functions and features of generating keys for ECDSA is enough to delve 
into the address generation in Bitcoin. In the simplest case, an address is obtained from a public key as a result of 
applying hashing algorithms (Fig. 3.18). These are called Secure Hash Algorithm 2 (SHA-2) and RACE Integrity Primitives 
Evaluation Message Digest (RIPEMD), to be specific SHA256 and RIPEMD160.

![Figure 3.18 -  Scheme of address computation in Bitcoin](/resources/img/volume-1/3.2-cryptography-in-bitcoin/3.18-address-in-Bitcoin.png)

A public key is hashed using SHA256; in order to obtain the result, the hash value is calculated with RIPEMD160. The 
output is a 160-bit (20-byte) number. Next, this number is presented in Base58Check encoding. During encoding, 4-byte 
checksum and 1-byte version are attached, and further, the 25-byte number is converted into a string according to the 
encoding alphabet. The resulting string of 35 characters is considered a bitcoin address.

> **_NOTE:_** *The format of an address created with the above scheme is called P2PKH (pay to public key hash). Other 
> bitcoin address formats are considered in 4.5.*

The Base58Check encoding alphabet is similar to the alphabet of the widely applied base64 encoding, but it does not 
contain characters that are difficult to distinguish, such as "I" (uppercase "i") and "l" (lowercase "L"), "O" 
(uppercase "o") and "0" (zero), as well as the symbols "+" and "/".

Why have these specific rules for address generation been defined in Bitcoin? Firstly, in cases where a digital 
signature algorithm has been compromised, hiding a public key protects users from theft. Secondly, different functions 
were applied to minimize the risk of an attack on hash functions. As hash function standards used in Bitcoin are 
independent, it is extremely unlikely that both algorithms have a backdoor.

### Confidentiality in Bitcoin

The Bitcoin protocol processes data of transactions and blocks, receiving and transmitting them through the global 
network. While transmitted, the data is not actually encrypted but instead remains in plaintext. There is limited value 
in trying to protect this data from modification in transit by unauthorized persons because it has either been hashed or 
can be authenticated with a digital signature. Moreover, this data is not encrypted so that it can be verified by 
anyone.

Virtually the only purpose for which the encryption of data transmitted in the Bitcoin network may be applied is to 
increase the level of privacy of the network node itself. It is important when a node owner wants to act anonymously 
(for more detail, see 7.1).

### Basic vectors of attack on keys in Bitcoin 

There are several ways in which an attacker can compromise keys that are used to store bitcoins:

* Hacking of mathematics (elliptic curve, key generation algorithm, hashing algorithm, or digital signature algorithm)
* Hacking of the hardware that generates keys or performs the signature 
* Hacking of the communication protocols (handshake, key exchange, TLS, signature verification process, etc.)
* Hacking of the software wallets (key generation, randomness sources, key storage, injecting executable code, etc.)
* Social attacks

**Frequently asked questions**

*– Is a random number generator used when obtaining a public key using the ECDSA?*

No, it isn’t. A public key is computed given a particular private key, and this computation is one-way. Bitcoin uses 
cryptography based on its own elliptic curve, which is defined by the equation y<sup>2</sup>=x<sup>3</sup>+7. A public 
key is a point with coordinates x and y. Since private key is a certain large natural number, a public key can be 
calculated as follows: public key = private key · G, where G is a base point (a point on an elliptic curve). The result 
of this operation is a new point on the curve. A base point G is a constant parameter from the secp256k1 specification. 
Having a public key, you can generate a wallet address.

*– Is it possible to divide P by G and get a private key?*

In cryptography, this is called a solution to the problem of a discrete logarithm in a group of points of an elliptic 
curve. This equation cannot be solved directly. Finding a solution is subject to cryptanalysis. There are methods that 
can theoretically make it possible, but they require significant computational power and memory which are not available 
nowadays.

*– Is a public key required only for obtaining an address?*

No. In addition to address obtaining, a public key is used to receive and to spend coins. A user first computes his 
address and then receives the coins on it. A user needs a public key to prove that she is the owner of a particular 
address. All validators compute a hash value of the public key and then verify whether it matches the user’s address.

*– Is a quantum computer a threat to Bitcoin?*

At the time of writing in 2018, a quantum computer with its current register length is not a threat to the cryptographic 
mechanisms used in Bitcoin. However, quantum computers are gradually evolving, and the length of the register is also 
increasing, and so the complexity of problems that they can solve is also growing. In years to come, quantum computing 
could theoretically pose a threat to modern elliptical cryptography—that it would be possible to calculate private keys 
by knowing the public keys. This will happen only if сryptography in Bitcoin won’t be updated, which is unlikely.

*– How can the quantum computer threat to the algorithms applied in Bitcoin be mitigated?*

First of all, note that the Bitcoin protocol can be updated (longer keys for a digital signature may be used or a 
post-quantum digital signature algorithm may be implemented). If the protocol is not updated, even according to the 
current rules, an attacker will have about 10 minutes to guess the key, create an alternative transaction, and try to 
confirm it. The average time for the first confirmation of a usual transaction is 10 minutes (from the moment it is 
broadcast on the network). When a user receives coins on his address, he will not immediately disclose a public key, 
and so it cannot be attacked (in practice, a simultaneous breaking of SHA-2 and RIPEMD160 hash functions is extremely 
unlikely; the same goes as to the separate breaking of each of them by a quantum computer). A public key of a digital 
signature can be attacked when bitcoins are spent (when an outgoing transaction is sent to the network). This means that 
a quantum computer is not a direct threat to Bitcoin in 2018. Moreover, the probability of an attack depends on the size 
of the financial profit: for small amounts, the use of a quantum computer for an attack will not be economically viable 
because its cost will greatly exceed the value of the gainings.

*– Is it possible to identify a specific person in Bitcoin by associating her with a digital signature?*

No. It is false because such a digital signature is not certified. In Bitcoin, there are no certification authorities 
(CA), which would issue users’ public key certificates. Accordingly, it is very difficult to uniquely identify a person. 
Therefore, Bitcoin is considered comparatively anonymous. However, you can try to achieve this by other methods. For 
example, you can identify a counterparty when she is exchanging bitcoins for cash, you can make marked banknotes, you 
can track which software and which IP addresses were used to send transactions to the network. However, by default, a 
digital signature is not associated with a particular person.

## 3.3 Keys storage and processing

Despite the existence of regulations and practices of using digital signatures and digital identity in some countries, 
it is safe to say that the use of these mechanisms in people's lives has been and still remains particularly modest. 
However, with the advent of Bitcoin, it became clear that digitalization of property rights for all assets is an 
inevitable event that corresponds to the needs of the 21st century. Due to peculiarities of its architecture, Bitcoin 
only relies on a digital method of authenticating transactions, so that even a trading bot can become a network user. 
The most optimal way to implement such an interaction between users was to use cryptographic keys and digital signature 
schemes. Such an approach, however, requires users to be particularly careful when dealing with keys. For this reason, 
issues related to the keys lifecycle management (generation, storage, recovery) are of enormous importance.

In this section, we will dive into the processes of storing and processing keys in digital wallets and also consider the 
most relevant approaches to the implementation of these processes. The material will help you understand how wallets 
work, how they can be categorized according to the key processing approach, and also to assess the risks and benefits of 
each approach.

### Main functions of a digital wallet

Speaking about wallets, people usually intend something that is meant to store money. This is why some users are often 
disoriented; some mistakenly believe that digital wallets are used to store coins. Strictly speaking, this is not 
correct. Digital coins are an abstraction and, in fact, they neither exist nor are stored anywhere. Hence the question 
is what are the processes occurring in digital wallets and how is it better to organize them?

Wallets are used to store keys for those coins associated with a user's balance. Accordingly, *the main functions of a 
wallet are the storage and the management of keys*. Achieving these functions is only possible if a digital wallet is 
designed correctly. 

> **Digital wallet modules**
>> * *Module for key generation and storage*
>> * *Module for synchronizing the current state*
>> * *Module for processing existing transactions*
>> * *Module for the creation of transactions and their signatures*

Digital wallets can have advanced functionality, which can vary widely from one application to another. However, each 
digital wallet provides mechanisms for authenticating transactions and restoring access to the wallet as well as 
functionalities to send and accept payments and display balances and transaction history.

### Basic approaches to wallet synchronization

> * *Keys are stored and processed on a remote server*
> * *Keys are stored on a remote server but processed by a user*
> * *Keys are stored and processed in the user's application*
> * *Combination of previous approaches with the application of multisignature*

When it comes to storing private keys, it is usually understood that a user must meet certain challenges: how to protect 
keys from loss or theft, and also how to backup and export them in order to use on other devices. Currently, there is no 
such an approach that would provide an ideal solution that meets all the requirements [38]. Therefore several basic 
approaches to storing keys have been formed.

Each approach has its advantages and disadvantages, and which you choose depends on your specific requirements. The 
approaches essentially differ in where the keys are stored and where they are processed.

### Processing and storing keys on a server

The case when keys are stored and processed on a dedicated server is one of the simplest; the service that provides the 
wallet fully controls the keys. Accordingly, users of the wallet do not have any access to the keys, meaning that they 
do not own the actual cryptocurrency—yet such services are quite popular. They provide each user with a personal account 
and a virtual balance, which corresponds to the balance of the digital currency (Fig. 3.19). However, the actual access 
to these coins is only provided by the keys that the service owns.

![Figure 3.19 -  Keys are stored and processed on a remote server](/resources/img/volume-1/3.3-keys-storage-and-processing/3.19-remote-server.png)

In this case, there are two options for transferring coins between users:

* Between two users of the same centralized service 
* Between a user of a particular service and the bitcoin wallet user

In the first case, everything is quite straightforward. Since coins do not go beyond the perimeter of the system, the 
service simply changes user balances on their accounts (inside the database maintained by the service) without creating 
a real Bitcoin transaction.

If you need to deposit funds from an external wallet or withdraw them to it, then, obviously, the creation of an actual 
(*on-chain*) transaction is inevitable. In this case, it is the service that creates this transaction and, using its 
keys, sends funds to an external wallet or otherwise receives funds from the external wallet to its addresses. Therefore 
it is the service that manages all the addresses.

This type of wallet is popular because of the advantages that users get when working with it. To start with, users can 
actually make instant payments without fees since they do not create any real transactions—in fact, this is one of the 
primary reasons most services use this approach. In addition, these services allow users to provide very simple access 
to their account from multiple devices. Even if you lost your account password, you can easily restore it.

Nevertheless, this approach has certain drawbacks. One of them is that users in such systems do not have any access to 
their coins. They do not control the keys and therefore do not control the coins of the digital currency. Users are 
completely dependent on such services: in order to use another service, you must withdraw all funds from the current 
service and send them to another wallet.

This is one of the simplest possible implementations of a wallet in development. Key storage and processing are on the 
server side. Most often you do not even have to have software on your device to manage the keys. For this, a server uses 
the same wallet which comes with the full network node of particular digital currency. Since all operations are 
performed on the server, the client application is very simple (as well as its implementation). In fact, it only deals 
with communicating with the server via APIs. However, given the fact that all keys are not just stored on a particular 
server but also processed on it, then, at a certain point in time, they will be stored in an open form in RAM or, 
possibly, even on the hard disk. The security requirements for such servers are very high: you need to protect the 
server as much as possible from the possibility of external access, hacking, and so on.

### Keys are on the server, but only the client has access

Another approach is that keys are stored on the server, but the keys management is carried out on the client 
application. In this case, a user has a higher level of control over his coins compared to the previous approach 
(Fig. 3.20). The service, although it stores the private keys of its clients, does not have direct access to them.

![Figure 3.20 -  Keys are stored on a remote server but processed by a user](/resources/img/volume-1/3.3-keys-storage-and-processing/3.20-stored-separately-with-direct-control.png)

When a user registers in such a service, she generates a private key on her device (in a mobile wallet or web wallet), 
encrypts it with a password, and then sends it to the server in a protected form. Later, when a user needs to obtain a 
private key, she would need to authenticate and request the service for an encrypted container with a private key. The 
wallet receives this container, decrypts the private key, and operates with it directly on the device.

What are the advantages of this approach? As in the previous case, you can easily access your account from multiple 
devices. In this case, users have direct control over their keys (and therefore over the coins), yet there is a certain 
dependency on the service. If a centralized service is unavailable, a user loses access to her coins (if she does not 
have a private key backup).

Development peculiarities are that algorithms for processing keys and signing transactions must be implemented in the 
user's application. This can be quite difficult, especially when the service supports applications for several different 
platforms, such as Android, iOS, web applications, etc. Despite the fact that user's private keys are stored on the 
servers of the service in an encrypted form, high demands towards security do exist. After all, engineers can still find 
vulnerabilities in the algorithms that ensure the protection of sensitive data and the authentication of clients of such 
services, and use them with malicious intent. Some centralized online wallets use this approach for processing and 
storing keys.

### Keys are on the user's device

In the next approach, storing and managing private keys is carried out on a user's device. In this case, you do not need 
ny back-end or API. Users fully control their coins and, accordingly, are more independent of the external services. For 
example, even without network access, a user can access their wallet and create a transaction that will be sent to the 
network once the access is restored (Fig. 3.21). He can transfer this transaction without even accessing the network 
from his device—it is possible to transfer the transaction to another device, the one with access, and send it to the 
network from there.

![Figure 3.21 -  Keys are stored and processed in the user's application](/resources/img/volume-1/3.3-keys-storage-and-processing/3.21-keys-in-app.png)

Such an approach, however, is also not perfect. The main disadvantage is the need to store keys on one device 
constantly. The loss of this device or its damage results in a loss of access to your keys. In addition, if a user 
forgets the password by which the private keys are encrypted, he will not be able to get them back. In this case, you 
should always back up private keys and store the backup separately. If you need to transfer the keys from one device to 
another, you will have to do it manually.

The development approach of such wallets are slightly different. As in the previous case, the key processing logic 
remains on the client side. If you try to create a cross-platform application, the problems will remain the same since 
all data is stored on the client devices and, in fact, users can directly communicate with the network to get the 
balance state and receive and send transactions. Security requirements for key storage are higher. When using different 
platforms, the so-called platform-dependent methods are often used. For example, iOS devices use KeyChain in which you 
can store sensitive data securely. In order to be able to transfer the keys from one device to another, wallets of this 
type provide manual export and import of keys. In the minimal case, it is simply a wallet with one private key which 
includes functions for viewing and entering a private key in the WIF (Wallet Import Format) encoding.

One example of an application of this approach is the Bitxfy wallet, which stores and processes private keys on a user's 
device. The actual data about transactions is received through trusted nodes of the network, which are supported by the 
development team.

### Key storage using multisignature

The last approach to consider is a mixed model of key storage that uses multisignature. This is not a separate approach 
but rather a combination of several previous methods and is used to increase the level of security. When using 
multisignature for sending coins (Fig.  3.22), several signatures with different private keys are required; each of the 
keys can be stored and processed on a separate device independently of others (we will describe this mechanism in more 
detail in section 4.5).

![Figure 3.22 -  Multisignature mechanism application](/resources/img/volume-1/3.3-keys-storage-and-processing/3.22-multisig.png)

For example, you can implement a 2-of-3 multisignature. In this case, there are three keys. Storage and management of 
one of them will be performed by a server, and the rest will be managed using a smartphone. In order to assure the 
transaction, it is enough to sign it with any of the two keys. Transmitting keys between devices is not required, but 
rather you can sign the transaction on one device and send this semi-signed transaction on another device to have it 
signed with the second required key.

According to the adversary model (see section 3.1), the most advanced approach to secure coins access is to keep keys on 
different devices from independent hardware suppliers (Apple, Samsung, Huawei, etc.) as well as use software wallets of 
independent developers.

Examples of wallets that use multisignature are the Bitgo service and the Electrum wallet. However, at the time of 
writing in 2018, these solutions are not perfect since they are difficult to use. We hope that in future these 
implementations will become better and alternative applications on their basis will be developed.

### Cold, warm, and hot wallets

Above we have considered the basic options of allocating responsibility for storing and processing keys of a digital 
wallet. Now, let's see what are the options for the responsible party to organize the processes of storing private keys 
and signing the transactions. There are three main approaches (Fig. 3.23):

* Hot storage wallet 
* Warm storage wallet 
* Cold storage wallet

*A hot storage wallet is a digital wallet where private keys are stored and processed by a device that has a permanent 
connection to the global network.*

*A cold storage wallet is a digital wallet where private keys are stored and processed only on devices that do not have 
the ability to directly connect to the global network.*

*A warm storage wallet is a digital wallet where private keys are stored only on devices that support the connection to 
the global network but not permanently—only according to the user's decision (for example, for sending transactions or 
updating their status).*

![Figure 3.23 - Comparison of hot, cold, and warm wallets](/resources/img/volume-1/3.3-keys-storage-and-processing/3.23-comparison-of-wallets.png)

The wallet application on smartphones and many digital wallets for PCs can be attributed to the group of *hot storage 
wallets*. These are the most convenient wallets. However, theoretically, an engineer with special abilities could find a 
vulnerability in such wallets. In this respect, a cold storage wallet is considered a safer option.

According to the security, in between the hot and cold wallets, there are *warm storage wallets*. Developers of such 
wallets try to minimize interaction of the wallet with the rest of the digital world but at the same time keep some of 
the comforts of hot wallets.

**Frequently asked questions**

*– Is it true that users who store coins on wallets with closed source code can one day discover that their coins are 
missing?*

Yes, it is possible. Theoretically, wallet developers can steal user keys using a backdoor in the program code, which is 
unlikely to be noticed by an ordinary user. However, it is noteworthy that such a situation is also theoretically 
possible with open source solutions, yet the probability is lower.

*– Is the probability of a backdoor in a digital wallet lower if its source code is open?*

Theoretically, yes. However, you should not forget that if the source code is open, this does not mean that a user has 
analyzed it before installation. And even if this is the case, a user must compile and install it on his device and 
disable automatic updates because, otherwise, he will have to perform the code audit again. In summary, users need to 
trust the developer of the application especially when it comes to storing sensitive data.

*– How big is the number of Bitcoin network nodes to which the client wallet is connected? Does it connect to the same 
nodes all the time?*

It all depends on the specific implementation of the wallet and its settings. A wallet can always connect to one trusted 
node on the network, and it can communicate with several network nodes that it does not even trust, and perform a full 
scan of all data for compliance with the protocol rules. For example, the implementation of the Bitcoin Core wallet is 
always connected to different nodes. The wallet of this implementation can even give preference to certain nodes 
depending on their total number, response time, network delays, and the frequency of receiving incorrect data from the 
nodes.

*– What is the best way to store wallet files to minimize the risks related to thefts of confidential data and user's 
private keys?*

There are many ways. To provide a minimum level of protection against hacking, which would allow a user to safely store 
funds (if it is not about millions of dollars), it is enough to use the password (if it can be installed). Then, with an 
additional secret key obtained from the password, confidential data will be encrypted and, accordingly, will not be 
stored open on the device.

*– If a person uses a software wallet on her PC, can other programs steal her coins?*

In general, they can. The risk is high enough, so for large amounts, it is recommended to use more reliable ways of 
storing and processing private keys.

*– What if the private key has been compromised?*

In this case, you should stop using the wallet the keys of which were compromised. If the reason for the violation of 
confidentiality is unknown, then you should even refuse to use the appropriate application or device [39].

[TECHNOLOGICAL DETAILS OF BITCOIN OPERATION](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-1/en/4-technological-details-of-bitcoin-operation.md)