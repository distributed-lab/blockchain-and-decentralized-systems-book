# 4 ТЕХНОЛОГІЧНІ ДЕТАЛІ ФУНКЦІОНУВАННЯ BITCOIN


## 4.1 Як працюють транзакції в Bitcoin?

Відсутність вимог реєстрації користувачів кардинально вплинули на формат транзакцій. У випадку з Bitcoin зберігання й оброблення транзакцій значно відрізняються від аналогів в наявних фінансових системах. Найголовнішими відмінностями стали зв’язок транзакцій між собою (т. зв. triple-entry accounting), поняття невитрачений вихід, а також особливості формування решти. Як працює цей механізм і чому, спробуємо розібратися на прикладах.

### Структура транзакції

Розглянемо транзакцію схематично (рис. 4.1). Її можна логічно поділити на три складники: заголовок, вхідні монети та вихідні монети.

Якщо трохи заглибитися, то кожна транзакція у своїй структурі може мати кілька входів і виходів; їхня кількість не обмежена. У Біткоіні обмежений тільки розмір транзакції: він становить 25 % від максимального розміру блоку. Якщо максимальний розмір блоку – 1 МБ, тоді максимальний розмір транзакції – 250 кБ.

На рис. 4.1 видно, що кожна транзакція містить вхід, який посилається на деяку попередню транзакцію (джерело монет), і вихід, який створюється в поточній транзакції для відправлення монет.

![Рисунок 4.1 – Спрощена структурна схема транзакції в Bitcoin](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.1-simplified-structure-of-tx.png)

Кожен вхід містить доказ, що автор транзакції володіє монетами, які хоче витратити. У Bitcoin монети не записані на якомусь балансі. Натомість вказується посилання на ту транзакцію, з якої вони були отримані. Таким чином, вибудовується ланцюжок, який легко верифікувати.

У кожному виході вказується сума платежу й *умови витрачання монет*, яким повинен задовольнити одержувач за допомогою *доказу володіння монетами*, щоби потім їх відправити далі.

Розглянемо детальніше тіло транзакції, яка колись давно в мережі Bitcoin отримала підтвердження. На рис. 4.2 вона подана у форматі JSON.

![Рисунок 4.2 – Приклад bitcoin-транзакції](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.2-example-of-tx.png)

> * *ScriptPubKey – поле, що містить умови витрачання монет*
> * *ScriptSig – поле, що містить докази володіння монетами*
> * *Для заповнення цих полів використовується спеціальна мова – Bitcoin Script*

Тут присутній заголовок, що містить два поля: версію транзакції й параметр *locktime* (докладніше буде розглянутий далі). Транзакція містить також два входи та два виходи. Найбільший обсяг має поле входів, а в ньому – *scriptSig*, тому що значення підпису займає 64 Б, а відкритий ключ у стисненому вигляді – 33 Б. У серіалізованій формі ця транзакція займає 373 Б (саме в такій формі вона передається в мережі).

> **_Зауваження._** *Серіалізація – це процес перетворення якоїсь структури даних у послідовність бітів.*

Найчастіше умови витрачання монет кодуються в зручну біткоін-адресу, а під час формування транзакції декодуются та вказуються в ScriptPubKey.

Якщо детальніше розглянути структуру *входу транзакції (vin)*, то можна побачити чотири поля, що зображені на рис. 4.3. У поле з геш-значенням (*hash*) вказують ідентифікатор попередньої транзакції, де монети були отримані. *Index* – це порядковий номер виходу попередньої транзакції, з якого витрачатимуться монети.

![Рисунок 4.3 – Структура входів транзакції](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.3-structure-of-in.png)

*ScriptSig* містить докази володіння монетами. Це поле має таку назву, тому що найчастіше містить цифровий підпис, а також може містити відкритий ключ для перевірки цього підпису.

Наступне поле має назву *sequence*. Воно позначає версію транзакції. Її задає сам відправник. Завдяки sequence можна замінити транзакцію, яку було відправлено в мережу, але ще не було підтверджено. Припустимо, була створена одна транзакція, яка ще не включена в блок із якихось причин: або час ще не минув, або занадто низька комісія була встановлена. Користувач вирішує змінити цю транзакцію: змінити адресу одержувача монет, указати інших одержувачів, додати комісію або змінити суму платежу тощо. Тоді він створює альтернативну транзакцію, яка витрачає ті ж монети, має ті ж входи, що й попередня, але в цих входах він задає значення *sequence* на одиницю більше. За правилами протоколу валідатори, які будуть підтверджувати цю транзакцію, можуть замінити стару транзакцію. Далі, найімовірніше, буде підтверджено саме нову транзакцію.

Структура *виходу транзакцій (vout)* містить два поля: *value*, де вказується кількість монет, що призначається отримувачу, і * *, у якому вказуються умови витрачання монет (рис. 4.4). Друге поле отримало таку назву, тому що найчастіше там вказується або відкритий ключ, або геш-значення відкритого ключа.

![Рисунок 4.4 – Структура виходів транзакції](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.4-structure-of-out.png)

Таким чином, на відміну від транзакцій у традиційних платіжних системах, які фактично містять у собі одне основне повідомлення – переказ певної суми з балансу А на баланс Б, – транзакції в Bitcoin представляють собою складні набори даних, які містять докази, що ініціатор транзакції володіє монетами, які він збирається переказати. У деяких ситуаціях такий підхід може виявитися більш надійним, однак у контексті пропускної здатності він більш витратний.

Обмежена пропускна здатність Bitcoin як облікової системи стала проблемою, що вимагала рішення. Воно було подано у формі покращення протоколу (оновлення Segregated Witness). Було запропоновано винести доказ володіння монетами за межі транзакції, тобто в окрему структуру *witness data* (рис. 4.5). У такий спосіб можна не записувати його до кожного входу транзакції, звільнивши водночас значний обсяг пам’яті. Виходить, що транзакція містить усі необхідні дані, зокрема про походження монет і новий їх розподіл, але доказ володіння ними перебуває за межами транзакції. У деяких випадках можна використовувати основну частину транзакції без witness data (див. 4.6).

![Рисунок 4.5 – Спрощена структура транзакції після оновлення Segregated Witness](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.5-simplified-tx-with-seg-witness.png)

### Невитрачені виходи

*Невитрачений вихід (UTXO, Unspent Transaction Output) – це такий вихід, монети якого можуть бути витрачені, коли зазначені у вході нової транзакції.*

Вище ми розглянули структуру транзакції, і можна відзначити, що на рівні протоколу немає акаунтів і балансів, а є транзакції з входами та виходами. Для кожного виходу характерні два стани: витрачений і невитрачений.

Невитрачені виходи можна порівняти з готівкою. Володіння біткоінами нагадує володіння звичайними купюрами, які ви отримали, але ще не витратили. Ви не можете сказати точно, скільки грошей у вашому гаманці, поки не відкриєте його й не перерахуєте всі гроші. Володіючи біткоін-гаманцем, вам необхідно перерахувати всі невитрачені виходи з транзакцій, адресовані вам, підсумувати їх, і тільки після цього можете дізнатися свій загальний баланс. Звісно, багато bitcoin-гаманців роблять це автоматично та показують кінцеву суму, але принцип формування цього балансу саме такий. Суть такої аналогії в схожості звичайної купюри й адресованого вам виходу транзакції, монети з якого ви ще не витратили. Ви не можете поділити купюру, коли оплачуєте щось більш дешеве – вам потрібно її розміняти, тобто віддати купюру з певним номіналом й отримати решту купюрами з меншими номіналами.

Незважаючи на те, що на рівні протоколу Bitcoin немає балансів, поточним балансом адреси прийнято називати суму всіх монет на невитрачених виходах, які були відправлені на дану bitcoin-адресу. Слід розуміти, що для кожної адреси в загальному випадку є два баланси: умовно (з високою ймовірністю) підтверджений і непідтверджений.

У реалізації повного вузла Bitcoin є окремий модуль *coins database* для зберігання й оброблення актуального стану всього набору UTXO.

### Отримання решти та встановлення комісії

Припустимо, користувач колись прийняв платіж на 10 монет, а тепер він хоче витратити 3 монети. Але суть у тому, що він не може витратити частину – тільки всю суму, тобто 10 монет.

Виникає питання про те, як правильно організувати решту в Bitcoin. Так, витратити тільки частину з отриманих монет можна, але ж можна додати кількох одержувачів у транзакцію. Рішення було знайдено: створюється транзакція, у якій 3 монети користувач відправляє одержувачу, а решту 7 монет, яку він не хоче витрачати, відправляє собі. Виходить, що решта – це вихід, адресований самому собі. Таким чином, у користувача з’являється новий невитрачений вихід на ці 7 монет.

Тепер буде логічно пояснити питання про комісії, оскільки описане вище має сенс, якщо транзакція в результаті буде підтверджена. Потрібно якимось чином мотивувати власника повного вузла валідувати саме вашу транзакцію. Саме для цього й передбачена комісія.
У розглянутій структурі транзакції немає спеціального поля, у якому би зазначалося значення комісії. Однак у кожного користувача є можливість задати її в транзакції самостійно.

Для цього важливо запам’ятати одне дуже просте й логічне правило в межах протоколу Bitcoin: *сума всіх виходів транзакції не має перевищувати суму всіх входів*. Скільки монет було, стільки після транзакції й залишається – вони можуть бути тільки по-іншому розподілені між адресами.

Біткоін улаштований так, що комісія за транзакцію визначається як різниця між сумою входів і сумою виходів. Уявіть, що ви маєте 5 монет і хочете заплатити 2 монети. Формуєте транзакцію так: зазначаєте один вхід – вихід деякої попередньої транзакції, де ви отримали 5 монет, – і два виходи. Перший вихід відправляє 2 монети як плату за послугу, другий відправляє решту 2 монети на вашу іншу адресу. У підсумку, на вході вашої транзакції 5 монет, на виході – 4. Тоді 1 монета й буде вважатися комісією.

Різниця, що залишилася, не належить нікому доти, поки транзакція не буде підтверджена та включена в блок. Коли буде сформований блок, у який буде додана ця транзакція, творець блоку зможе привласнити комісійні збори як винагороду.

### Схема передавання монет на прикладі

Припустимо, є користувач на ім’я Андрій із одним невитраченим виходом на 100 біткоінів: йому подарували їх на день народження. У певний момент він вирішив заплатити цими монетами двом людям, що схематично зображено на рис. 4.6.

![Рисунок 4.6 – Платіж двом одержувачам у межах однієї транзакції](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.6-transfers-within-tx.png)

Користувач створює транзакцію з одним входом, де він посилається на іншу транзакцію, з якої він отримав ці монети, і додає в транзакцію два виходи: один відправляє 45 монет Альоні, а інший – 50 монет Артему. Зверніть увагу, що різниця між сумою входів і сумою виходів дорівнює 5 монетам, які і є комісією в цьому разі.

Зі свого боку, Альона й Артем можуть витратити отримані монети на власний розсуд (рис. 4.7). Альона повинна заплатити садівникові за роботу 20 монет. Вона посилається на транзакцію, де отримала 45 монет, повністю їх витрачає в поточній транзакції, зазначаючи одержувачем адресу садівника, а другим одержувачем зазначає свою адресу та відправляє туди 20 монет. 5 монет залишається як комісія. Артем, який отримав 50 монет, теж витрачає свої кошти: 10 монет він платить скляру за нові вікна, 35 монет йде на оплачення послуг автомайстерні з ремонту автомобіля, а 5 монет залишає як комісію.

![Рисунок 4.7 – Використання виходів із попередньої транзакції для проведення платежів](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.7-using-tx-to-make-payments.png)

Однак уявіть, що скляр і власник автомайстерні виявилися приятелями й домовилися зробити спільному другу подарунок. Вони вирішили скинутися по 10 монет і купити картину в місцевого художника. Тоді вони складають загальну транзакцію, де буде вже два входи: 10 і 35 монет, і два виходи: один відправляє художнику 20 монет, другий відправляє 20 монет як решту власнику автомайстерні (рис. 4.8). Знову ж таки, 5 монет, які залишилися, підуть на комісію. У нашому випадку її сплатив власник автомайстерні. Уважатимемо, що він мав борг перед склярем за нове вікно.

![Рисунок 4.8 – Створення транзакції з входами від різних відправників, що платять одному одержувачу](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.8-creation-tx-from-diff-senders.png)

### Формування транзакцій у біткоін-гаманцях

Як працює біткоін-гаманець і які процеси відбуваються під час роботи з ним? У гаманці формуються ключова пара та біткоін-адреси, а також формуються, зберігаються, підписуються та відправляються транзакції. Щоб отримувати актуальні дані про нові блоки (про нові підтверджені транзакції), у мережі Bitcoin відбувається синхронізація всіх вузлів. Гаманець відображає поточний баланс і робить список зроблених транзакцій. Крім того, правильно реалізоване ПЗ гаманців дотримується певних правил під час формування транзакцій.

> **Широко застосовувані правила для формування транзакції**
>> * *Для кожного вхідного платежу й решти створювати нову адресу*
>> * *Оптимально підбирати UTXOs для цільової суми платежу*
>> * *Сортувати входи та виходи транзакції за спільним для всіх правилом*
>> * *Включати мінімальну комісію незалежно від розміру транзакції*

Уявімо, що у деякого мандрівника є біткоін-гаманець із набором невитрачених виходів: 1 BTC, 3,5 BTC, 0,3 BTC і 0,4 BTC. Мандрівник уже готовий підкорювати нові горизонти і йому залишилося тільки оплатити проїзд у громадському транспорті (рис. 4.9). Відомо, що квиток в один кінець коштує 0,5 BTC, але в гаманці мандрівника немає монети відповідного номіналу. Тому програма-гаманець, використовуючи алгоритм пошуку кращої комбінації, вибирає невитрачені виходи із сумами 0,3 BTC і 0,4 BTC. Далі вона формує нову транзакцію, посилаючись саме на вибрані в такий спосіб монети.

![Рисунок 4.9 – Вибір відповідних невитрачених виходів для проведення платежу](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.9-choosing-proper-outputs.png)

У нову транзакцію буде включено два виходи: нульовий адресований продавцю квитків (0,5 BTC), а перший – самому мандрівникові як решта (0,1 BTC). Очевидно, що комісія за транзакцію становить 0,1 BTC.

Після того як транзакція буде сформована й підписана гаманцем, вона повинна поширитися мережею. Для цього в мережі Bitcoin передбачений простий стандартний механізм, що нагадує поширення цікавої новини в реальному світі: якщо в когось з’явилася новина, він буде намагатися розповісти про неї якомога більшій кількості людей, і вони, зі свого боку, зроблять те саме.

Розглянемо Bitcoin-мережу, вузли якої мають випадковий набір з’єднань один з одним (рис. 4.10). Деякий вузол мережі отримує від програмного забезпечення гаманця мандрівника нову транзакцію, у якій він хоче оплатити проїзд декількома монетами. Вузол незалежно перевіряє транзакцію, додає її у власний *mempool* (якщо вважає правильною), а далі передає її іншим найближчим вузлам. Кожний із цих вузлів, зі свого боку, робить те саме (попередньо перевіривши транзакцію, передає її іншим найближчим вузлам). У результаті, транзакція розповсюджується в усій мережі Bitcoin.

![Рисунок 4.10 – Розповсюдження транзакції в мережі Bitcoin](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.10-propagation-of-tx.png)

Але цей процес не може продовжуватися вічно. Відзначмо, що кожна транзакція однозначно ідентифікується за її геш-значенням. Завдяки цьому будь-який вузол, що бере участь у пересиланні, може виявити, чи отримував він дане геш-значення раніше. Якщо так, то вузол не бере участі в подальшому розсиланні, щоб уникнути нескінченного циклу проходження транзакції.

Раніше згадувалося, що за конкретною адресою можна відстежити всю історію платежів в Bitcoin: можна відстежити всю *історію походження монет*. Точно так само, як у прикладі вище (див. пункт «Схема передавання монет на прикладі»): було 100 монет, і вони в певний спосіб перерозподілялися між різними адресами. Маючи повну копію бази даних, ви можете відстежити історію транзакцій до тієї транзакції, де було видобуто монету.

Що можна зробити, щоби фінансова історія користувача не була повністю розкрита? Уявіть, що кожен користувач Біткоіна використовує тільки одну адресу й для отримання, і для витрачання монет. Розкривши відповідність між цією адресою й особою конкретного користувача, можна відстежувати всю його фінансову історію, пов’язану з Біткоіном.

На рис. 4.11 схематично зображений зв’язок між різними транзакціями, які перебувають у ланцюжку блоків. Очевидно, що відновити в цьому разі історію походження монет і відстежити ланцюжок транзакцій, за яким користувач отримав платіж, не становитиме труднощів.

![Рисунок 4.11 – Зв’язок між різними транзакціями в ланцюжку блоків](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.11-link-between-txs.png)

> **_Зауваження._** *На рис. 4.11 нульовою ліком зображена coinbase-транзакція; вона містить передбачену правилами протоколу винагороду для валідатора, який створив цей блок (докладніше в 4.3). Coinbase-транзакція має спеціальний параметр coinbase maturity, який згідно з правилами протоколу Bitcoin дорівнює 100. Це означає, що після блоку з coinbase-транзакцією до основного ланцюжка має бути додано 100 блоків, щоб учасник, який видобув цей блок, міг витратити монети з виходу coinbase-транзакції. На схемі вище coinbase maturity дорівнює 1.*

Здебільшого відстеження фінансової історії сторонніми особами неприйнятне для користувачів. Тому є спосіб, який істотно ускладнює розплутування всіх ланцюжків транзакцій, відстеження історії платежів і встановлення належності конкретних монет конкретним користувачам. Біткоін-гаманці здебільшого автоматично створюють нову адресу для запиту на новий вхідний платіж або для отримання решти.

### Механізм locktime

Є спосіб обмежити підтвердження біткоін-транзакції за часом, і навіть якщо вона буде опублікована до мережі, валідатори не зможуть її підтвердити до досягнення певного моменту. З цією метою застосовується спеціальний параметр *locktime*. Він є 4-байтне значення, що входить до заголовку кожної транзакції в Bitcoin. Це значення й дозволяє вказати, до якого моменту прийняття транзакції буде відкладене. Параметр *locktime* може бути задано значенням одного з двох типів даних: або часу у форматі Unix timestamp, або висоти блоку. За правилами протоколу валідатор не може включити транзакцію до свого блоку до визначеного моменту часу чи до появи блоку з визначеною висотою, якщо встановлено параметр *locktime*.

Так реалізується механізм відкладених транзакцій, якщо передбачається, що з деякої причини невитрачені монети так і не буде витрачено (наприклад, ключ буде втрачено чи користувачі не досягнуть між собою консенсусу та не будуть задоволені умови витрачання монет). У такому разі створюються так звані резервні транзакції, які перекажуть монети на «запасну» адресу після вичерпання визначеного проміжку часу, але доти їх може бути витрачено у звичний спосіб. Схематично це показано на рис. 4.12.

![Рисунок 4.12 – Транзакція з відкладеним підтвердженням](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.12-tx-with-delayed-confirmation.png)

Припустімо, у вісімнадцятому блоці був створений деякий невитрачений вихід. Якщо транзакція, що платить монети цього UTXO, має параметр locktime, що дорівнює 404, і пройшла попередню верифікацію, то вона буде залишатися в mempool як непідтверджена. Там вона може перебувати до моменту підтвердження в блоці з висотою понад 404 чи може бути замінена конфліктною транзакцією (наприклад тією, яка платить монети того самого UTXO та містить комісію більшого розміру).

> **_Зауваження._** *Користувач може зберігати транзакцію й на папері в друкованій формі. Наприклад, у нього відсутнє інтернет-з’єднання, та він не може відновити його. У цьому разі користувач може сформувати та підписати транзакцію офлайн, а потім роздрукувати її на папері. Далі він відправляє роздруківку довіреній стороні з інтернет-з’єднанням (це може бути й отримувач монет), яка перенесе дані (уже підписаної транзакції з адресою отримувача) з паперу на свій пристрій і розповсюдить транзакцію в мережі для підтвердження.* 

### Off-chain протоколи

З непідтверджених транзакцій можна заздалегідь побудувати ланцюжок витрачання монет, який може бути підтверджено згодом. На рисунку 4.13 справа зображено основний ланцюжок блоків у формі вже сформованих блоків, що містять *on-chain транзакції*. Зліва зображено off-chain транзакції – ті, які вже посилаються на UTXO певної *on-chain транзакції*, але ще не додані до основного ланцюжка блоків (наприклад через заданий параметр locktime). Далі можна побудувати безліч транзакцій, які посилатимуться, відповідно, на виходи off-chain транзакцій. У результаті, ми отримаємо один чи кілька альтернативних ланцюжків витрачання монет. Проте жодну з off-chain транзакцій не може бути додано до блоку основного ланцюжка, поки не додано попередню до неї транзакцію (та, на вихід якої вона посилається).

![Рисунок 4.13 – Принцип функціонування off-chain протоколів](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.13-how-off-chain-protocol-work.png)

Який саме ланцюжок off-chain транзакцій буде підтверджений, визначають самі валідатори. Хтось із них створить новий блок, де буде частково чи повністю підтверджений один із альтернативних ланцюжків. Таким чином, якщо транзакція не підтверджена, вона не блокує монети, а на її основі можна будувати ланцюжок інших транзакцій. Власне, це і є основний принцип роботи off-chain протоколів.

### Signature hash types

Процес підписання bitcoin-транзакції можна розділити на два етапи. Перший етап – це формування повідомлення, на яке буде накладений цифровий підпис. Другий – власне обчислення цифрового підпису.

Може трапитися так, що користувачам зручно підписати тільки частину транзакції, тим самим залишаючи можливість її часткової модифікації. Найчастіше така потреба виникає під час формування транзакції з декількома входами, якими володіють кілька незалежних осіб.

Розгляньмо, яка частина транзакції може покриватися підписом, як генеруються шаблони транзакцій для кожного типу підпису, і в яких випадках варто використовувати конкретний тип підпису. Є три базові типи підпису: *SIGHASH_ALL*, *SIGHASH_NONE* і *SIGHASH_SINGLE* [40].

*SIGHASH_ALL* – тип підпису, який найчастіше використовують. Він покриває всі входи і виходи транзакції, захищаючи всі елементи транзакції від модифікації. Одне лише, що не підпадає під підпис, – це скрипт самого підпису (scriptSig).

*SIGHASH_NONE* дозволяє підписати всі входи, але водночас не підписувати жоден вихід. У цьому випадку будь-хто може змінити виходи транзакції доти, поки вони не будуть заблоковані іншим типом підпису. Безглуздо формувати транзакцію з одним входом і типом підпису SIGHASH_NONE. У цьому разі майнер просто може переписати виходи, і монети підуть не за призначенням. Такий підхід зручно використовувати, якщо формується спільна транзакція на кілька входів і досить тільки одному з підписантів використовувати SIGHASH_ALL.

*SIGHASH_SINGLE* дозволяє підписати всі входи й тільки один із виходів, індекс якого відповідає індексу входу, що містить підпис. Тобто цей випадок означає, що ви готові заплатити на вихідну адресу, але тільки в тому випадку, якщо всі інші учасники транзакції також витратять свої біткоіни. Для чого це може бути потрібно? Наприклад, чоловік і дружина хочуть заплатити 5 біткоінів за навчання дитини. У чоловіка є невитрачений вихід на 3 BTC, у його дружини – вихід на 2,5 BTC. Вони домовляються і формують транзакцію. Спочатку чоловік подає свої UTXO на вхід. Після він підписує всі входи і вихід, у якому вказується сума 5 BTC і адреса навчального закладу. Дружина може задати будь-який вихід і водночас не порушити підпис чоловіка. Вона встановлює вихід, куди відправляє свої 0,5 BTC, і підписує транзакцію (або SIGHASH_ALL, або SIGHASH_SINGLE).

### Записування довільних даних до ланцюжка блоків

Зі зростанням популярності облікової системи Bitcoin у користувачів закономірно виникло питання про те, як записувати до неї не тільки дані про облік монет, але й цілковито довільні.

Ще раз подивимося на формат блоку: там є заголовок блоку й дані транзакції. Заголовок блоку містить строго 80 Б даних і кожне поле валідується – тому туди довільні дані неможливо додати. Тому розглянемо детально структуру транзакцій (рис 4.14). Можливо, тут знайдеться місце для довільних даних [41].

![Рисунок 4.14 – Приклад транзакції, що містить довільні дані](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.14-arbitary-data.png)

У *заголовку транзакції* міститься 4 Б даних, за допомогою яких вказано версію транзакції.

Присутнє також поле *lock_time*, де можна довільно задати момент часу, до настання якого транзакцію неможливо додати до блоку. У цьому разі потрібно пам’ятати, що це може значною мірою обмежити час підтвердження транзакції. Однак дійсно можна маніпулювати цим значенням, задаючи момент часу, який уже настав. У такий спосіб вийде ввести тільки приблизно 1 Б довільних даних, а це мало порівняно з розміром усієї транзакції. Отже, такий спосіб неефективний.

*Входи транзакції* містять геш-значення від попередніх транзакцій, які обов’язково мають відповідати уже наявним транзакціям; також мають збігатися номери виходів попередніх транзакцій. Дані *доказу володіння монетами* має бути цілісними, так що внести зміни до них неможливо.

Що ж стосується *виходу транзакції*, тут ситуація більш сприятлива. Є певна сума монет, яка призначена отримувачу. Значення цієї суми встановлюється довільно в межах деякого допустимого діапазону. Інакше кажучи, довільні дані можна вносити через маніпулювання сумою виходу (*output amount*). Крім того, є адреса, для якої під час верифікування транзакцій не перевіряється, чи правильно вона була сформована; це просто 20-байтне геш-значення від тих даних, які ще не були опубліковані. Відповідно, їх можна встановити довільним чином. Є багато прикладів, де в транзакцію додавалися надлишкові виходи та замість адреси вбудовувалися довільні дані, які мали деякий сенс для сторонніх застосунків (наприклад анонімні сигнали трейдерів, а також пісні, вірші тощо). Сторонні застосунки, зі свого боку, мали можливість перевірити, що дані дійсно зберігаються в обліковій системі Біткоін.

Розробники протоколу помітили, що попит на запис довільних даних є, тому додали спеціальну операцію, за допомогою якої можна задавати умови витрачання монет, що дозволяють вбудувати у вихід довільні дані. Однак згідно з правилами верифікування вихід транзакції з такою операцією завжди вважається неправильним. Це означає, що монети таких UTXOs витратити неможливо, скільки би їх там не було. Операція має назву OP_RETURN аналогічно до того, що функція верифікації виходу відразу повертає значення FALSE. Вихід, що використовує таку операцію, дозволяє додати до 80 Б довільних даних [42]. Таким чином, багато застосунків (зокрема тих, що реалізують анонімне передавання даних), які працювали понад Bitcoin, використовували саме цю операцію.

Одним із них став протокол Colored Coins – це деяка додаткова логіка над звичайною логікою функціонування bitcoin-гаманця. У кожну з транзакцій за протоколом Colored Coins записуються додаткові (надлишкові для Bitcoin) дані, які показують особливості цієї монети, тобто «підфарбовують» її в певний колір, що асоціюється з деякою додатковою логікою: по-перше, валідацією транзакції, а по-друге, – сенсом монет, які передаються в цій транзакції. Сенс цієї дії в тому, що якась невелика кількість біткоінів була пофарбована й тепер вони представляють цінність не тільки як біткоіни, але і як, наприклад, акція деякої компанії. Якщо зберігати ці додаткові дані, то модифіковані гаманці, що підтримують протокол Colored Coins, розпізнаватимуть додатковий сенс монет і, відповідно, відображатимуть іншу їхню вартість. Водночас ці монети можна переказувати як «звичайні» біткоіни.

Є протоколи, як-от Omni Layer та Counterparty. Вони працюють понад протоколом Bitcoin і дозволяють користувачам випускати власні токени (а також обмінювати їх і торгувати ними). Протоколи підтримують власну логіку транзакцій, механізм досягнення консенсусу, структуру даних транзакцій, а також правила їх верифікування. Особливість цих протоколів полягає в тому, що транзакції в них серіалізуються та поділяються на 80-байтні послідовності даних. Це потрібно, щоби помістити їх до біткоін-транзакцій. Однак користувачі цих протоколів платять додаткову комісію за зберігання своїх транзакцій у Bitcoin, позаяк одна така транзакція в загальному разі «прив’язується» до кількох біткоін-транзакцій. Отже, ціна транзакції у межах протоколу Omni Layer або Counterparty буде вищою, ніж у Bitcoin.

### Підсумки

Один гаманець може обробляти необмежену кількість адрес, використовуючи кожен раз нову. Це підвищує приватність користувача завдяки ускладненню відстеження історії транзакцій його цифрового гаманця для сторонніх спостерігачів. Важливо розуміти, що отримані на один гаманець або одну адресу монети не об’єднуються разом і в базі даних не записуються в один баланс, – вони використовуються окремо. В одному гаманці можна мати різні монети: кожній монеті відповідатиме своя історія. Можна використовувати їх за різним призначенням і не розкривати інформацію про належність монет одному користувачу.

Кожний вихід транзакції прив’язаний до конкретної адреси. Інакше кажучи, монети заблоковано згідно з деякими умовах їх витрачання. Припустімо, можна відправити монети не на звичайну адресу, а на адресу, з якої можна витратити монети тільки за виконання деяких специфічних умов. Можна зазначити, що монети може витратити той, хто надасть розв’язок рівняння (наприклад, якщо зазначено рівняння 5 + 7, витратити монети зможе той, хто напише 12 у *scriptSig*). Умови можуть бути різними: надання відкритого цифрового ключа, прообразу геш-функції чи розв’язку певної математичної задачі (докладніше в 4.5).

**Часті запитання**

*– Чи блокують непідтверджені транзакції суму на рахунку?*

Ні. Доти, поки транзакція не підтверджена, можна створити альтернативну транзакцію, яка буде містити інші умови витрачання одних і тих же монет. Валідною та включеною до блоку буде вважатися тільки одна транзакція зі множини всіх альтернативних. Приймати рішення про включення тієї чи іншої транзакції до блоку буде безпосередньо валідатор, який створить блок. Транзакцію, яку включено до блоку, вважатиметься підтвердженою, якщо відповідний блок прийме решта валідаторів.

*– Чи може одержувач транзакції збільшити комісію, щоби «підштовхнути» її, якщо вона залишається непідтвердженою?*

Додати комісію до тієї транзакції, з якої отримує монети, він не може, але він може витратити з непідтвердженої транзакції монети й заплатити за нову транзакцію, у яку ще включить суму, якої не вистачає для попередньої транзакції. Така функціональність уже реалізована, і вона має назву child-pays-for-parent (див. 4.7). Деякі гаманці та більшість валідаторів її підтримують: можна заплатити новою транзакцією за стару, щоби вони тепер обидві потрапили до майбутнього блоку.

*– Як правильно порахувати комісію?*

Комісія у Bitcoin розраховується не у вигляді ставки за факт транзакції або відсотка від суми платежу, а залежить від популярності Bitcoin, тобто кількості транзакцій у мережі, та від розміру транзакції в байтах. Насамперед вам слід орієнтуватися на вартість запису 1 Б даних у базу Bitcoin, а потім цю вартість помножити на розмір транзакції в байтах. В Інтернеті є багато ресурсів, які підраховують ціну запису даних. Зазвичай це від 10 до 500 сатоші за байт залежно від поточного навантаження на мережу. У деяких випадках гаманці використовують динамічне значення цієї ціни, у деяких – константне значення, а в деяких випадках користувач може самостійно задати значення комісії.

*– Чи може валідатор підтверджувати транзакції незалежно від розміру комісії?*

Валідатори вільні вибирати самостійно транзакції, які вони будуть підтверджувати. Інакше кажучи, валідатор, який має чималу обчислювальну потужність і здатний генерувати блоки самостійно, може вибирати, які транзакції він додає собі до блоку. Він може фільтрувати маленькі транзакції й додавати тільки великі, може додавати тільки транзакції друзів, а може вибирати ті транзакції, де комісія менше – усе залежить від власника потужності, він самостійно розпоряджається своїм програмним забезпеченням. Найчастіше валідатори в гонитві за вигодою підтверджують тільки ті транзакції, які найбільше платять за одиницю обсягу своїх даних. Якщо ж ви – валідатор і хочете підтвердити транзакції з нульовою комісією, то ви можете це здійснити, самостійно підтверджуючи свої транзакції, які не платять комісії. У цьому випадку ви нічого не виграєте, тому що якщо ви заплатите більшу комісію, то самі її заберете. Такі транзакції краще не розповсюджувати в мережі, а додавати тільки до своїх блоків.

*– Чому гаманці не мають функціональності для відправки монет кільком одержувачам однією транзакцією?*

Так, дійсно, зазвичай гаманці передбачають створення транзакцій на два виходи: для платежу та для решти. Гаманці рідко реалізують функціональність для включення декількох одержувачів в одну транзакцію, тому що вона актуальна тільки в рідкісних випадках. Однак якщо ви візьмете Bitcoin Core, Electrum і ще деякі desktop-гаманці, то вони реалізують таку функціональність і ви можете додати скільки завгодно отримувачів у транзакцію. Ви також можете вибирати монети з раніше отриманих і вирішувати, які з них витрачати. Отже, якщо вам потрібен гнучкий спосіб складання транзакцій, то він теж є.

*– Якщо можна ускладнити відстеження ланцюжків транзакцій і належності біткоінів якимось певним особам, для чого є тоді міксери?*

Справді, генерація нових адрес ефективно ускладнює відстеження ланцюжків, але не відкидає таку можливість. Є способи, що дозволяють відновити з певною долею ймовірності справжній розподіл монет серед користувачів. Централізовані міксери – лише один зі способів заплутування історії монет, але він вважається ненадійним порівняно з іншими способами, тому що не має властивості *trustlessness* (докладніше в 7.2). Принцип роботи міксерів досить простий: користувач перенаправляє кошти на адресу, яку генерує сервіс, і там його виходи перемішуються з виходами інших клієнтів сервісу. Тільки після цього вже перемішані монети відправляються на заплановану адресу одержувача.

*– Чи можна складати дві різні транзакції, які витрачатимуть однакові монети?*

Так, можна. Але тоді ми матимемо дві конфліктні транзакції. Можна задати правила, згідно з якими одна з них буде більш пріоритетною для додавання в блок, за допомогою параметра *sequence*. Якщо ж таких правил не задавати, то валідатори додадуть одну з них у блок на свій розсуд.

*– Як формувати транзакції для зменшення комісії?*

Потрібно оптимальним чином підбирати невитрачені виходи або використовувати гаманці, де реалізований спеціальний алгоритм для цього. За аналогією з тим, як люди підбирають купюри, оплачуючи товар у магазині готівкою. Адже простіше суму $30 сплатити двома купюрами (з номіналами $20 і $10), ніж тридцятьма купюрами з номіналом $1. Так само – з біткоінами: вам потрібно вибирати невитрачені виходи, які найбільш відповідають своїм «номіналам». Якщо ви хочете заплатити декільком людям відразу, то краще зробити це не окремими транзакціями, а однією. У цьому разі розмір однієї транзакції буде визначений менше сумарного розміру кількох окремих, навіть якщо вони використовують один набір UTXO, оскільки вихід для решти буде включений тільки один раз. Завдяки такій оптимізації даних ви заощаджуєте на комісії.

## 4.2 Майнінг у Bitcoin

Одним із завдань, що стояли перед творцем Bitcoin, було забезпечення синхронізації даних між невідомою кількістю учасників, які не можуть бути ідентифіковані та не довіряють один одному. Наявні в той час підходи досягнення консенсусу не підходили для застосування в таких умовах, бо зловмисник міг створити безліч фіктивних учасників і діяти від їх імені, нав’язуючи чесним учасникам свою версію історії транзакцій (так звана атака Сивілли, чи Sybil attack). У результаті, це завдання було вирішено в спосіб, який не гарантує фінальної історії транзакцій, проте робить атаку економічно невигідною за нормальних умов. Ідея полягала в тому, щоби замість того, щоби проводити голосування за транзакції за принципом більшості учасників, вимагалося, щоби ті, хто голосує, надавали доказ володіння фізичним ресурсом (тобто доказ виконаної роботи), який відбивав безпосередні витрати реальних грошових коштів.

Таким чином, для успішного нав’язування своєї думки зловмиснику була би потрібна наявність більшої кількості ресурсів, ніж у всіх інших чесних учасників. У деякому сенсі майнінг виконує роль абсолютно чесної лотереї, яка визначає переможця (з-поміж тих, хто надав доказ своєї роботи), який отримує право сформувати новий блок й отримати винагороду за свою роботу.

У цьому підрозділі ми розглянемо механізм майнінгу в Bitcoin, його роль у децентралізованому середовищі, а також його особливості та завдання, що він вирішує.

### Мети майнінгу в Bitcoin

*Майнінг у Біткоіні – це процес створення блоку й підтвердження транзакцій, який винагороджується монетами* [43]. У майнінгу є декілька мет. Одна з них – мотивування користувачів до запускання вузлів мережі й підтримування коректної роботи платіжної мережі. Ще одна функція майнінгу полягає в тому, що він захищає історію транзакцій у Bitcoin від змін. Користувач, який успішно створив новий блок ланцюжка, отримує певну кількість нових біткоінів, передбачену правилами протоколу. Тому майнінг також ще й розв’язує проблему розподіляння нових монет серед користувачів, тому що участь у майнінгу може взяти будь-хто, хто має комп’ютер.

> **Завдання, які вирішує майнінг**
>> * *Прийняття рішень у децентралізованому середовищі*
>> * *Вибирання основної версії історії транзакцій*
>> * *Підтверджування транзакцій*
>> * *Здійснювання емісії*

### Класифікація вузлів мережі

Bitcoin-мережу можна подати схематично, як на рис. 4.15. Незалежні люди й організації підтримують повні вузли, але тільки деякі з них займаються майнінгом, тобто фактично є вузлами-валідаторами.

![Рисунок 4.15 – Схема Bitcoin-мережі](/resources/img/volume-1/4.2-mining-in-bitcoin/4.15-scheme-of-bitcoin-network.png)

У мережі є багато користувачів, і кожен із них переслідує власні мети. Хтось розвертає повний вузол та майнить, водночас активно підтримуючи мережу, хтось просто зберігає й обробляє всі транзакції, хтось працює оператором платіжного шлюзу, а хтось просто користується гаманцем і безпосередньої участі в підтвердженні транзакцій не бере. Таким чином, усі вузли мережі Bitcoin можна розділити щонайменше на три групи (рис. 4.16).

![Рисунок 4.16 – Класифікація вузлів мережі Bitcoin](/resources/img/volume-1/4.2-mining-in-bitcoin/4.16-classification-of-nodes.png)

*Повний вузол – вузол, що виконує перевіряння та зберігання всіх транзакцій.*

*Вузол-валідатор – повний вузол, що створює блоки.*

*Полегшений вузол – вузол, що виконує синхронізацію та перевіряння тільки своїх транзакцій.*

### Поняття ресурсоємна задача

Ресурсоємна задача в Bitcoin полягає в знаходженні прообразу геш-значення, отриманого за допомогою алгоритму SHA-2 на довжині 256 біт. Розв’язок задачі можливо знайти тільки пошуком грубою силою, тому його знаходження потребує великої кількості ресурсів. Перебирання полягає в пошуку такого вхідного значення, яке за гешування на виході дасть значення визначеної форми (рис. 4.17).

![Рисунок 4.17 – Перебір значень у пошуках прообразу](/resources/img/volume-1/4.2-mining-in-bitcoin/4.17-brute-force-search.png)

До того ж, це геш-значення має задовольнити визначеному параметру складності (*difficulty*). Згідно з правилами протоколу Біткоін зі збільшенням параметра складності збільшується кількість нульових старших шістнадцяткових розрядів у підсумковому геш-значенні.

Перерахування параметра складності виконується один раз на 2016 блоків із певними обмеженнями на максимальну зміну задля захисту від різких змін за короткий проміжок часу [44]. Алгоритм перерахування складності порівнює час, витрачений на формування останніх 2016 блоків, з двома тижнями (з 1 209 600 секундами). Якщо на формування блоків пішло менше за це значення, то параметр складності пропорційно збільшується. Якщо на формування блоків пішло більше часу, то складність пропорційно зменшується.

> **_Зауваження._** *Параметр складності не може збільшитися чи зменшитися в більш ніж 4 рази.* 
> 
> *Ресурсоємна задача унікальна для кожного блоку, оскільки дані, які містить блок, є вхідні для формування нової задачі.*

> * *Неможливо вкрасти чужий розв’язок та застосувати його у своєму блоці*
> * *Неможливо створити новий блок, не маючи даних попереднього блоку*

У контексті Bitcoin ресурсоємну задачу також називають задачею на формування proof-of-work (задачею PoW), оскільки її розв’язок є доказом, який можна легко перевірити, того, що автор блоку виконав певну роботу, яка відповідає заданому параметру складності.

> **Вимоги до задачі на формування PoW у Bitcoin**
>> * *Можливість встановити собі задачу самостійно* 
>> * *Перевірення розв’язку має бути дуже швидким* 
>> * *Перевірити правильність розв’язку може будь-хто* 
>> * *Передбачити умови на майбутню задачу неможливо* 
>> * *Задача для наступного блоку різна для всіх валідаторів* 
>> * *Складність задачі однакова для всіх учасників* 
>> * *Витрати ресурсів для знаходження розв’язку визначаються параметром складності*

Зважаючи на викладене вище, можна зробити висновок, що можливість створити першим новий блок є в кожного. Мова йде тільки про ймовірність цієї події для різних учасників.

Оскільки кожен учасник формує свою версію наступного блоку, то й задача буде для кожного своя. Однак складність цієї задачі буде для всіх однаковою. З огляду на те, що задача вирішується методом перебирання (грубою силою), імовірність розв’язати її першим пропорційно збільшуватиметься зі зростанням відсотку обчислювальної потужності, яку має учасник відносно всієї пущеної в дію в мережі потужності.

Майнінг винагороджується біткоінами. Це фактична плата за підтримку надійної роботи децентралізованої облікової системи. Принцип такий: учасники, які не надали доказ розв’язання складної задачі, не отримують права підтвердження транзакцій. Що більше незалежних і чесних валідаторів працюють у мережі, то надійніший Bitcoin [45].

У підсумку, такий простий механізм мотивування людей до майнінгу формує бажання заробляти більше й у такий спосіб стимулює підприємців до купування й запускання більшої кількості комп’ютерів. Вони конкурують за винагороду, і складність ресурсоємної задачі, відповідно, підвищується [46].

### Обмеження частоти формування блоків

Протокол задає середній час формування блоку, що дорівнює 10 хвилинам. Щоби забезпечити виконання цього правила, через кожні 2016 блоків відбувається перерахунок параметра складності, з урахуванням якого формуватимуться наступні блоки. Якщо, наприклад, потужність мережі різко зросте й 2016 блоків буде знайдено набагато раніше, ніж за 2 тижні, то параметр складності зросте, і частота появи нових блоків нормалізується. Така схема дозволяє забезпечувати середній час формування блоку, близьким до заданих 10 хвилин, що принципово важливо для Bitcoin.

### Orphan blocks

Очевидно, що над створенням нових блоків працює багато валідаторів, які розташовані на різних континентах земної кулі [47]. Через те, що час поширення повідомлень через канали передачі даних не дорівнює нулю, між вузлами мережі будуть затримки синхронізації. Грубо кажучи, вузли, які розташовані на одному континенті, отримають новий блок від валідатора зі свого континенту раніше, ніж новий блок від валідатора з іншого континенту, за тієї умови, що обидва блоки були створені в один момент часу. Тому неминучі ситуації, у яких вузли мережі матимуть неоднакові кінцеві стани своїх баз даних (ситуація схожа з описаною раніше у 2.5 про Капітана Джека Горобця та його команду).

Як же відбувається подальше формування й додавання наступного блоку? Кожен валідатор вибирає блок, який він вважає потрібним (наприклад той, що був отриманий раніше), додає його до своєї копії бази даних і на основі нього починає створювати новий блок. Водночас блоки з однаковою висотою конкурують один з одним за можливість стати продовженням основного ланцюжка (mainchain). «Перемагає» та версія ланцюжка, на створення блоків якої було витрачено більше обчислювальної потужності. У результаті, з’являються так звані *orphan blocks*, тобто валідні блоки, які, однак, не потрапляють до основного ланцюжка блоків. Транзакції, що перебувають у цих блоках, коректні; вони можуть бути підтверджені та додані до блоку і, відповідно, до mainchain пізніше.

Іноді виникнення orphan blocks тягне небажані наслідки. Перший полягає в тому, що валідатор, який сформував orphan block, у підсумку позбавляється нагороди за його видобуток. Також виникнення великої кількості orphan blocks дозволяє спростити проведення атаки 51 %. На графіку (рис. 4.18) наведена статистика кількості сформованих orphan blocks протягом проміжку часу з березня 2014 року по липень 2017 року [48].

![Рисунок 4.18 – Графік частоти формування orphan blocks](/resources/img/volume-1/4.2-mining-in-bitcoin/4.18-orphan-blocks-freq.png)

Крім того, поява великої кількості orphan blocks може сприяти проведенню атаки 51 %. Це пов’язано з тим, що вся обчислювальна потужність мережі розподіляється між альтернативними ланцюжками, які, зі свого боку, конкурують один із одним, що призводить до ситуації, за якої в зловмисника більше шансів отримати контроль над більшою частиною обчислювальної потужності, спрямованої на формування окремого ланцюжка. Як згадувалося у 2.5, результатом атаки 51 % може бути подвійна витрата (а саме ситуація, за якої зловмисник може витратити ті самі гроші більш ніж одного разу). Відзначмо, що одна з мет, для якої параметр складності перераховується кожні 2016 блоків, полягає у вирівнюванні потужностей валідаторів, завдяки чому не допускається збільшення кількості orphan blocks.

> **_Зауваження._** *Іноді люди плутають два поняття: orphan blocks та stale blocks. Насправді ці терміни різні. Orphan blocks – це блоки, які створені правильно та повністю, але за збігом обставин вони не були додані до основного ланцюжка блоків. Stale blocks – це блоки, над якими валідатори припинили роботу через те, що інший валідатор сформував правильний блок (розв’язав ресурсоємну задачу раніше).*

### Атака подвійної витрати

Можна виокремити одну атаку, від котрої повинна бути захищена будь-яка система обліку фінансів. Це так звана *атака подвійного витрачання (double-spending attack)*, суть якої полягає в тому, що користувач відправляє ті самі монети двом різним одержувачам й обидва приймають платіж. Авжеж, монет удвічі більше не стане, але відправник може за допомогою хитрощів змусити одержувачів повірити, що вони вже володіють монетами.

У контексті Bitcoin є декілька способів, за допомогою яких зловмисник може потенційно реалізувати атаку подвійного витрачання. Один із найбільш тривіальних способів – знаходження вразливості в програмному забезпеченні окремих вузлів, що підтримують мережу Bitcoin, яка технічно може дозволити зловмиснику подвоїти монети. Інший спосіб – коли окрема сторона (група, організація) володіє обчислювальною потужністю, що перевищує 51 % від загальної потужності мережі. У такому випадку ця сторона може з легкістю цензурувати транзакції в мережі та здійснювати атаки подвійного витрачання, використовуючи свої обчислювальні ресурси.

Як приклад можна уявити користувача на ім’я Тарас, у якого є 4 монети та намір здійснити атаку подвійного витрачання. Він збирається купити комп’ютер в інтернет-магазині Е1 і смартфон в інтернет-магазині Е2, причому кожний із його товарів коштує 4 монети (рис. 4.19). Оскільки він має лише 4 монети, він збирається розрахуватися ними двічі.

![Рисунок 4.19 – Створення двох транзакцій, які витрачають однакові монети](/resources/img/volume-1/4.2-mining-in-bitcoin/4.19-conflicting-txs.png)

Отже, Тарас створює дві транзакції. У першій транзакції монети відправляються на гаманець інтернет-магазину Е1, а в другій – інтернет-магазину Е2. Звісно, ці транзакції конфліктні й не можуть бути підтверджені одночасно. Тому першу транзакцію Тарас відразу розповсюджує до мережі, а другу тримає в таємниці.

Поки інтернет-магазин Е1 чекає повне підтвердження першої транзакції, Тарас швидко формує блок, у який включає свою другу транзакцію (і непідтверджені транзакції інших користувачів за бажанням). Цей блок посилається на стан ланцюжка блоків, коли в Тараса було 4 монети, тому правила протоколу розпізнають другу транзакцію коректною.

Відразу після цього Тарас починає майнити, щоби підтвердити альтернативний блок. Якщо блок створений успішно, не публікуючи його, Тарас відразу починає створювати наступний блок на його основі. Ідея Тараса в тому, що він таємно будує другий ланцюжок, де підтверджує транзакцію для Е2. Очевидно, що він не буде публікувати її до мережі допоки Е1 не прийме платіж (рис. 4.20)

![Рисунок 4.20 – Прийняття платежа одним із магазинів](/resources/img/volume-1/4.2-mining-in-bitcoin/4.20-acceptance-of-payment-by-the-shop.png)

Згідно з правилом найдовшого ланцюжка гілка Тараса має бути довшою, ніж у всіх інших валідаторів. Коли інтернет-магазин Е1 бачить, що перша транзакція отримала достатню кількість підтверджень, він упевнений, що за товар Тарас розрахувався, і відправляє комп’ютер. Не гаючи часу, Тарас публікує свій альтернативний ланцюжок. Якщо цей ланцюжок перевершуватиме за довжиною ланцюжки інших валідаторів, усі вузли переключаться на нього та вважатимуть основним ланцюжком його (рис. 4.21). Це буде можливо тільки в тому разі, якщо Тарас контролює більш ніж половину обчислювальної потужності мережі Bitcoin.

![Рисунок 4.21 – Тарас проводить подвійну витрату](/resources/img/volume-1/4.2-mining-in-bitcoin/4.21-doublespending.png)

Згідно з альтернативним ланцюжком блоків ті самі 4 монети відтепер належать інтернет-магазину Е2, який відправить Тарасу смартфон. Той факт, що попередній ланцюжок із першою транзакцією відтепер вважається недійсним, свідчить про те, що інтернет-магазин Е1 залишається без монет (рис. 4.22). Якщо це так, то ми можемо стверджувати, що Тарас виконав атаку 51 %, унаслідок чого витратив свої монети двічі.

![Рисунок 4.22 – Результат виконання атаки подвійного витрачання](/resources/img/volume-1/4.2-mining-in-bitcoin/4.22-result-of-attack.png)

### Поява спеціального обладнання

Так склалося, що з часом для ефективного майнінгу знадобилося спеціалізоване обладнання [49]. За часів стрімкого зростання ціни на монети, майнінг виявився вельми прибутковою діяльністю. Люди намагалися обзавестися якомога більшою кількістю обчислювальних ресурсів, щоби мати можливість конкурувати один із одним за винагороду, розв’язуючи задачу PoW. Стало зрозуміло, що розв’язувати її на центральному процесорі звичайного комп’ютера неефективно.

> * *CPU – центральні процесори (2009–2010)*
> * *GPU – графічні процесори (2010–2012)*
> * *FPGA – програмовані вентильні матриці (2011–2013)*
> * *ASIC – інтегральні схеми спеціального призначення (2012–сьогодення)*

З’явилася ідея виконувати обчислення на графічному процесорі, оскільки це дозволило би виконувати перебирання в кілька потоків паралельно та з набагато меншими витратами електроенергії. Щоби цього досягти, вирішили адаптувати вихідний код розв’язання задачі під його виконання на графічному процесорі. Таким чином, надалі зростав попит на дедалі більш енергоефективне обладнання для майнінгу. У результаті, навіть з’явилися компанії, які спроєктували оптимізовані чіпи (ASIC) для розв’язання однотипних задач (пошук прообразу геш-значення) і запустили їх виробництво (рис. 4.23).

![Рисунок 4.23 – Обладнання для майнінгу](/resources/img/volume-1/4.2-mining-in-bitcoin/4.23-mining-equip.jpg)

Перші такі чіпи почали з’являтися у 2012 році. Вони значно перевершували за продуктивністю (у тисячі разів) процесори звичайних комп’ютерів. Матеріальна вигода привернула увагу багатьох учасників, які нарощували свою потужність (*hash rate*). Поступово ця тенденція стала нагадувати гонку потужностей. На графіку нижче (рис. 4.24) відображена залежність hash rate усієї мережі Bitcoin від часу [50].

![Рисунок 4.24 – Графік зміни значення hash rate з плином часу](/resources/img/volume-1/4.2-mining-in-bitcoin/4.24-hashrate.png)

З огляду на те, що параметр складності постійно змінюється (рис. 4.25) [50], учасникам потрібно вдосконалювати майнінгове обладнання, щоби розв’язувати поставлені собі задачі більш енергоефективно. Крім енергоефективності, як критерії оцінювання обладнання можна використовувати показники, як-от час знаходження розв’язку конкретним пристроєм і вартість цього розв’язку.

![Рисунок 4.25 – Змінювання параметру складності в Bitcoin](/resources/img/volume-1/4.2-mining-in-bitcoin/4.25-difficulty.png)

### Майнінгові пули та їхні завдання

Припустімо, мережа має 1 млн однакових комп’ютерів. Імовірність знаходження блоку одним із комп’ютерів у цьому разі дорівнює 0,000001. Відповідно, володілець обладнання з такою потужністю створює один блок у середньому за 10 млн хвилин, тобто за трохи більший час, ніж 19 років.

Авжеж, нікого не влаштовує сумнівний інвестиційний цикл тривалістю в 19 років. Тому люди об’єднують своє майнінгові потужності, щоби швидше розв’язати одну спільну задачу та розподілити винагороду. У такий спосіб видобувачі біткоінів почали об’єднуватися в майнінгові пули.

*Майнінговий пул (mining pool) – це група володільців майнінгового обладнання, яка має одного лідера.* Він формує блок і роздає всім учасникам групи задачу. Якщо один із учасників знаходить розв’язок, то винагорода розподіляється між усіма пропорційно до потужності пущеного в дію обладнання. У результаті, учасники пулу отримують винагороду меншого розміру, але доволі часто (рис. 4.26).

![Рисунок 4.26 – Порівняння поодиночного майнінгу та майнінгу в пулі за частотою знаходження блоку й обсягом винагороди](/resources/img/volume-1/4.2-mining-in-bitcoin/4.26-comparing-solo-and-pool-mining.png)

Щодо такого підходу слід відзначити одну деталь: конкретний володілець майнінгового обладнання не вирішує, які транзакції включати до блоку. Його завдання полягає тільки в розв’язанні ресурсоємної задачі. Але коли володілець майнінгового обладнання помічає, що лідер його майнінгового пулу підозріло вибирає транзакції для підтвердження, то він вибирає для підключення інший майнінговий пул, який на думку підприємця є більш чесним і незалежним, і надалі працює вже з ним.

На діаграмах нижче відображений розподіл обчислювальних потужностей мережі Bitcoin між валідаторами [51]. Деякі валідатори розкрили свої особистості, а деякі – ні («Unknown»). В ідеальному разі з погляду *децентралізації* та *незалежності прийняття рішень* валідатори мають залишатися анонімними (це не завжди можна вважати гарантованою умовою, нижче ми пояснимо чому). Але проаналізуймо зміну ситуації в динаміці в межах невеликого проміжку часу.

Як видно з діаграми (рис. 4.27), загальна обчислювальна потужність таких валідаторів не перевищує 9 %. Зображені дані актуальні станом на кінець серпня 2018 року й дозволяють зробити висновок про те, що велика частина блоків формується від імені публічно відомих вузлів-валідаторів, що є лідери майнінгових пулів. Відповідно, можна побачити, що пули, як-от BTC.com, AntPool, SlushPool, BTC.TOP, акумулюють більш ніж половину всієї обчислювальної потужності. І хоча до цього моменту пули не змовлялися між собою, насправді це не ідеальна реалізація принципів децентралізації.

![Рисунок 4.27 – Розподіл майнінгових потужностей у мережі Bitcoin наприкінці серпня 2018 рок](/resources/img/volume-1/4.2-mining-in-bitcoin/4.27-distributing-the-mining-capacities.png)

Технічно пули можуть провести атаку 51 %, але якщо вони перейдуть до її здійснення, то в мережі це відразу буде помітно. Найімовірніше, спільноту це обурить – і володільці майнінгових потужностей перейдуть до іншої групи з іншим лідером. А учасники змови втратять свою репутацію, своих клієнтів та свій бізнес.

Цікавим фактом є те, що на початку грудня того самого року (рис. 4.28) частина анонімних валідаторів зросла до 22,6 %. На перший погляд такий стан сприятливий у контексті децентралізованої системи, але проаналізувавши можливі загрози, можна зробити висновок, що технічно валідатори можуть утворювати анонімні пули, які складно деанонімізувати. Причому володіти таким пулом може як група валідаторів, так й одна людина. Є ймовірність, що, досягнувши деякого порогового розміру, такий майнінговий пул може провести атаку подвійного витрачання.

![Рисунок 4.28 – Розподіл майнінгових потужностей у мережі Bitcoin на початку грудня 2018 року](/resources/img/volume-1/4.2-mining-in-bitcoin/4.28-distributing-th-mining-cap-december.png)

### Статистика майнінгу й оцінка енергоспоживання

У квітні 2018 року показник спожитої електроенергії для майнінгу склав 110 ГВт на добу, а сума винагород усіх підприємців, які займаються майнінгом, за добу – $32 млн [52; 53]. Відсоток комісійних зборів від усієї винагороди становив 21 %, тобто приблизно п’яту частину, а комісія за середню за розміром транзакцію протягом року коливалася від $0,1 до $40. Розмір усіх даних у ланцюжку блоків Bitcoin перевищує 175 ГіБ.

Показник спожитої електроенергії зріс упродовж наступних кількох місяців, і на момент 31 серпня 2018 року для мережі Bitcoin він становив 200,3 ГВт на добу, тобто 73,1 ТВт на рік.

Щоби зрозуміти, чи багато це чи мало, подивімося, скільки електроенергії може виробити найпотужніша електростанція у світі. Такою на кінець серпня 2018 року вважається китайська Three Gorges Dam [113], і за 2017 рік її показник виробленої електроенергії склав 97,6 ТВт. Графік на рис. 4.29 не менш показовий. На ньому зображено рівень енергоспоживання Bitcoin порівняно з деякими державами. Очевидно, що рівень споживання електроенергії, потрібний для функціонування Bitcoin, перевищує потреби Чилі, Чеської Республіки чи Австрії [52].

![Рисунок 4.29 – Витрати електроенергії держав порівняно з Bitcoin](/resources/img/volume-1/4.2-mining-in-bitcoin/4.29-energy-consumption.png)

Було розраховано, що для підтвердження однієї транзакції в Bitcoin споживається майже 921 кВт на добу. Приблизно стільки само електроенергії потрібно, щоби забезпечити понад 30 середньостатистичних будинків США протягом доби. Якщо порівняти Bitcoin із платіжною системою Visa та проаналізувати графік на рис. 4.30, нескладно обчислити, що 1 транзакція в Bitcoin виходить дорожчою, аніж 500 000 транзакцій у системі Visa.

![Рисунок 4.30 – Витрати на транзакцію в Bitcoin порівняно з витратами на транзакцію в Visa](/resources/img/volume-1/4.2-mining-in-bitcoin/4.30-bitcoin-vs-visa.png)

Споживання електроенергії в Bitcoin не завжди підвищується. Простеживши за динамікою зміни цього показника із серпня по грудень 2018 року [54], можна відзначити його різке зниження із середини листопада до значення 53,04 ТВт на рік (рис. 4.31).

![Рисунок 4.31 – Споживання електроенергії в Bitcoin](/resources/img/volume-1/4.2-mining-in-bitcoin/4.31-energy-in-bitcoin.png)

Незважаючи на явно марнотратне споживання енергії, не все так однозначне, оскільки цінність Bitcoin полягає передусім у його властивостях, зокрема в *захищеності від цензурування транзакцій*. До того ж, щодня Bitcoin-спільнота підтримує та розвиває протокол, пропонує покращення та нові способи оптимізування його роботи.

**Поширені міфи**

*Після 2140 року майнінг припиниться.*

Після 2140 року майнінг не буде припинений і валідатори надалі отримуватимуть винагороду за формування блоку. Однак винагорода буде складатися виключно з комісій за транзакції, без нових випущених монет.

*Вартість біткоіна цілковито залежить від вартості майнінгу.*

Насправді же прямої залежності між ціною монети та витратами на її видобуття немає (з тієї самої причини, з якої ціна золота в доларах не визначається безпосередньо вартістю добування золота). Можлива лише непряма залежність: коли ціна монет зростає, з’являється більше тих, хто хоче видобувати їх.

*Іноді люди думають, що якщо вони куплять і запустять більше обладнання, то гарантовано видобудуть більше біткоінів або навіть видобудуть усі монети, передбачені як емісія, набагато раніше за 2140 рік.*

Якщо використовувати більше обчислювальних потужностей, то можна збільшити свою частину винагороди, але видобути більше монет, ніж заздалегідь визначено, не можна. Темп емісії ніяк не залежить від того, яка поточна майнінгова потужність усієї мережі.

*Складність майнінгу завжди підвищується.*

Це не так, вона може й знижуватися. Складність зростала, тому що біткоіни дорожчали, що тягнуло зростання конкуренції за винагороду. Якщо ж винагороди в доларовому еквіваленті знижуватимуться, то охочих майнити буде менше. У крайньому разі можливо, що обладнання, що вже працює, доведеться вимкнути, оскільки винагороди може не вистачати для оплати електроенергії й інших витрат на його обслуговування.

*Якщо взяти суперкомп’ютер і почати майнити, то можна завжди першим створювати блок.*

Найпотужніший суперкомп’ютер у світі не отримає й долі відсотка від усієї обчислювальної потужності мережі Bitcoin, тому що суперкомп’ютер використовує звичайні процесори широкого призначення, які не адаптовані під задачу PoW саме в Bitcoin. Тому компанії, як-от Google або IBM, не можуть ефективно використовувати свої data-центри для цензурування транзакцій, які підтверджуються.

**Часті запитання**

*– Маючи можливість обчислювати геш-значення швидше за всіх інших, хіба не можна перезаписати наявні блоки?*

Можна, але є певні особливості. Потрібно враховувати відсоток наявної обчислювальної потужності щодо потужності всіх інших у мережі, витрати на обслуговування обладнання й час, протягом якого доведеться працювати. Тому потрібно розрахувати економічну доцільність переписування історії останніх блоків, оскільки ключовим показником у процесі майнінгу є його енергоефективність. Здебільшого вартість атаки за сумою витрат перевищує отриману користь.

*– Як обчислили дату видобутку останнього біткоіну, якщо частота генерації блоку може змінюватися в часі?*

На коротких проміжках часу частота генерації блоків дійсно може доволі відрізнятися. Однак на довгих проміжках часу вона майже однакова. За правилами протоколу мережа прагне до того, щоби середній період формування блоку дорівнював 10 хвилинам. Це досягається завдяки регулюванню параметру складності задачі PoW.

*– Чому така слабка конкуренція у сфері виробництва обчислювальних машин для видобутку біткоінів?*

На момент 2018 року є 5 великих компаній, які проєктують майнінгове обладнання, і 2 великі компанії, які виробляють для нього спеціалізовані чіпи. Таке виробництво досить складне, потрібні інвестиції для розроблення чіпа та його виробництва. Це справа на мільйони доларів. До того ж, виробничий цикл може зайняти більш ніж рік, а галузь має великий ризик, оскільки ці чіпи більше нікому, крім підприємців, які видобувають біткоіни, продати не вийде. Звісно, підприємці неохоче йдуть у цю галузь. Утім, конкуренція виробників усе-таки є.

*– Яка різниця між майнером і валідатором у Біткоіні?*

Деякі люди плутають ці терміни. Строго кажучи, валідатор – це роль учасника системи, тобто це підприємець, який налаштовує обладнання та стежить за коректністю його роботи. Майнер же – це те, що розв’язує ресурсоємну задачу, тобто саме обладнання.

## 4.3 Як реалізовано blockchain у Bitcoin?

Сам підхід до зберігання даних у зв’язаному вигляді не є чимось новим, однак blockchain став новим способом організації бази даних цілої *облікової системи*. І це сталося не внаслідок теоретичних наукових розробок, а під час спроби відповісти на загрози безпеці з боку учасників анонімної розподіленої мережі. Важливо відзначити, що наявні до цього облікові системи часто спиралися на не технологічні способи захисту інформації та вирішення конфліктів – це було можливим в неанонімному середовищі, де є вже визначені сторони, призначені регулювати проблемні ситуації, як-от суди, поліція тощо. Сатоші, як деякі інші інженери, робив спроби створення *фінансової облікової системи*, у якій би всі стали рівноправними й могли зберігати приватність. У цьому випадку вже неможливо звернутися по допомогу до суду (це може бути як плюсом, так і мінусом залежно від ситуації й мети користувача).

Анонімна розподілена мережа, до того ж стійка до цензури, вимагала зовсім інших підходів до вирішення проблем – у звичайному світі багато небажаних речей просто не відбуваються, тому що є ризик розкриття злочину, подальшого розголосу, втрати репутації й навіть тюремного ув’язнення. Тому захист від багатьох атак просто відсутній – суспільство, у якому закони працюють ефективно, їх просто не вимагає. Наприклад, у США за втрати банківської карти та PIN-коду до неї банк усе одно поверне вам украдені гроші – позаяк усе застраховано. І навіть якщо приблизно 4 % прибутку банків витрачається на страхування, це все одно виявляється дешевше, ніж безпосередній захист від усіх можливих сценаріїв шахрайства. У випадку Bitcoin багато конфліктів просто нікому вирішувати. Тому він спроєктований у такий спосіб, щоб *уникати появи конфліктів*, а не створювати механізми їх вирішення постфактум. У Bitcoin неможливо відправити монети, яких немає, але є загроза проведення успішної атаки подвійного витрачання [55]. Вивчення даної теми дасть відповіді на питання, у який спосіб уперше була реалізована технологія blockchain і чому саме так.

Визначмо поняття *блокчейн* у контексті Bitcoin: це база даних, яка містить транзакції, і вона загальна для всіх вузлів, залучених до системи Bitcoin. Особливість її полягає в тому, що кожен наступний блок підтверджує цілісність попереднього блоку, який так само підтверджує цілісність попереднього щодо нього блоку й так до *genesis block*. Забезпечується односторонній зв’язок усіх блоків і підтверджується факт того, що блок був створений після появи попереднього. Така організація даних гарантує, що під час створення кожного блоку визнається вся історія транзакцій за весь час наявності Bitcoin.

Трохи розширмо уявлення про структуру даних у ланцюжку блоків (рис. 4.32). Пригадаймо, що кожний блок складається з двох частин: заголовка блоку та включених транзакцій.

![Рисунок 4.32 – Структура ланцюжка блоків](/resources/img/volume-1/4.3-how-is-blockchain-implemented-in-bitcoin/4.32-structure-of-the-chain-of-blocks.png)

*Genesis block – це перший блок, створений у ланцюжку, за яким учасники можуть створювати наступні блоки*. Особливість genesis block полягає в тому, що він не розповсюджується під час синхронізації вузлів, позаяк він закладений до ПЗ вузла мережі й має порядковий номер 0 [56].

Коли потрібно провести поверхову верифікацію децентралізованої облікової системи, вузлу досить завантажити тільки заголовки блоків. Це дозволяє перевірити час створення блоку, геш-значення попереднього блоку, зміну параметра складності з часом. Однак для більш серйозної перевірки, наприклад перевірки на наявність подвійної витрати, вузлу знадобиться й тіло блоку з транзакціями, тобто повний блок.

### Структура блоку

Розгляньмо докладно структуру блоку, що передається мережею Bitcoin. Відповідний порядок даних вказаний у таблиці 4.1.

Таблиця 4.1 — Структура блоку в Bitcoin

| field        | value                                         | size      |
|--------------|-----------------------------------------------|-----------|
| MagicNo      | 0xD9B4BEF9                                    | 4 Bytes   |
| BlockSize    | number of bytes following up to the end block | 4 Bytes   |
| BlockHeader  | consists of 6 items                           | 80 Bytes  |
| TxCounter    | positive integer                              | 1-9 Bytes |
| Transactions | the (non empty) list of transactions          | N/A       |

У блоці передбачається декілька полів, перше з них – *magicNo* – є спеціальним константним числом. Для протоколу Bitcoin воно завжди має саме таке значення й займає 4 байта. Використовується воно для ідентифікації потоку даних. Припустимо, є канал передачі, де проходять дані від різних протоколів. Щоб ідентифікувати, що в певний проміжок часу почався блок Bitcoin, можна використовувати пошук за цим значенням. Відповідно, для інших протоколів значення буде іншим.

Після нього йде поле *blockSize* (розмір блоку), яке займає також 4 байта й містить значення кількості байтів у цьому блоці включно з усіма даними транзакцій. За ним йде заголовок блоку, він складається із шести полів і завжди дорівнює 80 байтам.

Нижче розташовується *txCounter* (лічильник транзакцій). Кількість транзакцій у блоці може бути настільки великою, що лічильник може мати розмір від 1 до 9 байт. Після йдуть дані самих транзакцій, їх розмір не визначений. На практиці блок може мати розмір від 100 байт і до 1 MB: набір транзакцій теж може бути різним за кількістю.

Ключовим складником блоку є його *block header* (заголовок блоку). Тема блоку містить 6 полів. Їх перевіряють усі вузли мережі, навіть полегшені. Верифікація кожного поля виконується за суворо визначеними правилами, основні з яких навряд чи буде змінено згодом. Характеристика всіх полів представлена в таблиці 4.2.

Одне з них має назву *nonce*, у якому подано кількість спроб розв’язання ресурсоємної задачі. Є також параметр difficulty, який позначає складність видобування монет і перебуває в полі *bits* (присутній у заголовці блоку). Він змінюється приблизно одного разу на два тижні (одного разу за період побудування 2016 блоків).

Таблиця 4.2 – Структура заголовку блоку

| field          | size                                     | updated value                                           | size     |
|----------------|------------------------------------------|---------------------------------------------------------|----------|
| Version        | Block version number                     | You upgrade the software and it specifies a new version | 4 Bytes  |
| HashPrevBlock  | 256-bit hash of the previous blockheader | With the generation of each new block                   | 32 Bytes |
| HashMerkleRoor | 256-bit hash of txes                     | A transaction is accepted                               | 32 Bytes |
| Time           | Current timestamp                        | Every few seconds                                       | 4 Bytes  |
| Bits           | Current target in the compat format      | The difficulty is adjusted                              | 4 Bytes  |
| Nonce          | 32-bit number (starts at 0)              | Increments after each hash is checked                   | 4 Bytes  |

Отже, у першому полі записується версія – це 4 байта. Вона відповідає версії протоколу, за якою працював валідатор (творець блоку). Далі *hashPrevBlock*, тобто геш-значення від заголовку попереднього блоку, яке має довжину 256 біт. Відзначмо, що це геш-значення отримується внаслідок застосування подвійного гешування за допомогою геш-функції SHA-2. Це поле містить 32 байти даних. Нижче розташоване отримане спеціальним чином (*Merkle tree*) геш-значення від усіх транзакцій у блоці – теж 32 байти, після чого йде часова позначка (Unix timestamp), яку зазвичай встановлюють рівній часу створення блоку, – 4 байти. Після цього йде стислий параметр складності – так званий *bits* – 4 байти. Останній параметр – *nonce*, який називають рішенням завдання PoW конкретно для цього блоку. Він теж має розмір 4 байти. У результаті, заголовок блоку в Bitcoin завжди займає 80 байт.

Отже, ми розглянули структуру блоку та з’ясували, що блоки бувають двох типів: genesis block, тобто нульовий блок у ланцюжку, і наступні блоки, які завантажує й обробляє ПЗ вузла мережі.

### Приклади блоків у Bitcoin

Розгляньмо декілька прикладів блоків у Bitcoin. У таблиці 4.3 представлений genesis block [56]. Його особливість у тому, що значення попереднього блоку в нього дорівнює 0, тобто всі 256 бітів цього значення нульові.

Таблиця 4.3 – Genesis block у Bitcoin

| Version             | 01000000                                                         |
|---------------------|------------------------------------------------------------------|
| Previous block hash | 0000000000000000000000000000000000000000000000000000000000000000 |
| MerkleRoot          | 4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b |
| Timestamp           | 1231006505                                                       |
| Bits                | 486604799                                                        |
| Nonce               | 2083236893                                                       |
| Transaction count   | 1                                                                |
| -                   | Coinbase transaction (reward)                                    |

Genesis block був створений 3 січня 2009 року. Параметр складності, який був встановлений спочатку, Сатоші розрахував у такий спосіб, щоби складність майнінгу відповідала можливостям звичайного настільного комп’ютера. Genesis block теж був сформований шляхом майнінгу, а саме знаходженням прообразу геш-функції певного типу. У цьому блоці міститься тільки одна транзакція, у якій Сатоші згідно з правилами протоколу відправив собі перші в системі 50 монет. Фактично, геш-значення від усіх транзакцій цього блоку (*Merkle root*) є геш-значенням *coinbase-транзакції*.

У таблиці 4.4 подано ще один блок, який посилається на деякий попередній, який уже потрапив у спільну базу даних Bitcoin. На відміну від попереднього прикладу, тут геш-значення попереднього блоку встановлене. Поданий у таблиці блок містить 63 транзакції, іншу версію, відповідну позначка часу, збільшений параметр складності, нове *nonce*.

Таблиця 4.4 – Приклад блоку в Bitcoin

| Version             | 613687296                                                        |
|---------------------|------------------------------------------------------------------|
| Previous block hash | 00000000000000000007c0fb40d7d6225edaa5da8f43490cc56e60c34082e39b |
| MerkleRoot          | 167167cde7164fe0005a71e8b75a8da1e760deb546a944d67d7e3f15dcb60d45 |
| Timestamp           | 1671542973                                                       |
| Bits                | 386397584                                                        |
| Nonce               | 971790600                                                        |
| Transaction count   | 2702                                                             |
| -                   | ...                                                              |

> **_Зауваження._** *Інші блоки можуть містити куди більше транзакцій (не обов’язково 63, як блок у табл. 4.4).*

Розгляньмо докладніше позначки часу. Кожен заголовок блоку містить позначку часу згідно до стандарту Unix timestamp. Unix timestamp – це формат часу, що вказує кількість секунд із півночі 1 січня 1970 (00:00:00 UTC).

Для верифікування позначок часу в протоколі Bitcoin є відповідні правила. Ці правила, зокрема, описують обмеження для часової позначки блоку під час його верифікування. Нижньою межею є медіанне значення, розраховане на підставі позначок часу одинадцяти останніх здобутих блоків. Верхня межа розраховується інакше: якщо вузол отримує з мережі новий блок, програмне забезпечення виконує перевірку того, що позначка часу була менше, ніж медіанне значення поточного часу на вузлах, з якими даний вузол має з’єднання з мережею, плюс 2 години.

Таким чином, для позначки часу кожного нового блоку, завантаженого вузлом із мережі, є досить широке вікно. Воно дозволяє уникнути конфліктів в історії транзакцій за різниці в поточному часу на різних машинах і забезпечити певний порядок прийняття правильних блоків. Теоретично позначка часу попереднього блоку може випереджати позначку наступного блоку, але в невеликих діапазонах це нормально. Bitcoin використовує ці позначки, тільки на великих проміжках часу для оновлення параметру складності майнінгу (difficulty), а на невеликих проміжках це не грає особливої ​​ролі.

*Coinbase-транзакція – це транзакція, яка є перша в списку (має нульовий індекс)*; вона присутня в кожному блоці. У ній валідатор, який знайшов рішення та створив новий блок, виписує собі винагороду за роботу та привласнює комісії з усіх транзакцій, які він включив до цього блоку.

Coinbase-транзакція вироджена тому, що вона не має входів: вони заповнюються іншими значеннями, а виходи якраз містять винагороду, яку зможе забрати собі валідатор. Нагадаємо, що в Bitcoin використовується параметр *coinbase maturity*, що визначає кількість підтверджень coinbase-транзакції, необхідних для того, щоби її творець отримав можливість витрачати зароблені монети. Сатоші встановив значення цього параметра таким, що дорівнює 100.

### Поняття mempool у Bitcoin

У протоколі Bitcoin є ключове поняття *mempool*: це окремий модуль кожного повного вузла мережі, що зберігає й обробляє непідтверджені транзакції. Таким чином, кожен вузол мережі Bitcoin має свій mempool, де він зберігає чергу транзакцій, які він перевірив і вважає правильними. Грубо кажучи, mempool займається організацією такої черги (рис. 4.33), у ньому зберігаються й сортуються транзакції, перед тим як із них будуть формуватися нові блоки.

![Рисунок 4.33 – Функціонування mempool](/resources/img/volume-1/4.3-how-is-blockchain-implemented-in-bitcoin/4.33-operation-of-mempool.png)

Mempool безпосередньо відображає стан пропускної здатності мережі. За 2017 рік середня завантаженість черги склала 30 000 транзакцій, розмір яких приблизно дорівнює 40 MB. Це досить велика черга, якщо врахувати, що в мережі Bitcoin в середньому кожні 10 хвилин створюється блок розміром 1 MB, який підтверджує в середньому 1 500 транзакцій (див. пункт 4.7).

### Життєвий цикл блоку
> * *Формування*
> * *Створення*
> * *Розповсюдження*
> * *Верифікація*
> * *Приєднання*
> * *Від’єднання*

*Формування блоку.* Валідатор вибирає транзакції з mempool, обчислює значення Merkle root, визначає геш-значення від попереднього блоку, поле *timestamp*, *txCounter* і *blockSize*, після чого об’єднує ці дані та формує блок.

*Створення блоку.* Процес створення блоку, за суттю, і є майнінг (докладно описано в 4.2).

*Розповсюдження блоку*. Після створення нового блоку вузлом-валідатором відбувається його розповсюдження мережею Bitcoin. Творець блоку передає його сусіднім вузлам, з якими має безпосереднє з’єднання. Після отримання блоку кожен вузол перевіряє відповідність цього блоку правилам протоколу. Якщо блок коректний, тобто не містить конфліктних транзакцій, то вузол додає отриманий блок у власну базу даних і розповсюджує його далі мережею. Водночас вузол припиняє роботу над добуттям власного блоку, усі конфліктні транзакції видаляються, а інші відправляються назад до mempool і чекають на подальше підтвердження.

На рисунку 4.34 показано, як відбувається процес розповсюдження нового блоку в мережі. Процес не є миттєвим, унаслідок чого й виникає неоднорідність стану бази даних у мережі в конкретний момент часу, коли деякі вузли ще не прийняли останній створений блок.

![Рисунок 4.34 – Розповсюдження блоку в мережі](/resources/img/volume-1/4.3-how-is-blockchain-implemented-in-bitcoin/4.34-block-propagation.png)

*Верифікація блоку*. Щоби перевірити, що конкретна монета не витрачається двічі, поряд з основною використовують окрему базу даних, яку веде кожен вузол мережі Bitcoin, і вона має назву *coins database*. Вона зберігає поточний стан усіх невитрачених виходів.

Усі транзакції мають багато виходів: одні з них уже було витрачено, інші – ні. Виходи, що не були витрачені, зберігаються й індексуються програмним забезпеченням окремо. Коли надходить новий блок (він попередньо був перевірений: що структура збігається, складність майнінгу правильна, задача PoW розв’язана, цифрові підписи правильні… насправді, перевірок набагато більше, але перелічені основні), то додатково під час приєднання блоку до своєї локальної копії ланцюжка бази даних, кожен вузол мережі перевіряє кожну транзакцію щодо того, що вона витрачає наявні монети саме з coins database. У такий спосіб гарантується захист від подвійного витрачання й оптимізується цей процес. Немає потреби звертатися до входу кожної транзакції, шукати транзакцію, що витрачається, і перевіряти, чи не було там подвійної витрати, а просто виконується індексування всіх невитрачених монет. Це прискорює процес перевірки нових блоків.

*Приєднання блоку*. Це важливий процес, що визначає, як блоки верифікуються та зберігаються на кожному вузлі в локальній копії ланцюжка. Для цього кожний вузол вибирає блок (серед тих, що отримані та вважаються коректними), а також відповідний цьому блоку ланцюжок, і приєднує їх до своєї локальної копії бази даних.

*Від’єднання блоку*. Протилежним процесом від під’єднання блоків є від’єднання блоків. Розгляньмо ситуацію, коли це може виникати.

Коли вузол-валідатор орієнтується на деякий блок (позначмо його прапором на рис. 4.35), поточний стан його бази даних відповідає цьому блоку, і він працює над створенням наступного блоку. Припустимо, у мережі був опублікований альтернативний блок, що міг з’явитися з різних причин. Через деякий час у мережі з’являється це один блок, що був створений на основі альтернативного. На схемі ця гілка зображена знизу. Коли стане відомим альтернативний ланцюжок, що виявиться довше тієї гілки, на яку вузол орієнтується в той час, то згідно з правилами протоколу він повинен буде переключитися. Проте насправді цей процес організований не так просто, як може здатися на перший погляд.

![Рисунок 4.35 – Перемкнення на альтернативний ланцюжок](/resources/img/volume-1/4.3-how-is-blockchain-implemented-in-bitcoin/4.35-switching-between-blockchains.png)

Є процес, що має назву *reorganization*. Він дозволяє користувачу скасувати одну версію історії подій і переключитися на іншу. Як це працює? Reorganization включає від’єднання блоків, яке становить деяку ключову складність. Вузол мережі повинен повернути всі монети, витрачені в блоці, який від’єднується, і знову позначити їх як невитрачені, тобто повернути їх до coins database. Також потрібно повернути всі транзакції, які були підтверджені в цьому блоці, до mempool, щоби вони знову отримали статус непідтверджених. Тільки після цього можливе приєднання альтернативного блоку, де, імовірно, ті самі транзакції стануть підтвердженими, а ті сами монети стануть витраченими. Цей процес повинен бути чітко виконаний вузлом мережі, щоби мати кінцевий стан локальної копії бази даних, що ідентичний іншим чесним вузлам.

### Початкова синхронізація вузла

Вище ми розглянули, що представляє собою ланцюжок блоків у Bitcoin, а також які властивості облікової системи можуть бути забезпечені та в який спосіб (за допомогою яких механізмів). Зараз мова піде про те, яким саме чином дані ланцюжка блоку організовані безпосередньо на обчислювальних машинах користувачів.

Спосіб організації ланцюжка блоків може істотно різнитися серед різних виробників програмного забезпечення гаманців. Наприклад, розробники Bitcoin Core використовують базу даних LevelDB, що підтримує зв’язок *ключ–значення* для організації даних.

Слід також згадати, що за замовчуванням ланцюжок блоків розташований в «%APPDATA%\bitcoin», якщо ви використовуєте ОС сімейства Windows, чи в «~/.bitcoin», якщо ви працюєте з ОС Linux, чи в «~/Library/Application Support/Bitcoin», якщо ви використовуєте Mac OC.

Незалежно від програмного забезпечення, що використовується, основною вимогою є досягнення консенсусу щодо кінцевого стану бази даних між користувачами мережі. Це означає, що якщо Аліса відправляє Бобу 7 біткоінів, то ця транзакція повинна бути правильно оброблена незалежно від способу зберігання ланцюжка блоків.

Уявімо, що користувач вирішив запустити вузол мережі Bitcoin. Оскільки він це робить уперше, то копії спільної бази даних з усіма транзакціями він не має. Користувач запускає спеціальне програмне забезпечення й починає завантажувати весь ланцюжок блоків, оскільки йому потрібно його верифікувати, щоби переконатися в актуальності стану всіх невитрачених виходів, перш ніж продовжити роботу з іншими вузлами. Під час цієї синхронізації користувач наражається на деякі ризики, бо в цьому випадку можуть бути використані вразливості мережевої взаємодії (або інші) для проведення низки атак.

Одна з них – спам неправильними ланцюжками з боку зловмисника. Під час завантаження ланцюжка блоків користувачу можуть нав’язати альтернативні версії стану бази даних, згідно з якими він монет не має, а зловмисник – має. Таким чином, користувача можуть обдурювати, а його ПЗ у статусі мережевого з’єднання буде відображати, що все коректне. Чому? Тому що альтернативний ланцюжок теж побудований за правилами протоколу, а коректну версію ланцюжка від чесних користувачів ще не було завантажено.

Питання полягає в тому, як попередити виникнення ситуацій, у яких вузол ізольований від інших чесних вузлів мережі. Як можна гарантувати, що ланцюжок блоків, який завантажив користувач, від самого початку є правильним й актуальним? У протоколі Bitcoin це вирішується за допомогою спеціального механізму, що має назву checkpoints. Він діє як додатковий рівень захисту від виникнення таких ситуацій.

### Checkpoints

*Checkpoints – це механізм, що зв’язує геш-значення наявного блоку на певній висоті з відповідним до нього правильним геш-значенням*. Це співвідношення використовується для верифікації правильності блоків, які вузол отримує від інших учасників мережі під час початкової синхронізації.

Ці checkpoints від самого початку записані у ядро програмного забезпечення вузла. Під час початкової синхронізації вузол перевіряє відповідність між отриманими геш-значеннями зі значеннями checkpoints, що є в програмному забезпеченні вузла.

На рисунку 4.36 ви можете побачити, що серед усіх блоків, що завантажує вузол, тільки деякі з них перевіряються у відповідності з checkpoints [57]. Якщо значення збігаються, програмне забезпечення продовжує працювати нормально, якщо ні – користувачу відправляють повідомлення. Таке повідомлення свідчить про те, що або checkpoint неправильний, або користувача на мережевому рівні намагаються обдурити, передаючи неправильну історію транзакцій у Біткоіні.

![Рисунок 4.36 – Відповідність checkpoints до блоків на певній висоті](/resources/img/volume-1/4.3-how-is-blockchain-implemented-in-bitcoin/4.36-checkpoints.png)

Автор цих checkpoints – *спільнота*, а саме розробники, які створили це ПЗ. З огляду на це потрібно довіряти тому, що вони дійсно вибрали геш-значення від правильних блоків, які вже мають багато підтверджень, а ймовірність того, що ця історія буде переписана в спосіб, що передбачає протокол, украй мала.

Checkpoints не можуть бути створені для тих блоків, які ще не створено, або для тих блоків, які було опубліковано зовсім недавно, тому що для недавніх блоків ймовірність переписування історії й появи альтернативного ланцюжка доволі висока. І це може бути якраз правильним ходом. Таким чином, з виходом нової версії програмного забезпечення, воно містить дедалі більше checkpoints для використання під час початкової синхронізації з мережею.

### Властивості спільної бази даних Bitcoin

З огляду на той факт, що Bitcoin реалізує децентралізовану облікову систему, яку підтримують десятки тисяч незалежних вузлів, її база даних придбала дійсно цінні властивості.

> * *Можливість перевірки цілісності транзакцій*
> * *Синхронізація та резервне копіювання в режимі реального часу*
> * *Можливість аудиту в режимі реального часу*
> * *Колективне прийняття рішень щодо додавання записів*
> * *Transparency (прозорість обліку)*
> * *Trustlessness (мінімальний рівень необхідної довіри)*
> * *Незмінність (immutability)*

База даних, що забезпечує властивості, як-от *цілісність* даних та їх *доступність*, має цінність для деяких додатків, що реалізують, припустімо, timestamping або додавання геш-значень від якихось важливих документів у базу даних Bitcoin. Це зумовлено потребою мати докази, що дані було додано в деякий певний проміжок часу, а не пізніше або раніше.

Є дійсно великий попит на використання бази даних, що зберігається в багатьох учасників: її складно підробити заднім числом і неможливо повністю знищити, оскільки велика кількість комп’ютерів уже зберігають і верифікують її. Технічні аспекти щодо запису довільних даних до ланцюжка блоків Bitcoin ми описували раніше (див. 4.1).

Правильне використання технології blockchain може допомогти в досягненні наступних властивостей.

> * *Більш високий рівень децентралізації облікової системи* 
> * *Забезпечення більшої відмовостійкості системи*
> * *Підвищення складності шахрайства*
> * *Більш високий рівень довіри користувачів системі*
> * *Більш надійне забезпечення незмінності та незворотності (irreversibility) транзакцій*

Ці чинники є основною причиною, з якої люди починають говорити про технологію blockchain окремо від криптовалют. Було багато пропозицій, чи можливе застосування технології blockchain у програмах окрім Bitcoin. Більш докладно ми розглянемо такі застосування далі (див. 5.1 та 5.2).

**Поширені міфи**

*Якщо не було жодної транзакції в мережі, то наступний блок не буде сформовано.*

Дійсно, такий погляд може траплятися. Однак чи можна вважати, що майнінг позбавляється сенсу, коли в мережі відсутні нові транзакції? Зовсім ні, новий блок буде створено, тому що за це передбачена винагорода. Кожен блок містить щонайменше одну транзакцію (coinbase). Якщо уявити аналогію в контексті голосування, то користувач може голосувати як за певні транзакції, якщо вони є, так і за їхню відсутність. Незалежно від того, за що голосує користувач, голос враховується. Валідатор може сформувати блок й отримати винагороду, не додаючи в нього жодної транзакції (крім coinbase).

*Якщо валідатор має недостатньо потужне обладнання, то він може створювати невеликі блоки (що містять мало транзакцій).*

Валідатор може вибирати будь-які транзакції для підтвердження, причому незалежно від потужності обладнання. Щоби сформувати блок, потрібно розв’язати задачу знаходження прообразу геш-значення. Це завдання формується з урахуванням параметра складності, який однаковий для всіх учасників мережі. Тому ймовірність створення блоку за допомогою конкретного обладнання пропорційна його частці в сумарній обчислювальній потужності мережі й у загальному разі не залежить від розміру блоку.

**Часті запитання**

*– Чим відрізняються блоки версії 1 і 2?*

У момент активації одного з оновлень протоколу Bitcoin версію блоку інкрементували. Були також застосовані нові правила відповідно до BIP9 [58], що стосуються формування версійних байтів у заголовках блоків.

*– Чи може валідатор вказати в coinbase-транзакції суму винагороди більшу, ніж задану в протоколі? Чи буде такий блок прийнято в мережі?*

Так, валідатор може це вказати, він може навіть створити такий блок, розв’язавши задачу PoW, і розповсюдити його своїми мережевими з’єднаннями. Проте блок відразу піддасться верифікації іншими вузлами, невідповідність протоколу буде відразу виявлено. Цей блок буде відкинуто з боку чесних учасників і далі мережею він розповсюджуватися не буде. Отже, його також не буде підтверджено з боку інших валідаторів.

*– Коли ми запускаємо новий вузол мережі, як він дізнається про інші вузли, де він бере мережеві адреси, щоб уперше з’єднатися з ними й завантажити ланцюжок блоків?*

Найкращим варіантом буде під час створення нового вузла відкрити конфігураційний файл і вручну вписати туди мережеві адреси Bitcoin-вузлів ваших друзів, знайомих і якихось сервісів, яким ви довіряєте. Якщо ж такої можливості немає, тоді ПЗ Bitcoin використовує *Bitcoin seeds*, які воно містить за замовчуванням. Це адреси вузлів, які належать спільноті. Якщо ви довіряєте їм, то це один із варіантів. Знову-таки, мережеві з’єднання здебільшого проходять саме через них спочатку – за їх використання більш імовірно, що ваш трафік буде перехоплено та переспрямовано на зловмисні вузли й т. ін.

*– Чому дорівнює максимально допустима кількість записів у coins database, де індексовані всі UTXO?*

Обмеження на максимальну кількість записів coins database не має. Інакше частина транзакцій, у яких кількість виходів перевищує кількість входів, не могли би потрапити навіть до mempool, не кажучи вже про підтвердження.

*– Чи правильне твердження, що ця база даних зростає, поки підтверджуються транзакції?*

Вона одночасно як росте, так і зменшується, тому що як створюються нові невитрачені виходи, так і їх хтось витрачає. Зі збільшенням кількості користувачів має збільшуватися ця база даних. Що більше користувачів, то більше на кожного припадає невитрачених виходів і то більша, відповідно, ця база даних. Але обмеження граничного розміру вона не має.

*– Чи мають власники повних вузлів такий самий вплив на стан мережі, як вузли-валідатори?*

Повні вузли, які не беруть участі в підтвердженні транзакцій, не впливають на стан мережі. Вони можуть верифікувати транзакції для себе або передавати дані іншим користувачам тоді, коли вони стають чиїмось довіреним вузлом. Однак реальний вплив на кінцевий стан спільної бази даних мають тільки вузли-валідатори.

*– Як у Біткоіні з’явилися блоки з розміром понад 1 МБ?*

У серпні 2017 року було прийнято оновлення протоколу, яке дозволило відокремити докази володіння монетами від основних даних транзакції, – *Segregated Witness*. Максимальний базовий розмір блоку так і залишився обмеженим до 1 МБ, але розмір з урахуванням доказів може перевищувати це значення та досягати 4 МБ (див. 4.6).

## 4.4 Підходи до синхронізування з мережею й SPV-вузли

В основі безпеки Bitcoin лежить прозорість, тобто хто завгодно може перевірити історію транзакцій, надійність зберігання цієї історії, а також протоколи та їх реалізації, що використовуються для функціонування вузла в мережі. Забезпечити надійність зберігання та достовірність даних в таких умовах є одночасно складним й амбітним завданням. Для досягнення цієї мети необхідна наявність по-справжньому незалежних модулів, що будуть перевіряти роботу один одного. Взаємодія програмного забезпечення користувача з програмним забезпеченням інших вузлів мережі є критично важливим завданням, підходи до вирішення якого розглянуті у даній темі.

Раніше ми відзначали, що в мережі Біткоіна вузли постійно звіряють відповідність їхньої локальної копії бази даних до локальних копій інших вузлами та самостійно приймають рішення у разі невідповідності. Такий підхід дозволяє користувачеві бути впевненим, що він отримує завжди актуальні дані і вони надійно зберігаються. Однак цей простий на перший погляд процес влаштований складно і має безліч тонкощів, які потрібно враховувати при виборі способу синхронізації вузлів один з одним. Саме на цьому етапі зловмисники можуть виключати користувачів із загальної мережі, транслюючи їм, наприклад, підроблені транзакції [59]. Нижче будуть розглянуті основні підходи до синхронізації гаманців з Bitcoin-мережею та особливості цих підходів.

Якщо згадати основні функції цифрового гаманця і його устрій, то нескладно помітити, як часто гаманцю потрібен зв'язок з мережею для синхронізації актуальних даних. Розуміння принципів роботи гаманців пояснює деякі аспекти безпеки при їх використанні.

> **Базові функціональності цифрового гаманця**
>> * *Резервне копіювання особистих ключів*
>> * *Прийом платежів*
>> * *Відображення балансу* 
>> * *Відображення історії транзакцій*
>> * *Відправлення платежів*

Для резервного копіювання особистих ключів потрібен тільки модуль, відповідальний за зберігання й управління ключами. Однак за використання решти функцій обов'язково потрібно буде працювати з Bitcoin-мережею. Щоб отримати доступ до загальної бази даних з транзакціями та можливість змінювати її, необхідно як мінімум стати одним з вузлів мережі Bitcoin, а також слідувати специфікації обробки та обміну даними у ній.

Для коректної роботи гаманцю необхідно мати дані про всі транзакції, у яких брали участь його адреси. Нагадаємо, що входи транзакції безпосередньо зв’язані з виходами попередніх транзакцій, тому важливо, щоб монети з цих виходів можна було гарантовано витратити. Отже, украй нелогічно складати нову транзакцію і здійснювати платежі, не знаючи стан підтвердження старих транзакцій. Статус своїх транзакцій – це найбільш важливе з того, що користувачу повинно бути відомо під час приймання та відправлення платежів. Якщо транзакція не отримала достатньої кількості підтверджень, то одержувач не може вважати платіж повністю підтвердженим. Поки транзакція, що відповідає платежу за деякий товар, не стала повністю підтверджено, продавець не може відправити товар покупцю, не ризикуючи залишитися ні з чим.

### Складнощі роботи в розподіленій мережі

Робота з розподіленою мережею є досить складною темою. При її організації зазвичай стикаються з кількома проблемами. Як зазначалося вище, усі вузли мережі регулярно звіряють свій стан із актуальним для всієї мережі та синхронізуються у разі невідповідності. Одна з проблем полягає у виборі способу перевіряння даних, отриманих із розподіленої мережі, а друга полягає в оптимізуванні зберігання цих даних. Складність у тому, що ці вимоги деякою мірою конфліктують між собою. Водночас ідеального рішення немає, тому що неможливо верифікувати транзакції максимально достовірно й одночасно пустити в дію для цього якнайменше ресурсів. Що повніші дані користувач має, то більш достовірні результати перевірки він може отримати. Тому доводиться шукати певний компроміс і балансувати між простотою і безпекою.

Є ще одна проблема. Якщо володілецьповного вузла мережі має намір отримати історію транзакцій за певною адресою, щоб переглянути її, то йому доведеться пройтися по всьому ланцюжку блоків (від genesis block до останнього відомого блоку), що навіть за мінімальної індексації (за замовчуванням в *Bitcoin Core*) доволі довго. Ідеться про великий обсяг даних, а грубий перебір – це малоефективно. Для оптимізування запитів застосовуються спеціальні модулі-надбудови над звичайним вузлом мережі, які допомагають індексувати дані всіх блоків і кешувати деякі з них для прискорення пошуку по популярних метриках. За таким принципом працює будь-який *оглядач блоків* (*block explore*r). Навіть тоді, коли оглядач блоків реалізує публічний інтерфейс для загального використання, він здатний досить швидко повертати дані майже про будь-який, блок, адресу, транзакцію тощо.

Розглянемо кілька принципово різних підходів до здійснення взаємодії і синхронізації цифрового гаманця з розподіленою мережею.

### Підходи до синхронізації гаманця з платіжною мережею

Є три основні підходи (рис. 4.37). Перший передбачає, що гаманець сам є повним вузлом мережі Bitcoin. У другому підході використовується так званий довірений вузол (зазвичай це чужий вузол мережі, але користувач гаманця йому довіряє). Третій підхід має на увазі пряму взаємодію з іншими вузлами мережі, але в спрощеному варіанті. Для цього використовується метод SPV (*Simplified Payment Verification*), яка дозволяє з досить високим ступенем надійності перевірити підтвердження транзакцій, не вдаючись до запуску повного вузла мережі. Зупинимося докладніше на кожному з цих підходів до синхронізації.

![Рисунок 4.37 – Підходи до синхронізації гаманця з мережею](/resources/img/volume-1/4.4-approaches-to-network-synchronization-and-spv-nodes/4.37-approaches-for-wallet-synch.png)

### Робота з повними вузлами

У цьому випадку все досить просто. Гаманець реалізує механізми зберігання й обробки всього ланцюжка блоків, і модуль мережевої взаємодії (обміну повідомленнями P2P) з іншими вузлами мережі Bitcoin. Тому користувач завжди може перевірити нову вхідну транзакцію, чи дійсно вона відповідає правилам протоколу, чи не робить подвійної витрати тощо. Володілець повного вузла може здійснювати детальну перевірку всіх даних.

Однак для зберігання повної історії всіх транзакцій, що постійно збільшується, потрібно виділити великий обсяг дискового простору, що є, скоріше, недоліком. Крім цього, повний вузол підтримує роботу мережі, і йому потрібно безперебійне з'єднання з мережею, щоб постійно синхронізуватися з іншими вузлами і своєчасно оновлювати програмне забезпечення.

Користувачі, які приймають і відправляють платежі на великі суми, потребують підвищеного рівня надійності (достовірності статусів транзакцій), тому для них найкращим є даний підхід. Усі великі сервіси, які надають можливість централізованого зберігання біткоінів, wallet-сервіси, великі торговці тощо, обов'язково використовують саме такий підхід, оскільки вони висувають високі вимоги до безпеки та незалежності при роботі з Bitcoin.

Отже, підтримувати повний вузол або навіть кілька таких (з альтернативними програмними реалізаціями протоколу) – найнадійніший підходом до синхронізування з іншими вузлами мережі, причому Bitcoin-спільнота намагається підтримувати доступність цього підходу для користувача зі звичайним ПК. Для цього просто потрібно взяти готові бінарні файли, наприклад файли Bitcoin Core, і запустити. Досвідчені користувачі можуть пустити в дію загальнодоступний вихідний код. Суттєвим недоліком можна вважати тільки вимоги до дискового простору.

### Робота з довіреними вузлами

Відмінність даного підходу від попереднього полягає у відокремленні логіки гаманця від логіки перевіряння транзакцій. Тут присутній так званий довірений вузол. Це звичайний повний вузол Bitcoin-мережі, якому користувач довіряє перевірку своїх транзакцій. Зокрема, це може бути вузол мережі, який підтримує друг користувача.

Вельми часто такий підхід використовується в мобільних додатках цифрових гаманців. Припустимо, компанія, що розробляє подібний додаток, підтримує довірені вузли і обіцяє, що забезпечить коректну перевірку транзакцій. У такому випадку користувачі, які працюють з таким цифровим гаманцем, довіряють компанії-розробнику, тобто вірять обіцянкам. Користувач при цьому може самостійно зберігати свої особисті ключі і завіряти транзакції на своєму пристрої, проте статус підтвердження транзакцій він запитує у довіреного вузла, а не перевіряє самостійно.

Які ж переваги і недоліки цього підходу? Перевага полягає в тому, що користувачу не потрібно зберігати весь ланцюжок блоків на своєму пристрої. Утім, залежність від довіреного вузла – недолік, адже в разі його відмови користувач не завжди може швидко переключитися на інший довірений вузол.

Можна згадати практичний випадок, коли вузол приватної компанії Blockchain.com відмовив ув обслуговуванні на дві доби через проблеми з DNS (рис. 4.38) [60]. Додатки, які використовували цей вузол в якості довіреного, не могли синхронізуватися з Bitcoin-мережею і підтримувати нормальну роботу.

![Рисунок 4.38 – Відмова в обслуговуванні одного з сервісів](/resources/img/volume-1/4.4-approaches-to-network-synchronization-and-spv-nodes/4.38-dos.png)

Оскільки перевірка транзакцій відбувається на віддаленому сервері, потрібно переконатися у надійності каналу передачі даних між гаманцем і сервером, на якому відбувається перевірка. За такого підходу з’являється загроза атак людини посередині (man-in-the-middle attacks), коли користувач отримує змінену версію історії транзакцій.

Оскільки саме гаманець користувача (а не довірений вузол) зберігає й обробляє особисті ключі, що відповідають адресам, ПЗ гаманця має періодично повідомляти вузлу, за якими адресами потрібно отримати актуальну історію транзакцій і відомості про поточний стан транзакцій. Інакше кажучи, користувач залежить від довіреного вузла. Причому ця залежність має як мінімум два аспекти. З одного боку, користувач отримує *тільки* ті дані, які йому транслює довірений вузол. Тому існує ймовірність, що вузол може передавати на гаманець підроблені дані. З іншого боку, сам факт розголошення гаманцем всіх своїх транзакцій володільцю вузла свідчить про ризики, які несе користувач щодо конфіденційності своїх транзакцій. Слід розуміти, що як тільки користувач втрачає доступ до довіреного вузлу або вузол відмовляє в обслуговуванні, можливість актуалізації ступеня підтвердження транзакцій і поширення нових транзакцій також втрачається. Відповідно, отримувати і відправляти платежі володілецьгаманця в цьому випадку теж не може.

Для зменшення ризиків, пов'язаних із залежністю від одного довіреного вузла, можна використовувати декілька вузлів. На практиці це означає, що за нормальних умов користувач підключається та працює з одним довіреним вузлом, але якщо трапляється втрата доступу, то цифровий гаманець автоматично підключається до іншого довіреного вузлу. Фактично, при кожному з'єднанні гаманець випадковим чином вибирає один вузол зі списку довірених.

Такий спосіб використовують переважно мобільні гаманці, тому що він дозволяє і верифікувати транзакції, і спростити роботу мобільного додатка. Прикладами таких мобільних гаманців для Bitcoin є Mycelium і Coinomi. Компанія Distributed Lab розробила і підтримує гаманець Bitxfy, де застосований цей підхід.

### Робота з SPV-вузлами

Третій поширений підхід до синхронізування цифрового гаманця з Bitcoin-мережею – це полегшений вузол мережі. Ідеться про *SPV-вузол*. У цьому підході може бути відсутня необхідність запуску своїх повних вузлів або вибору довірених. Передбачається, що цифровий гаманець безпосередньо спілкується з іншими вузлами мережі: вибирає кілька десятків чужих повних вузлів і підтримує з ними з'єднання. Відмінність полягає в тому, що полегшений вузол спілкується з іншими вузлами на рівних, обмінюючись з ними повідомленнями P2P, але при цьому не зберігає всю історію транзакцій. Тут для перевірки вхідних транзакцій застосовується метод SPV. Полегшений вузол проводить тільки частину найбільш важливих перевірок з тих, що проводить повний вузол мережі.

Як відбувається робота в цьому випадку? Замість того, щоб отримувати блоки, як це робить повний вузол, SPV-вузол отримує тільки заголовки блоків, які мають набагато менший розмір (80 байт). У заголовку містяться необхідні дані для перевірки факту підтвердження конкретної транзакції в цьому блоці, не маючи при цьому всіх інших транзакцій блоку. Таким чином, цифровий гаманець може переконатися, що транзакція була дійсно підтверджена в конкретному блоці.

Чому це не можна вважати повноцінною верифікацією транзакцій? Звичайно, користувач отримує незалежність від конкретних вузлів мережі і може безпосередньо спілкуватися з розподіленою мережею. Для цього йому не потрібно зберігати всю історію транзакцій. Але недолік полягає в тому, що полегшений клієнт самостійно не перевіряє транзакцію повністю, тому що у вас немає всіх необхідних даних для цього (наприклад, невитрачені монети). Він перевіряє лише факт підтвердження транзакції валідаторами – тобто переконується, що цю транзакцію повністю перевірили інші вузли і володільці більшості обчислювальної потужності мережі (валідатори). У цьому випадку надійність знову зводиться до довіри, що більшість обчислювальної потужності використовується для чесної роботи. Інакше кажучи, ви не самі перевіряєте транзакцію, а довіряєте це більшості.

Особливістю використання цифрових гаманців, які реалізують підхід SPV-вузла, є необхідність підтримки мережевого з'єднання з великою кількістю незалежних повних вузлів мережі. Це потрібно, щоб мінімізувати ймовірність того, що вузол буде підключатися і отримувати дані тільки від вузлів зловмисника. Тоді зловмисник може нав'язати користувачеві альтернативний (підроблений) стан історії транзакцій. Як наслідок – жертва може прийняти платіж з тієї транзакції, яка за версією зловмисника підтверджена, хоча насправді ні. Щоб збільшити шанси отримання актуальних даних про реальний стан мережі, користувачеві слід максимально збільшити кількість незалежних вузлів для спілкування. Чим їх більше, тим менше ймовірність, що вони всі у змові проти користувача.

Як ви вже зрозуміли, SPV-вузли менш вимогливі до стабільної роботи мережевого з'єднання, проте часто застосовуються навіть в мобільних додатках. Цей підхід синхронізації з обліковою системою досить широко поширений і використовується у ряді популярних Bitcoin гаманців. Серед них можна виділити Bitcoin Wallet, Electrum, а також Bread Wallet.

### Функціонування SPV-вузла

Для *початкової синхронізації клієнту*, який використовує метод SPV, необхідно завантажити тільки заголовки всіх блоків основного ланцюжка. Якщо врахувати, що розмір заголовка блоку дорівнює 80 Б, то нескладно порахувати необхідний обсяг даних для завантаження. Для цього досить помножити висоту останнього відомого блоку на розмір його заголовка. Взявши до уваги, що в середині серпня 2018 року було видобуто блок на висоті 537 000, можна обчислити, що загальний розмір заголовків всього ланцюжка не перевищував 41 МіБ. Відзначимо, що в цей же час розмір локальної копії бази даних Bitcoin дорівнював 175 ГіБ. Для подальшої синхронізації з мережею SPV-вузлу також знадобляться тільки 80-байтні заголовки наступних блоків [61]. Схема, що описує функціонування SPV-вузла представлена ​​на рис. 4.39.

![Рисунок 4.39 – Модель функціонування SPV-вузла](/resources/img/volume-1/4.4-approaches-to-network-synchronization-and-spv-nodes/4.39-spv-node.png)

Щоб SPV-вузол вважав транзакцію підтвердженою, повинні виконуватися дві умови:
* Транзакція повинна бути додана до блоку.
* Блок із транзакцією повинен перебувати в основному ланцюжку блоків.

Для встановлення першого факту знадобиться значення *Merkle root*, що міститься в заголовку блоку. Розраховується значення Merkle root наступним чином (рис. 4.40). Перш за все обчислюються геш-значення від кожної транзакції, після вони попарно конкатенуються, а результат знову піддається гешуванню. Тепер вийшло менше геш-значень, вони знову попарно конкатенуються і подаються на вхід геш-функції. Так відбувається до тих пір, поки не залишиться одне геш-значення – Merkle root. Якщо уявити це схематично, то за кілька раундів, проміжні хеш-значення складаються в деревоподібну структуру (дерево Меркла), яка і містить у своїй вершині значення Merkle root.

![Рисунок 4.40 – Зв’язок Merkle Root із кожною транзакцією в блоці](/resources/img/volume-1/4.4-approaches-to-network-synchronization-and-spv-nodes/4.40-merkle-root.png)

Перевага тут у тому, що для перевірки входження транзакції в блок, нам не потрібен увесь блок. Досить значень, які знадобляться для попарного гешування і дозволять дістатися до кореня дерева Меркла.

Маючи значення Merkle root SPV-вузол може запросити у повного вузла тільки необхідні для верифікації деякої транзакції в блоці геш-значення (*Merkle branch*). За допомогою отриманих значень користувач може самостійно обчислити значення Merkle root і порівняти його з тим, що зберігається у заголовці блоку. Якщо отримане значення збігається з наявним, то транзакція з досить великою долею ймовірності включена до цього блоку.

Другий факт, в якому користувач повинен бути впевнений, це дійсна наявність блоку в основному ланцюжку. Переконатися в цьому досить просто. У користувача SPV-вузла є всі значення заголовків блоків основного ланцюжка. Кожен заголовок блоку містить посилання на попередній блок у вигляді його хеш-значення, тому користувач може перевірити, чи посилаються наступні блоки на той, який перевіряють.

Якщо коротко, то описати функціонування SPV-вузла можна наступним чином. SPV-вузол не верифікує блоки цілком. Верифікуються тільки їх заголовки. Для перевірки коректності транзакції вузол повинен запросити деякі значення у повних вузлів, які дозволять йому переконається у тому, що транзакція дійсно знаходиться у блоці. Відзначимо, що вузол перевіряє належність кожного блоку до основного ланцюжка (mainchain) і тільки після цього може перевіряти приналежність окремих транзакцій цьому блоку.

### Підсумки

Розглянувши три основні підходи до синхронізації гаманців з мережею, можна оцінити переваги та недоліки кожного. Найбільш надійним для роботи з Bitcoin є повний вузол, проте це й найбільш вимогливий до ресурсів підхід. Взаємодія з мережею через довірений не потребує наявності великого дискового простору для зберігання даних, але прийнятна тільки тоді, коли користувач готовий довірити приватність своїх транзакцій володільцю цього вузла. Для користувачів, яким не підходить ні перший, ні другий спосіб, є метод SPV. У цьому випадку користувач може самостійно перевірити поточний статус підтвердження потрібних транзакцій, не завантажуючи при цьому вміст всього ланцюжка блоків. Така перевірка теж вимагає довіри, але в цьому разі йдеться про довіру більшості учасників мережі. Відзначимо, що довіра більшості необхідна й за використання повного вузла, але володілець SPV-вузла не може верифікувати дані транзакцій та блоків, він може перевірити тільки наявність конкретного блоку в основному ланцюжку блоків.

Теоретично можна припустити, що якщо більшість учасників домовляться між собою, то вони зможуть транслювати користувачам SPV-гаманців підроблену історію транзакцій. Тому дуже важливо розуміти важливість безпечної синхронізації при роботі з цифровим гаманцем.

**Часті запитання**

*– Чи можна той самий гаманець запустити одночасно на трьох різних комп'ютерах і почати синхронізацію?*

Швидше за все, мова йде про якийсь вузол мережі: або SPV-вузол, або повний вузол. Було використано кілька різних комп'ютерів та один і той же гаманець. А під гаманцем маються на увазі особисті ключі. Є кілька повних вузлів, що реалізують функціональність гаманців. На цих вузлах ми вставляємо одні і ті ж особисті ключі і починаємо синхронізацію. Швидше за все, при повній синхронізації з мережею на кожному гаманці, який використовує свій вузол, буде відображений один і той же баланс. Якщо ж користувач побачить зміни на одному вузлі, то після синхронізації з мережею він побачить точно такі ж зміни на всіх інших вузлах. Транзакція не залишається в секреті – вона поширюється по всіх вузлах, які її верифікують і відображають відповідні зміни, якщо це стосується їхніх адрес. Так, можна використовувати одні ключі на декількох вузлах, але всі транзакції теж будуть синхронізуватися автоматично. Біткоіни точно від цього не подвояться і, більш того, не потрояться.

*– Де можна знайти повні вузли, яким можна довіряти?*

Досить складно відповісти, яким вузлам можна довіряти. Це питання особистих уподобань. Є сервіси, що надають відкритий доступ до свого вузла, але їм рідко довіряють, особливо, якщо мова йде про великі суми. Потрібно бути дуже обережним у виборі довіреного вузла, оскільки він є посередником між користувачем і децентралізованою обліковою системою. У цьому разі немає універсального сервісу, якому можна довіряти. Це, імовірніше, питання соціальної довіри. Якщо вузол мережі належить другу користувача, то слід мати на цвазі довіру цьому другу. Найнадійнішим варіантом вважається використання власного повного вузла в ролі довіреного для інших своїх пристроїв (наприклад для мобільного гаманця).

*– Які гарантії надає команда розробників гаманця та яка її відповідальність?*

Це питання має більше юридичний характер, ніж технічний. Будь-яке ПЗ, що розповсюджується офіційно, має *умови використання* (*terms of use*), де прописано, що користувач може пред'явити розробникам в разі виникнення певних проблем в їх програмному забезпеченні. Умови використання різні в різних застосунках. Як і завжди, користувач з’ясовує, чи довіряє він розробникам чи ні, перш ніж почати використовувати їх продукт.

*– Скільки може бути довірених вузлів?*

Ви можете вибрати будь-яку кількість довірених вузлів, щоб мінімізувати ризик втрати доступу до мережі. Наприклад, три вузла. Якщо виникнуть проблеми з доступом до першого, то ви підключаєтеся до другого і продовжуєте з ним працювати точно за таким же принципом.

*– Що станеться з монетами, якщо сервера, на яких вони зберігаються, будуть повністю або частково знищені землетрусом?*

Тут потрібно сказати не про монети, а про зберігання ключів, які використовуються для доступу до цих монет. Якщо буде знищений сервер, який забезпечував доступ до мережі Bitcoin, то це ніяк не вплине на функціонування цифрового гаманця. Користувач тимчасово втратить доступ до розподіленої бази даних, але у нього залишаються ключі, які дозволяють йому витратити монети. Якщо ж знищений сервер, на якому зберігалися ключі користувача, при цьому у нього немає резервної копії цих ключів, то він не зможе отримати доступ до своїх монет.

*– Чи залишиться доступ до монет якщо встановити програмний гаманець, відправити на нього монети, записати мнемонічну фразу на папері та видалити застосунок?*

Фактично, так. Надійно зберегти мнемонічну фразу – це достатній мінімум. У спільній базі даних зберігаються дані про те, скільки монет було відправлено на відповідні адреси. Грубо кажучи, щоб довести володіння монетами і відправити їх на іншу адресу досить знати особисті ключі, в даному випадку мати папір з мнемонічною фразою.

*– Чи можна локально поставити деяку надбудову над децентралізованою обліковою системою, щоб мати можливість детально аналізувати актуальні дані у режимі реального часу?*

Так, можна. Будь-хто охочий може використовувати будь-яке доступне йому ПЗ, яке буде виконувати такий аналіз. Це може бути ПЗ, яке написав сам користувач, а може бути готове рішення. Все залежить від цілей конкретного користувача. Якщо йому потрібно оптимізувати запити з пошуку певних транзакцій, пов'язаних з певними адресами, як це робить оглядач блоків, користувач може застосувати програмне забезпечення, яке буде індексувати всі блоки і кешувати певні дані. Прикладом такого програмного забезпечення є BitCore (підтримується компанією BitPay). BitCore має відкритий вихідний код, і його можна досить просто використовувати разом з повним вузлом мережі.

## 4.5 Механізм мультипідпису та Bitcoin Script

Розуми дослідників давно бентежила ідея *грошей, що програмуються*, тобто можливості задавати умови для виконання транзакцій (однією з перших стала публікація Nick Szabo з ідеєю смарт-контрактів [62]). Але доволі швидко після появи Біткоіна стало зрозуміло, що ризик компрометації ключів набагато вищий, ніж може здатися на перший погляд. Потрібно було вирішити проблему з ключами, перш ніж надалі працювати над реалізацією нових можливостей. І це рішення було знайдено, причому воно виявилося дуже елегантним.

Як явище *мультипідпис* (*multisignature*) був наявний сторіччями. Для паперових документів було природним, що на контракті потрібно поставити кілька підписів, щоб він став юридично значущим. Однак для традиційного уявлення про підписи електронних транзакцій це виявилося чимось новим (варіант колективного підпису в банківських системах не враховуємо, оскільки він реалізований не криптографічним способом). Серед криптографів був популярний метод Шаміра [116], коли ключ математично розділяється на частини, деяку підмножину з яких може відновити первісний ключ. Метод вимагав наявності довіреної сторони для початкової генерації і розподілу долей, і був непридатний для анонімного середовища. А у Bitcoin був запропонований максимально простий метод, суть якого полягала у тому, що транзакція мала бути завірена кількома підписами. До того ж цей підхід допомагає вирішувати проблему надійного зберігання монет і робити можливим спільне управління балансом гаманця. Ідея мультипідпису згодом набула широкого застосування у смарт-контрактах.

Розглянемо механізм мультипідпису, реалізований в протоколі Bitcoin. Зверніть увагу, що в інших цифрових валютах ці механізми можуть бути реалізовані інакше, оскільки багато що залежить від моделі транзакцій.

Multisignature-адреса (скор. MultiSig-адреса) – це така bitcoin-адреса, до якої прив'язані відразу декілька пар ключів. Кожна пара складається з особистого та відкритого ключів. Комбінації, в яких можна використовувати ці ключі, можуть бути різними. Більш того, можна визначити умови, за яких потрібно буде надати кілька підписів, щоб витратити монети з адреси.

### Bitcoin-транзакція з використанням мультипідпису

Нагадаємо, що звичайна bitcoin-адреса формується шляхом подвійного гешування відкритого ключа (див. 3.2). В загальному уявленні MultiSig-адреса формується таким самим чином, тільки вже кілька відкритих ключів конкатенуються перед гешем. Детально це буде розглянуто нижче. На рис. 4.41 зображена транзакція, яка витрачає монети з MultiSig-адреси.

![Рисунок 4.41 – Схема MultiSig-транзакції](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.41-multisig-tx-structure.png)

Угорі (рис. 4.41) позначена область заголовка, який містить два поля. Зліва зображені два входи, а праворуч – два виходи. У першому вході знаходяться заповнені поля: записане геш-значення попередньої транзакції, яка витрачає дані монети, номер виходу тощо. Поле *scriptSig* містить відкритий ключ і підпис, що характерно для звичайної транзакції.

Звернімо увагу на другий вхід транзакції. У полі *scriptSig* знаходиться інша комбінація даних: два відкритих ключа і два підписи. Вони повинні перевірятися цими відкритими ключами у відповідному порядку. Це і є той вхід транзакції, що витрачає монети з MultiSig-адреси. Саме так буде виглядати доказ володіння монетами.

На рисунку нижче (рис. 4.42) ви можете побачити приклад справжньої MultiSig-транзакції. Розглянемо поле *script*. Воно містить значення підпису і відкриті ключі власників MultiSig-адреси, на яку були відправлені монети. Якщо порівняти с полем *script* стандартної транзакції  в Bitcoin, то поле script в MultiSig-транзакції містить в собі більше даних і, відповідно, потребує більше місця, тому що може містити від 2 до 15 підписів і відповідних відкритих ключів.

![Рисунок 4.42 – Приклад MultiSig-транзакції](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.42-real-multisig-tx.png)

Оскільки можливі різні комбінації ключів при використанні MultiSig-адрес, залежно від обставин найдоречнішою може виявитися будь-яка з них. Варто зазначити, що максимальною щодо кількості необхідних підписів і відкритих ключів буде схема 15-з-15. Однак є часто використовувані варіанти, які треба розглянути в першу чергу: 2-з-2, 2-з-3 і 3-з-3. 

### Варіант мультипідпису 2-з-2

Комбінація 2-з-2 є найпростішою і має на увазі, що є певна MultiSig-адреса, до якої прив'язані дві пари ключів. По суті, отримано геш-значення від конкатенації двох відкритих ключів як відповідної адреси. Щоб витратити монети з цієї адреси, потрібно надати два підписи, які будуть верифікуватися двома наявними відкритими ключами, конкатенація і гешування яких в належному порядку мають давати таке ж значення адреси. Узагальнюючи описане вище, є два заздалегідь встановлених ключа, а також потрібні обов'язково два підписи, які будуть перевірятися цими ключами відповідно.

Уявіть, що чоловік і дружина (рис. 4.43) вирішили вести загальний бюджет. Вони домовляються, що тільки за згодою кожного з них кошти з бюджету будуть витрачатися на певні потреби. За допомогою Bitcoin це можна реалізувати досить просто. Вони створюють MultiSig-адресу за такую схемою, де один ключ контролює дружина, а другий – чоловік. Тоді всі платежі родина отримуватиме на цю адресу, а витрачатися монети зможуть лише за взаємною домовленістю.

![Рисунок 4.43 – Чоловік та дружина вирішили створити MultiSig-адресу](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.43-h-and-w.png)

Передбачаючи питання про сценарії, за яким чоловік і дружина не домовляться, уявімо, що дружина вважає необхідною купівлю пральної машини, тому що вона втомилася прати руками, а чоловік вважає, що це не така й важка робота, а буде доцільніше витратити всі монети на останню модель PlayStation і проводити таким чином дозвілля. Дружина ображається на чоловіка і знищує паперовий носій, на якому був записаний її особистий ключ, унеможливлюючи витрату з цієї адреси взагалі. Як уникнути такої ситуації і захистити себе від остаточної втрати монет?

Є спосіб створити транзакцію, яка може витрачати всі монети з потрібної адреси, незважаючи на те, що сума заздалегідь невідома. Він полягає в тому, що підпис для транзакції створюється завчасно, а відсутні дані можуть бути підставлені пізніше. Інакше кажучи, якщо дані, які повинні вказані на вході, невідомі, їх можна буде вписати у вже підписану транзакцію. Можна навіть створити транзакцію, яка витратить монети з ще не існуючої транзакції, підписати її всіма необхідними підписами, і відкласти. Коли настане час, наприклад з'явиться необхідна транзакція (яка була визначена завчасно), потрібно буде підставити необхідні дані і відправити в Bitcoin-мережу для підтвердження.

У такій транзакції можна задати поле *locktime* (детально було в 4.3), що дозволить відкласти її підтвердження на певний час. Отже, чоловік і дружина відразу після створення MultiSig-адреси, ще до отримання будь-яких платежів, можуть створити дві locktime-транзакції, в яких всі майбутні монети будуть перенаправлені на звичайні адреси чоловіка і дружини. Відповідні два ключа вони зберігають і обробляють в секреті один від одного. При цьому транзакції будуть відстроченими і можуть бути підтверджені тільки, наприклад, через два місяці. Ці транзакції можуть бути роздруковані на папері та зберігатися в сейфі у кожного окремо.

Якщо виникне ситуація, коли монети знаходяться на балансі MultiSig-адреси, а ключі втрачені (один або обидва), то монети стають замороженими. Але є locktime-транзакція. Той, хто опублікує таку транзакцію, зможе відправити ці монети на діючу зовнішню адресу. Монети будуть збережені.

Наведений приклад був спрощеним, на практиці можливі й більш складні механізми.

### Варіант мультипідпису 2-з-3

Схема використання MultiSig-адреси 2-з-3 має на увазі, що будь-які два ключі з трьох заздалегідь встановлених повинні бути задіяні для перевірки двох підписів, поданих як доказ володіння монетами. Тобто, щоб витратити монети, потрібно надати два підписи, які будуть перевірені двома відкритими ключами з попередньо встановлених трьох.

Припустимо, є група людей, які мають загальний бюджет. Вони створюють MultiSig-адресу, в якій є три ключі, але для підпису транзакції достатньо двох підписів (рис. 4.44). За згодою учасників, які становлять більшість групи, ці монети можуть бути витрачені. Тобто будь-які два учасники з трьох можуть витратити монети. Їм для цього достатньо поширити транзакцію в мережу.

![Рисунок 4.44 – Варіант використання мультипідпису 2-з-3](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.44-2-of-3-multisig.png)

Більш цікавий спосіб застосування комбінації 2-з-3 можна навести на прикладі Wallet Service. Сервіс гаманця в даному контексті не варто плутати з bitcoin-гаманцем, який користувач контролює самостійно. Сервіс не надає повноцінного сховища для монет і не володіє ними, а тільки надає послуги для комфортної роботи. Якщо зобразити ситуацію схематично (рис. 4.45), то один з особистих ключів належить безпосередньо сервісу, другий генерується тільки користувачем (і лише йому відомий), третій ключ генерується і зберігається теж користувачем, але окремо і зазвичай не використовується. Після цього з особистих ключів обчислюються відкриті ключі та створюються MultiSig-адреса. Туди надходять монети і тепер умови витрачання обмежуються.

![Рисунок 4.45 – Використання мультипідпису 2-з-3 у випадку з Wallet-сервісом](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.45-2-of-3-with-involved-wallet.png)

Уявімо, що ми маємо справу з певним веб-сервісом, що дозволяє клієнту приймати і відправляти монети, використовуючи браузер. Браузер завантажує код, який реалізує тільки частину функціональності bitcoin-гаманця (отримання UTXO, формування транзакцій і завірення їх цифровим підписом). Якщо користувач хоче витратити монети, то він просто у браузері створює транзакцію і підписує її своїм (одним з необхідних) підписом.

Зауважмо, що особистий ключ користувач може отримати або зі свого пароля, або скористатися генератором випадкових послідовностей, потім зашифрувати отриманий особистий ключ своїм паролем і зберігати цей ключ в зашифрованому вигляді на боці сервісу. В останньому випадку користувач надсилає запит веб-сервісу, отримує контейнер із зашифрованим ключем, розшифровує його, використовуючи в якості ключа свій пароль або геш-значення пароля, і таким чином отримує доступ до свого особистого ключа.

Коли користувач підписує транзакцію, вона відправляється на сторону сервісу, щоб сервіс поставив другий необхідний підпис і відправив транзакцію. Сервіс уточнює факт необхідності підписання транзакції через другий канал аутентифікації, який встановлений заздалегідь. В якості цього каналу можна розглядати дзвінок на мобільний телефон, відправку SMS, повідомлення на електронну пошту та інші способи альтернативної комунікації (аж до особистого візиту, якщо того вимагає рівень безпеки). Коли сервіс переконався, що запит на підпис транзакції дійсно ініціює зареєстрований користувач, він ставить відсутній підпис за допомогою свого ключа. Після цього транзакція стає валідною і може бути поширена в мережу для підтвердження.

Третій ключ використовується у тих випадках, коли сервіс відмовляє в обслуговуванні. Програмне забезпечення генерує цей ключ і пропонує його зберегти зручним для вас способом. Користувач зазвичай зберігає його в надійному місці. Якщо сервіс відмовляє в обслуговуванні, то користувач може підписати транзакцію своїми ключами (другим і третім). Якщо ж другий ключ зберігався на стороні сервісу, то захищений контейнер з цим ключем буде заздалегідь відправлений користувачеві по альтернативному каналу зв'язку, наприклад на електронну пошту. Далі розшифровка ключа не представляє складності. Користувач отримує два необхідних особистих ключа і вводить в спеціальне програмне забезпечення, яке сервіс надав заздалегідь. Після цього програмне забезпечення працює вже автономно на комп'ютері користувача, тобто без участі сервісу. Варто зазначити, що цим програмним забезпеченням слід користуватися тільки в крайніх випадках, коли сервіс дійсно відмовляє в обслуговуванні (тобто його зламали, він пошкоджений або перестав існувати). Тоді користувач підписує транзакцію своїми ключами і відправляє монети за призначенням.

### Переваги wallet-сервісів із мультипідписом 2-з-3

На перевагах таких Wallet-сервісів зупинимося докладніше. Це надійний спосіб зберігання, тому що сервіс не володіє всім необхідним набором ключів – він володіє тільки однією частиною, якої недостатньо, щоб заволодіти балансом свого клієнта. Причому доступу до монет не має ні сам сервіс, ні хакер, який його може зламати.

Зручність такого підходу полягає у тому, що користувачеві не обов'язково мати захищений доступ до цього сервісу. У нього може бути звичайний персональний комп'ютер або смартфон. При цьому існує ризик інфікування шкідливим програмним забезпеченням і пристрій може контролюватися шахраями, а дані можуть бути скомпрометовані або замінені. Але зловмиснику недостатньо володіти тільки цим пристроєм, тому що з нього можна добути тільки один з двох підписів. Ще одна перевага полягає у тому, що навіть якщо сервіс відмовляє в обслуговуванні, користувач не втрачає доступ до своїх монет.

Вище були представлені лише деякі з можливих схем використання MultiSig-адрес, яких достатньо для знайомства. Умови витрачання описуються за допомогою Bitcoin Script, тому далі розберемося, що таке Bitcoin Script.

### Bitcoin Script

*Bitcoin Script* – це базована на стеках неповна за Тьюрингом мова описання сценарію для витрачання монет. Неповна за Тьюрингом означає, що мова має обмежену функціональність і не може здійснювати безумовні переходи по довільним адресам в програмі, цикли та рекурсії. Отже, сценарій не може виконуватися нескінченно. Такий принцип дозволяє обмежити можливості зловмисних сторін по створенню складних транзакцій і уповільнення роботи всієї системи.

Призначення скрипта – перевіряння умови, що сторона, яка хоче витратити монети, має всі необхідні докази володіння цими монетами. У кожної транзакції є поля *scriptSig* і *scriptPubKey*. Поле *scriptPubKey* містить умови витрачання монет, а поле *scriptSig* – необхідні дані для розблокування монет. Перед виконанням скрипта ці поля конкатенуються.

Виконання скрипта має на увазі під собою послідовне виконання операцій над деякими даними, що містяться у стеку. Під час виконання кожної з операцій дані дістаються зі стека, над ними виконується дія, визначена відповідним *кодом операції* (що також має назву *OP-код*), і результат виконання назад поміщається в стек. Монети вважаються розблокованими тільки у тому випадку, якщо в результаті виконання всього скрипта в стеці залишається лише значення true. Також потрібно враховувати, що максимальна місткість стека при використанні Bitcoin Script обмежена 520 байтами.

OP-коди складають свого роду команди мови програмування для bitcoin-транзакцій [64]. Кожна операція представлена набором бітів, який зчитується віртуальним процесором і виконується. Кожен OP-код можна розглядати з двох частин: префікса «OP_» і безпосередньо назви самої операції. Найбільш розповсюдженими операціями є OP_SHA256, OP_HASH160, OP_EQUALS, OP_CHECKSIG, OP_CHECKMULTISIG, OP_CHECKLOCKTIMEVERIFY [64].

### Концепція P2SH-адрес і переваги їх використання

BIP16 [65] упровадило в протоколі Bitcoin нову концепцію – так званий *pay to script hash* (P2SH). Це можливість задати умови витрачання монет не скриптом у відкритій формі, де поспіль прописуються операнди і деякі дані, які потім виконуються розглянутим вище чином, а у вигляді геш-значення від потрібного скрипта, тобто контрольної суми від цих операндів. Стало можливо в виході транзакції задавати великі і складні умови витрачання монет, але сам вихід при цьому залишався коротким.

Щоб витратити монети з такого виходу, користувачеві потрібно довести, що він знає умови витрачання, а також задовольнити цим умовам. Для цього він публікує ці умови, тобто весь скрипт, а також геш-значення від цього скрипта. Тепер будь-хто може переконатися, що умови саме такі, просто порівнявши отримане геш-значення від скрипта з тим, що було опубліковано користувачем. Далі відправнику залишається тільки задовольнити цим умовам витрачання монет, щоб всі інші могли верифікувати транзакції відповідно до правил протоколу.

Ця пропозиція щодо поліпшення Bitcoin було прийнята 3 січня 2012 року. Зараз вона активно застосовується для реалізації MultiSig-адреси.

Розглянемо на прикладі, як це працює. Щоб розібратися у процесі формування таких транзакцій потрібно мати уявлення про поняття, як-от *redeem script*, *locking script* й *unlocking script*, а також правила заповнення відповідних полів.

*Redeem Script* містить в собі відкриті ключі, до яких буде прив'язана MultiSig-адреса. В даному випадку розглядається комбінація ключів «2-з-5». Спочатку йде значення 2, тобто вказується, що необхідно буде 2 підписи, які будуть перевірятися відповідними відкритими ключами. Після цього записують п'ять відкритих ключів. Далі вказується кількість відкритих ключів, тобто значення 5 (коли дані зчитуються в зворотному порядку, це значення знадобиться, щоб зрозуміти, скільки ключів потрібно прочитати). Після цього вказується операція перевірки мультипідпису (operation check multisignature, OP_CHECKMULTISIG).

*Locking Script* – скрипт, який вказується в виході транзакції, яка платить на MultiSig-адресу. Тут буде проводитися операція отримання геш-значення, наприклад OP_SHA256 або OP_HASH160. Далі йде геш-значення redeem script, яке в даному випадку має розмір 20 байт. Після цього проводиться операція з перевірки відповідності даних фактичному геш-значенню.

*Unlocking Script* є конкатенацією скриптів на вході транзакції зі скриптами на виході транзакції, яка платила за цією адресою. Є два підписи, необхідні для витрачання монет, і повний redeem script, який пізніше буде поданий на вхід геш-функції і перевірений на предмет відповідності адресою, на яку були відправлені монети. Після цього скрипт буде виконуватися цілком, в тому числі для перевірки мультипідпису.

Важливо, що є обмеження на максимальний розмір для кожного з перерахованих скриптів – 520 байт. Це число було розраховано виходячи з того факту, що в unlocking script може поміститися максимум 15 підписів, 15 відповідних відкритих ключів, а також декілька OP-кодів для верифікації цих даних. Саме так була отримана певна кількість, яка при округленні в більшу сторону дала 520 байт. Слід сказати, що такий обсяг даних дозволяє використати щонайбільше MultiSig-адрес 15-з-15, що є доволі розумна межа на практиці. Redeem script за використання великої кількості підписів стає дуже великим за розміром. Той користувач, який використовує MultiSig-адресу або інші P2SH-адреси, при витраті монет з них має дуже великі за розміром транзакції. Це означає, що для підтвердження своїх транзакцій йому доведеться платити великі комісії.

Тепер розглянемо переваги P2SH. Перше з них полягає в тому, що такі адреси можуть бути закодовані в звичний вигляд з використанням base58, в якому їх довжина становить 34 символи. Відповідно до BIP13, яке визначає правила установки версійного байта для bitcoin-адрес [57], закодованих за допомогою base58Check, починатися адреса буде з «3», тобто туди вставляється певний версійний байт. Нижче представлений приклад, як може виглядати P2SH-адреса.

**3P14159F73E4gFr7JterCCQh9QjiTjiZrG**

Однак варто зауважити, що це може бути не обов'язково MultiSig-адреса. Redeem script може описувати і інші в тому числі більш складні умови витрачання монет. Крім того, P2SH – це не єдиний метод реалізації мультипідпису в Bitcoin.

Можна скористатися й іншим методом: зазначити у виході, який буде платити на MultiSig-адресу, не геш-значення від скрипта, а сам скрипт, тобто перелічити саме у виході всі відкриті ключі та задати операцію перевіряння мультипідпису. Однак цей спосіб має свої недоліки. За відправлення монет у такий спосіб користувач розголошує свої відкриті ключі (це знижує його рівень приватності). Іншим недоліком є ​​великий розмір транзакції, за яку відправнику доведеться сплачувати більшу комісію за відправку монет на MultiSig-адресу. Навряд чи відправник захоче переплачувати за те, що одержувач хоче використовувати складні умови витрачання монет, які займають більший обсяг даних.

P2SH дає можливість перекласти ці комісійні витрати на одержувача. Якщо одержувач хоче приймати монети на MultiSig-адресу, то він сам буде платити за підтвердження великих транзакцій, що є більш справедливим підходом. Додамо, що P2SH дозволяє реалізувати різні варіанти мультипідпису (2-з-2, 2-з-3 й інші).

### Приклад використання P2SH для MultiSig-адреси

Уявімо, що Аліса хоче заплатити Бобу, який використовує тільки MultiSig-адресу. Для цього Боб локально на своєму комп'ютері (до речі, замість Боба і Аліси можуть бути будь-які організації) генерує кілька особистих ключів, отримує з них відповідні відкриті ключі, які конкатенуються певним чином (рис. 4.46). Найчастіше відкриті ключі представлені спочатку закодованими за допомогою base58Check, потім вони сортуються в алфавітному порядку, після чого декодуются і конкатенуються, утворюючи *redeem script*.

![Рисунок 4.46 – Процес використання P2SH](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.46-using-of-p2sh.png)

Сортування необхідне, коли потрібен перерахунок відкритих ключів з особистих. Їх потрібно конкатенувати точно в такому ж порядку, тому що наступним кроком буде створення redeem script і його гешування. Якщо точно такі ж ключі потраплять до redeem script, але в іншому порядку, ми отримаємо інше геш-значення та іншу адресу. Це спричинить певні непорозуміння. Тому перед конкатенацією відкриті ключі потрібно впорядкувати згідно деякому правилу. Найчастіше використовують сортування за алфавітом base58.

Отже, Боб порахував хеш-значення від redeem script. Він може його представити у вигляді 20 байт і відправити Алісі, сказавши, що це MultiSig-адреса з використанням P2SH. Боб також може закодувати його з версійним байтом, як звичайну адресу, і просто відправити Алісі. Аліса зрозуміє по версійному байту, що це MultiSig-адреса, складе транзакцію і відповідним чином заповнить її вихід, щоб Боб отримав свої монети. Далі вона поширює транзакцію в мережу. Вони чекають підтвердження і Боб приймає платіж від Аліси. Натомість Боб, наприклад, надає послугу або передає товар.

Настає момент, коли Боб хоче витратити ці монети. Слід розуміти, що повний redeem script не був опублікований, поки монети перебували на його MultiSig-адресі. І навіть Аліса не бачила, які саме відкриті ключі використовував Боб, скільки їх там було тощо. Вона взагалі не знає, за якими правилами ця P2SH-адреса складена, чи MultiSig-адреса це чи ні тощо. Відповідно, атаки на цифровий підпис (на еліптичну криву) ще неможливі.

Припустимо, Боб хоче відправити платіж Єві (рис. 4.47). Тоді вона генерує нову адресу і дає її Бобу. Він створює заготовку транзакції, у вході якої він вказує ту транзакцію, в якій він отримав монети від Аліси, а на виході – адресу Єви. Тепер він повинен надати докази володіння монетами, які він витрачає. Для цього він бере два своїх особистих ключа (припустимо, його MultiSig-адреса передбачає варіант 2-з-5), з яких обчислює два підписи до даної транзакції. Далі, він додає повний *redeem script* у вхід транзакції.

![Рисунок 4.47 – Процес доведення Бобом власництва монет](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.47-bob-proves-the-ownership.png)

Зверніть увагу, що цей redeem script повинен зберігатися в Боба на комп'ютері цілком або він повинен запам'ятати порядок, в якому він використовував відкриті ключі для складання цього скрипта. Якщо ж він застосовував певні правила сортування, то він повинен запам'ятати їх. Він також повинен пам'ятати, що до певних особистих ключів прив'язана MultiSig-адреса. Без цих знань Боб не знав би, якими з його особистих ключів оперувати і в якому порядку їх слід подавати на вхід геш-функції, щоб отримати потрібну адресу.

Отже, у нього є два підписи та повний redeem script. Транзакція вважається правильною; Боб поширює її в мережі та чекає на її підтвердження. Це основне з того, що стосується витрачання з MultiSig-адреси.

## 4.6 Особливості оновлення Segregated Witness

Оновлення Segregated Witness стало, напевно, найбажанішим і водночас важко досяжним у десятирічній історії протоколу Bitcoin. Воно викликало перший розкол спільноти і показало всьому світу нетривіальність здійснення *governance* в децентралізованому анонімному середовищі, де учасники мають суперечливі інтереси. Коли учасники спільноти зіткнулися з обмеженою пропускною здатністю Bitcoin на рівні трьох-чотирьох транзакцій на секунду, вони стали шукати рішення. Розійшлися думки і з приводу того, хто несе фінальну відповідальність за прийняття нових правил: розробники, валідатори чи користувачі. Справедливо зазначити, що багато проектів після Bitcoin (особливо Dash, Cardano, EOS) включили механізми *governance* спочатку до p2p протоколу. Але, на щастя чи на жаль, під час проектування Bitcoin Сатоші не передбачив механізмів вирішення таких суперечок.

> **Проблеми оригінальної архітектури Bitcoin**
>> * *Низька пропускна здатність облікової системи*
>> * *Transaction malleability (змінюваність непідтверджених транзакцій)*
>> * *Об'єднання бізнес-логіки і доказів володіння монетами*
>> * *Обмеження для впровадження off-chain протоколів*

Segregated Witness привніс великі зміни до протоколу й істотно поліпшив формат транзакцій. У цьому підрозділі розглядаються його вплив на пропускну здатність облікової системи, нові формати адрес і транзакцій, можливість відокремити дані з доказами, нові формати вхідних і вихідних скриптів.

Розгляньмо, чим серіалізована транзакція з застосуванням Segregated Witness (segwit-транзакція) відрізняється від звичайної bitcoin-транзакції в серіалізованій формі, що зображена на рисунку 4.48.  

![Рисунок 4.48 – Приклад звичайної транзакції в серіалізованій формі](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.48-serialized-tx.png)

На рисунку 4.49 зображена Segregated Witness транзакція. Різниця між цими транзакціями полягає *в даних доказу володіння монетами (witness data)*, які виділені на рисунку і можуть бути відокремлені від інших даних транзакції (на відміну від стандартної транзакції). Вузли, які оновили своє програмне забезпечення, отримують в цьому випадку всі дані (включаючи дані доказу володіння монетами), в той час, як не оновлені вузли отримують тільки транзакцію без witness data й вважають її коректною за замовчуванням (вважається, що кожен може витратити цю транзакцію). Пізніше ми розглянемо, чому відбувається саме так.

![Рисунок 4.49 – Приклад SegWit-транзакції в серіалізованому вигляді](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.49-serialized-sewit-tx.png)

Дослівно Segregated Witness перекладається з англійської як відокремлений свідок. За суттю, головна ідея оновлення така: *дані доказу володіння монетами зберігаються окремо від основних даних транзакції* (рис. 4.50).

![Рисунок 4.50 – Відокремлення доказів володіння монетами від інших даних транзакції](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.50-segregation-of-coin-ownership.png)

До того ж, оновлення включає багато інших покращень. SegWit дозволяє збільшити пропускну здатність мережі, відокремити дані доказів володіння монетами від інших даних транзакції, виправити недоліки формату транзакцій, пов’язані з можливістю модифікування даних у підписаних транзакціях (*transaction malleability*), і водночас зберегти зворотню сумісність із попередніми версіями протоколу. Найбільша цінність даного оновлення полягає в тому, що воно дозволяє реалізувати багато дуже важливих off-chain рішень понад протоколом Bitcoin (докладніше в 4.8).

### Збільшення пропускної здатності та зворотня сумісність

Оскільки розмір блоку обмежений, то обмежена і кількість транзакцій, що можна вмістити у нього, а від цього залежить пропускна здатність системи. Звісно, коли постало питання про підвищення пропускної здатності, насамперед відповідь почали шукати в способах збільшення максимального розміру блоку. Але ця ідея не отримала підтримки більшості учасників мережі.

Будь-яка пропозиція ретельно перевіряє та тестує команда розробників протоколу Bitcoin. Якщо згода спільноти досягнута і вирішено впровадити пропозицію до протоколу, виходить відповідне оновлення. Розгляньмо два основних способи вирішення проблеми збільшення пропускної здатності облікової системи. 

*Hardfork*. Найпростіший підхід до оновлення полягає у збільшенні розміру блоку. Передбачається, що один блок буде вміщати до себе більше транзакцій, підвищуючи пропускну здатність. Однак такий блок не братимуть вузли, що працюють за старим протоколом, в правилах якого записано, що максимальний розмір блоку не може перевищувати 1 МБ. Така зміна вимагає hardfork, який організаційно складніший, ніж softfork.

Оновлення *softfork*. Segregated Witness дозволяє нам вирішити цю проблему за допомогою softfork. Як саме? Він дозволяє нам розділити блок на дві частини, в першій з яких зберігаються транзакції, а в другій – докази. При цьому нові вузли мережі отримують обидві частини, а старі – тільки блок транзакцій із розміром 1 МБ. Старі вузли не можуть отримувати блоки з доказами і, відповідно, не можуть затверджувати транзакції, які отримують, але це дозволяє їм брати участь в досягненні консенсусу і не вдаватися до hardfork, а поступово переходити до нового програмного забезпечення.

Згідно зі старими правилами блок містить транзакції з убудованими доказами і його макимальний розмір обмежено 1 МБ. Водночас нові правила передбачають, що максимальний базовий розмір блоку – 1 МБ, але додатково є структура даних із доказами. Відповідно, загальний розмір нового блоку перевищує 1 МБ.

З метою забезпечення сумісності, правила роботи протоколу дозволяють працювати старим вузлам з новими блоками, але вони будуть отримувати блок тільки в базовій комплектації з максимальним розміром 1 МБ. Їм недоступна структура *witness*. Нові ж вузли отримують повноцінний блок з транзакціями і доказами. Ознайомитися з цим питанням допоможе рис. 4.51.

![Рисунок 4.51 – Результат оновлення протоколу](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.51-result-of-segwit-update.png)

Зліва представлена схема роботи протоколу Bitcoin до активації Segregated Witness. Блок мав максимальний розмір 1 МБ, і він поширювався між різними вузлами мережі в одному вигляді.

### Нововведення Segregated Witness

Першим і найважливішим нововведенням Segregated Witness стала нова структура транзакцій. Крім вже відомих полів, в новій транзакції присутні три нових: *marker* та *flag*, що застосовуються для встановлення версій (в даному випадку вони строго задані, але в наступних протоколах вони можуть змінюватися), а також поле *witness*. *Witness data – це набір доказів володіння монетами, які винесено за межі основної частини транзакції*. Структурно він виглядає, як набір входів, при цьому кожен елемент *witness data* відповідає входу з певним номером, що дозволяє зіставити докази з конкретними витраченими монетами.

Кожна транзакція має свій унікальний ідентифікатор, *txid*, за яким можна її знайти. Щоб отримати ідентифікатор транзакції, потрібно звести саму транзакцію до однієї послідовності даних, а потім отримати геш-значення від цієї послідовності. З введенням Segregated Witness з'явився і новий ідентифікатор (*wtxid*), і новий формат серіалізації. Для старих транзакцій, які витрачають монети, не використовуючи Segregated Witness, *wtxid* такий самий, як *txid*. На рис. 4.52 зазначено, які з полей транзакції беруть участь у формуванні *wtxid* (відповідно, для стандартної та SegWit-транзакції).

![Рисунок 4.52 – Різниця між ідентифікаторами транзакцій](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.52-diff-between-txs.png)

*Wtxid* потрібен, щоб побудувати альтернативне дерево Меркла для доказів. Будується воно так само, як і для звичайних транзакцій, тільки замість геш-значення транзакції тут застосовується *wtxid*. Відповідно, *wtxid* попарно гешуються і дають в результаті значення Merkle root.

Відзначмо, що Merkle root вставляється до coinbase-транзакції, а не до заголовку блоку. Якби він був у заголовці блоку, то змінилася би структура блоку. Вузли, які підтримують старий протокол, не могли б працювати з такими блоками, і це перешкоджало би збереженню зворотньої сумісності. Тому Merkle root вставляється в один з виходів coinbase-транзакції. Коли всі вузли перейдуть на Segregated Witness, ця ситуація може змінитися та будуть розглядатися нові підходи.

Розглянемо докладніше проблему *змінюваності транзакцій (transaction malleability)*. У Bitcoin є можливість змінити певні дані транзакції, залишаючи при цьому саму транзакцію коректною: монети будуть надходити з тієї ж адреси і приходити на колишню [67]. Ці зміни можуть бути незначними, але їх буде достатньо, щоб спричинити зміну результату гешування. Фактично, це буде вже зовсім інша транзакція, хоча робить вона те саме, що й оригінальна. Провернути таке можна тільки з непідтвердженими транзакціями, проте навіть для непідтверджених транзакцій незмінюваність даних дуже важлива, тому що невизначена ймовірність такої зміни заважає реалізуванню off-chain протоколів, які побудовані на можливості створення ланцюжків із непідтверджених транзакцій.

Як це працює? При складанні bitcoin-транзакції, підписуються не всі дані. Щонайменше не можна підписати scriptSig, оскільки це і є поле, в яке будуть записані дані цифрового підпису, який користувач буде формувати. Така вразливість дозволяє провести кілька видів атак. Розглянемо основні.

Перша з них – це зміна формату підпису. Так склалося, що в протоколі Bitcoin формат підпису, який поміщається в scriptSig, затверджений нестрого і залежить від реалізації OpenSSL, який також не передбачає суворого формату. Третя сторона може перехопити транзакцію і незначно змінити її, при цьому залишивши її валідною. Геш-значення транзакції зміниться, і це буде зовсім інша транзакція.

Друга атака полягає у впливі безпосередньо на scriptSig. Оскільки scriptSig – це набір команд, який дозволяє користувачеві довести володіння монетами, можна вказати в ньому велику кількість додаткових операцій. Існує можливість додати до початкових даних в scriptSig декілька нічого не значущих операцій, які ніяк не вплинуть на результат виконання цього скрипта, але змінять результат гешування транзакції.

Що ж поганого у зміні геш-значення транзакції? Питання справедливе, бо до непідтверджених транзакцій немає довіри, тобто доки транзакція не підтвердиться, спиратися на дані, які в ній містяться не слід. Однак проблема змінності транзакцій важливіша, ніж здається на перший погляд. По-перше, тому що існує можливість створити точно таку транзакцію, як оригінальна, але насправді вона буде сприйматися вузлами мережі як інша (нова), тому що буде мати інше геш-значення. Відповідно, оригінальна буде конкурувати з альтернативною, в результаті неможливо сподіватися на підтвердження транзакції зі збереженням її оригінального геш-значення. По-друге, проблема змінності транзакції важлива для реалізації самих протоколів, тому що ці протоколи якраз і побудовані на тому, що ми формуємо ланцюг з непідтверджених транзакцій. Якщо змінюється геш-значення хоча б однієї транзакції з цього ланцюга, то весь наступний ланцюг транзакцій стане не валідним. Таким чином, змінити геш-значення транзакції можливо, не маючи доступ до особистих ключів.

Оновлення SegWit вирішує проблеми, пов’язані з *transaction malleability*, саме для транзакцій нового формату, де були визначені жорсткі правила заповнення полей. Це дозволило задавати дані і серіалізовувати їх однозначно, відкидаючи різночитання.

### Приклад segwit-транзакції

Розглянемо приклад підтвердженої segwit-транзакції у форматі JSON (рис. 4.53), щоб побачити вміст її полів.

![Рисунок 4.53 – Приклад segwit-транзакції](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.53-real-segwit-tx.png)

Для початку звернемо увагу на те, що поля scriptSig порожні. Відповідні докази володіння монетами у цьому випадку знаходяться у додаткових полях: witness. І як у звичайних bitcoin-транзакціях ці поля складаються з даних цифрового підпису та даних відкритого ключа. Різниця лише в тому, що поле scriptSig входить до базової структури транзакції, а поле witness не входить. Це дозволяє не передавати ці дані мережею, не перевіряти і не зберігати в пам'яті, коли вони не потрібні, бо докази володіння монетами вже були перевірені.

Фактично *witness data* це окрема частина транзакції, яка в деяких випадках може не використовуватися або навіть зовсім бути відсутньою не змінюючи при цьому базову структуру транзакції та її геш-значення. Але при виведенні транзакції на екран або представленні у форматі JSON *witness data* зручно показувати у входах цієї транзакції.

### Нові поняття вага та розмір

Ще одна нова річ оновлення Segregated Witness, – упровадження понять, як-от *вага транзакції та вага блоку*. До Segregated Witness зазвичай говорили тільки про *розмір транзакції та розмір блоку*. Усе, що з цим було пов’язано (наприклад комісія за транзакцію), визначалося згідно з розміром. Водночас розмір блоку було обмежено 1 МБ. З впровадженням Segregated Witness з'явилася потреба обробляти транзакції старого типу разом із транзакціями нового типу. 

Крім того, потрібно було зменшити вартість оброблення додаткової частини блоку (witness data). Для вирішення цієї проблеми було запроваджено поняття ваги транзакції та відповідних *вагових одиниць* (*weight units*). Розмір основної частини транзакції тепер розраховується з коефіцієнтом 3, а розмір witness data – з коефіцієнтом 1. Як можна здогадатися, будь-які дані, які були включені до witness data вимагали в 3 рази меншої комісії, ніж основні дані транзакції. Такий підхід дозволяє валідаторам визначити більш вигідну транзакцію щодо місця, що займається в блоці, і винагороди, що отримується. Вага транзакції розраховується за формулою нижче.

**transaction weight = base size * 3 + total size**

* Transaction weight – вага транзакції (вимірюється у вагових одиницях);
* base size – базовий розмір транзакції (вимірюється в байтах);
* total size – підсумковий розмір транзакції (вимірюється в байтах).

Незалежно від того, чи за новими або за старими правилами серіалізована транзакція старого зразку, розмір вона завжди буде мати однаковий. Відповідно, вага транзакції збільшиться рівно в 4 рази. А для SegWit-транзакції вага буде трохи меншою, тому що вона не міститиме дані доказів володіння монетами.

Разом із вагою було запроваджено поняття *віртуальний розмір* (*virtual size*), що обчислюється через ділення ваги на 4. Віртуальний розмір використовується, щоб розрахувати комісії для транзакцій і щоб валідатори могли зрозуміти, наскільки їм вигідно включати певну транзакцію до блоку, використовуючи звичну ціну запису, яка вимірюється в одиницях spb (satoshi per byte, сатоші на байт).

**virtual size = weight units / 4**

Оскільки вага транзакції старого зразка буде вчетверо більшою, ніж розмір, то віртуальний розмір транзакції буде дорівнювати звичайному розміру. Відповідно, для старих транзакцій підрахунок комісії не зміниться. Для нових транзакцій він буде трохи менше за рахунок того, що ми виносимо підпис в окрему структуру. Таким чином, за них можна платити менші комісії, але мати той же пріоритет у валідаторів при включенні в блок. При цьому, максимальний розмір блоку без witness data (base size) залишився 1 МБ, а максимальна вага блоку дорівнює 4 МБ.

Яким буде підсумковий розмір блоку разом із witness data? Абсолютно точно сказати неможливо. Очевидно, що це значення перебуватиме в межах від 1 МБ до 4 МБ (умовних вагових одиниць, які відповідають 1 МБ фактичного розміру). Але можна зробити точнішу теоретичну оцінку. Вийде приблизно 1,8 МБ. Звідки це значення? Типовий блок з транзакціями на поточний момент складається приблизно на 60% з даних доказів володіння монетами. Розрахуймо вагу блоку з розміром 1 МБ, що складається на 60% з даних доказів володіння монетами.

**400,000 bytes * 4 = 1,600,000 умовних вагових одиниць**

**600,000 bytes * 1 = 600,000 умовних вагових одиниць**

**1,600,000 + 600,000 = 2,200,000 умовних вагових одиниць** (Ця величина відповідає 1 МВ фактичного розміру.)

Тепер, з огляду на максимальну вагу блоку в 4 000 000 умовних одиниць (визначеного за правилами протоколу), можна визначити, наскільки це дозволить збільшити підсумковий розмір блоку разом із witness data.

**4,000,000 / 2,200,000 = 1.8** (Отже, розмір блоку складатиме 1,8 МБ.)

Тобто можна припускати, що максимально ефективний розмір блоку складатиме приблизно 1,8 МБ (не плутати реальний розмір блоку з його вагою). Але очевидно, що на практиці це значення повністю залежатиме від складу транзакцій у цьому блоці.

### Статистика адаптування оновлення

Станом на листопад 2018 року кількість SegWit-транзакцій подолало позначку 40% від загальної кількості у Біткоіні. Більш того, якщо врахувати загальну кількість переказаних біткоінів, то приблизно 55–60% із них було переказано за допомогою SegWit-транзакцій. Водночас основні сервіси для роботи з Bitcoin і цифрові гаманці, як-от Electrum та Bitxfy, реалізували підтримку Segregated Witness незадовго до початку 2018 року. 

У динаміці підсумкового розміру блоку після активації оновлення також можна помітити істотні зміни (рис. 4.54). У моменти збільшення потоку нових транзакцій майже всі блоки виходять значно більшими за 1 МБ, а іноді навіть більшими за 2 МБ. Цілком очевидно, що після активації SegWit питання про потребу термінового вирішення проблеми низької пропускної здатності вже не здавалося таким гострим [68].

![Рисунок 4.54 – Зміна розміру блоку після активації SegWit](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.54-block-changing-after-adoption.png)

Якщо подивитися на залежність середньої комісії за транзакцію від кількості транзакцій нового формату, то теж можна помітити дуже сильну кореляцію в змінах цих величин (рис.  4.55).

![Рисунок 4.55 – Залежність середньої комісії за транзакцію від кількості транзакцій](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.55-average-tx-fee.png)

Також не слід забувати, що оновлення Segregated Witness уможливило розвиток off-chain рішень понад протоколом Bitcoin. Одне з таких рішень – протокол Lightning Network. Заздалегідь відзначимо, що адаптування Lightning Network набагато складніше, ніж реалізування SegWit. Утім, робота в цьому напрямі йде на повний хід і вже є значні здобутки (див. 4.8).

**Часті питання**

*– Чи правильно стверджувати, що для SegWit-транзакцій не буде працювати RBF (replace-by-fee)*

Ні, replace-by-fee працюватиме для SegWit-транзакцій, тому що він базований не на тому, які у вас правила витрачання, а на тому, що ви використовуєте ті самі монети та вказуєте sequence входу транзакції. Якщо ви збільшуєте значення на вході, використовуючи ті ж монети, і вказуєте коректні докази того, що ви володієте цими монетами, то ви точно так само можете замінити попередню транзакцію.

*– Як можна змінити геш від непідтвердженої транзакції?*

Геш від транзакції – це результат обчислення геш-функції від всіх даних, які зберігаються в транзакції. ScriptSig, який міститься в транзакції, бере участь в розрахунку гешу, але не може бути підписаний. Незначні зміни в цьому полі, що не спричинять зміни правил перевіряння підпису, спричинять зміну геш-значення транзакції. Це означає, що підпис і транзакція залишаться валідними, але геш-значення від транзакції зміниться.

*– Як у транзакції зберігаються witness data?*

Як було відзначено раніше, транзакції в Segregated Witness мають нову структуру: набор входів, набор виходів, а також докази, у яких, відповідно, зберігаються witness data. Максимально просто це можна уявити так: користувача має просто набір даних, де написано, що є два входи транзакції (байти першого входу та байти другого входу), два виходи, а після них ще два набори witness data, які точно так само записані у формі послідовності байтів.

## 4.7 Механізм комісій у Bitcoin

У цій темі детально описана основна задача комісій у Bitcoin, як вони працюють і на що впливають. Пояснені причини волатильності комісій, затримки в підтвердженні транзакцій і описані підходи до вирішення цих проблем. Крім того, зазначено, як саме оновлення Segregated Witness сприяє зниженню вартості транзакцій. В кінці наведені думки з приводу того, як дружба з валідаторами знижує комісії до нуля, і до чого така тенденція може призвести в майбутньому.

Згідно з правилами протоколу Bitcoin, щоби підтвердити транзакцію, володільці більшої частини обчислювальної потужності повинні створити блок, який міститиме цю транзакцію, та далі продовжувати ланцюжок, базований на цьому блоці. Тоді транзакція буде вважатися повністю підтвердженою. Іншими словами, на основі блоку, в якому транзакція отримала перше підтвердження, має бути побудовано ще кілька блоків (рис. 4.56). Важливо, що цей ланцюжок повинен бути найдовшим і конкурентних ланцюжків не має бути. Необхідну кількість таких блоків (підтверджень транзакції) визначає сам одержувач платежа на свій розсуд. Він керується таким правилом: *що більше підтверджень має транзакція, то менша ймовірність її подальшого скасування*.

![Рисунок 4.56 – Процес включення транзакції до блоку](/resources/img/volume-1/4.7-fees-mechanism-in-bitcoin/4.56-inclusion-the-transaction-in-the-block.png)

Із ростом популярності Біткоіна значно збільшився потік нових транзакцій в мережі. Відомо, що розмір блоку визначений правилами протоколу та жорстко обмежений. У Біткоіні максимальний розмір блоку становить 1 МБ, а час створення блоку в середньому складає 10 хвилин, отже, пропускна здатність обмежена (1,7 кБ/с). Якщо потік нових транзакцій перевищує пропускну здатність, то не всі з них будуть оброблені. І такі ситуації трапляються нерідко. Які транзакції отримають підтвердження першими, а які залишаться чекати – це питання, що вимагає чіткої відповіді. Суть цього питання полягає в конкуруванні транзакцій між собою за право бути доданими до блоку.

Механізм комісій у Біткоіні необхідний для оплати послуг розподіленої мережі, де послугою мережі, фактично, є надійне зберігання даних. Користувачі Біткоіна платять за кожен байт даних, доданих до загальної бази. Зважаючи на те, що пропускна здатність цієї бази даних обмежена, користувачі конкурують між собою за пріоритет запису.

Формуючи транзакції, користувачі встановлюють комісію у вигляді певної кількості сатоші за один байт даних. Водночас кожен вузол-валідатор виставляє всі непідтверджені транзакції в чергу таким чином, що спочатку він підтверджує транзакції, які платять більшу комісію за одиницю свого розміру (вагову одиницю). Очевидно, що ті транзакції, які потрапляють в кінець черги, можуть довго залишатися непідтвердженими (рис. 4.57).

![Рисунок 4.57 – Конкуренція за місце у блоці](/resources/img/volume-1/4.7-fees-mechanism-in-bitcoin/4.57-competition-for-the-space.png)

Ще одне важливе завдання, яке вирішує механізм комісій, – це «*трагедія громад*». В контексті Bitcoin мається на увазі захист від спаму транзакціями. Наявність обов'язкових комісій означає, що зловмиснику дорого обійдеться протягом тривалого часу засмічувати мережу підробленими транзакціями, якщо він матиме такі наміри.

### Волатильність ціни запису даних

Користувачі мережі Bitcoin час від часу стикаються з незвично високою волатильністю комісій. Наприклад, у 2017 році середня ціна запису одного байта даних до бази Bitcoin коливалася в діапазоні від 1 до 500 сатоші. Черга непідтверджених транзакцій же коливалася від декількох КіБ до десятків і навіть сотень МіБ.

Через те, що ціна на запис даних в облікову систему Bitcoin може різко зміниться, користувачі змушені конкурувати один з одним майже наосліп. Це обумовлено тим, що практично транзакція буде підтверджена в середньому протягом 8 хвилин, тоді як комісію за обробку потрібно встановити ще до її підписання. Тому питання правильно встановленої комісії все одно залишається актуальним, тому що всі хочуть швидкого підтвердження своїх транзакцій з мінімальними витратами. Природно, платити більше 50 USD за типову транзакцію – не найкращий варіант, особливо коли можна заощадити до 90% цієї суми, грамотно розрахувавши комісію.

Наслідками різкого збільшення потоку нових транзакцій є виникнення великої черги транзакцій, які чекають додавання до блоку. Серед них і ті транзакції, відправники яких або не звернули увагу на зміну ціни запису, або сформували транзакцію в момент перед різким підвищенням. Найчастіше проблема криється не в поведінці самого користувача, а в програмному забезпеченні гаманця або у сервісі управління біткоінами. Більш того, в багатьох програмних продуктах для роботи з Bitcoin управління комісіями взагалі приховане від користувача.

### Рішення проблеми з волатильністю комісій

Незалежно від наявності можливості ручного управління пріоритетом запису транзакцій, які формуються, біткоін-гаманці можуть використовувати механізми оцінки поточної ціни запису даних, замість використання константних або оновлюваних вручну значень. Це надає велику перевагу гаманцю з точки зору управління пріоритетом запису транзакції в загальну базу і економії коштів на комісії.

Варто зазначити, що прогнозування ціни на запис також можливе, але найчастіше такі прогнози працюють тільки на дуже коротких проміжках часу (в середньому кілька хвилин). Якщо прогноз застарів, а транзакція не підтвердилася, то цілком ймовірно, що чекати її підтвердження можна ще довго – найчастіше кілька годин, а іноді і діб.

**transaction fee = transaction size * byte price**

Динамічний, або адаптивний, розрахунок комісії за транзакцію означає автоматичну оцінку підсумкового розміру транзакції в байтах і оцінку ціни запису одного байта даних в базу Bitcoin на найближчі кілька годин. Для обох оцінок існують специфічні алгоритми аналізу транзакцій і активності в мережі. Після отримання оцінки розміру транзакції в байтах і ціни запису одного байта ці значення перемножуються, і виходить сума в біткоінах, яку потрібно додати в транзакцію як комісію.

Перевагою підходу з адаптивною оцінкою є включення до транзакції більш точної комісії, яка буде вищою за мінімальний поріг, але не занадто високою, що економить монети користувача. Навіть більше, ймовірність, що транзакція виявиться глибоко в черзі непідтверджених, мінімальна. Утім, можливі винятки, тому розглянемо докладніше, що можна зробити в екстреній ситуації.

### Підвищення комісії після відправки транзакції

Відзначимо, що протокол Bitcoin вельми гнучкий  відносно комісій. Є два покращення протоколу, які дозволяють підвищити комісію вже сформованої і відправленої транзакції: *replace-by-fee* [69] і *child-pays-for-parent* [70]. На жаль, мало гаманців, що реалізують цю функціональність для зручності своїх користувачів, хоча з часом їх стає більше. 

*RBF (replace-by-fee)* дозволяє замінити непідтверджену транзакцію альтернативною транзакцією з вищою комісією. Це означає, що користувач може заново створити транзакцію, що ідентична непідтвердженій, збільшити розмір комісії в ній та відправити знову до мережі. Є набір правил, що визначають, як створити таку транзакцію та як вузли мережі повинні її обробити (здійснити заміну). Після створення такої транзакції вона буде конфліктувати з тією, що була випущена раніше, а отже, з обох транзакцій може бути підтверджена лише одна (звісно, валідатору вигідно включити до блоку транзакцію з більш високою комісією).

У разі *CPFP (child-pays-for-parent)* вам потрібно створити нову дочірню транзакцію, яка буде платити монети за вашу непідтверджену батьківську транзакцію. Для цього до дочірньої транзакції ви включаєте комісію, яка дуже вигідна для валідаторів. Але щоби її підтвердити й отримати відповідну винагороду, валідаторам потрібно для початку підтвердити батьківську транзакцію та додати обидві транзакції до одного блоку. Такий метод був запропонований у серпні 2016 року [71]. Такий підхід має низку технічних нюансів й організаційних вимог для його коректного використання. Одна з таких вимог полягає в тому, що користувач (або ПЗ в автоматичному режимі) повинен наново переоцінити комісію транзакції, сформувати та підписати нову (альтернативну) транзакцію, поширити її мережею та продовжити спостереження за її станом.

Приклад транзакції, підтвердженої за допомогою методу child-pays-for-parent, подано на рис. 4.58, де зображено дві відповідні транзакції (батьківська та дочірня), які були підтверджені в одному блоці.

![Рисунок 4.58 – Механізм child-pays-for-parents](/resources/img/volume-1/4.7-fees-mechanism-in-bitcoin/4.58-child-pays-for-parent.png)

Як бачимо, проблема збільшення комісії може бути вирішена, однак рішення мають деякі незручності. Незважаючи на те, що опції RBF і CPFP протокол підтримує доволі довго, їх упровадження до ПЗ bitcoin-гаманців відбувається доволі повільно.

### Як Segregated Witness допомагає знизити комісії?

Нагадаємо, що одна зі змін протоколу, які були внесені з оновленням Segregated Witness, – введення нового формату транзакції і її *ваги (transaction weight)*. До появи Segregated Witness при розрахунку комісії зазвичай враховували тільки розмір транзакції. Тепер важливими є і розмір транзакції і її вага. Нова транзакція зберігає докази володіння монетами в окремій структурі (witness data). Щоб перевести *розмір транзакції (total size)* в її вагу, розмір witness data множиться на менший коефіцієнт, ніж інші дані транзакції. Вага транзакції розраховується за формулою нижче.

**transaction weight = base size * 3 + total size**

В цьому випадку *base size* – це розмір транзакції без урахування розміру witness data. Як можна здогадатися, будь-які дані, які включаються в witness data, вимагають в чотири рази меншої комісії, ніж інші дані транзакції. Подібний підхід дозволяє валідаторам визначити вигіднішу транзакцію щодо займаного в блоці місця та отриманої винагороди.

Відомо, що близько 60% всіх даних транзакції становлять саме дані доказу володіння монетами (тобто такі, які можна записати у witness data). Відповідно, вага транзакцій нового формату значно зменшиться. Таким чином, користувач може платити менше за підтвердження нової транзакції, при цьому вона буде мати той же пріоритет у валідаторів при включенні в блок, що й стара транзакція з більшою комісією.

На рис. 4.59 відображена залежність ціни запису одного байта даних до спільної бази даних Bitcoin від навантаження (потоку непідтверджених транзакцій), виражена в байтах в секунду (byte per second). Висновок можна зробити дуже простий: якщо потік нових транзакцій нижче або дорівнює пропускній спроможності облікової системи, то ціна запису практично нульова. А якщо потік нових транзакцій перевищить пропускну здатність, то ціна різко спрямовується вгору.

![Рисунок 4.59 – Залежність між пропускною здатністю системи та розміром комісії](/resources/img/volume-1/4.7-fees-mechanism-in-bitcoin/4.59-dependence-of-fees-and-capacity.png)

### Варіант із другом-майнером

Уявіть, що ви маєте друга, який займається майнінгом і контролює 10% усієї обчислювальної потужності Біткоіна. У середньому він створює блок один раз на 100 хвилин. У цьому разі ви можете сформувати свою транзакцію, у якій встановите нульову комісію, після чого відправите цю транзакцію своєму другу для підтвердження (рис. 4.60).

![Рисунок 4.60 – Ситуація з другом-майнером](/resources/img/volume-1/4.7-fees-mechanism-in-bitcoin/4.60-friend-miner-case.png)

У середньому перше підтвердження з імовірністю близькою до 100% ваша транзакція отримає протягом 100 хвилин, а повне підтвердження – за 50 хвилин після першого. У підсумку, ваші транзакції отримуватимуть повне підтвердження приблизно протягом 150 хвилин. Якби ви такого друга не мали, повне підтвердження транзакція отримувала би приблизно протягом 60 хвилин, але вже з оплатою повноцінної комісії.

Як бачите, якщо мова йде про економію коштів, то вам пощастило, якщо у вас є друг валідатор, який контролює значну частину всієї майнінгової потужності в Bitcoin. Але якщо такого друга немає, то можуть існувати альтернативні варіанти оплати місця в блоці.

### Варіант із продажем місць у черзі на підтвердження

Зазвичай валідатор діє за стандартною схемою і сортує транзакції за ціною запису 1 байта даних. Схоже, що зараз так реалізовано практично все програмне забезпечення для майнінгу. Однак не виключено, що у валідатора може бути краща мотивація. Він може самостійно формувати політику монетизації своєї активності. Інакше кажучи, він може діяти нестандартно щодо транзакцій при їх запису до свого блоку. Якщо знайдуться більш вигідні умови, ніж просто взяти комісію за вашу транзакцію, найімовірніше, він змінить свою політику. Такий підхід передбачає, що користувачі будуть платити валідатору за підтвердження своїх транзакцій через не заздалегідь встановлену комісію, а безпосередньо (за власною схемою).

На практиці, будь-який досить великий майнінговий пул може вести свою кампанію з метою підвищення прибутковості і використовувати для цього нехитрі механізми, наприклад:
* Визначити свої пріоритети сортування транзакцій
* Укласти партнерство з деякими сервісом (біржа, магазин, браузер тощо)
* Продавати гарантії на деяке місце в подальшому блоці

До того ж, пул може навіть почати попередній продаж сертифікатів на вільне місце у власних блоках, як зобов'язання на надання певної пропускної здатності обліковій системі згодом (докладніше про *токенізацію* в 6.4).

**Часті запитання**

*– Як відправити транзакцію з нульовою комісією другу-майнеру?*

Як звичайна транзакція, у мережі вона навряд чи розповсюдиться, оскільки за замовчуванням, конфігурація вузлів має параметр *minRelayFee*, який не дорівнює нулю. Це означає, що транзакція повинна обов'язково мати комісію більше деякого порогового значення, щоб вузли могли відреагувати на неї і передати далі (захист від спаму). Тому в такій ситуації користувачеві необхідно знайти інший підхід для доставки «незвичайної» транзакції своєму другові-майнеру. Один з варіантів полягає у тому, щоб фізично з'єднати вузол користувача з вузлом-валідатором друга, вручну вписавши мережеву адресу до файлу з конфігурацією вузла користувача, а на вузлі-валідаторі встановити minRelayFee рівним нулю. Але є проблема: вузол друга повинен відрізняти «незвичайні» транзакції від транзакцій інших користувачів. Тому інший варіант рішення – це використання API власного виробництва в гаманці користувача та на вузлі-валідаторі друга-майнера.

*– У чому полягає вигода валідатора брати меншу комісію, продаючи сертифікати на місце в блоці, якщо він може взяти більше біткоінами?*

Вигода полягає в тому, що валідатор може продавати місце в блоках заздалегідь, якщо, наприклад, гроші йому потрібні сьогодні більше, ніж завтра, на відміну від інших валідаторів. Також може бути важлива фіксована ціна для користувачів біткоін-гаманців: іноді їм потрібно точно знати свої витрати на кілька місяців вперед. До того ж, це хоч якась гарантія того, що для транзакцій користувача знайдеться місце в подальших блоках за заздалегідь відомою ціною.

## 4.8 Платіжні канали та Lightning Network

Ідея *платіжних каналів* (і її розвиток у *Lightning Network*) стала, безперечно, революційною для світу електронних платежів. Її застосування не обмежується використанням у криптовалютах. Важливими проблемами будь-якої фінансової облікової системи є обмеження за пропускною здатністю, а також занепокоєння щодо приватності користувачів. До появи систем цифрового зв’язку ці проблеми були не актуальні: авжеж, операція щодо передавання паперової банкноти з рук до рук не вимагала звернення до сервера, а також вона не відстежувалася та не цензурувалася. Поява цифрових облікових систем уможливила швидке переміщення грошових коштів, водночас уникаючи обмежень, пов’язаних із фізичним переміщенням золота або банкнот. З іншого боку, тепер кожна нова транзакція повинна бути якомога раніше додана до загальнодоступної бази даних, щоб обидві сторони могли переконатися, що платіж пройшов. До того ж, суб’єкт, який має доступ до історії всіх транзакцій (наприклад уряд), отримував би величезний важіль впливу на життя людей, якби міг аналізувати цю історію та відстежувати діяльність громадян.

Поява off-chain платіжних каналів і Lightning Network (LN) [72] робить уможливила появу платіжних систем із високою масштабованістю, безпекою, низькою вартістю підтримання, які працюють за принципом p2p. Нижче ми розберемо основні принципи обох механізмів, їхні особливості в контексті Bitcoin і розглянемо, як вони працюють.

## Що таке платіжний канал?

Уперше ідею платіжних каналів описав сам Сатоші Накамото в особистому листі одному з активних розробників протоколу багато років назад. Тоді ще в Bitcoin не було прийнято досить важливих оновлень, що дозволяють проєктувати надійні платіжні канали. Однак пізніше це стало можливо, і в 2013 році повернулися до цієї воістину перспективної ідеї. Ми розглянемо основні методи реалізації платіжних каналів.

*Платіжний канал – це метод проведення багатьох платежів без додання транзакцій для кожного з них до ланцюжкаа блоків*. Для відкриття та закриття платіжного каналу контрагентам потрібно здійснити on-chain транзакції: відкриваючу та закриваючу. Водночас учасники каналу взаємодіють тільки один з одним [73]. Наявність додаткових валідаторів або третіх довірених сторін не потрібна.

Процес використання платіжного каналу аналогічний процесу обліку позики на побутовому рівні (запис на папері), але з тією різницею, що завдяки платіжним каналам з’явилася можливість гарантованого виконання зобов’язань з боку всіх сторін (чого запис на папері, авжеж, не може забезпечити).

Нижче ми розберемося з принципами роботи платіжних каналів і з протоколом, який дозволив розвинути й застосувати цю концепцію для вдосконалення системи Bitcoin, – Lightning Network.

## Чому потрібні платіжні канали?

Основними обмеженнями в Bitcoin є великий час підтвердження транзакцій і непередбачувані (а також досить високі) комісії, які роблять мікроплатежі (на суму кілька центів або доларів) недоцільними. Які ж переваги дає платіжний канал перед звичайними транзакціями? У рамках платіжного каналу учасники проводять платежі між собою, не публікуючи транзакції в мережі Bitcoin. Сторона-одержувач виконує швидку незалежну перевірку і приймає платіж. У базовому варіанті комісій немає. Відповідно, мікроплатежі мають місце. Саме через цю особливість платіжні канали також називають *micropayment channels* [74].

Взаємодія учасників каналу за замовчуванням приватна: деталі кожного мікроплатежу залишаться в таємниці від усіх інших, хоча сам факт використання платіжного каналу між конкретними bitcoin-адресами буде відомий усім.

## Платіжний канал: кроковий приклад

У спрощеному варіанті роботу платіжного каналу можна зобразити на такій схемі (рис. 4.61). Аліса та Боб мають bitcoin-гаманці з додатковими модулями, що підтримують роботу з платіжним каналом. Ці модулі обмінюються даними, потрібними для проведення платежів (наприклад дані про розподілення монет, актуальні дані підписів тощо).

![Рисунок 4.61 – Схема функціонування платіжного каналу](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.61-operation-of-payment-channel.png)

Пропонуємо розглянути більш детально, у який спосіб перерозподіляються монети в платіжному каналі (рис. 4.62).

![Рисунок 4.62 – Взаємодія в межах платіжного каналу](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.62-interaction-within-payment-channel.png)

*Крок 0*. Для відкриття каналу Аліса та Боб створюють MultiSig-адресу й обидва переводять свої гроші на неї (припустимо, по 5 BTC кожен). Тепер на адресі зберігається 10 монет; 5 з них «належать» Алісі та 5 Бобу (далі ми пояснимо акцент на слові «належить»).

*Крок 1*. Уявімо, що Аліса хоче заплатити Бобу 2 BTC за деякі послуги. Вона створює транзакцію, що розподіляє монети в платіжному каналі так: 3 BTC Алісі, 7 BTC Бобу.

*Крок 2*. Алісі знову потрібно заплатити Бобу, наприклад, 1 BTC. Для передачі цінності Бобу, Аліса знову створює off-chain транзакцію, яка розподіляє монети – 2 BTC Алісі і 8 BTC Бобу.

*Крок 3*. Тепер Боб хоче заплатити Алісі 7 BTC і тому він створює нову транзакцію з новими правилами розподілу монет: Аліса отримує 9 BTC, а Боб 1 BTC.

*Крок 4*. Після цього Аліса й Боб вирішують, що платежів між ними більше не буде, і закривають канал. Вони публікують останню сформовану транзакцію (яку сформував Боб на кроці 3) в Bitcoin-мережу. На вході цієї результуючої транзакції будуть 10 BTC з MultiSig-адреси, на виході ця транзакція заплатить 9 BTC на адресу Аліси і 1 BTC на адресу Боба.

Слід відзначити, що тільки 2 транзакції (з усіх, які були сформовані) були відправлені в Bitcoin-мережу й додані до ланцюжка блоків: це та, що відкриває (крок 0) і закриває (крок 4) платіжний канал. Решта транзакцій були off-chain, отже, не навантажували мережу Bitcoin. Відповідно, Аліса й Боб не платили комісію за ці транзакції. Усередині платіжного каналу вони просто обмінювалися один з одним ідентичними транзакціями (з різницею тільки в сумах виходів). Коли настає момент закриття каналу, один із його учасників публікує в мережі останній оновлений стан транзакції й у такий спосіб ініціює закриття платіжного каналу.

### Особливості платіжного каналу

Не можна сказати, що в платіжних каналів є серйозні недоліки порівняно зі звичайними транзакціями, але є деякі характерні особливості.

Платіжний канал потрібно відкрити і, відповідно, рано чи пізно закрити. Ці процеси супроводжуються окремими on-chain транзакціями. Для них неминуча оплата комісії, і необхідно очікувати на їх підтвердження. Для відкриваючої транзакції краще дочекатися повного підтвердження.

Усередині конкретного каналу платежі доступні тільки в межах попередньо визначеної суми (згідно з нашим прикладом вище це означає, що Аліса та Боб можуть діяти тільки в межах суми, на яку відкритий канал, тобто 10 ВТС). Її задають самі учасники, заморожуючи потрібну суму за допомогою спеціального скрипту.

Платіжні канали можуть бути *односпрямовані (unidirectional)* та *двоспрямовані (bidirectional)*. Це залежить від методу реалізації каналу.

Період наявності каналу та максимальна кількість платежів у каналі можуть бути необмеженими. Проте залежно від методу ці параметри каналу можна обмежити. Відповідно, канали можуть бути зачинені з досягненням певного моменту часу чи достроково. Причому закрити канал можна як за спільною згодою, так і на бажання одного з них, але з деякими особливостями.

### Методи реалізації платіжних каналів

Як згадувалося в прикладі з Алісою та Бобом, у користувачів є спеціальний модуль, що дозволяє їм діяти в межах платіжного каналу. Залежно від реалізації, ці модулі можуть підтримувати різні методи функціонування платіжних каналів. Ми наведемо перелік найбільш популярних із них.

*Spillman-style payment channel* – це найпростіший варіант односпрямованого каналу з обмеженою тривалістю роботи й необмеженою кількість платежів.

Пізніше було прийнято ще одне вдосконалення протоколу Bitcoin і стали можливі *CLTV-style payment channels*, що є вдосконалення попереднього методу.

*Poon-Dryja payment channel* – це метод двонаправлених каналів із необмеженим часом роботи. Вони потребують ще декількох оновлень протоколу Bitcoin, які нещодавно були прийняті. Ці канали використовуються під час проєктування Lightning Network.

*Decker-Wattenhofer duplex payment channel* – це варіант використання двух односпрямованих каналів одночасно, який удосконалив їхні властивості завдяки формуванню не послідовного ланцюжка замінних транзакцій, а цілого дерева замінних транзакцій. У таких каналах може бути більш ніж 2 учасники.

Розглянемо докладніше реалізацію Spillman-style, оскільки вона найпростіша та найдоступніша для розуміння.

### Spillman-style payment channels

Отже, *Spillman-style payment channel* – це метод створення односпрямованих платіжних каналів, де є ролі відправника й отримувача. Тривалість роботи такого каналу встановлює відправник довільно, водночас отримувач може достроково закрити канал. Давайте розглянемо основні кроки роботи такого каналу на схемі (рис. 4.63).

![Рисунок 4.63 – Схема функціонування Spillman-style payment channels](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.63-spillman-style-payment-channel.png)

Для зручності сприйняття уявімо, що є деякий сервіс, який торгує доступом до глобальної мережі через точку доступу Wi-Fi, і деякий клієнт, який хоче отримати доступ до Мережі протягом доби. Послуга буде коштувати одну монету. Очевидно, що клієнт не довіряє сервісу на таку суму й хоче розраховуватися за трафік посекундно.

Тоді вони вирішують відкрити платіжний канал на добу з сумою один біткоін. Сервіс генерує нову пару ключів для цифрового підпису й передає відкритий ключ клієнту. Клієнт, зі свого боку, генерує нову пару ключів і використовує свій відкритий ключ і відкритий ключ сервісу для формування MultiSig-адреси 2-з-2. Далі, клієнт формує транзакцію під номером один, у якій він відправляє один біткоін на MultiSig-адресу, підписує її, але не розповсюджує до Bitcoin-мережі, оскільки сервіс може підставити клієнта і відмовитися підписувати будь-які транзакції для подальшого передавання одного біткоіна.

Тому клієнт формує транзакцію під номером два, де монети з MultiSig-адреси відправляються на адресу, яку він контролює сам. Причому встановлює таке значення параметра locktime, щоби транзакція могла бути підтверджена через добу. Цю транзакцію він не підписує, а відправляє сервісу. Зі свого боку, сервіс погоджується з тим, що клієнт може забрати цілу монету собі, але не раніше, ніж через добу, і підписує транзакцію своїм ключем. Підпис він передає клієнту, клієнт її перевіряє. Тепер він має можливість допідписати транзакцію своїм ключем і гарантовано забрати монету назад, якщо сервіс вирішить відмовити в обслуговуванні. Таким чином, друга транзакція страхує від шахрайства й повинна бути підписана ще до того, як кошти будуть відправлені сервісу. Такий спосіб страхування стає можливим завдяки правильному використанню механізму locktime. Саме цей механізм дозволяє нам стверджувати що користувач фактично володіє відповідною кількістю монет з MultiSig-адреси.

Наступним кроком клієнт розповсюджує транзакцію 1 у мережі Bitcoin чи передає її сервісу для розповсюдження, якщо в нього немає з’єднання. Після підтвердження цієї транзакції платіжний канал вважається відкритим.

Тут транзакція 1 називається *funding transactio*n, а транзакція 2 – *refunding transaction*.

Як же виконується взаємодія під час розрахунків у межах платіжного каналу? Розгляньмо схему на рис. 4.64.

![Рисунок 4.64 – Розрахунки в каналі після проведення платежу](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.64-coins-settlement.png)

Для відправки першого платежу клієнт робить запит на bitcoin-адресу сервісу, яку той контролює самостійно. Далі клієнт формує транзакцію 3, у якій монета з MultiSig-адреси розподіляється між між двома виходами: перший – це платіж на адресу сервісу за одну секунду роботи точки доступу Wi-Fi, а другий – це решта на власну адресу клієнту. Клієнт підписує транзакцію 3 своїм ключем і передає сервісу. Сервіс перевіряє правильність транзакції й підпису та потім приймає платіж, тому що він може допідписати цю транзакцію своїм особистим ключем і гарантовано отримати сплату першої секунди трафіку, якщо допідпише цю транзакцію своїм особистим ключем протягом доби. Але якщо сервіс має наміри в подальшому надавати обслуговування клієнту й отримувати оплату в межах каналу, то він просто зберігає транзакцію 3 локально до закриття каналу.

Для відправки всіх подальших платежів клієнт змінює вихідні значення транзакції під номером три, відповідно, перепідписує її й передає сервісу вже тільки самий підпис і суму зміни. Сервіс також перевіряє отримані дані і зберігає вже нову транзакцію під номером три, позаяк у цій версії він отримує вже більше монет (рис. 4.65).

![Рисунок 4.65 – Опублікування результатів у мережі Bitcoin](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.65-publication-to-the-bitcoin.png)

Як же виконується закриття каналу? На схемі видно, що сервіс повинен встигнути опублікувати в мережі Bitcoin останню версію транзакції 3 до завершення часу роботи каналу. В іншому разі відправник може зхитрувати та забрати всю суму на свою адресу, допідписавши та опублікувавши транзакцію 2.

Варто відзначити, що клієнт може опублікувати refunding transaction у будь-який час роботи каналу й установити будь-яку суму переказу в межах одного біткоіна (сума, на яку був відкритий канал). Якщо refunding transaction публікується в mainchain і час, який встановлено в полі locktime, настав, транзакція може бути підтверджена. Тому сервіс постійно стежить за появою refunding transaction у мережі та, якщо виявивляє її, розриває договір із клієнтом (закриває канал) достроково (раніше за час, заданий у полі locktime), публікуючи останню версію транзакції 3. Так сервіс може бути впевнений, що клієнт не зможе його обдурити та вкрасти гроші.

### Застосування платіжних каналів

Є два варіанти застосування платіжних каналів: або в чистій формі для здійснення регулярних платежів між заздалегідь установленими сторонами, або формування Lightning Network завдяки комутації каналів між собою.

Комутація означає можливість проведення платежу між користувачами, які не відкрили платіжний канал один з одним, але мають відкриті канали з іншими вузлами мережі. Тоді монети передаватимуться через ланцюжок каналів незнайомих користувачів, якщо такий є.

У разі Lightning Network є додаткові складнощі та особливості. Це вироблення загальноприйнятого формату комутації каналів і протоколу спілкування вузлів. Також важливо, щоби гаманці від одних розробників могли працювати з гаманцями від інших. Ще однією складністю є питання маршрутизації в такій мережі: потрібно знайти найкоротший шлях передачі цінності зважаючи на те, що в кожному каналі є обмеження на суму переказу за кожним із напрямків.

### Особливості роботи мережі Bitcoin та Lightning Network

У мережі Bitcoin вузли обмінюються даними про транзакції та блоки, а також мережевими адресами один одного. Водночас досягається консенсус і формується загальна база даних.

*Lightning Network* полягає в надійній маршрутизації платежу від відправника до одержувача через множину *двоспрямованих платіжних каналів*, що відкриті, зокрема, між сторонніми учасниками, що не знайомі з відправником й одержувачем цього платежу. Вузли Lightning Network не обмінюються готовими (які відповідають протоколу й можуть бути підтверджені валідаторами) транзакціями й не досягають консенсусу. Тому кожен вузол цієї мережі повинен чи безпосередньо отримувати актуальні дані про свої транзакції від вузлів мережі Bitcoin, чи від довірених джерел.

Ідея Lightning Network почала формуватися разом із появою платіжних каналів в Bitcoin [73]. Приблизно тоді само, коли було запропоновано використання платіжних каналів, розробники *Bitcoin Core* Пітер Тодд (Peter Todd) і Ґевін Андресен (Gavin Andresen) почали розглядати створення платіжних мереж поверх основної облікової системи. Однак тільки у 2015 році світ побачив роботу під назвою «The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments» [72].

На момент публікації whitepaper LN описана ідея була несумісною з поточною версією Bitcoin. Тому були потрібні деякі зміни в протоколі. Першими змінами стали додавання операцій OP_CHECKLOCKTIMEVERIFY та OP_CHECKSEQUENCEVERIFY, що дозволяли блокувати монети на деякий час. Також необхідним стало оновлення SegWit, що було активовано влітку 2017 року (див. 4.6). Офіційно альфа-стадія LN почалась у січні 2017 року [76]; тоді само перша повна реалізація LN [77; 112].

Як згадувалося раніше, влітку 2017 року було випущено оновлення SegWit, що лягло до основи для впровадження LN. Через три місяці Blockstream оголосила про першу вдалу транзакцію за допомогою LN [114]. У листопаді був здійснений перший переказ монет між обліковими системами Bitcoin та Litecoin. А в грудні провідні команди, як-от Blockstream, Lightning Labs та ASINQ, оголосили про повну сумісність між їхніми реалізаціями.

На рис. 4.66 ребрами позначені мережеві з’єднання між вузлами мереж, і стрілками – їхня взаємодія для актуалізації станів. Також вузлам Lightning Network необхідно оновлювати інформацію про стан один одного й обмінюватися повідомленнями для підтримки роботи платіжних каналів.

![Рисунок 4.66 – Обмінювання повідомленнями між мережею Bitcoin і Lightning Network](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.66-message-exchanging.png)

### Як працює Lightning Network?

Для розуміння базової ідеї LN наведемо такий приклад. Припустімо, у місті є продуктовий магазин, який дозволяє своїм клієнтам платити за товари за допомогою біткоінів. До того ж, цей магазин надає постійним покупцям можливість відкриття двонаправленого платіжного каналу для економії на комісіях та часу підтвердження оплати. Припустимо, що Аліса та Боб являються постійними покупцями й мають відкриті канали з магазином.

Ідея LN полягає в тому, що Аліса та Боб можуть не тільки здійснювати платежі стороні, з якою вони безпосередньо відкрили канал (у нашому випадку це магазин із продуктами), але також можуть передавати монети один одному, використовуючи магазин у ролі посередника. Важлива особливість такої взаємодії – відсутність у клієнта потреби довіряти посереднику (на практиці часто кількість таких посередників більш ніж один).

Як ми описували раніше, реалізація платіжних каналів розроблена в такий спосіб, що дозволяє запобігти шахрайській поведінці в корені (спроба вкрасти монети у взаємодіючої сторони може призвести до втрати всіх своїх коштів у каналі). Функціонування Lightning Network використовує ті ж самі принципи. Посередники, які передають ваші гроші, на рівні протоколу позбавлені можливості їх украсти. Це й робить платежі в Lightning Network атомарними – передача монет проходить чи цілком успішно, або не проходить зовсім. Основою для такої trustless взаємодії стало використання механізму locktime в протоколі LN (більш детально ми розглянемо це в наступній частині книги).

Тепер для кращого розуміння роботи LN розгляньмо приклад (рис. 4.67), який показує, як монети переходять від Аліси до Боба, причому в них немає відкритого платіжного каналу безпосередньо між собою.

![Рисунок 4.67 – Розташування вузлів Lightning Network у прикладі](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.67-simplified-example.png)

На рисунку вище схематично представлена невелика мережа із шести користувачів, у кожного з яких є вузол. На практиці таких вузлів можуть бути сотні. Припустимо, що Алісі необхідно переслати Бобу 2 ВТС. У такому випадку програмне забезпечення її вузла повинно знайти найбільш оптимальний шлях для передавання монет. Оскільки вузли в мережі постійно синхронізуються між собою, вузол Аліси знає необхідну інформацію про інші відкриті канали (кількість монет у каналах, час, на який відкритий відповідний канал тощо).

Програмне забезпечення вузла Аліси визначає шляхи, якими можна передати 2 ВТС Бобу. У каналі Аліса–Кен стан балансів – 6|10. Це означає, що Аліси має 6 ВТС, а Кен – 10 ВТС у межах платіжного каналу, тобто переказ можливо здійснити. У каналі Кен–Ден стан балансів – 1|4, а отже, цілісний переказ у 2 ВТС неможливий через цей канал. Зауважимо, що якби в каналі Кен–Ден стан балансів був протилежний, а саме 4|1, то переказ був би можливий.

![Рисунок 4.68 – Відправка платежу від Аліси до Боба](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.68-sending-the-payment.png)

Є й інший шлях. У каналі Аліса–Єва, баланси відповідаються 17|43, а отже, платеж можливо провести. У каналі Єва–Дейв на балансі Єви є 4 ВТС, а на балансі Дейва – 1 ВТС. І в цьому випадку платіж може бути вільно проведений (так, Дейва має лише 1 ВТС на балансі, але можливість передачі платежу повністю залежить від балансу сторони-відправника в платіжному каналі, а в цьому разі – від балансу Єви). Щоби закінчити переказ, платіж повинен пройти каналом Дейв–Боб. Баланси в цьому каналі дорівнюють 17|15, а отже, платіж пройде без проблем. У результаті, для передачі монет Бобу одним платежем у 2 ВТС Аліса може використовувати верхній шлях і двох посередників. На рисунку 4.69 показано, як змінився стан балансів у платіжних каналах після переказу.

![Рисунок 4.69 – Зміна станів платіжних каналів після проведення платежу](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.69-state-of-channels.png)

Насправді в цій ситуації можливий і інший спосіб відправлення платежу у 2 ВТС від Аліси до Боба. Для цього Алісі необхідно розділити платіж на дві частини по 1 ВТС і відправити їх різними шляхами (1 ВТС через Єву та Дейва, та 1 ВТС через Кена й Дена), як вказано на рисунку 4.70.

![Рисунок 4.70 – Відправлення одного платежу за допомогою двох шляхів](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.70-sending-the-same-payment.png)

На рисунку 4.71 ви можете побачити, як зміниться стан балансів у платіжних каналах після проведення платежу в такий спосіб (якщо Аліса ділить монети та відправляє їх різними шляхами).

![Рисунок 4.71 – Зміна станів каналів після проведення платежу](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.71-end-state.png)

На практиці, кількість вузлів-посередників і можливих шляхів може бути набагато більшою. До того ж, LN, як і мережа Bitcoin, неоднорідна. Це значить, що в мережі присутні вузли з більшим і меншим навантаженням, а також вузли з непостійною активністю. На рисунку 4.72 ви можете побачити актуальний стан LN у грудні 2018 року [78].

> **Статистика Lightning Network у 2018 році**
>> * *Приблизно 4 500 вузлів*
>> * *У середньому приблизно 14 000 відкритих каналів*
>> * *479,70 BTC заблоковано в Bitcoin (використовуються в LN)*

![Рисунок 4.72 – Стан LN на кінець 2018 року](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.72-state-of-ln.png)

Для відкриття кожного платіжного каналу потрібно заморозити відповідну кількість монет. Прийом та відправка платежів у каналах можливі тільки в межах обмеженої суми. Якщо звичайний користувач розділить свої монети на декілька частин і відчинить декілька каналів, то він отримає дуже маленьке вікно для платежу в кожному з каналів у порівнянні з початковою сумою. Водночас, *хабами* будуть виступати великі організації, наприклад, розробники гаманців, централізовані біржі чи популярні мерчанти. Вони можуть собі дозволити підтримку великої кількості каналів, відкритих на великі суми і тривалі проміжки часу, не виходячи в офлайн. Звичайні ж користувачі будуть відкривати в кращому випадку один чи два платіжних канали з одним із таких хабів.

Зважаючи на описане вище, визначмо основні функції вузлів LN.

> * *Маршрутизація*
> * *Відкриття каналів*
> * *Проведення платежів між іншими вузлами*
> * *Зачинення каналів*

Маршрутизація – однією з найскладніших функцій вузлів LN. Кожен вузол LN займається розрахунком оптимального шляху слідування платежу і йому необхідно враховувати для цього багато чинників, як-от пропускну здатність певного каналу, суму, на яку він відкритий, як ці параметри можуть змінитись після проходження платежу в мережі й що робити, якщо деякі канали раптом зачиняться.

Також кожен вузол мережі має турбуватися про наявність каналів із іншими вузлами. Деякі канали особливо важливі для мережі загалом і їх утрата може призвести як до порушення функціонування, так і до розриву мережі. Щоб уникнути такої ситуації, кожному вузлу рекомендується підтримувати зв’язок із якомога більшою кількістю інших вузлів.

Мабуть, першочерговою функцією вузлів є саме проведення платежів. Розмір і кількість платежів, які здатний провести вузол цілком залежать від ширини каналів, які були відкриті цим вузлом.

Насамкінець, на вузлах лежить функція зачинення платіжних каналів. У LN є декілька так званих домінантних вузлів (з великою кількістю відкритих каналів). Такі вузли можуть у деякому сенсі маніпулювати рухом коштів шляхом відкриття й закриття своїх платіжних каналів. Таку проблему також можна вирішити через збільшення кількості каналів між усіма вузлами LN, проте такий підхід доволі дорого коштуватиме їхнім володільцям (комісії за відкриття та закриття каналів і кошти, які будуть заморожені для функціонування кожного з каналів).

**Часті запитання**

*– Наскільки платежі в каналах надійні в порівнянні зі звичайними bitcoin-транзакціями?*

За надійністю платежі в каналах можна порівняти зі звичайними, тобто монети не відберуть, а платіж не скасують. Але є низка особливостей на кшталт необхідності своєчасного відкриття й закриття каналів, обмеження на суму всередині каналу, необхідності постійної синхронізації з Bitcoin-мережею, імовірності заморозки монет на деякий час.

*– Чи обмежена пропускна здатність у каналах та Lightning Network?*

Річ у тому, що жодного обмеження немає, але можуть бути затримки, пов’язані з обробленням даних каналу, розвідуванням мережі й побудуванням маршруту, які залежать від продуктивності конкретних вузлів мережі. Слід також врахувати, що всі вузли можуть непередбачено ставати офлайн, а це може спричинити певні обмеження в здійсненні платежів іншим учасникам.

*– Чи повинні учасники каналу довіряти один одному?*

Ні, механізм платіжних каналів у межах протоколу передбачає захист від зловмисних дій сторін, які взаємодіють між собою.

*– Яка користь від каналів людині, яка хоче відправити тільки один платіж?*

Якщо людина хочу позбавитися від останніх монет і більше не планує приймати і відправляти платежі, то їй слід не відкривати канал, а відправити звичайну, on-chain транзакцію. У всіх інших випадках відкриття каналу буде корисним; наприклад, дозволить зменшити комісію та скоротити час підтвердження транзакції.

*– У чому полягає різниця sidechains та платіжних каналів?*

*Sidechain* представляє собою окремий ланцюжок блоків, що враховує монети з *mainchain*. Правила роботи в ньому можуть відрізнятися від правил в mainchain і визначатися новим протоколом. Sidechain не має базової валюти, але реалізує механізм переказу монет з основного ланцюжку блоків. Водночас платіжний канал не є окремий ланцюжок блоків і не реалізує переказування монет із mainchain. Він є просто метод проведення великої кількості платежів без оброблення транзакцій із боку валідаторів. Точніше, валідатори підтверджують тільки дві транзакції для кожного платіжного каналу: ту, що відкриває канал, і ту, що закриває канал.

*– За якими критеріями відбувається валідування транзакцій у межах платіжного каналу в Bitcoin?*

Учасник каналу прото перевіряє коректність ланцюжка off-chain транзакцій. Фактично, йому потрібно переконатися в тім, що він гарантовано отримає свої монети з каналу, якщо опублікує потрібні транзакції з цього ланцюжка. Учасник самостійно вирішує, чи вважати ці off-chain транзакції правильними чи ні. Крім того, це рішення залежить від поточного стану облікової системи, над якою працює платіжний канал, тобто від on-chain транзакцій.

*– Чи фіксується історія транзакцій під час використання платіжного каналу? Чи можна приховати транзакцію від сторонніх спостерігачів, «сховавши» її в платіжний канал?*

Історія транзакцій не фіксується у відкритій розподіленій базі даних; її фіксують тільки учасники платіжного каналу. У загальному разі решта користувачів не може ні підтвердити, ні спростувати підозри щодо факту проведення платежу чи суми платежу всередині каналу. Вони можуть бачити тільки транзакцію, що закриває канал, і її суму, тобто різницю між станом бази даних до відкриття каналу та станом після закриття каналу.

Якщо після закриття платіжного каналу його учасники знищать усі проміжні дані, деталі їхньої взаємодії ніколи не буде розкрито. Це правильне тільки для окремого платіжного каналу, у якому зазвичай взаємодіють два учасники. Відзначмо, що Lightning Network працює з багатьма платіжними каналами та багатьма учасників-посередників – у цій мережі рівень конфіденційності off-chain транзакцій значно нижчий.

[ТЕХНОЛОГІЯ BLOCKCHAIN](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-1/ua/5-blockchain-technology.md)    