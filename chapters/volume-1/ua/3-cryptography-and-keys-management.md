# 3 КРИПТОГРАФІЯ Й КЕРУВАННЯ КЛЮЧАМИ


## 3.1 Вступ до криптографії

У цьому підрозділі ми, не вдаючись глибоко до деталей, познайомимося з криптографією як наукою, її завданнями та основними механізмами. Також будуть розглянуті специфічні криптографічні механізми та функції, які застосовуються саме в протоколі Bitcoin. Також звернемо увагу на особливості роботи з цифровим підписом і відповідними цифровими ключами; ці особливості мають, передусім, практичне значення.

Роль *криптографії – науки про захист інформації математичними методами* – у розвитку інформаційних систем складно переоцінити. Bitcoin став першою у світі платіжною системою, де основні процеси та операції захищені криптографічно.

Читач матиме змогу ознайомитися з основними принципами захисту інформації, а після цього розглянути найбільш важливі криптографічні алгоритми, що стосуються протоколу Bitcoin.

### Принципи криптографічного захисту інформації

Розвиток криптографії почався з давніх часів, її історія налічує понад 4 тисячі років. Спочатку криптографія вирішувала лише одне завдання – забезпечення конфіденційності під час передавання та зберігання даних. Для її вирішення в давні часи використовувалися такі механізми, як схеми перестановки тексту, перемішування символів тексту, використання альтернативних алфавітів тощо.

Нині криптографія використовує математичну базу. Застосовуються спеціальні перетворення, які визначені в таких розділах математики, як теорія чисел, теорія груп, кілець, полів, а також у деяких інших розділах. Ця специфічна математика відома далеко не всім, оскільки її здебільшого не викладають у навчальних закладах.

Сучасна криптографія включає схеми симетричного й асиметричного шифрування, схеми цифрового підпису, схеми гешування даних, методи управління ключами, схеми доказів із нульовим розголошенням, методи криптоаналізу та постквантову криптографію.

> **Основні послуги безпекии**
>> * *Забезпечення ***конфіденційності*** даних*
>> * *Забезпечення ***цілісності*** даних*
>> * *Забезпечення ***доступності*** даних*
>> * *Забезпечення ***справжності*** даних*

*Конфіденційність* передбачає, що неавторизовані особи не можуть отримати доступ до смислового змісту документу, який зберігається чи передається. Найчастіше ця послуга забезпечується за допомогою шифрування (симетричного чи асиметричного).

*Цілісність* передбачає, що неавторизовані користувачі не можуть непомітно модифікувати дані. Завдання з перевіряння цілісності даних після зчитання з носія інформації чи отримання з мережі найчастіше вирішується за допомогою гешування та перевіряння контрольної суми.

*Доступність* передбачає, що суб’єкти, що мають право на доступ до інформації, гарантовано отримають доступ до неї.

*Справжність (автентичність)* передбачає можливість довести, що дані було дійсно отримано від конкретного автора. Завдання з перевіряння справжності даних найчастіше вирішується за допомогою цифрового підпису.

> **_Зауваження._** *Доступність, на відміну від інших перелічених послуг, забезпечується не криптографічними методами (резервування, використання систем безперебійного живлення тощо).*

### Поняття ключ

*Сучасний криптографічний ключ – це цифрова послідовність певної довжини, створена за певними правилами, з використанням генераторів випадкових чисел та розрахована за допомогою спеціального алгоритму*. Криптографічний ключ – це важливий складник криптографічних операцій. Безпечність криптографічних схем здебільшого залежить від захищеності ключів.

У загальному розумінні в Bitcoin *особистий ключ (private key)* – це велике випадкове натуральне число фіксованої довжини. Є спеціальні програмні й апаратні генератори випадкових чисел, на основі яких формується випадкова послідовність фіксованої довжини (у разі програмних генераторів насправді більш коректно говорити про *псевдовипадкові* числа). Особистий ключ – це натуральне число сталої довжини, яке сформовано за допомоги таких генераторів. Відкритий ключ отримується з особистого за допомогою математичних перетворень (рис. 3.1).

![Рисунок 3.1 – Зв’язок відкритого й особистого ключів](/resources/img/volume-1/3.1-introduction-to-cryptography/3.1-public-and-private-relation.png)

> **_Зауваження._** *Для криптографічних алгоритмів, які вважаються досить надійними (згідно з криптографічними стандартами), обернене перетворення – тобто отримання особистого ключа з відкритого – неможливо здійснити практично.*

Є певні методи в галузі криптоаналізу, що дозволяють атакувати криптографічні схеми ефективніше, ніж простим перебиранням чисел. Утім, для великих довжин ключів практична реалізація атаки вимагає великих обчислювальних ресурсів, тому процес може затягнутися на дуже тривалий термін (мільярди років або навіть довше).

### Генерування й обробляння секретних ключів

На практиці дуже важливо, щоби схеми формування ключів і цифрового підпису працювали коректно, а механізми організації безпеки були надійними. У криптовалютах *володіння монет доводиться знанням особистого ключа, який потрібен для обчислення дійсного цифрового підпису*. Для володільця ключа важливо, щоби ніхто інший не міг украсти, обчислити чи згенерувати такі самі ключові дані.

Що це означає? Користувачі Біткоіна й інших криптовалют повинні використовувати надійні генератори випадкових чисел, які видають дійсно випадкові послідовності в такий спосіб, що зловмисник не може повторити процес генерації й отримати ключ користувача, оскільки буде перебувати в інших умовах. Було відзначено, що генератори можуть бути програмними та апаратними. Чим вони відрізняються?

*Програмні генератори* в прямому сенсі не можуть генерувати випадкові числа. Вони генерують т. зв. *псевдовипадкові числа* (послідовності чисел). Це означає, що через певний період, числа починають повторюватися. Можна визначити цей період, на якому циклічно будуть повторюватися числа, а здебільшого він відомий заздалегідь. Очевидно, що зловмисник може скористатися такими знаннями.

*Апаратні генератори* найчастіше будуються на основі стохастичних процесів, які складно або неможливо передбачити. Наприклад, можуть використовуватися діоди Зенера або радіоактивне випромінювання, а також спеціальні датчики, які вловлюють шум цих процесів, оцифровують його та в результаті формують потік випадкових біт. На основі даних із цього потоку можна генерувати ключі для застосування в криптографічних схемах.

Важливість процесів генерації можна проілюструвати на такому прикладі. На ранніх стадіях розвитку Bitcoin був один лише гаманець для Android-пристроїв – Bitcoin Wallet. Розробники цього додатка допустили вразливість у коді програмного генератора випадкових чисел. Він генерував числа в певному вузькому діапазоні, тобто можна було передбачити підмножину можливих ключів, які належали користувачам цього гаманця. Зловмисник міг перебирати ключі в цій підмножині і з великою ймовірністю отримувати такі, до яких прив’язані чужі монети. Так і сталося. Ця обставина призвела до великого скандалу, тому що було викрадено значну кількість біткоінів. Зрозуміло, що незабаром було випущено оновлення, у якому вразливість була усунена, але факт розкрадання вже ж трапився.

Отже, генерації випадкових чисел, особливо в таких випадках, потрібно приділяти особливу увагу. Генератор випадкових чисел може використовувати комбінацію обох реалізацій: програмної та апаратної. Отже, можна використовувати шум із мікрофона смартфона або показання з таких датчиків, як гіроскоп або акселерометр, для підвищення випадковості через внесення більшої *ентропії* (хаотичності, непередбачуваності) [30] в процес генерації випадкових чисел.

*Компрометація ключів* – це поняття, яке передбачає факт доступу сторонніх осіб до секретних ключів, або можливість такого доступу, або підозру на таку можливість.

Скомпрометований особистий ключ становить серйозну небезпеку для будь-якої системи захисту інформації, тому приймаються спеціальні заходи для захисту особистих ключів (або інших конфіденційних даних): їх ніколи не записують на жорсткий диск комп’ютера у відкритому вигляді, а тримають на окремих носіях, зашифровують, захищають паролем тощо.
Якщо є підозра, що ключі скомпрометовані, їх дія припиняється й починається процедура їх заміни, перевипуску тощо.

### Поняття односпрямована функція й NP-повна задача

Перш ніж познайомитися з геш-функціями, розгляньмо, що таке односпрямована (одностороння) функція та які властивості вона має. Односпрямована функція – це математична функція, для якої:

* Розрахувати вихідне значення доволі просто для будь-якого вхідного аргумента 
* Розрахувати вхідний аргумент для заданого вихідного значення складно (це означає розв’язати NP-повну задачу)

Як один із простих прикладів можна навести розбиту чашку: зібрати всі її уламки та відновити з них цілу чашку дуже клопітно. У схожий спосіб працює односпрямована функція: передбачається, що ви не зможете знайти вхідні дані, маючи тільки вихідне значення. Теоретично така можливість є, але на практиці ця задача надзвичайно складна (за умови, що односпрямована функція достатньо надійна).

NP-повна задача – це задача, у якій потрібно знайти об’єкт, що задовольняє визначеним умовам. Дотримуючись нашого прикладу, розв’язання такої задачі рівнозначне відновленню розбитої чашки. Знаходження початкового об’єкта – складне завдання, яке є перебирання великої кількості можливих варіантів. Але за наявності готового розв’язку доволі просто перевірити, чи задовольняє цей розв’язок умовам.

Проблема рішення NP-повної задачі дуже важлива для сучасної криптографії. Тому що якщо знайдеться швидкий спосіб вирішення таких задач, то під загрозою опиняться багато сучасних криптопримітивів. До таких задач можна віднести задачу знаходження прообразу геш-функції, знаходження секретного ключа, що відповідає визначеному відкритому ключу, а також так звану задачу комівояжера (її ми розглянемо трохи докладніше).

Задача комівояжера полягає в знаходженні найбільш вигідного маршрута з усіх можливих. Згідно з умовами необхідно пройти через усі зазначені міста, після чого повернутися до початкового міста. Водночас переміщення між двома містами має визначену вартість. Щоби розв’язати цю задачу та вибрати оптимальний маршрут, комівояжеру потрібно перебрати всі можливі варіанти переміщення. Відзначмо, що складність знаходження такого маршрута експоненційно зростає зі збільшенням кількості міст. Якщо в умові задачі буде 5 таких міст, то отримаємо 12 можливих варіантів переміщення, а за наявності 10 міст доведеться перебрати 181 440 варіантів.

### Геш-функції

Тепер слід розглянути таке важливе поняття, як геш-функція. *Геш-функція – це функція перетворення масиву вхідних даних довільної довжини у вихідний бітовий рядок фіксованої довжини, що виконується за допомогою певного алгоритму*.

Геш-функція односпрямована, тому що, маючи вихідне значення, тобто число певної довжини, неможливо визначити, які дані було подано на вхід. Вона вважається криптографічно безпечною, якщо її можна атакувати лише «грубою силою», тобто перебирати всі можливі варіанти вхідних значень і намагатися знайти вихідне значення, що відповідає заданому. Схематично принцип роботи геш-функції матиме вигляд, як зображено на рис. 3.2.

![Рисунок 3.2 – Принцип роботи геш-функції](/resources/img/volume-1/3.1-introduction-to-cryptography/3.2-principle-of-hash-function.png)

На вхід геш-функція може приймати повідомлення практично необмеженого розміру (будь-які дані), а на виході – унікальний ідентифікатор – геш-значення. Маючи геш-значення, отримане за допомогою криптографічно безпечної геш-функції, неможливо визначити, які дані були подані їй на вхід. До того ж, у Bitcoin використовується кілька різних алгоритмів гешування.

Улаштування функції гешування можна зрозуміти на прикладі такої функції, яка підраховує суму цифр у вхідному повідомленні. Така функція має такі особливості. По-перше, у цьому випадку, результат обчислюється досить швидко через простоту алгоритму підрахунку. По-друге, така функція дійсно односпрямована, позаяк вихідне значення містить дані тільки про суму цифр у повідомленні, але не про їхнє розташування. Тобто складність відновлення вихідного повідомлення зростає з його довжиною (рис 3.3).

![Рисунок 3.3 – Приклад дії спрощеної геш-функції](/resources/img/volume-1/3.1-introduction-to-cryptography/3.3-silly-hash-function.png)

Однак використання такої функції небезпечне з погляду простоти знаходження колізій, позаяк у цьому випадку дуже просто замінити вхідне повідомлення (тобто подати на вхід функції повідомлення з тими ж числами, що вказані на рис. 3.4).

![Рисунок 3.4 – Приклад колізії геш-функції](/resources/img/volume-1/3.1-introduction-to-cryptography/3.4-silly-hash-colision.png)

Розберімося ж, які властивості повинна мати геш-функція, щоби її використання було якнайбезпечніше для користувача.

> **Вимоги до геш-функції**
>> * *Стійкість до колізій*
>> * *Стійкість до пошуку першого прообразу*
>> * *Стійкість до пошуку другого прообразу*

Стійкість геш-функції до колізій означає, що в ній відсутній алгоритм, що дозволяє знаходити колізії за порівняно короткий час. Колізією називають ситуацію, коли є декілька вхідних значень, яким відповідає те саме значення на виході геш-функції (рис. 3.5).

![Рисунок 3.5 – Колізія геш-функції](/resources/img/volume-1/3.1-introduction-to-cryptography/3.5-collision.png)

*Стійкість до пошуку першого прообразу* (незворотність) є вимогою до геш-функції, за виконання якої неможливо відновити вхідне повідомлення за реальний час, знаючи тільки відповідне йому геш-значення.

*Стійкість до пошуку другого прообразу* є вимогою, що передбачає, що за її виконання сторона, що має вихідне повідомлення і відповідне йому геш-значення, не може створити ще одне повідомлення, що на виході геш-функції надасть той же самий результат.

Також криптографічно стійка геш-функція повинна мати властивість, згідно з якою зміна одного біту на вході повинна призводити до зміни близько половини вихідних бітів. Проілюструвати на прикладі таку властивість можна так (рис. 3.6). Допустимо, що ми формуємо транзакцію, у якій вказано, що ми пересилаємо Алісі 10 біткоінів, й обчислюємо відповідне геш-значення. Якщо хтось забажає підмінити транзакцію й дописати, наприклад, що переводиться не 10 біткоінів, а 100, то підробку транзакції буде виявлено відразу.

![Рис 3.6 – Зміна вихідного значення геш-функції залежно від вхідного](/resources/img/volume-1/3.1-introduction-to-cryptography/3.6-input-affect-output.png)

Як приклад однієї з достатньо сучасних геш-функцій, принцип функціонування якої досить просто пояснити, наведемо SHA-1 [31]. Фактично, робота цієї функції полягає в циклічному перемішуванні (80 циклів) і використанні основних бітових операцій (and, xor, rot, add, or) з використанням вхідних даних. На рис. 3.7 подано один цикл роботи геш-функції SHA-1, де

* К<sub>t</sub> константа;
* F<sub>t</sub> змінна-функція (змінюється кожні 20 циклів); 
* W<sub>i</sub> модифікований елемент вхідного повідомлення (4 байт);
* <<<*x* циклічний зсування вліво на х позицій.

![Рисунок 3.7 – Схема роботи алгоритму SHA-1](/resources/img/volume-1/3.1-introduction-to-cryptography/3.7-sha1.png)

### Застосування геш-функцій

Очевидно, що гешування дуже зручно використовувати для отримання унікального ідентифікатора набору даних. У разі Bitcoin, роль геш-функції полягає у timestamping і зв’язуванні блоків, а також здатності повертати ідентифікатор даних (доводити наявність даних), не розголошуючи самих даних. Як наслідок, геш-функції набули широкого поширення. Розглянемо основні варіанти їх застосування.

Геш-значення використовуються в якості контрольних сум під час передавання даних. Щоби перевірити, що повідомлення не було випадково порушено через якихось шумів у каналі передачі даних, сторона-отримувач може повторно обчислити геш-значення від отриманих даних і порівняти його з уже наявними.

Крім цього, такі функції використовуються для пошуку дублікатів даних, що зберігаються, або для порівняння великих масивів даних. Щоби не порівнювати великі обсяги даних безпосередньо, можна зберігати відповідні їм значення геш-функцій і порівнювати тільки ці значення. Якщо значення геш-функції для різних наборів даних збігаються, значить із дуже великою ймовірністю й самі дані збігаються. Це значно прискорює процес, наприклад, під час формування цифрового підпису. Зазвичай під час підписання документа підписуються не самі дані повідомлення, а геш-значення від них. Водночас вважається, що це геш-значення передається разом із повідомленням і підписом: так одержувач може перевірити й цілісність повідомлення, і коректність цифрового підпису.

### Дерева Меркла

Дерева Меркла – це структура даних, яка дозволяє зв’язати окремі фрагменти даних у єдине кореневе значення та згодом довести, що певний блок даних відповідає конкретному кореневому значенню. Концепцію побудови таких дерев уперше опублікував в 1979 році Ральф Меркл (Ralph C. Merkle) [32]. Одним із перших застосувань дерев Меркла став протокол BitTorrent.

Дерево Меркла містить такі компоненти (рис. 3.8):

* Листки дерева (Merkle leaves) 
* Вузли дерева (Merkle nodes) 
* Корінь дерева (Merkle root)

![Рисунок 3.8 – Структура дерева Меркла](/resources/img/volume-1/3.1-introduction-to-cryptography/3.8-merkle-tree.png)

Листки дерева Меркла – геш-значення від блоків даних, які необхідно зібрати в структуру. Вузол дерева є значенням, яке було отримано в результаті конкатенації та подальшого гешування двох дочірніх вузлів або листів. Корінь дерева Меркла – це вузол, що перебуває на вершині дерева.

> **Особливості дерев Меркла**
>> * Зміна хоча б одного біта в одному з блоків даних повністю потягне за собою зміну значення Merkle root
>> * За порушення цілісності одного з блоків можна досить швидко й точно визначити який саме блок був модифікований
>> * Є можливість швидко довести чи входить певний блок до структури дерева Меркла

### Симетричне шифрування

Простими словами, *шифрування документа – це видозміна тексту документа в такий спосіб, що тільки той, хто має відповідний ключ, має можливість відновити вихідний текст*. Розглянемо докладніше, як працює шифрування.

Почнімо з найбільш зрозумілого типу – симетричного шифрування. Схематично цей процес буде виглядати так, як показано на рис. 3.9.

![Рисунок 3.9 – Схема симетричного шифрування](/resources/img/volume-1/3.1-introduction-to-cryptography/3.9-symmetric-encryption.png)

Є функція, яка виконує шифрування даних: на вхід вона приймає відкритий текст і ключ шифрування, а на виході повертає зашифровані дані, або, як часто говорять, шифротекст. Також є інша функція, яка виконує розшифрування: на вхід вона приймає зашифровані дані й точно такий же ключ шифрування, а на виході повертає відкриті дані, тобто вихідний текст. Цей тип шифрування називають симетричним, тому що для шифрування й розшифрування застосовується один і той же ключ.

Яскравий приклад симетричного шифрування – шифр Вернама, або ж *одноразовий блокнот* (рис 3.10). Суть метода полягає в складанні за модулем вхідного тексту з одноразовим ключем. У цьому випадку ключ шифрування (він же є ключем розшифрування) повинен бути рівним за довжиною вхідному повідомленню. Такий шифр – яскравий приклад абсолютно стійкого шифру. Це значить, що за перехоплення тільки шифртексту, зловмисник не може отримати жодної інформації про вхідне повідомлення.

![Рисунок 3.10 – Приклад роботи шифра Вернама](/resources/img/volume-1/3.1-introduction-to-cryptography/3.10-vernam-cipher.png)

Цей метод шифрування може вважатися достатньо безпечним за умови, що ключ був згенерований у випадковий спосіб. Генерування випадкового ключа також накладає свої обмеження, оскільки генератори дійсно випадкових чисел доволі повільні (порівняно з пропускною здатністю каналів, якими передаються секретні дані).

Наведімо структурну схему для одного із сучасних симетричних шифрів, а саме Advanced Encryption Standard (AES) [33] (рис 3.11). Цікава особливість цього шифру – подання даних у формі байтових матриць, над якими і здійснюються всі операції.

Основні операції, що використовуються в AES, – такі:

* *Substitute* (підстановлення) – замінювання елементів матриці відповідними табличними значеннями 
* *Shift Rows* (зсування рядків) – циклічне зсування рядків матриці вліво на відповідну кількість елементів 
* *Mix Columns* (перемішування стовпців) – множення стовпців матриці на статичну, заздалегідь визначену матрицю 
* *Add Round Key* – складання матриці стану з раундовим ключем

![Рисунок 3.11 – Конструкція шифру AES](/resources/img/volume-1/3.1-introduction-to-cryptography/3.11-aes.jpg)

У симетричного шифрування є й недоліки. Один із них пов’язаний із необхідністю забезпечувати конфіденційність секретного ключа під час його передавання одержувачу повідомлення до початку взаємодії, оскільки для роботи необхідна наявність цього ключа й у відправника, і в одержувача. Другий недолік – складність створення та зберігання нового ключа для кожного нового учасника в системі, де використовується захищена комунікація, заснована тільки на симетричному шифруванні. Складність цього завдання збільшується квадратично зі збільшенням кількості учасників, оскільки кількість нових ключів зростає з появою нового користувача.

### Асиметрична криптографія

Асиметрична криптографія вперше було показано в 1970-х роках, і її поява стала революцією в криптографії. Асиметрична криптографія використовує не один ключ, а т. зв. *ключову пару*. Ключова пара складається, як правило, з *особистого ключа* та *відкритого ключа*. Особистий ключ ви повинні зберігати в секреті, а відкритий ключ можете передати своєму контрагенту, з яким будете надалі взаємодіяти.

Припустимо, Аліса хоче приймати від своїх друзів такі повідомлення, які тільки вона зможе прочитати. Тоді за схемою асиметричного шифрування вона генерує ключову пару. Особистий ключ вона залишає в себе, а відкритий розміщує де-небудь на своїй сторінці в соціальній мережі (або повідомляє його потенційному співрозмовникові іншим способом).

Коли один із друзів Аліси хоче відправити їй приватне повідомлення, він шифрує документ за допомогою відкритого ключа Аліси й може передавати цей документ через відкриті канали передачі даних. Отримавши повідомлення, Аліса розшифровує його своїм особистим ключем. Будь-яка інша сторона, яка б перехопила це повідомлення, не змогла б отримати доступ до тексту повідомлення.

Розгляньмо схематично (рис. 3.12), як працює асиметричне шифрування. Є функція шифрування, яка приймає на вхід відкриті дані і відкритий ключ, а на вихід повертає зашифровані дані. Обернена функція називається функцією розшифрування. Вона приймає зашифроване повідомлення й особистий ключ одержувача, а повертає відкритий текст цього повідомлення.

![Рисунок 3.12 – Схема асиметричного шифрування](/resources/img/volume-1/3.1-introduction-to-cryptography/3.12-assymetric-encryption.png)

### Цифровий підпис

Інший варіант застосування ключової пари – цифровий підпис.

Як він працює? Людина, яка хоче підписати повідомлення, спершу генерує ключову пару. Особистий ключ ця людина зберігає в себе, щоби сформувати цифровий підпис. А відкритий публікує, щоб одержувач підписаного повідомлення міг перевірити справжність цього повідомлення. Тепер, щоби підписати повідомлення, відправник використовує свій особистий ключ. Після цього він поширює два файли: підписане повідомлення і прикріплений підпис. Інша людина, яка хоче впевнитися, що документ був правильно сформований і правильно підписаний, може взяти відкритий ключ і повідомлення та перевірити, чи відповідає їм підпис.

> **_Зауваження._** *У схемі цифрового підпису відкритий ключ використовується для перевіряння підпису стосовно підписаного документа. Отже, відкритий ключ має передаватися в захищений спосіб (за відсутності сертифіката відкритого ключа, який містить дані про конкретну особу, зв’язану з ключем), щоби унеможливити підмінювання підпису разом із відкритим ключем.*

Функція формування підпису приймає на вхід повідомлення й особистий ключ автора, а на виході формує дані підпису, які прикріплюються до повідомлення (рис. 3.13). Далі, повідомлення разом із підписом відправляється одержувачу. Одержувач, щоби переконатися, що підпис коректний, викликає функцію перевірки. Ця функція приймає три параметри: повідомлення, значення підпису і відкритий ключ. Вона повертає значення логічної змінної, чи вірний підпис. Виявитися неправильним підпис може у випадках, коли або повідомлення було підмінено, або дані підпису були порушені, або для перевірки використовувався неправильний (пошкоджений або підмінений) відкритий ключ.

![Рисунок 3.13 – Схема цифрового підпису](/resources/img/volume-1/3.1-introduction-to-cryptography/3.13-digital-signature.png)

### Модель загроз і модель порушника

Одна з необхідних умов для побудування надійної інформаційної системи – розроблення політики безпеки, для якої часто використовуються опис моделі загроз інформаційній безпеці та моделі її порушника.

Модель загроз – це структурований опис можливих загроз (джерела виникнення загрози, послуги інформаційної безпеки, на які спрямована та чи інша загроза, можливі способи здійснення).

Модель порушника – це структурований опис (характеристика) порушника (категорія, до якої може належати порушник, його мети, технічні можливості та кваліфікація).

Насамперед розгляньмо, хто може бути порушником у системі Bitcoin. Порушник – це фізична особа чи група осіб, що виконують дії, що порушують політику безпеки системи. Порушниками в Bitcoin можуть бути:

* Користувачі
* Валідатори
* Члени спільноти
* Власники bitcoin-сервісів
* Виробники гаманців

Також варто відзначити, що кожний із можливих порушників – учасник системи. Він може брати участь в управлінні нею, впливати на відповідне обладнання для його модифікування тощо. Інакше кажучи, немає майже жодних обмежень дій порушників для атаки на систему.

Яку ж мету може ставити порушник? По-перше, це змінення бази даних для змінення стану «балансів» користувачів. По-друге, це може бути спроба обмеження доступу певного вузла чи низки вузлів до актуального стану бази даних. Крім того, сюди можна долучити нанесення шкоди шляхом впровадження вірусного ПЗ чи безпосередньої модифікації користувацького ПЗ.

Для повноти моделі порушника також розглядаються технічне забезпечення та кваліфікація порушника. Оскільки Bitcoin є децентралізованою системою, вузли якої можуть володіти всіляким рівнем забезпечення (від одинокого ноутбука до кластера), то слід припускати, що будь-який потенційний порушник може мати найновіше програмне й апаратне забезпечення, а також високу кваліфікацію.

Спробуймо описати модель загроз для Bitcoin. Розгляньмо послуги інформаційної безпеки, які повинна надавати облікова система Bitcoin, а також те, на порушення яких послуг може бути спрямовано загрози.

*Конфіденційність*. За замовчуванням Bitcoin не забезпечує цієї послуги безпеки. Тобто база даних загальнодоступна, і всі транзакції та повідомлення між користувачами передаються у відкритій формі.

*Цілісність*. Використання технології blockchain у Bitcoin орієнтовано саме на забезпечення цієї послуги безпеки (відповідно, її забезпечення потребує максимальної уваги до всіх процесів, що пов’язані з обробкою даних: зберіганням, передачею тощо).

*Доступність*. Як згадувалося раніше, база даних у Bitcoin загальнодоступна. Завдяки цьому кожен користувач може незалежно проводити аудит усіх процесів у межах облікової системи Bitcoin.

Зважаючи на категорії та можливості порушників, розгляньмо загрози, що можуть бути здійснені в Bitcoin:

1. Зловмисник може створити транзакцію, яка повторно витрачає монети (яка створює кошти «з повітря»). 
2. Зловмисник, що володіє доброю репутацією, може переконати спільноту прийняти оновлення з деякою вразливістю. 
3. Зловмисник може створити форк і внести деяку вразливість. Після цього він може якимось чином переключити деяку кількість користувачів на цільову (вразливу) систему. 
4. Зловмисник може побудувати небезпечний протокол понад Біткоіном і переконати учасників Біткоіна користуватися цим протоколом. 
5. Зловмисник може накопичити велику кількість обчислювальної потужності та спробувати створити альтернативні ланцюжки. 
6. Зловмисник може отримати доступ до обладнання інших учасників системи (і в підсумку заволодіти більшістю обчислювальної потужності). 
7. Зловмисник може змінити програмне забезпечення мережевого вузлу. 
8. Зловмисник може створювати підроблені сайти та гаманці (надавати недостовірну інформацію). 
9. Зловмисник може змінити своє обладнання (пристрої) і розповсюдити його. 
10. Зловмисник може змінити своє програмне забезпечення (гаманець).
11. Зловмисник може перехопити/підмінити будь-яке повідомлення між учасниками системи (наприклад для передання неправильної історії транзакцій чи обмеження доступу відповідного вузлу до поточного стану бази даних). 
12. Зловмисник може видавати себе за будь-якого з учасників системи або навіть імітувати цілу мережу (у такий спосіб зловмисник може нав’язувати альтернативну історію окремому користувачу або групі користувачів). 
13. Зловмисник може легко приховати свої дії (з огляду на те, що в межах протоколу Bitcoin користувачі не ідентифікуються). 
14. Зловмисник може ідентифікувати учасників транзакцій, аналізуючи інтернет-трафік (передбачається, що інтернет-провайдер може прослуховувати весь вхідний і вихідний трафік конкретного користувача).

Після того як ми згадали можливі загрози, не можна не сказати про те, як від них захиститися. Перші 4 загрози найбільш складно реалізувати, позаяк для цього потрібна велика підтримка зі сторони учасників системи. А оскільки від оновлень, що запропоновані, безпосередньо залежить безпека монет користувачів, то такі пропозиції будуть ретельно розглядатися і впровадити до них backdoors доволі проблематично.

Мета загроз 5 та 6 – заволодіти великою кількістю обчислювальної потужності. Реалізація цих загроз дуже витратна, і рідко вигода від таких атак перевищує витрати на її проведення. З іншого боку, для користувачів такі атаки дуже небезпечні, оскільки в цих випадках зловмисник обдурює користувачів, водночас уникаючи порушення самого протоколу.

Наступні 4 загрози (7–10) реалізувати набагато простіше попередніх. Найчастіше вони можуть бути реалізовані постачальниками програмного й апаратного забезпечення. З огляду на те, що аж ніяк не кожний користувач перевіряє вихідний код гаманця на наявність вразливостей, такі атаки вкрай імовірні. Вони можуть спричинити те, що користувачі втратять свої монети. Для захисту від таких атак користувачам рекомендується перевіряти програмне забезпечення гаманців на наявність вразливостей і використовувати програмне забезпечення тільки з довірених джерел.

4 загрози, що залишилися (11–14), провести найпростіше, оскільки вони реалізуються на мережевому рівні. Такі атаки дуже рідко можуть спричинити втрату монет з боку користувачів, однак обмежити доступ користувача до актуальної інформації та обмежити його дії в мережі можуть. Захистити децентралізовану систему від таких атак загалом важче, але це можливо зробити за допомогою збільшення кількості зв’язків кожного користувача з іншими вузлами мережі.
Незважаючи на все перелічене вище, передбачається, що зловмисник **не може**:

* Угадати, який відкритий ключ використовується для формування конкретної адреси 
* Отримати доступ до секретного ключа в пам’яті захищеного пристрою 
* Виявити другий (чи третій) пристрій, який зберігає один з особистих ключів MultiSig-адреси (див. 4.5)

## 3.2 Криптографія в Bitcoin

У цьому підрозділі розглядається те, як використання криптографічних властивостей еліптичної кривої дозволяє організувати взаємодію в trustless системах.

## Особливості роботи еліптичних кривих

Еліптична криптографія – найшвидший і найефективніший метод побудови асиметричних криптографічних перетворень у сучасному цифровому світі [34]. Зокрема, Bitcoin використовує ECDSA – стандартизований алгоритм цифрового підпису.

Еліптична крива (ЕК) над полем дійсних чисел складається з безлічі точок на площині, чиї координати задовольняють рівнянню y<sup>2</sup> = x<sup>3</sup> + ax+b, де a і b – дійсні числа, і т. зв. нескінченно віддаленої точки, яка не має дійсних координат. Зазначене канонічне рівняння – окремий випадок рівняння Веєрштрасса. Національний інститут стандартів і технологій США (NIST) рекомендує 15 еліптичних кривих для використання в алгоритмах цифрового підпису [35]. Найчастіше використовуються псевдовипадкові еліптичні криві (параметри ЕК і поля генеруються в псевдовипадковий спосіб, часто за допомогою геш-функцій). Однак крива в Bitcoin не належить до тих, які рекомендує NIST, і є ЕК спеціального призначення, оскільки коефіцієнти та базове поле було спеціально підібрано для більшої ефективності операцій. У Bitcoin a=0, а b=7, тому еліптичну криву задано рівнянням y<sup>2</sup> = x<sup>3</sup> + 7 [36]. Графік цієї кривої показано на рис. 3.14, а більш детально ділянку кривої, що містить точки перегину, – на рис. 3.15.

![Рисунок 3.14 – Еліптична крива в Bitcoin](/resources/img/volume-1/3.2-cryptography-in-bitcoin/3.14-ec-in-bitcoin.png)

![Рисунок 3.15 – Ділянка кривої з точками перегину](/resources/img/volume-1/3.2-cryptography-in-bitcoin/3.15-curve-segment.png)

Основні операції в групі точок еліптичної кривої – такі: *складання*, *подвоєння* і *множення на скаляр*. Відзначмо, що результат кожної з перерахованих операцій – також точка, яка належить ЕК [37].

*Складання точок ЕК, заданої над полем дійсних чисел, має просту геометричну інтерпретацію (рис. 3.16). Сумою двох точок A<sub>1</sub> й A<sub>2</sub> називають третю точку A<sub>3</sub>=A<sub>1</sub>+A<sub>2</sub>, симетричну відносно осі Ox до третьої точки (-A<sub>3</sub>) перетину еліптичної кривої та прямої, що проходить через точки A<sub>1</sub> й A<sub>2</sub>*.

*Множення на скаляр – це багаторазове складання точки із самою собою*. На рис. 3.17 графічно показано, як відбувається подвоєння точки.

![Рисунок 3.16 – Сума точок ЕК](/resources/img/volume-1/3.2-cryptography-in-bitcoin/3.16-addition.png)

![Рисунок 3.17 – Подвоєння точки ЕК](/resources/img/volume-1/3.2-cryptography-in-bitcoin/3.17-doubling.png)

### Створення адрес у Bitcoin

Розуміння принципів роботи геш-функцій і особливостей генерації ключів для ECDSA досить, щоби перейти до генерування адрес у Bitcoin. У найпростішому разі адреса отримується з відкритого ключа внаслідок застосування алгоритмів гешування (рис. 3.18), які мають назву Secure Hash Algorithm II (SHA-2) та RACE Integrity Primitives Evaluation Message Digest (RIPEMD), а саме – SHA256 і RIPEMD160.

![Рисунок 3.18 – Схема обчислення адреси в Bitcoin](/resources/img/volume-1/3.2-cryptography-in-bitcoin/3.18-address-in-Bitcoin.png)

Відкритий ключ гешують за допомогою SHA256, а для результату знову розраховується геш-значення, але вже за допомогою RIPEMD160. На виході отримують 160-бітне (20-байтне) число. Далі це число подається в кодуванні Base58Check. Під час кодування прикріплюються 4-байтна контрольна сума та 1-байтна версія, а далі відбувається перетворення 25-байтного числа в рядок відповідно до алфавіту кодування. Підсумковий 35-символьний рядок і вважається біткоін-адресою.

> **_Зауваження._** *Формат адреси, яка створюється згідно зі схемою вище, має назву P2PKH (pay to public key hash). Інші формати біткоін-адреси розглядаються в 4.5.*

Алфавіт кодування Base58Check схожий на алфавіт широко застосовуваного кодування base64, але тут відсутні символи, які важко розрізнити, як-от «I» (велика «i») і «l» (маленька «L»), «O» (велика «o») і «0» (нуль), а також не використовуються символи «+» і «/».

Чому визначено саме такий порядок формування адрес у Bitcoin? По-перше, приховування відкритого ключа захищає користувачів від крадіння монет, якщо буде зламано алгоритм цифрового підпису. По-друге, різні функції було застосовано задля зниження ризику атаки на геш-функції: було взято незалежні стандарти, і ймовірність, що обидва містять backdoor, дуже мала.

### Конфіденційність у Bitcoin

Протокол Bitcoin обробляє дані транзакцій у блоках, отримуючи та передаючи їх глобальною мережею. Під час передавання дані не шифруються, а залишаються у відкритій формі. Немає сенсу в спробах захистити ці дані від переглядання з боку сторонніх осіб, тому що вони захищені геш-значеннями або навіть завірені цифровим підписом. Крім того, ці дані відкриті для того, щоби їх міг верифікувати будь-хто охочий.

Мало не одна лише мета, заради якої може бути застосовано шифрування даних, що передаються в мережі Bitcoin, – підвищення рівня приватності самого вузла мережі. Це важливо, коли володілець вузла бажає вести свою діяльність анонімно (докладніше в 7.1).

### Основні вектори атак на ключі в Bitcoin 

Зловмисна сторона може скомпрометувати ключі користувача в декілька способів:

* Зламування математики (еліптичної кривої, алгоритму генерації ключів, алгоритму гешування чи алгоритму цифрового підпису)
* Зламування апаратного пристрою, яке генерує ключі чи виробляє цифровий підпис 
* Зламування комутаційних протоколів (handshake, обмін ключами, TLS, процес верифікації підпису тощо)
* Зламування програмного забезпечення гаманців (генерація ключів, зберігання ключів, внесення шкідливого коду тощо)
* Соціальні атаки

**Часті запитання**

*– Чи використовується генератор випадкових чисел під час обчислення відкритого ключа за схемою ECDSA?*

Ні. Відкритий ключ обчислюється з особистого, і це обчислення односпрямоване. Bitcoin використовує криптографію, що ґрунтується на власній еліптичній кривій, яку визначено рівнянням y<sup>2</sup>=x<sup>3</sup>+7. Відкритий ключ – точка з координатами x й y. Оскільки особистий ключ – це деяке велике натуральне число, обчислити відкритий ключ можна в такий спосіб: *public_key* = *private_key* · *G*, де *G* – базова точка. Результат цієї операції – нова точка на кривій, яка і є відкритий ключ. Базова точка G – це сталий параметр зі специфікації secp256k1. Маючи відкритий ключ, можна згенерувати адресу гаманця.

*– Чи можливо розділити P на G й отримати особистий ключ у такий спосіб?*

У криптографії це називають розв’язанням задачі знаходження дискретного логарифма в групі точок еліптичної кривої. Безпосередньо це рівняння не розв’язується. Розв’язок знаходять за допомогою криптоаналізу. Є методи, які теоретично можуть дозволити це зробити, але вони потребують дуже великих обчислювальних потужностей і великого обсягу пам’яті, які на сьогодні недоступні.

*– Чи відкритий ключ потрібен тільки для отримання адреси?*

Ні, окрім отримання адреси, відкритий ключ використовують для отримання та витрачання монет. Спочатку користувач обчислює адресу, а після на нього отримує монети. Під час витрачання монет користувач публікує відкритий ключ, щоби довести, що саме він – володілець цієї адреси. Усі ті, хто перевіряє, обчислюють геш-значення від відкритого ключа та перевіряють, чи збігається воно з адресою.

*– Чим загрожує квантовий комп’ютер Біткоіну?*

Станом на 2018 рік реалізовано квантовий комп’ютер із такою довжиною регістру, що він не загрожує криптографії, яка використовується в Біткоіні. Але квантові комп’ютери поступово розвиваються, і довжина регістру збільшується, тобто збільшується складність задач, які вони можуть вирішувати за дуже короткі проміжки часу. Припускається, що через роки квантовий комп’ютер зможе бути загрозою для сучасної еліптичної криптографії. Тоді буде можливо обчислити особистий ключ, знаючи відкритий. Однак це може статися, тільки якщо криптографія в Bitcoin не оновлюватиметься, що малоймовірно.

*– Як можна послабити загрозу квантового комп’ютера алгоритмам, які застосовуються в Bitcoin?*

Передусім, відзначмо, що може вийти оновлення протоколу Bitcoin (використання довших ключів для цифрового підпису або реалізація постквантового алгоритму цифрового підпису). Якщо ж протокол не оновиться, то навіть за поточними правилами зловмисник матиме приблизно 10 хвилин на підібрання ключа, створення альтернативної транзакції та спробу її підтвердити, тому що середній час першого підтвердження звичайної транзакції дорівнює 10 хвилинам (з моменту її розповсюдження в мережі). Коли користувач отримує монети на свою адресу, він ще не публікує відкритий ключ й атакувати його неможливо (на практиці одночасно зламати геш-функції SHA-2 та RIPEMD160 навряд вийде). Відкритий ключ цифрового підпису можна атакувати тоді, коли біткоіни витрачаються (вихідна транзакція відправляється до мережі). Тому можна сказати, що безпосередньо квантовий комп’ютер не загрожує зберіганню біткоінів станом на 2018 рік. А згодом протокол Bitcoin можна буде оновити. До того ж, імовірність здійснення атаки залежить від фінансової вигоди: для маленьких сум атака квантового комп’ютера буде недоцільною, тому що витрати багаторазово перевищать розмір прибутку.

*– Чи можна ідентифікувати конкретну особу в Біткоіні, зіставивши її з цифровим підписом?*

Ні. Це не так, тому що такий цифровий підпис не сертифікується. У Біткоіні немає центрів сертифікації, які видавали би сертифікати відкритих ключів користувачів. Тому однозначно ідентифікувати особу дуже непросто. Тому Bitcoin і вважається порівняно анонімним. Але ви можете спробувати зробити це в інші способи. Наприклад, ідентифікувати контрагента під час обмінювання біткоінів на готівку, робити мічені купюри, відстежувати, за допомогою якого ПЗ та з яких IP-адрес було відправлено транзакції. Але за замовчуванням підпис не зв’язаний із особою.

## 3.3 Зберігання й оброблення ключів

Незважаючи на наявність у деяких країнах законодавства та практики використання цифрового підпису та цифрової identity, можна сміливо стверджувати, що використання цих механізмів було й залишається вкрай незначним. Однак саме з появою Bitcoin стало зрозуміло, що оцифровка реєстрів прав власності для всіх активів – неминуче явище, що відповідає потребам ХХІ століття. З огляду на особливості своєї архітектури Bitcoin міг спиратися тільки на цифровий метод завірення транзакцій, щоби навіть торговий робот міг стати користувачем мережі. Найоптимальніший спосіб реалізації такої взаємодії між користувачами Bitcoin полягав у застосуванні криптографічних ключів і схем цифрового підпису. Цей підхід потребував від користувачів дбайливого ставлення до використання ключів. Тому питання управління життєвим циклом (генерації, зберігання, відновлення) ключів мають колосальну важливість.

У цьому підрозділі ми заглибимося в процеси зберігання й обробки ключів цифрового гаманця, а також розглянемо найбільш актуальні підходи до реалізації цих процесів. Матеріал дає змогу зрозуміти, як працюють гаманці, як можна їх класифікувати залежно від підходу до обробки ключів, а також оцінити ризики й переваги кожного підходу.

### Головне завдання цифрового гаманця

Коли ми говоримо про гаманець, зазвичай маємо на увазі дещо, призначене для зберігання грошей. Це вводить користувачів цифрових валют в оману, тому що деякі помилково вважають, що цифрові гаманці використовуються для зберігання монет. Насправді це не так. Цифрові монети – це абстракція, насправді їх немає, і вони ніде не зберігаються (див. 4.1). Але які ж тоді процеси проходять у цифрових гаманцях і як їх краще організувати?

Гаманці використовуються для зберігання ключів, за допомогою яких відбувається управління монетами користувача. Відповідно, основні функції гаманця – це зберігання ключів і управління ними. Реалізація цих функцій можлива завдяки правильному проектуванню цифрового гаманця.

> **Модулі цифрового гаманця**
>> * *Модуль генерування та зберігання ключів*
>> * *Модуль синхронізування актуального стану*
>> * *Модуль оброблення наявних транзакцій*
>> * *Модуль формування та підписання транзакцій*

Цифрові гаманці можуть мати розширену функціональність, яка може дуже сильно відрізнятися від одного застосунку до іншого. Однак кожен цифровий гаманець забезпечує механізми завірення транзакцій і відновлення доступу, функціональність прийому платежів і відображення балансу, а також відображення історії транзакцій та відправки платежів.

### Основні підходи до синхронізації гаманця

> * *Ключі зберігаються й обробляються на віддаленому сервері*
> * *Ключі зберігаються на віддаленому сервері, але обробляються користувачем*
> * *Ключі зберігаються й обробляються в застосунку користувача*
> * *Поєднання попередніх підходів через використання мультипідпису*

Коли мова йде про зберігання особистих ключів, зазвичай мається на увазі, що користувач повинен вирішити завдання, як-от захист від утрачення, захист від крадіння, резервне копіювання (backup) й експортування особистих ключів для використання на інших пристроях. Зараз, на жаль, немає такого підходу, який надав б ідеальне рішення, що задовольняло б усім вимогам [38]. Тому до зберігання ключів сформувалося декілька основних підходів.

Кожен підхід має свої переваги та недоліки, і вибір кожного з них може бути раціональним залежно від конкретних вимог. Розрізняються вони за місцем зберігання ключів і за місцем їх оброблення.

### Оброблення та зберігання ключів на сервері

Випадок, коли ключі зберігаються й управляються на виділеному сервері, – один із найпростіших. Сервіс, який надає послугу у вигляді такого гаманця, повністю контролює ключі. Відповідно, користувачі гаманця не мають ніякого доступу до ключів, тобто вони не володіють реальною криптовалютою. Такі сервіси надають кожному користувачу особистий акаунт із віртуальним рахунком, для якого зарезервована відповідна кількість монет цифрової валюти (рис. 3.19). Але реальний доступ до цих монет забезпечують тільки ключі, якими володіє сервіс.

![Рисунок 3.19 – Ключі зберігаються й обробляються на віддаленому сервері](/resources/img/volume-1/3.3-keys-storage-and-processing/3.19-remote-server.png)

Слід розуміти, що в цьому разі можливі два варіанти переказу монет між користувачами:

* Між двома користувачами одного централізованого сервісу 
* Між користувачем сервісу та користувачем біткоін-гаманця

У першому варіанті все достатньо просто. Оскільки монети криптовалюти не виходять за межі системи, можна просто переписати баланси користувачів у їхніх акаунтах, водночас не створюючи *on-chain транзакцію*.

Якщо ж нам потрібно отримати кошти з зовнішнього гаманця або вивести їх на зовнішній гаманець, то без формування транзакції не обійтися. У цьому разі транзакцію створює сервіс, і він, відповідно, відправляє зі своїх ключів кошти на зовнішній гаманець чи отримує їх на свої адреси і, отже, може їми розпоряджатися.

Цей вид гаманців доволі популярний завдяки перевагам, які отримують користувачі під час роботи з ним. По-перше, ви дійсно можете проводити миттєві платежі без комісії, оскільки ви не проводите ніяких реальних транзакцій. Саме з цієї причини сервіси здебільшого використовують цей підхід. Такі сервіси дозволяють забезпечити максимально простий доступ до акаунта з декількох пристроїв. Навіть якщо ви загубили пароль від аккаунта, ви легко можете відновити його.

Утім, такий підхід має певні недоліки. Один із них полягає в тому, що користувачі в такій системі не мають ніякого доступу до своїх монет. Вони не управляють ключами, а отже, не управляють і монетами цифрової валюти. Користувачі повністю залежать від таких сервісів: щоби використовувати інший сервіс, потрібно явно вивести всі кошти з поточного сервісу й надіслати їх на інший гаманець.

Це одна з найпростіших реалізацій гаманця під час розроблення. По-перше, усе управління та зберігання ключів здійснюється на сервері; найчастіше для роботи з гаманцем навіть не потребується власне програмне забезпечення. Для управління ключами використовується той гаманець, який зазвичай надається разом із повним вузлом мережі певної криптовалюти. Оскільки всі операції виконуються на сервері, то клієнтський застосунок дуже простий (як і його реалізація). Фактично, він займається тільки тим, що спілкується із сервером за допомогою APIs. Тим не менш, з огляду на те, що всі ключі не просто зберігаються на певному сервері, але й управляються на ньому, у певний момент часу вони зберігатимуться у відкритій формі в оперативній пам’яті чи, можливо, навіть на жорсткому диску. Вимоги до безпеки таких серверів дуже високі: потрібно максимально захистити сервер від можливості доступу зовні, зламу тощо.

### Ключі на сервері, але доступ до них має тільки клієнт

Другий підхід полягає в тому, що ключі зберігаються на сервері, але управління ключами виноситься вже до клієнтського застосунку. У цьому разі користувач має вищий рівень контролю над своїми монетами порівняно з попереднім підходом (рис. 3.20). Сервіс не має прямого доступу до особистих ключів клієнтів, хоча він їх і зберігає.

![Рисунок 3.20 – Ключі зберігаються на віддаленому сервері, але обробляються користувачем](/resources/img/volume-1/3.3-keys-storage-and-processing/3.20-stored-separately-with-direct-control.png)

Коли користувач реєструється в такому сервісі, він генерує на своєму пристрої (в мобільному гаманці чи веб-гаманці) особистий ключ, після чого шифрує його за допомогою пароля і відправляє на сервер уже в захищеному вигляді. Згодом, коли користувачу потрібно отримати особистий ключ, йому потрібно пройти автентифікацію й запросити в сервісу захищений контейнер із особистим ключем. Гаманець отримує цей контейнер, розшифровує особистий ключ і працює з ним безпосередньо на своєму пристрої.

Які ж переваги цього підходу? Як і в попередньому розглянутому підході, зберігається достатньо простий доступ до акаунту з декількох пристроїв. У цьому же разі користувач отримує прямий контроль над своїми ключами, а отже й безпосередньо над своїми монетами. Утім, повної залежності від сервісу він не позбавляється. Таким чином, якщо централізований сервіс буде недоступний, користувач втрачає доступ до своїх монет, якщо в нього не буде резервної копії особистих ключів.

Особливості під час розроблення полягають у тім, що алгоритми оброблення ключів і підписання транзакцій повинні бути реалізовані в застосунку користувача. Це може бути достатньо складно, особливо тоді, коли сервіс підтримує застосунки для декількох різним платформ, таких як Android, iOS, веб-застосунки тощо. Незважаючи на те, що особисті ключі користувача не зберігаються на серверах сервіса у відкритій формі, висуваються високі вимоги до його безпеки. Адже однаково інженери можуть знайти вразливість в алгоритмах забезпечення захисту секретних даних та автентифікації клієнтів такого сервісу та скористатися нею зловмисно. Деякі централізовані онлайн-гаманці використовують саме такий підхід до оброблення та зберігання ключів.

### Ключі на пристрої користувача

Наступний підхід – зберігання й управління особистими ключами користувача здійснюється безпосередньо на його пристрої. У цьому разі вам не потрібен ніякий back-end чи API. Користувач повністю контролює монети і, відповідно, більше незалежний від зовнішніх сервісів. Наприклад, не маючи доступу до мережі, він може зайти до свого гаманця, створити транзакцію і просто відправити її, коли з’явиться доступ до мережі (рис. 3.21). Користувач може передати цю транзакцію, навіть не підключаючи свій пристрій до мережі. Він може певним чином передати цю транзакцію на інший пристрій і вже з нього відправити її до мережі.

![Рисунок 3.21 – Ключі зберігаються й обробляються в застосунку користувача](/resources/img/volume-1/3.3-keys-storage-and-processing/3.21-keys-in-app.png)

Однак такий підхід також не ідеальний. Основним недоліком є необхідність зберігати ключі завжди на одному пристрої. Втрата цього пристрою чи його пошкодження тягнуть за собою втрату доступу до ключів. Якщо ж користувач забув пароль, за допомогою якого зашифровані особисті ключі, він також не зможе їх отримати назад. У такому випадку необхідно завжди здійснювати резервне копіювання особистих ключів і окремо зберігати резервну копію. Якщо потребується перенести ключ з одного пристрою на інший, прийдеться здійснити це вручну.

Трохи змінюються особливості розробки таких гаманців. Як і в попередньому випадку, логіка обробки ключів залишається на клієнті. Якщо спробувати створити кросплатформенні застосунки, проблеми залишаються такі ж, оскільки всі дані зберігаються на пристроях клієнтів і, за суттю, користувачі можуть безпосередньо спілкуватися з мережею для отримання стану балансу, а також для отримання і відправки транзакцій. Підвищуються вимоги до безпеки зберігання ключів. За використання різних платформ найчастіше застосовуються так звані платформозалежні способи. Наприклад, для пристроїв iOS використовується KeyChain, у якому можна зберігати секретні дані достатньо захищеним способом. Для того щоби мати можливість переносити ключі з одного пристрою на інший, гаманці такого типу передбачають обов’язковий ручний експорт та імпорт ключів. У найбільш простому випадку мова йде про гаманець з одним особистим ключем, а також функцією переглядання та введення особистого ключа в кодуванні WIF (Wallet Important Format).

Як  приклад застосування цього підходу можна навести мобільний гаманець Bitxfy, який зберігає й обробляє особисті ключі на пристрої користувача. Актуальні дані щодо транзакцій він отримує через довірені вузли мережі, які підтримує команда розробників.

### Зберігання монет із застосуванням мультипідпису

Останнім розглянемо підхід, який є змішаною моделлю зберігання ключів із використанням мультипідпису. Це навіть не окремий підхід, а комбінація з кількох попередніх методів, що дозволяє підвищити рівень безпеки зберігання ключів. За використання мультипідпису для відправлення монет потрібно кілька підписів різними особистими ключами, кожен із яких можна зберігати й обробляти на окремому пристрої незалежно від інших (рис. 3.22) (докладніше в 4.5).

![Рисунок 3.22 – Застосування механізму мультипідпису](/resources/img/volume-1/3.3-keys-storage-and-processing/3.22-multisig.png)

За допомогою цього способу можна, наприклад, реалізувати мультипідпис 2-із-3. Припустимо, є три ключі. Зберігання й управління одним із них буде здійснюватися з допомогою сервера, а іншими за допомогою смартфону. Щоби завірити транзакцію, достатньо її підписати будь-якими двома з цих ключів. Зовсім не обов’язково в цьому разі пересилати ключі між пристроями – досить переслати з одного пристрою на інший частково підписану транзакцію, щоби допідписати її іншим ключем.

З огляду на модель порушника (див. 3.1) найнадійніший спосіб зберігання монет – зберігання ключів на різних пристроях від незалежних виробників (Apple, Samsung, Huawei тощо), а також використання програмного забезпечення гаманців від незалежних розробників.

Приклади гаманців, які використовують мультипідпис, – сервіс Bitgo та гаманець Electrum. Але на момент 2018 року ці рішення ще не ідеальні, оскільки вони складні у використанні. Сподіваємося, надалі ці реалізації стануть кращими й на їх основі буде розроблено альтернативні застосунки.

### Холодні, теплі та гарячі гаманці

Вище було розглянуто основні варіанти розподілення відповідальності за зберігання й оброблення ключів цифрового гаманця. Тепер розберімо, як саме відповідальна особа може організувати процеси зберігання особистих ключів і підписання транзакцій. Тут також можна виділити три основних підходи (рис. 3.23):

* *Hot storage wallet* (гаманець «гарячого» зберігання) 
* *Warm storage wallet* (гаманець «теплого» зберігання)
* *Cold storage wallet* (гаманець «холодного» зберігання)

*Hot storage wallet – цифровий гаманець, у якому особисті ключі зберігаються пристроєм, що постійно має з’єднання з глобальною мережею.*

*Cold storage wallet – цифровий гаманець, у якому особисті ключі зберігаються й обробляються тільки на такому пристрої, що не має можливості прямого з’єднання з глобальною мережею.*

*Warm storage wallet – цифровий гаманець, у якому особисті ключі зберігаються тільки на такому пристрої, що підтримує з’єднання з глобальною мережею не постійно, а тільки за рішенням користувача, наприклад для відправки транзакцій чи оновлення їхніх статусів.*

![Рисунок 3.23 – Порівняння холодних, теплих та гарячих гаманців](/resources/img/volume-1/3.3-keys-storage-and-processing/3.23-comparison-of-wallets.png)

Програму-гаманець на смартфоні та багато цифрових гаманців для ПК можна віднести до групи hot storage wallets. Це найбільш зручні у використанні гаманці, але, потрібно враховувати, що теоретично інженеру з особливими здатностями простіше знайти вразливість саме в таких гаманцях. У цьому сенсі cold storage wallet – безпечніший варіант.

Проміжне положення між «гарячими» й «холодними» гаманцями займають warm storage wallets, розробники яких намагаються звести до мінімуму взаємодію гаманця з іншим цифровим світом, але зберегти при цьому деякі зручності «гарячих» гаманців.

**Часті запитання**

*– Чи правда, що користувачі, які зберігають монети на гаманцях із закритим вихідним кодом, можуть одного разу виявити відсутність своїх монет?*

Так, теоретично розробники гаманця можуть вкрасти ключі користувача через закладений backdoor у програмному коді, який навряд чи помітить звичайний користувач. Водночас така ж ситуація теоретично можлива й для open-source рішень, хоча вона й менш імовірна.

*– Чи зменшить імовірність наявності backdoor у цифровому гаманці той факт, що його вихідний код відкритий?*

Так, теоретично зменшить. Але не слід забувати, що, якщо вихідний код відкритий, це зовсім не значить, що користувач його проаналізував перед встановленням. І навіть якщо так, то користувачу необхідно самостійно його скомпілювати і встановити на свій пристрій, не забувши вимкнути автоматичне оновлення. Таким чином, користувач змушений довіряти розробнику застосунків, у яких він зберігає важливі дані.

*– Наскільки велика кількість вузлів мережі Bitcoin, до яких підключається клієнтський гаманець? Чи підключається він до тих самих вузлів?*

Все залежить від конкретної реалізації гаманця і його налаштувань. Гаманець може завжди підключатися до одного довіреного вузла в мережі, а може підтримувати зв’язок із декількома вузлами мережі, яким він навіть не довіряє, і виконати повну перевірку всіх даних на предмет відповідності правилам протоколу. Наприклад, реалізація гаманця Bitcoin Core підключається завжди до різних вузлів. Гаманець цієї реалізації може навіть віддавати перевагу певним вузлам залежно від їхньої загальної кількості, часу реагування, мережевих затримок і частоти отримання деяких даних від вузлів (і навіть від репутації вузла).

*– Як краще зберігати файли гаманців для мінімізації ризиків викрадення конфіденційних даних й особистих ключів користувачів?*

Є доволі багато способів. Щоби забезпечити мінімальний рівень захисту, що вбереже користувача від простих випадків зламу й дозволить йому достатньо безпечно зберігати кошти (якщо мова не йде про мільйони доларів), достатньо скористатися паролем, якщо можливість його встановлення підтримується. Тоді додатковим секретним ключем, отриманим із паролю, конфіденційні дані будуть зашифровані і, відповідно, на пристрої вони не зберігатимуться у відкритій формі.

*– Якщо користувач використовує програмний гаманець на своєму ПК, чи можуть інші програми вкрасти монети користувача?*

У загальному разі – можуть. Ризик цього доволі великий, і для великих сум рекомендується використовувати надійніші способи зберігання й оброблення особистих ключів.

*– Що робити, якщо особистий ключ був скомпрометований?*

У цьому разі слід припинити використовувати гаманець, ключі якого були скомпрометовані. Якщо причина порушення конфіденційності невідома, то варто навіть відмовитися від використання відповідного застосунку чи пристрою [39].

[ТЕХНОЛОГІЧНІ ДЕТАЛІ ФУНКЦІОНУВАННЯ BITCOIN](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-1/ua/4-technological-details-of-bitcoin-operation.md)