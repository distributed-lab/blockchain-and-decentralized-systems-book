# 3 КРИПТОГРАФИЯ И УПРАВЛЕНИЕ КЛЮЧАМИ


## 3.1 Введение в криптографию

В этом подразделе мы, не вдаваясь глубоко в детали, познакомимся с криптографией как наукой, ее задачами и основными механизмами. Здесь же будут рассмотрены специфические криптографические механизмы и функции, которые применяются именно в протоколе Bitcoin. Также обратим внимание на особенности работы с цифровой подписью и соответствующими цифровыми ключами; эти особенности имеют, прежде всего, практическое значение.

Роль *криптографии – науки о защите информации математическими методами* – в развитии информационных систем сложно переоценить. Биткоин, по сути, стал первой в мире платежной системой, где все процессы и операции защищены криптографически.

Читатель будет иметь возможность ознакомиться с основными принципами защиты информации, а после этого рассмотреть наиболее важные криптографические алгоритмы, которые имеют отношение к протоколу Bitcoin.

### Принципы криптографической защиты информации

Развитие криптографии началось с древних времен, ее история насчитывает 4 тысячи лет. Поначалу криптография решала всего одну задачу – обеспечение конфиденциальности при передаче и хранении данных. Для ее решения в давние времена использовались такие механизмы, как схемы перестановки слов текста, перестановки символов текста, использование альтернативных алфавитов и т. п.

В настоящее время криптография использует математическую базу. Применяются специальные преобразования, которые определены в таких разделах математики, как теория чисел, теория групп, теория колец, теория полей, а также в некоторых других разделах. Эта специфическая математика известна далеко не всем, поскольку ее не преподают в большинстве учебных заведений.

Современная криптография включает схемы симметричного и асимметричного шифрования, схемы цифровой подписи, схемы хэширования данных, методы управления ключами, схемы доказательств с нулевым разглашением и постквантовую криптографию.

> **Основные услуги безопасности**
>> * *Обеспечение ***конфиденциальности*** данных*
>> * *Обеспечение ***целостности*** данных*
>> * *Обеспечение ***доступности*** данных*
>> * *Обеспечение ***подлинности*** данных*

*Конфиденциальность* подразумевает, что неавторизованные лица не могут получить доступ к смысловому содержанию документа, который хранится либо передается. Чаще всего эта услуга обеспечивается с помощью шифрования (симметричного или асимметричного).

*Целостность* подразумевает, что неавторизованные пользователи не могут незаметно модифицировать данные. Задача по проверке целостности данных после чтения с носителя информации или получения из сети чаще всего решается с помощью хэширования и проверки контрольной суммы.

*Доступность* подразумевает, что субъекты, имеющие право на доступ к информации, гарантировано получат доступ к ней.

*Подлинность (аутентичность)* подразумевает возможность доказать, что данные были действительно получены от конкретного автора. Задача по проверке подлинности данных чаще всего решается с помощью цифровой подписи.

> **_Замечание._** *Доступность, в отличие от остальных вышеперечисленных услуг, обеспечивается не криптографическими методами (резервирование, использование систем бесперебойного питания и т. д.).*

### Понятие ключ

*Современный криптографический ключ – это цифровая последовательность определенной длины, созданная по определенным правилам, с использованием генераторов случайных чисел и/или рассчитанная согласно специальному алгоритму из других значений.* Криптографический ключ – это важная составляющая криптографических операций. Безопасность криптографических схем во многом зависит от защищенности ключей.

В общем понимании в Bitcoin *личный ключ (private key)* – это большое случайное натуральное число фиксированной длины. Существуют специальные программные и аппаратные генераторы случайных чисел, на основе которых формируется случайная последовательность фиксированной длины (в случае программных генераторов на самом деле более корректно говорить о *псевдослучайных* числах). С помощью данных генераторов создаются личные ключи. *Открытый ключ (public key)* получается из личного путем математических преобразований (рис. 3.1).

![Рисунок 3.1 – Связь открытого и личного ключей](/resources/img/volume-1/3.1-introduction-to-cryptography/3.1-public-and-private-relation.png)

> **_Замечание._** *Для криптографических алгоритмов, которые считаются достаточно надежными (согласно криптографическим стандартам), обратное преобразование – то есть получение личного ключа из открытого – невозможно совершить практически.*

Существуют определенные методы в области криптоанализа, которые позволяют атаковать криптографические схемы эффективнее, чем простым перебором чисел. Впрочем, для больших длин ключей практическая реализация атаки требует больших вычислительных ресурсов, поэтому процесс может затянуться на очень длительный срок (миллиарды лет или даже дольше).

### Генерация и обработка секретных ключей

На практике очень важно, чтобы схемы формирования ключей и цифровой подписи работали корректно, а механизмы обеспечения безопасности были надежными. В криптовалютах *владение монетами доказывается знанием личного ключа, который необходим для вычисления действительной цифровой подписи*. Для владельца ключа важно, чтобы никто другой не мог украсть, вычислить или сгенерировать такие же ключевые данные.

Что это значит? Пользователи Биткоина и других цифровых валют должны использовать надежные генераторы случайных чисел, которые выдают действительно случайные последовательности. Иначе говоря, злоумышленник не может повторить процесс генерации и получить ключ пользователя, поскольку будет находиться в других условиях.

Ранее было отмечено, что генераторы могут быть программными и аппаратными. Чем они отличаются?

*Программные генераторы* в прямом смысле не могут генерировать  случайные числа. Они генерируют т. н. *псевдослучайные числа* (последовательности чисел). Это значит, что через определенный промежуток времени числа начинают повторяться с определенной периодичностью (циклически). Этот период можно определить, но чаще всего он известен заранее. Очевидно, что злоумышленник, владея такими знаниями, может воспользоваться ими в личных интересах.

*Аппаратные генераторы* чаще всего строятся на основе стохастических процессов, которые сложно или невозможно предсказывать. Например, могут использоваться диоды зенеровского пробоя или радиоактивное излучение, а также специальные датчики, которые улавливают шум этих процессов, оцифровывают его и в результате получается поток случайных бит. На основе данных из этого потока можно генерировать ключи для применения в криптографических схемах.

Важность процессов генерации можно проиллюстрировать на следующем примере. На ранних стадиях развития Биткоина существовал единственный кошелек для Android-устройств – Bitcoin Wallet. Создатели этого приложения допустили уязвимость в коде программного генератора случайных чисел. Он генерировал числа в определенном узком диапазоне, т. е. можно было предугадать подмножество возможных ключей, которые принадлежали пользователям этого кошелька. Злоумышленник мог перебирать ключи в этом подмножестве и с большой вероятностью получать такие, к которым привязаны чужие монеты. Так и случилось. Это обстоятельство повлекло за собой большой скандал, потому что было украдено значительное количество биткоинов. Разумеется, что вскоре было выпущено обновление, в котором возможность такой уязвимости была устранена, но факт хищения уже случился.

Итак, генерации случайных чисел нужно уделять особое внимание. Генератор случайных чисел может использовать комбинацию обеих реализаций: программной и аппаратной. Следовательно, можно использовать шум с микрофона смартфона либо показания с таких датчиков, как гироскоп или акселерометр, для повышения случайности путем внесения большей *энтропии* (хаотичности, непредсказуемости) [30] в процесс генерации случайных чисел.

*Компрометация ключей* – это понятие, которое подразумевает факт доступа посторонних лиц к секретным ключам, саму возможность такого доступа или подозрение на такую возможность.

Скомпрометированный личный ключ представляет серьезную опасность для любой системы защиты информации, поэтому принимаются специальные меры для защиты личных ключей (или других конфиденциальных данных): их никогда не записывают на жесткий диск компьютера в открытом виде, а держат на отдельных носителях, зашифровывают, защищают паролем и т.д.

Если существует подозрение, что ключи скомпрометированы, их действие прекращается и начинается процедура их замены, перевыпуска и т. п.

### Понятия однонаправленная функция и NP-полная задача

Прежде чем познакомится с хэш-функциями, рассмотрим, что такое однонаправленная (односторонняя) функция и какими особенностями она обладает. Однонаправленная функция – это математическая функция, для которой:

* Вычислить выходное значение довольно просто для любого входного аргумента 
* Вычислить входной аргумент для заданного выходного значения очень сложно (это значит решить NP-полную задачу)

Как один из простых примеров можно привести разбитую чашку: собрать все ее осколки и восстановить из них целую чашку довольно хлопотно. Подобным образом работает однонаправленная функция: предполагается, что вы не сможете найти входные данные, имея только выходное значение. Теоретически такая возможность существует, но на практике эта задача чрезвычайно сложная (при условии, что однонаправленная функция достаточно надежна).

NP-полная задача представляет собой задачу, в которой нужно найти объект, удовлетворяющий определенным условиям. Следуя нашему примеру, решение такой задачи равнозначно восстановлению разбитой чашки. Нахождение этого объекта – сложная задача, которая представляет собой перебор множества возможных вариантов. Но при наличии готового решения достаточно просто проверить, удовлетворяет ли это решение условиям.

Проблема решения NP-полной задачи очень важна для современной криптографии. Если обнаружится быстрый способ решения таких задач, то под угрозой окажутся многие современные криптопримитивы (простейшие криптографические алгоритмы). К таким задачам можно отнести нахождение прообраза хэш-функции, нахождение секретного ключа, который соответствует определенному открытому ключу, а также так называемую задачу коммивояжера (ее мы рассмотрим чуть подробнее).

Задача коммивояжера состоит в нахождении наиболее выгодного маршрута из всех возможных. Согласно условиям нужно пройти через все указанные города, после чего вернуться в начальный город. При этом перемещение между двумя городами имеет определенную стоимость. Чтобы решить эту задачу и выбрать оптимальный маршрут, коммивояжеру нужно перебрать все возможные варианты перемещения. Отметим, что сложность нахождения такого маршрута возрастает с увеличением количества городов. Если в условии задачи будет 5 городов, то мы получим 12 возможных вариантов маршрута, а при наличии 10 городов придется перебрать 181 440 вариантов.

### Хэш-функции

Теперь пора рассмотреть такое важное понятие, как хэш-функция. *Хэш-функция – это функция преобразования массива входных данных произвольной длины в выходную битовую строку фиксированной длины, которая выполняется с помощью определенного алгоритма*.

Хэш-функция однонаправленная, потому что, имея выходное значение, то есть число определенной длины, невозможно определить, какие данные были поданы на вход. Она считается криптографически безопасной, если ее можно атаковать только «грубой силой», то есть перебирать все возможные варианты входных значений и добиваться, чтобы выходное значение соответствовало заданному. Схематически принцип работы хэш-функции будет выглядеть, как изображено на рисунке 3.2.

![Рисунок 3.2 – Схема работы хэш-функции](/resources/img/volume-1/3.1-introduction-to-cryptography/3.2-principle-of-hash-function.png)

На вход хэш-функция может принимать сообщение практически неограниченного размера (любые данные), а на выходе получается уникальное хэш-значение. Имея хэш-значение, полученное с помощью криптографически безопасной хэш-функции, невозможно определить, какие данные были поданы ей на вход. Более того, в Биткоине используется несколько разных алгоритмов хэширования.

Устройство функции хэширования можно понять на примере такой функции, которая считает сумму цифр входного сообщения. Такая функция обладает следующими особенностями. Во-первых, в этом случае, результат вычисляется достаточно быстро за счет простоты алгоритма подсчета. Во-вторых, такая функция действительно однонаправленная, так как выходное значение содержит данные только о сумме цифр в сообщении, но не о расположении этих цифр. То есть сложность восстановления исходного сообщения растет с его длиной (рис. 3.3).

![Рисунок 3.3 – Пример упрощенного аналога хэш-функции](/resources/img/volume-1/3.1-introduction-to-cryptography/3.3-silly-hash-function.png)

Однако использование такой функции небезопасно с точки зрения простоты нахождения коллизий, так как в этом случае очень просто подменить входное сообщение (то есть подать на вход функции сообщение с теми же числами), чтобы получить тот же результат (рис. 3.4).

![Рисунок 3.4 – Пример коллизии хэш-значения](/resources/img/volume-1/3.1-introduction-to-cryptography/3.4-silly-hash-colision.png)

Давайте же разберемся, какими свойствами должна обладать хэш-функция, чтобы ее использование было максимально безопасным для пользователя.

> **Требования к хэш-функции**
>> * *Стойкость к коллизиям*
>> * *Стойкость к поиску первого прообраза*
>> * *Стойкость к поиску второго прообраза*

Стойкость хэш-функции к коллизиям означает, что отсутствует алгоритм, позволяющий находить коллизии за сравнительно короткое время. Коллизией называют ситуацию, когда существует несколько входных значений, которым соответствует одно и то же значение на выходе хэш-функции (рис. 3.5).  

![Рисунок 3.5 – Коллизия хэш-значения](/resources/img/volume-1/3.1-introduction-to-cryptography/3.5-collision.png)

Стойкость к поиску первого прообраза (необратимость) является требованием к хэш-функции, при выполнении которого невозможно восстановить исходное сообщение за адекватный промежуток времени, зная только соответствующее ему хэш-значение.

Стойкость к поиску второго прообраза является требованием, которое подразумевает, что при его выполнении сторона, имеющая исходное сообщение и соответствующее ему хэш-значение, не может создать другое сообщение, которое на выходе хэш-функции предоставит тот же результат.

Криптографически стойкая хэш-функция также должна обладать свойством, согласно которому изменение одного бита на входе должно приводить к изменению в среднем половины выходных битов. Проиллюстрировать на примере подобное свойство можно следующим образом (рис. 3.6). Допустим, мы формируем транзакцию, в которой указано, что мы пересылаем Алисе 10 биткоинов, и вычисляем соответствующее хэш-значение. Если кто-то захочет подменить транзакцию и дописать, например, что переводится не 10 биткоинов, а 100, то подделка транзакции будет обнаружена сразу же.

![Рисунок 3.6 – Изменение выходного значения хэш-функции в зависимости от входного](/resources/img/volume-1/3.1-introduction-to-cryptography/3.6-input-affect-output.png)

Хорошим примером одной из хэш-функций, принцип функционирования которой достаточно просто объяснить, послужит SHA-1 [31]. Вся суть работы этой функции заключается в циклическом перемешивании (80 циклов) и использовании основных битовых операций (and, xor, rot, add, or) с использованием входных данных. На рисунке 3.7 представлен один цикл работы хэш-функции SHA-1, где

* К<sub>t</sub> константа;
* F<sub>t</sub> переменная-функция (меняется каждые 20 циклов); 
* W<sub>i</sub> модифицированный элемент входного сообщения (4 байт);
* <<<*x* циклический сдвиг влево на х позиций.

![Рисунок 3.7 – Схема работы алгоритма SHA-1](/resources/img/volume-1/3.1-introduction-to-cryptography/3.7-sha1.png)

### Применение хэш-функций

Очевидно, что хэширование очень удобно использовать для получения уникального идентификатора набора данных. В случае Bitcoin роль хэш-функции заключается в обеспечении timestamping и связывании блоков, а также в способности возвращать идентификатор данных (доказывать наличие данных), не разглашая самих данных. Как следствие, хэш-функции получили широкое распространение. Рассмотрим основные варианты их применения.

Хэш-значения используются в качестве контрольных сумм при передаче данных. Чтобы проверить, что сообщение не было случайно нарушено из-за каких-то шумов в канале передачи данных, принимающая сторона может повторно вычислить хэш-значение от полученных данных и сравнить его с уже имеющимся.

Кроме этого, такие функции используются для поиска дубликатов хранимых данных или для сравнения больших массивов данных. Чтобы не сравнивать большие объемы данных непосредственно, можно хранить соответствующие им значения хэш-функций и сравнивать только эти значения. Если значения хэш-функции для разных наборов данных совпадают, значит с очень большой вероятностью и сами данные совпадают. Это значительно ускоряет процесс, например, при формировании цифровой подписи. Обычно при подписании документа подписываются не сами данные сообщения, а хэш-значение от них. При этом считается, что это хэш-значение передается вместе с сообщением и подписью: так получатель может проверить и целостность сообщения, и корректность цифровой подписи.

### Деревья Меркла

Деревья Меркла представляют собой структуру данных, которая позволяет связать отдельные фрагменты данных в единственное корневое значение и впоследствии доказать, что определенный блок данных соответствует конкретному корневому значению. Концепцию построения таких деревьев впервые опубликовал в 1979 году Ральф Меркл (Ralph C. Merkle) [32]. Одним из первых применений деревьев Меркла стало их использование в протоколе BitTorrent.

Дерево Меркла содержит следующие компоненты (рис. 3.8):

* Листья дерева (Merkle leaves) 
* Узлы дерева (Merkle nodes) 
* Корень дерева (Merkle root)

![Рисунок 3.8 – Структура дерева Меркла](/resources/img/volume-1/3.1-introduction-to-cryptography/3.8-merkle-tree.png)

Листья дерева Меркла представляют собой хэш-значения от блоков данных, которые необходимо собрать в структуру. Узел дерева является значением, которое было получено в результате конкатенации и дальнейшего хэширования двух дочерних узлов или листьев. Корень дерева Меркла – это узел, который находится на вершине дерева.

> **Особенности деревьев Меркла**
>> * Изменение хотя бы одного бита в одном из блоков данных повлечет за собой полное изменение значения Merkle root
>> * При нарушении одного из блоков можно достаточно быстро и точно определить какой именно блок был модифицирован
>> * Возможно быстро проверить, входит ли определенный блок в структуру дерева Меркла

### Симметричное шифрование

*Простыми словами, шифрование документа – это видоизменение текста документа таким образом, что только тот, кто имеет соответствующий ключ, имеет возможность восстановить исходный текст.* Рассмотрим подробнее, как работает шифрование.

Начнем с наиболее понятного типа – симметричного шифрования. Схематически этот процесс будет выглядеть таким образом, как показано на рис. 3.9.

![Рисунок 3.9 – Схема симметричного шифрования](/resources/img/volume-1/3.1-introduction-to-cryptography/3.9-symmetric-encryption.png)

Существует функция, которая выполняет шифрование данных: на вход она принимает открытый текст и ключ шифрования, а на выходе возвращает зашифрованные данные, или, как часто говорят, шифротекст. Также существует другая функция, которая выполняет расшифрование: на вход она принимает зашифрованные данные и точно такой же ключ шифрования, а на выходе возвращает открытые данные, т. е. исходный текст. Этот тип шифрования называют симметричным, потому что для шифрования и расшифрования применяется один и тот же ключ.

Ярким примером симметричного шифрования является шифр Вернама, или же *одноразовый блокнот* (рис. 3.10). Суть метода является сложение по модулю исходного текста с одноразовым ключом. В этом случае ключ шифрования (он же является ключом расшифрования) должен быть равным по длине исходному сообщению. Такой шифр является ярким примером абсолютно стойкого шифра. Это значит, что при перехвате только шифртекста злоумышленник не сможет получить никакой информации об исходном сообщении.

![Рисунок 3.10 – Пример использования шифра Вернама](/resources/img/volume-1/3.1-introduction-to-cryptography/3.10-vernam-cipher.png)

Этот метод шифрования может считаться достаточно безопасным при условии, что ключ был сгенерирован случайным образом. Генерация случайного ключа также накладывает свои ограничения, поскольку генераторы действительно случайных чисел достаточно медленные (по сравнению с пропускной способностью каналов, по которым передаются секретные данные).

Приведем структурную схему для одного из современных симметричных шифров, а именно Advanced Encryption Standard (AES) [33] (рис. 3.11). Интересная особенность этого шифра – представление данных в виде байтовых матриц, над которыми и происходят все операции.

Основными операциями, которые используются в AES, являются следующие:

* *Substitute* (подстановка) – замена элементов матрицы соответствующими табличными значениями 
* *Shift Rows* (сдвиг строк) – циклический сдвиг строк матрицы влево на соответствующее количество элементов 
* *Mix Columns* (перемешивание столбцов) – умножение столбцов матрицы на статическую, заранее определенную матрицу 
* *Add Round Key* – сложение матрицы состояния с раундовым ключом

![Рисунок 3.11 – Конструкция шифра AES](/resources/img/volume-1/3.1-introduction-to-cryptography/3.11-aes.jpg)

У симметричного шифрования есть и недостатки. Один из них связан с необходимостью обеспечивать конфиденциальность секретного ключа при его передаче получателю сообщения до начала взаимодействия, поскольку для работы необходимо наличие этого ключа и у отправителя, и у получателя. Второй недостаток – сложность создания и хранения нового ключа для каждого нового участника в системе, где используется защищенная коммуникация, основанная только на симметричном шифровании. Сложность этой задачи увеличивается квадратично с увеличением количества участников, поскольку количество новых ключей растет с добавлением нового пользователя.

### Асимметричная криптография

Асимметричная криптография впервые была представлена в 1970-х годах, и ее появление стало революцией в криптографии. Асимметричная криптография использует не один ключ, а т. н. *ключевую пару*. Ключевая пара состоит, как правило, из *личного ключа* и *открытого ключа*. Личный ключ вы должны хранить в секрете, а открытый ключ можете передать своему контрагенту, с которым будете дальше взаимодействовать.

Допустим, Алиса хочет принимать от своих друзей такие сообщения, которые сможет читать только она. Тогда по схеме асимметричного шифрования она генерирует ключевую пару. Личный ключ она оставляет у себя, а открытый размещает где-нибудь на своей страничке в социальной сети (либо сообщает его потенциальному собеседнику другим способом).

Когда один из друзей Алисы хочет отправить ей приватное сообщение, он шифрует документ с помощью открытого ключа Алисы и может передавать этот документ через открытые каналы передачи данных. Получив сообщение, Алиса расшифровывает его своим личным ключом. Любая другая сторона, которая бы перехватила это сообщение, не смогла бы получить доступ к смысловому содержимому сообщения.

Давайте рассмотрим схематически (рис. 3.12), как работает асимметричное шифрование. Существует функция шифрования, которая принимает на вход открытые данные и открытый ключ, а на выход возвращает зашифрованные данные. Обратная функция называется функцией расшифрования. Она принимает зашифрованное сообщение и личный ключ получателя, а возвращает открытый текст этого сообщения.

![Рисунок 3.12 – Схема применения асимметричного шифрования](/resources/img/volume-1/3.1-introduction-to-cryptography/3.12-assymetric-encryption.png)

### Цифровая подпись

Другой вариант применения ключевой пары – цифровая подпись.

Как она работает? Человек, который хочет подписать сообщение, сперва генерирует ключевую пару. Личный ключ этот человек хранит у себя, чтобы сформировать цифровую подпись. А открытый публикует, чтобы получатель подписанного сообщения мог проверить подлинность этого сообщения. Теперь, чтобы подписать сообщение, он использует свой личный ключ. После этого он распространяет два файла: подписанное сообщение и прикрепленную подпись. Другой человек, который хочет убедиться, что документ был правильно сформирован и правильно подписан, может взять открытый ключ и сообщение и проверить, соответствует ли им подпись.

> **_Замечание._** *В схеме цифровой подписи открытый ключ используется для проверки значения подписи относительно подписанного документа. Следовательно, открытый ключ должен передаваться защищенным образом (при отсутствии сертификата открытого ключа, который содержит данные о конкретной личности, связанной с ключом), чтобы исключить подмену подписи вместе с открытым ключом.*

Функция формирования подписи принимает на вход сообщение и личный ключ автора, а на выходе формирует данные подписи, которые прикрепляются к сообщению (рис. 3.13). Далее сообщение вместе с подписью отправляется получателю. Получатель, чтобы убедиться, что подпись корректна, вызывает функцию проверки. Эта функция принимает три параметра: сообщение, значение подписи и открытый ключ. Она возвращает значение логической переменной, верна ли подпись. Оказаться неверной подпись может в случаях, когда либо сообщение было подменено, либо данные подписи были нарушены, либо для проверки использовался неправильный (поврежденный или подмененный) открытый ключ.

![Рисунок 3.13 – Схема применения цифровой подписи](/resources/img/volume-1/3.1-introduction-to-cryptography/3.13-digital-signature.png)

### Модель угроз и модель нарушителя

Одно из необходимых условий для построения надежной информационной системы – разработка политики безопасности, для которой зачастую используются описания модели угроз информационной безопасности и модели ее нарушителя.

Модель угроз представляет собой структурированное описание возможных угроз (источники возникновения угрозы, услуги информационной безопасности, на которые направлена та или иная угроза, возможные способы осуществления).

Модель нарушителя представляет собой структурированное описание (характеристику) нарушителя (категория, к которой может относится нарушитель, его цели, технические возможности и квалификация).

Прежде всего рассмотрим, кто может являться нарушителем в системе Bitcoin. Нарушитель – это физическое лицо или группа лиц, которые выполняют действия, нарушающие политику безопасности системы. Нарушителями в Bitcoin могут быть:

* Пользователи 
* Валидаторы 
* Члены сообщества 
* Владельцы bitcoin-сервисов 
* Производители кошельков

Также стоит отметить, что каждый из возможных нарушителей – участник системы. Он может принимать участие в управлении ею, воздействовать на соответствующее оборудование для его модификации и т. д. Иначе говоря, нет почти никаких ограничений действий нарушителей для атаки на систему.

Какую же цель может преследовать нарушитель? Во-первых, это изменение базы данных с целью изменения состояния «балансов» пользователей. Во-вторых, это может быть попытка ограничения доступа определенного узла или ряда узлов к актуальному состоянию базы данных. Кроме того, сюда можно отнести нанесение ущерба путем внедрения вирусного ПО или непосредственной модификации пользовательского ПО.

Для полноты модели нарушителя также рассматриваются техническая обеспеченность и квалификация нарушителя. Поскольку Bitcoin является децентрализованной системой, узлы которой могут обладать всевозможным уровнем обеспечения (от одиночного ноутбука до кластера), то следует предполагать, что любой потенциальный нарушитель может обладать новейшим программным и аппаратным обеспечением, а также высокой квалификацией.

Постараемся описать модель угроз для Bitcoin. Рассмотрим услуги информационной безопасности, которые должна обеспечивать учетная система Bitcoin, а также на нарушение каких услуг могут быть направлены угрозы.

*Конфиденциальность*. По умолчанию Bitcoin не обеспечивает эту услугу безопасности. То есть база данных общедоступная, и все транзакции и сообщения между пользователями передаются в открытом виде.

*Целостность*. Использование технологии blockchain в Bitcoin ориентировано именно на обеспечение этой услуги безопасности (соответственно, ее обеспечение требует максимального внимания ко всем процессам, связанным с обработкой данных: хранением, передачей и т.д.).

*Доступность*. Как упоминалось ранее, база данных в Bitcoin общедоступна. Благодаря этому каждый пользователь может независимо проводить аудит всех процессов в рамках учетной системы Bitcoin.

С учетом категорий и возможностей нарушителей  рассмотрим угрозы, которые могут быть осуществлены в Bitcoin:

1. Атакующий может создать транзакцию, которая повторно тратит монеты (которая создает средства «из воздуха»). 
2. Злоумышленник, обладающий хорошей репутацией, может убедить общество принять обновление с некоторой уязвимостью. 
3. Злоумышленник может создать форк и внести некоторую уязвимость. После этого он может каким-то образом переключить некоторое количество пользователей на целевую (уязвимую) систему. 
4. Злоумышленник может построить небезопасный протокол поверх Биткоина и убедить участников Биткоина пользоваться этим протоколом. 
5. Атакующий может накопить большое количество вычислительной мощности и попытаться создать альтернативные цепочки. 
6. Злоумышленник может получить доступ к оборудованию других участников системы (тем самым завладеть большей частью вычислительной мощности). 
7. Злоумышленник может изменить программное обеспечение сетевого узла. 
8. Злоумышленник может создавать поддельные сайты и кошельки (предоставлять недостоверную информацию). 
9. Злоумышленник может изменить свое оборудование (устройство) и распространять его. 
10. Злоумышленник может изменить свое программное обеспечение (кошелек).
11. Злоумышленник может перехватить/подменить любое сообщение между участниками системы (например для передачи неверной истории транзакций либо ограничения доступа определенного узла к текущему состоянию базы данных). 
12. Атакующий может выдавать себя за любого из участников системы или даже имитировать целую сеть (таким образом атакующий может навязывать альтернативную историю отдельному пользователю либо группе пользователей). 
13. Атакующий может легко скрыть свои действия (ввиду того, что в рамках протокола Bitcoin пользователи не идентифицируются). 
14. Злоумышленник может идентифицировать участников транзакций, анализируя интернет-трафик (подразумевается, что интернет-провайдер может отслеживать весь входящий и исходящий трафик конкретного пользователя).

После того как мы упомянули возможные угрозы, нельзя не сказать о том, как от них защититься. Первые 4 угрозы наиболее сложно реализовать, так как для этого необходима большая поддержка со стороны участников системы. А поскольку от предлагаемых обновлений непосредственно зависит безопасность монет пользователей, то такие предложения будут тщательно рассматриваться и незаметно внедрить в них backdoors довольно проблематично.

Цель угроз 5 и 6 – завладеть большим количеством вычислительной мощности. Реализация этих угроз очень дорогостоящая, и редко выгода от таких атак превышает затраты на ее проведение. С другой стороны, для пользователей такие атаки очень опасные, поскольку в этих случаях атакующий обманывает пользователей, при этом избегая нарушения самого протокола.

Следующие 4 угрозы (7–10) реализовать гораздо проще предыдущих. Чаще всего они могут быть реализованы поставщиками программного и аппаратного обеспечения. Ввиду того, что далеко не каждый пользователь проверяет исходный код кошелька на предмет уязвимостей, такие атаки более чем вероятны. Они могут привести к тому, что пользователи утратят свои монеты. Для защиты от таких атак пользователям рекомендуется проверять ПО кошельков на предмет уязвимостей и использовать ПО только из доверенных источников.

Оставшиеся 4 угрозы (11–14) провести проще всего, поскольку они реализуются на сетевом уровне. Такие атаки очень редко могут повлечь потерю монет пользователями, однако ограничить доступ пользователя к актуальной информации и ограничить его действия в сети могут. Защитить децентрализованную систему от подобных атак в целом более тяжело, но это возможно сделать за счет увеличения количества связей каждого пользователя с другими узлами сети.

Несмотря на все вышеперечисленное, предполагается, что злоумышленник **не может**:

* Угадать, какой открытый ключ используется для формирования конкретного адреса 
* Получить доступ к секретному ключу в памяти защищенного устройства 
* Обнаружить второе (или третье) устройство, которое хранит один из личных ключей MultiSig-адреса (см. 4.5)

**Часто задаваемые вопросы**

*– Правда ли что при использовании цифровой подписи злоумышленники могут подменить открытый ключ отправителя и соответственно заменить сообщение с подписью?*

Да, для того чтобы цифровая подпись подмененного сообщения была проверена как правильная, кроме сообщения злоумышленнику нужно подменить и данные подписи, и данные открытого ключа. Именно поэтому открытый ключ не распространяется вместе с подписанным сообщением, а передается при личной встрече, либо через защищенный канал, либо через доверенную сторону. На практике доверенной стороной часто являются центры сертификации ключей, которые подтверждают соответствие открытых ключей конкретным личностям.

*– Постквантовые алгоритмы цифровой подписи уже используются в децентрализованных системах?*

Нет, потому что на момент 2022 года практика создания достаточно эффективного квантового компьютера слишком далека от его теоретического потенциала, поэтому угроза взлома используемых криптографических алгоритмов невелика. Осуществлять переход на постквантовые криптографические алгоритмы раньше необходимости нет смысла с точки зрения их ресурсозатратности: размер цифровой подписи и соответствующих ключей в постквантовых алгоритмах в десятки раз больше по сравнению с используемыми сейчас.

## 3.2 Криптография в Bitcoin

В этом подразделе рассматривается то, как использование криптографических свойств эллиптической кривой позволяет организовать взаимодействие в trustless системах.

## Особенности работы эллиптических кривых

Эллиптическая криптография – наиболее быстрый и эффективный методом построения асимметричных криптографических преобразований в современном цифровом мире [34]. В частности, Bitcoin использует ECDSA – стандартизированный алгоритм цифровой подписи.

Эллиптическая кривая (ЭК) над полем вещественных чисел состоит из множества точек на плоскости, чьи координаты удовлетворяют уравнению y<sup>2</sup> = x<sup>3</sup> + ax+b, где a и b – вещественные числа, и т. н. бесконечно удаленной точки, у которой нет вещественных координат. Указанное каноническое уравнение – частный случай уравнения Вейерштрасса. Национальный институт стандартов и технологий США (NIST) рекомендует 15 эллиптических кривых для использования в алгоритмах цифровой подписи [35]. Наиболее часто используются псевдослучайные эллиптические кривые (параметры ЭК и поля генерируются псевдослучайным образом, зачастую с помощью хэш-функций). Однако кривая в Bitcoin не относится к рекомендованным NIST и представляет собой ЭК специального назначения, поскольку коэффициенты и базовое поле были специально подобраны для большей эффективности операций. В Bitcoin a=0, а b=7, поэтому эллиптическая кривая задана уравнением y<sup>2</sup> = x<sup>3</sup> + 7 [36]. График этой кривой показан на рис. 3.14, а более детально участок кривой, содержащий точки перегиба, – на рис. 3.15.

![Рисунок 3.14 – Эллиптическая кривая в Bitcoin](/resources/img/volume-1/3.2-cryptography-in-bitcoin/3.14-ec-in-bitcoin.png)

![Рисунок 3.15 – Участок кривой с точками перегиба](/resources/img/volume-1/3.2-cryptography-in-bitcoin/3.15-curve-segment.png)

Основными операциями в группе точек эллиптической кривой являются: *сложение*, *удвоение* и *умножение на скаляр*. Отметим, что результатом каждой из перечисленных операций также является точка, которая принадлежит ЭК [37].

У сложения точек ЭК, заданной над полем вещественных чисел, есть простая геометрическая интерпретация (рис. 3.16). *Суммой двух точек A<sub>1</sub> и A<sub>2</sub> называется третья точка A<sub>3</sub>=A<sub>1</sub>+A<sub>2</sub>, симметричная относительно оси Ox третьей точке (-A<sub>3</sub>) пересечения эллиптической кривой и прямой, проходящей через точки A<sub>1</sub> и A<sub>2</sub>*.

*Умножение на скаляр – это многократное сложение точки с самой собой*. На рис. 3.17 графически показано, как происходит удвоение точки.

![Рисунок 3.16 – Сумма точек ЭК](/resources/img/volume-1/3.2-cryptography-in-bitcoin/3.16-addition.png)

![Рисунок 3.17 – Удвоение точки ЭК](/resources/img/volume-1/3.2-cryptography-in-bitcoin/3.17-doubling.png)

### Создание адресов в Bitcoi

Понимания принципов работы хэш-функций и генерации ключевой пары для ECDSA достаточно, чтобы перейти к  генерации адресов в Bitcoin. В самом простом случае адрес получается из открытого ключа пользователя в результате применения алгоритмов хэширования (рис. 3.18), которые называются Secure Hash Algorithm II (SHA-2) и RACE Integrity Primitives Evaluation Message Digest (RIPEMD), а конкретно – SHA256 и RIPEMD160.

![Рисунок 3.18 – Схема вычисления адреса в Bitcoin](/resources/img/volume-1/3.2-cryptography-in-bitcoin/3.18-address-in-Bitcoin.png)

Открытый ключ хэшируют с помощью SHA256, а для результата снова рассчитывается хэш-значение, но уже при помощи RIPEMD160. На выходе получают 160-битное (20-байтное) число. Далее это число представляется в кодировке Base58Check. Во время кодирования прикрепляются 4-байтная контрольная сумма и 1-байтная версия, а далее происходит преобразование 25-байтного числа в строку в соответствии с алфавитом кодировки. Итоговая 35-символьная строка и считается биткоин-адресом.

> **_Замечание._** *Формат адреса, который создается согласно схеме выше, называется P2PKH (pay to public key hash). Другие форматы биткоин-адреса рассматриваются в 4.5.*

Алфавит кодировки Base58Check похож на алфавит широко применяемой кодировки base64, но здесь отсутствуют трудно различимые символы, такие как «I» (заглавная «i») и «l» (строчная «L»), «O» (заглавная «о») и «0» (нуль), а также не используются символы «+» и «/».

Почему определен именно такой порядок формирования адресов в Bitcoin? Во-первых, сокрытие открытого ключа защищает пользователей от кражи монет, если будет взломан алгоритм цифровой подписи. Во-вторых, разные функции были применены для снижения риска атаки на хэш-функции: были взяты независимые стандарты, и вероятность, что оба содержат backdoor, предельно мала.

### Конфиденциальность в Bitcoin

Протокол Биткоин обрабатывает данные транзакций в блоках, получая и передавая их через глобальную сеть. Во время передачи данные не шифруются, а остаются в открытом виде. Нет смысла в попытках защитить эти данные от просмотра посторонними лицами, потому что они защищены хэш-значениями или даже заверены цифровой подписью. Кроме того, эти данные открытые затем, чтобы их мог верифицировать любой желающий.

Чуть ли не единственная цель, ради которой может быть применено шифрование передаваемых в сети Bitcoin данных, – повышение уровня приватности самого узла сети. Это важно, когда владелец узла желает осуществлять свою деятельность анонимно (подробнее в 7.1).

### Основные векторы атак на ключи в Bitcoin 

Атакующая сторона может скомпрометировать ключи пользователя несколькими способами:

* Взлом математики (эллиптической кривой, алгоритма генерации ключей, алгоритма хеширования или алгоритма цифровой подписи)
* Взлом аппаратного устройства, которое генерирует ключи или вырабатывает цифровую подпись 
* Взлом коммутационных протоколов (handshake, обмен ключами, TLS, процесс верификации подписи и т. д.)
* Взлом программного обеспечения кошельков (генерация ключей, хранение ключей, внедрение вредоносного кода и т. д.)
* Социальные атаки

**Часто задаваемые вопросы**

*– Используется ли генератор случайных чисел при вычислении открытого ключа по схеме ECDSA?*

Нет. Открытый ключ вычисляется из личного, и это вычисление однонаправленное. Bitcoin использует криптографию, основанную на собственной эллиптической кривой, которая определена уравнением y<sup>2</sup>=x<sup>3</sup>+7.. Открытый ключ является точкой с координатами x и y. Поскольку личный ключ представляет собой некоторое большое натуральное число, вычислить открытый ключ можно следующим образом: *public_key* = *private_key* · G, где G – базовая точка. Результат этой операции – новая точка на кривой, которая и является открытым ключом. Базовая точка G – это константный параметр из спецификации secp256k1. Имея открытый ключ, можно сгенерировать адрес кошелька.

*– Возможно ли разделить P на G и получить личный ключ в результате?*

В криптографии это называют решением задачи нахождения дискретного логарифма в группе точек эллиптической кривой. Напрямую это уравнение не решается. Решение находят при помощи криптоанализа. Существуют методы, которые теоретически могут позволить это сделать, но они требуют очень больших вычислительных мощностей и большого объема памяти, которые на сегодня недоступны.

*– Открытый ключ нужен только для получения адреса?*

Нет, помимо получения адреса, открытый ключ используется для получения и траты монет. Сначала пользователь вычисляет адрес, а после получает на него монеты. Во время траты монет пользователь публикует открытый ключ, чтобы доказать, что именно он – владелец этого адреса. Все проверяющие вычисляют хэш-значение от открытого ключа и проверяют, совпадает ли оно с адресом.

*– Чем угрожает квантовый компьютер Биткоину?*

По состоянию на 2018 год реализован квантовый компьютер с такой длиной регистра, что он не угрожает криптографии, которая используется в Биткоине. Но квантовые компьютеры постепенно развиваются, и длина регистра увеличивается, то есть увеличивается сложность задач, которые они могут решать за очень короткие промежутки времени. Предполагается, что спустя годы квантовый компьютер сможет представить угрозу для современной эллиптической криптографии. Тогда будет возможно вычислить личный ключ, зная открытый. Однако это может случиться, только если криптография в Bitcoin не будет обновляться, что маловероятно.

*– Как можно ослабить угрозу квантового компьютера алгоритмам, которые применяются в Bitcoin?*

Прежде всего, отметим, что может выйти обновление протокола Bitcoin (использование более длинных ключей для цифровой подписи либо реализация постквантового алгоритма цифровой подписи). Если же протокол не обновится, то даже по текущим правилам у атакующего будет около 10 минут на подбор ключа, создание альтернативной транзакции и попытку ее подтвердить, потому что среднее время первого подтверждения обычной транзакции равно 10 минутам (с момента ее распространения в сети). Когда пользователь получает монеты на свой адрес, он еще не публикует открытый ключ и атаковать его невозможно (на практике одновременно взломать хэш-функции SHA-2 и RIPEMD160 вряд ли получится). Открытый ключ цифровой подписи можно атаковать тогда, когда биткоины тратятся (исходящая транзакция отправляется в сеть). Поэтому можно сказать, что напрямую квантовый компьютер не угрожает хранению биткоинов по состоянию на 2018 год. А в будущем протокол Биткоина можно будет обновить. Более того, вероятность совершения атаки зависит от финансовой выгоды: для маленьких сумм атака квантового компьютера будет нецелесообразной, потому что затраты многократно превысят размер прибыли.

*– Можно ли идентифицировать конкретную личность в Биткоине, сопоставив ее с цифровой подписью?*

Нет. Это не так, потому что такая цифровая подпись не сертифицируется. В Биткоине нет центров сертификации, которые выдавали бы сертификаты открытых ключей пользователей. Соответственно, однозначно идентифицировать личность очень непросто. Поэтому Биткоин и считается сравнительно анонимным. Но вы можете попробовать сделать это другими способами. Например, идентифицировать контрагента при обмене биткоинов на наличные, делать меченые купюры, отслеживать, при помощи какого ПО и с каких IP-адресов были отправлены транзакции. Но по умолчанию подпись не связана с личностью.

*– У одного адреса может быть несколько ключей?*

Если адрес был получен в результате хэширования ключа, то да. Из-за коллизий может существовать множество ключей, которые при хэшировании дают один адрес, но подобрать их сложно.

## 3.3 Хранение и обработка ключей

Несмотря на наличие в некоторых странах законодательства и практики использования цифровой подписи и цифровой identity, можно смело утверждать, что использование этих механизмов было и остается крайне незначительным. Однако именно с появлением Bitcoin стало понятно, что оцифровка реестров прав собственности для всех активов – неизбежное явление, которое соответствует потребностям XXI века. В силу особенностей своей архитектуры Bitcoin мог опираться только на цифровой метод заверения транзакций, чтобы даже торговый робот мог стать пользователем сети. Наиболее оптимальный способ реализации такого взаимодействия между пользователями Bitcoin состоял в применении криптографических ключей и схем цифровой подписи. Этот подход требовал от пользователей бережного отношения к использованию ключей. Поэтому вопросы управления жизненным циклом (генерации, хранения, восстановления) ключей имеют колоссальную важность.

В этом подразделе мы углубимся в процессы хранения и обработки ключей цифрового кошелька, а также рассмотрим наиболее актуальные подходы к реализации этих процессов. Материал дает возможность понять, как работают кошельки, как можно их классифицировать в зависимости от подхода к обработке ключей, а также оценить риски и преимущества каждого подхода.

### Главная задача цифрового кошельк

Когда мы говорим о кошельке, обычно подразумеваем нечто, предназначенное для хранения денег. Это вводит пользователей цифровых валют в заблуждение, потому что некоторые ошибочно полагают, что цифровые кошельки используются для хранения монет. На самом деле это не так. Цифровые монеты – это абстракция, на самом деле их не существует, и они нигде не хранятся (см. 4.1). Но какие же тогда процессы проходят в цифровых кошельках и как их лучше организовать?

Кошельки используются для хранения ключей, с помощью которых происходит управление монетами на балансе пользователя. Соответственно, о*сновные функции кошелька – это хранение ключей и управление ими*. Реализация этих функций возможна благодаря правильному проектированию цифрового кошелька.

> **Модули цифрового кошелька**
>> * *Модуль генерации и хранения ключей*
>> * *Модуль синхронизации актуального состояния*
>> * *Модуль обработки существующих транзакций*
>> * *Модуль формирования и подписи транзакций*

Цифровые кошельки могут иметь расширенную функциональность, которая может сильно разниться от одного приложения к другому. Однако каждый цифровой кошелек обеспечивает механизмы заверения транзакций и восстановления доступа, функциональность приема платежей и отображения баланса, а также отображения истории транзакций и отправки платежей.

### Основные подходы к управлению ключами кошелька

> * *Ключи хранятся и обрабатываются на удаленном сервере*
> * *Ключи хранятся на удаленном сервере, но обрабатываются пользователем*
> * *Ключи хранятся и обрабатываются в приложении пользователя*
> * *Сочетание предыдущих подходов за счет использования мультиподписи*

Когда речь идет о хранении личных ключей, обычно подразумевается, что пользователь должен решить задачи, такие как защита от потери, защита от кражи, резервное копирование (backup) и экспорт личных ключей для использования на других устройствах. Сейчас, к сожалению, нет такого подхода, который бы предоставил идеальное решение, удовлетворяющее всем требованиям [38]. Поэтому к хранению ключей сформировалось несколько основных подходов.

Каждый подход имеет свои преимущества и недостатки, и выбор каждого может быть рациональным в зависимости от конкретных требований. Различаются они по месту хранения ключей и по месту их обработки.

### Обработка и хранение ключей на сервере

Случай, когда ключи хранятся и управляются на выделенном сервере, – один из самых простых. Сервис, который предоставляет услугу в виде такого кошелька, полностью контролирует ключи. Соответственно, пользователи кошелька не имеют никакого доступа к ключам, то есть они не владеют монетами. Такие сервисы предоставляют каждому пользователю личный аккаунт с виртуальным счетом, для которого зарезервировано соответствующее количество монет цифровой валюты (рис. 3.19). Но реальный доступ к этим монетам обеспечивают только ключи, которыми владеет сервис.

![Рисунок 3.19 – Ключи хранятся и обрабатываются на удаленном сервере](/resources/img/volume-1/3.3-keys-storage-and-processing/3.19-remote-server.png)

Следует понимать, что в этом случае возможны два варианта перевода монет между пользователями:

* Между двумя пользователями одного централизованного сервиса 
* Между пользователем сервиса и пользователем биткоин-кошелька

В первом варианте все достаточно просто. Поскольку монеты криптовалюты не выходят за пределы системы, можно просто переписать балансы пользователей в их аккаунтах, при этом не создавая *on-chain транзакцию*.

Если же нам нужно получить средства с внешнего кошелька либо вывести их на внешний кошелек, то без формирования транзакции не обойтись. В этом случае транзакцию создает сервис и он, соответственно, отправляет со своих ключей средства на внешний кошелек либо принимает их на свои адреса и, следовательно, может ими распоряжаться.

Этот вид кошельков популярен благодаря преимуществам, которые получают пользователи при работе с ним. Во-первых, вы действительно можете совершать моментальные платежи без комиссии, поскольку не проводите никаких реальных транзакций. Именно по этой причине большинство сервисов используют этот подход. Такие сервисы позволяют обеспечить максимально простой доступ к аккаунту с нескольких устройств. Даже если вы потеряли пароль от аккаунта, вы без труда можете восстановить его.

Тем не менее, такой подход имеет определенные недостатки. Один из них состоит в том, что пользователи в такой системе не имеют никакого доступа к своим монетам. Они не управляют ключами, а значит, не управляют и монетами цифровой валюты. Пользователи полностью зависимы от таких сервисов: чтобы использовать другой сервис, необходимо явно вывести все средства с текущего сервиса и выслать их на другой кошелек.

Это одна из самых простых возможных реализаций кошелька при разработке. Во-первых, все управление и хранение ключей осуществляется на сервере; зачастую для работы с кошельком даже не требуется свое программное обеспечение. Для управления ключами используется тот кошелек, который обычно предоставляется вместе с полным узлом сети определенной криптовалюты. Поскольку все операции выполняются на сервере, то клиентское приложение очень простое (как и его реализация). По сути, оно занимается только тем, что общается с сервером посредством APIs. Тем не менее, ввиду того, что все ключи не просто хранятся на определенном сервере, но и обрабатываются на нем, в определенный момент времени они будут храниться в открытом виде в оперативной памяти или, возможно, даже на жестком диске. Требования к безопасности таких серверов очень высоки: нужно максимально защитить сервер от возможности доступа извне, взлома и т. д.

### Ключи на сервере, но доступ есть только у клиента

Другой подход состоит в том, что ключи хранятся на сервере, но управление ключами выносится уже в клиентское приложение. В этом случае пользователь имеет более высокий уровень контроля над своими монетами по сравнению с предыдущим подходом (рис. 3.20). Сервис не имеет прямого доступа к личным ключам клиентов, хотя он их и хранит.

![Рисунок 3.20 – Ключи хранятся на удаленном сервере, но обрабатываются пользователем](/resources/img/volume-1/3.3-keys-storage-and-processing/3.20-stored-separately-with-direct-control.png)

Когда пользователь регистрируется в таком сервисе, он генерирует на своем устройстве (в мобильном кошельке или веб-кошельке) личный ключ, после чего шифрует его с помощью пароля и отправляет на сервер уже в защищенном виде. Позже, когда пользователю нужно получить личный ключ, необходимо пройти аутентификацию и запросить у сервиса защищенный контейнер с личным ключом. Кошелек получает этот контейнер, расшифровывает личный ключ и работает с ним непосредственно на устройстве.

Какие же преимущества у такого подхода? Как и в предыдущем рассмотренном подходе, сохраняется достаточно простой доступ к аккаунту с нескольких устройств. В этом же случае пользователь получает прямой контроль над своими ключами, а значит и непосредственно над своими монетами, тем не менее, полностью зависимости от сервиса он не лишается. Таким образом, если централизованный сервис будет недоступен, пользователь теряет доступ к своим монетам, если у него не будет резервной копии личных ключей.

Особенности при разработке заключаются в том, что алгоритмы обработки ключей и подписание транзакций должны быть реализованы в приложении пользователя. Это может быть достаточно сложно, особенно тогда, когда сервис поддерживает приложения для нескольких разных платформ, таких как Android, iOS, веб-приложения и т. д. Несмотря на то, что личные ключи пользователя не хранятся на серверах сервиса в открытом виде, выдвигаются высокие требования к его безопасности. Ведь все равно инженеры могут найти уязвимости в алгоритмах обеспечения защиты секретных данных и аутентификации клиентов такого сервиса и воспользоваться ими со злым умыслом. Некоторые централизованные онлайн-кошельки используют именно такой подход к обработке и хранению ключей.

### Ключи на устройстве пользователя

Следующий подход – хранение и управление личными ключами пользователя осуществляется на его устройстве. В этом случае вам не нужен никакой back-end или API. Пользователь полностью контролирует монеты и, соответственно, более независим от внешних сервисов. Например, не имея доступа к сети, он может зайти в свой кошелек, создать транзакцию и просто отправить ее, когда появится доступ к сети (рис. 3.21). Пользователь может передать эту транзакцию, даже не подключая свое устройство к сети. Он может определенным образом передать эту транзакцию на другое устройство и уже с него отправить ее в сеть.

![Рисунок 3.21 – Ключи хранятся и обрабатываются в приложении пользователя](/resources/img/volume-1/3.3-keys-storage-and-processing/3.21-keys-in-app.png)

Однако такой подход тоже не идеален. Основным недостатком является необходимость хранить ключи всегда на одном устройстве. Потеря этого устройства либо его повреждение влекут за собой потерю доступа к ключам. Если же пользователь забыл пароль, с помощью которого зашифрованы личные ключи, он также не сможет их получить обратно. В таком случае нужно всегда осуществлять резервное копирование личных ключей и отдельно хранить резервную копию. Если потребуется перенести ключи с одного устройства на другое, придется осуществлять это вручную.

Немного изменяются особенности разработки таких кошельков. Как и в предыдущем случае, логика обработки ключей остается на клиенте. Если попытаться создать кроссплатформенное приложение, проблемы останутся теми же, поскольку все данные хранятся на устройствах клиентов и, по сути, пользователи могут напрямую общаться с сетью для получения состояния баланса, а также для получения и отправки транзакций. Повышаются требования к безопасности хранения ключей. При использовании разных платформ зачастую применяются так называемые платформозависимые способы. Например, для устройств iOS используется KeyChain, в котором можно хранить секретные данные достаточно защищенным образом. Для того чтобы иметь возможность переносить ключи с одного устройства на другое, кошельки такого типа предусматривают обязательный ручной экспорт и импорт ключей. В наиболее простом случае речь идет о кошельке с одним личным ключом, а также функцией просмотра и ввода личного ключа в кодировке WIF (Wallet Import Format).

В качестве примера применения этого подхода можно привести мобильный кошелек Bitxfy, который хранит и обрабатывает личные ключи на устройстве пользователя. Актуальные данные о транзакциях он получает через доверенные узлы сети, которые поддерживает команда разработчиков.

### Хранение монет с применением мультиподписи

Последним рассмотрим подход, который является смешанной моделью хранения ключей с использованием мультиподписи. Это даже не отдельный подход, а комбинация из нескольких предыдущих методов, позволяющая повысить уровень безопасности хранения ключей. При использовании мультиподписи для отправки монет требуется несколько подписей разными личными ключами, каждый из которых можно хранить и обрабатывать на отдельном устройстве независимо от остальных (рис. 3.22) (подробнее в 4.5).

![Рисунок 3.22 – Вариант применение механизма мультиподписи](/resources/img/volume-1/3.3-keys-storage-and-processing/3.22-multisig.png)

С помощью данного способа можно, например, реализовать мультиподпись 2-из-3. Допустим, есть три ключа. Хранение и управление одним из них будет совершаться с помощью сервера, а остальными – с помощью смартфона. Чтобы заверить транзакцию, достаточно ее подписать любыми двумя из этих ключей. Вовсе не обязательно в этом случае пересылать ключи между устройствами – достаточно переслать с одного устройства на другое частично подписанную транзакцию, чтобы доподписать ее вторым ключом.

Исходя из модели нарушителя (см. 3.1), наиболее надежный способ хранения монет – хранение ключей на различных устройствах от независимых производителей (Apple, Samsung, Huawei и т. д.), а также использование программного обеспечения кошельков от независимых разработчиков.

Примеры кошельков, которые используют мультиподпись, – сервис Bitgo и кошелек Electrum. Но по состоянию на 2018 год эти решения еще не идеальны, поскольку они сложны в использовании. Надеемся, в будущем эти реализации станут лучше и на их основе будут разработаны альтернативные приложения.

### Холодные, теплые и горячие кошельки

Выше были рассмотрены основные варианты распределения ответственности за хранение и обработку ключей цифрового кошелька. Теперь разберем, как именно ответственное лицо может организовать процессы хранения личных ключей и подписания транзакций. Здесь тоже можно выделить три основных подхода (рис. 3.23):

* Hot storage wallet (кошелек «горячего» хранения) 
* Warm storage wallet (кошелек «теплого» хранения)
* Cold storage wallet (кошелек «холодного» хранения)

*Hot storage wallet – цифровой кошелек, где личные ключи хранятся и обрабатываются устройством, которое имеет соединение с глобальной сетью постоянно.*

*Cold storage wallet – цифровой кошелек, где личные ключи хранятся и обрабатываются только на таком устройстве, которое не имеет возможности прямого соединения с глобальной сетью.*

*Warm storage wallet – цифровой кошелек, где личные ключи хранятся только на таком устройстве, которое поддерживает соединение с глобальной сетью не постоянно, а только по решению пользователя, например для отправки транзакций или обновления их статусов.*

![Рисунок 3.23 – Сравнение холодных, теплых и горячих кошельков](/resources/img/volume-1/3.3-keys-storage-and-processing/3.23-comparison-of-wallets.png)

Программу-кошелек на смартфоне и многие цифровые кошельки для ПК можно отнести к группе hot storage wallets. Это наиболее удобные в использовании кошельки, но, следует учитывать, что теоретически инженеру с особыми способностями проще найти уязвимости именно в таких кошельках. В этом отношении cold storage wallet – более безопасный вариант.

Промежуточное положение между «горячими» и «холодными» кошельками занимают warm storage wallets. Их разработчики стараются свести к минимуму взаимодействие кошелька с остальным цифровым миром, но сохранить при этом некоторые удобства «горячих» кошельков.

**Часто задаваемые вопросы**

*– Правда ли, что пользователи, которые хранят монеты на кошельках с закрытым исходным кодом, могут однажды обнаружить отсутствие своих монет?*

Да, теоретически разработчики кошелька могут украсть ключи пользователя через заложенный backdoor в программном коде, который вряд ли заметит обычный пользователь. В то же время такая же ситуация теоретически возможна и для open-source решений, хотя и менее вероятна.

*– Уменьшит ли вероятность наличия backdoor в цифровом кошельке тот факт, что его исходный код открыт?*

Да, теоретически уменьшит. Но не следует забывать, что, если исходный код открыт, это совсем не значит, что пользователь его проанализировал перед установкой. И даже если так, то пользователю необходимо самостоятельно его скомпилировать и установить на свое устройство, не забыв выключить автоматические обновления. Таким образом, пользователю вынужден доверять разработчику приложений, в которых он хранит важные данные.

*– Насколько велико количество узлов сети Bitcoin, к которым подключается клиентский кошелек? Подключается ли он все время к одним и тем же узлам?*

Все зависит от конкретной реализации кошелька и его настроек. Кошелек может всегда подключаться к одному доверенному узлу в сети, а может поддерживать связь с несколькими узлами сети, которым он даже не доверяет, и выполнять полную проверку всех данных на предмет соответствия правилам протокола. К примеру, реализация кошелька Bitcoin Core подключается всегда к разным узлам. Кошелек этой реализации может даже отдавать предпочтение определенным узлам в зависимости от их общего количества, времени реакции, сетевых задержек и частоты получения некорректных данных от узлов.

*– Как лучше хранить файлы кошельков для минимизации рисков кражи конфиденциальных данных и личных ключей пользователя?*

Есть достаточно много способов. Чтобы обеспечить минимальный уровень защиты, который убережет пользователя от простых случаев взлома и позволит ему достаточно безопасно хранить средства (если речь не идет о миллионах долларов), достаточно воспользоваться паролем, если возможность его установки поддерживается. Тогда дополнительным секретным ключом, полученным из пароля, конфиденциальные данные будут зашифрованы и, соответственно, на устройстве они не будут храниться в открытом виде.

*– Если пользователь использует программный кошелек на своем ПК, могут ли другие программы украсть монеты пользователя?*

В общем случае – могут. Риск этого достаточно велик, поэтому для больших сумм рекомендуется и использовать более надежные способы хранения и обработки личных ключей.

*– Что делать, если личный ключ был скомпрометирован?*

В данном случае следует прекратить использовать кошелек, ключи которого были скомпрометированы. Если причина нарушения конфиденциальности неизвестна, то стоит даже отказаться от использования соответствующего приложения или устройства [39].

[ТЕХНОЛОГИЧЕСКИЕ ДЕТАЛИ ФУНКЦИОНИРОВАНИЯ BITCOIN](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-1/ru/4-technological-details-of-bitcoin-operation.md)