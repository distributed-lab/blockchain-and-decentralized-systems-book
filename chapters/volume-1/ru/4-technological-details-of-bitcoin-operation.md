# 4 ТЕХНОЛОГИЧЕСКИЕ ДЕТАЛИ ФУНКЦИОНИРОВАНИЯ BITCOIN


## 4.1 Как работают транзакции в Bitcoin?

Отсутствие требований регистрации пользователей кардинально повлияли на формат транзакций. В случае с Bitcoin хранение и обработка транзакций значительно отличаются от таковых в существующих финансовых системах. Самыми главными отличиями стали связь транзакций между собой (т. н. triple-entry accounting), понятие непотраченный выход, а также особенности формирования сдачи. Как и почему работает этот механизм, постараемся разобраться на примерах.

### Структура транзакции

Рассмотрим транзакцию схематично (рис. 4.1). Ее можно логически разбить на три составляющие: заголовок, входные монеты и выходные монеты.

Если немного углубиться, каждая транзакция в своей структуре может иметь несколько входов и выходов; их количество не ограничено. В Биткоине ограничен только размер транзакции: он составляет 25 % от максимального размера блока. Если максимальный размер блока – 1 МБ, то максимальный размер транзакции – 250 кБ.

На рис. 4.1 видно, что каждая транзакция содержит вход, который содержит ссылку на некоторую предыдущую транзакцию (источник монет), и выход, который создается в текущей транзакции для отправки монет.

![Рисунок 4.1 – Упрощенная структурная схема транзакции в Bitcoin](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.1-simplified-structure-of-tx.png)

Каждый вход содержит доказательство, что автор транзакции владеет монетами, которые хочет потратить. В Биткоине монеты не записаны на каком-то балансе. Вместо этого указывается ссылка на ту транзакцию, из которой они были получены. Таким образом, выстраивается цепочка, которую легко верифицировать.

В каждом выходе указывается сумма платежа и *условия траты монет*, которым должен удовлетворить получатель с помощью *доказательства владения монетами*, чтобы потом их отправить дальше.

Рассмотрим детальнее тело транзакции, которая когда-то давно в сети Биткоин получила подтверждение. На рис. 4.2 она представлена в формате JSON.

![Рисунок 4.2 – Пример bitcoin-транзакции](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.2-example-of-tx.png)

> * *ScriptPubKey – поле, содержащее условия траты монет*
> * *ScriptSig – поле, содержащее доказательства владения монетами*
> * *Для заполнения этих полей используется специальный язык – Bitcoin Script*

Здесь присутствует заголовок, который содержит два поля: версию транзакции и параметр locktime (подробнее будет рассмотрен далее). Транзакция содержит также два входа и два выхода. Наибольший объем имеет поле входов, а в нем – scriptSig, потому что подпись занимает 64 Б, а открытый ключ в сжатом виде – 33 Б. В сериализованном виде эта транзакция занимает 373 Б (именно в таком виде она передается по сети).

> **_Замечание._** *Сериализация – это преобразование какой-либо структуры данных в последовательность битов.*

Чаще всего условия траты монет кодируются в удобный биткоин-адрес, а при формировании транзакции декодируются и указываются в scriptPubKey.

Если детально рассмотреть структуру *входа транзакции (vin)*, то можно видеть четыре поля, как изображено на рис. 4.3. В поле с хэш-значением (*hash*) указывают идентификатор предыдущей транзакции, где монеты были получены. *Index* – это порядковый номер выхода предыдущей транзакции, из которого будут тратиться монеты.

![Рисунок 4.3 – Структура входов транзакции](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.3-structure-of-in.png)

ScriptSig содержит доказательства владения монетами. Это поле так названо, потому что чаще всего содержит цифровую подпись, а также может содержать открытый ключ для проверки этой подписи.

Следующее поле называется *sequence*. Оно обозначает версию транзакции. Ее задает сам отправитель. Благодаря sequence можно заменить транзакцию, которая была отправлена в сеть, но еще не была подтверждена. Допустим, была создана одна транзакция, которая еще не включена в блок по каким-то причинам: либо время еще не прошло, либо слишком низкая комиссия была установлена. Пользователь решает изменить эту транзакцию: изменить адрес получателя монет, указать других получателей, добавить комиссию или изменить сумму платежа и т. д. Тогда он составляет альтернативную транзакцию, которая тратит те же монеты, имеет те же входы, что и предыдущая, но в этих входах он задает значение sequence на единицу больше. По правилам протокола валидаторы, которые будут подтверждать эту транзакцию, могут заменить старую транзакцию. Далее, скорее всего, будет подтверждена именно новая транзакция.

Структура *выхода транзакций (vout)* содержит два поля: *value*, где указывается количество монет, которое предназначается получателю, и scriptPubKey (подробнее в 4.5), где указываются условия траты монет (рис. 4.4). Второе поле получило такое название, потому что чаще всего там указывается либо открытый ключ, либо хэш-значение открытого ключа.

![Рисунок 4.4 – Структура выходов транзакции](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.4-structure-of-out.png)

Таким образом, в отличие от транзакций в традиционных платежных системах, которые по сути содержат в себе одно основное сообщение – перевод определенной суммы с баланса А на баланс Б, – транзакции в Bitcoin представляют собой сложные наборы данных, которые содержат доказательства, что инициатор транзакции владеет монетами, которые он собирается перевести. В некоторых ситуациях такой подход может оказаться более надежным, однако в контексте пропускной способности он является более затратным.

Ограниченная пропускная способность Биткоина как учетной системы стала проблемой, которая требовала решения. Оно было представлено в виде улучшения протокола (обновление Segregated Witness). Было предложено вынести доказательство владения монетами за пределы транзакции, то есть в отдельную структуру *witness data* (рис. 4.5). Таким образом можно не вписывать его в каждый вход транзакции, освободив тем самым значительный объем памяти. Получается, что транзакция содержит все необходимые данные, в том числе о происхождении монет и новом их распределении, но доказательство владения ими находится за пределами транзакции. В некоторых случаях можно использовать основную часть транзакции без witness data (см. 4.6).

![Рисунок 4.5 – Упрощенная структура транзакции после обновления Segregated Witness](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.5-simplified-tx-with-seg-witness.png)

### Непотраченные выходы

*Непотраченный выход (UTXO, Unspent Transaction Output) – это такой выход, монеты которого могут быть потрачены, будучи указанными во входе новой транзакции.*

Выше мы рассмотрели структуру транзакции, и можно отметить, что на уровне протокола нет аккаунтов и балансов, а есть транзакции со входами и выходами. Для каждого выхода характерно два состояния: потраченный и непотраченный.

Непотраченные выходы можно сравнить с наличными деньгами. Владение биткоинами напоминает владение обычными купюрами, которые вы получили, но еще не потратили. Вы не можете сказать точно, сколько денег в вашем кошельке, пока не откроете его и не пересчитаете все деньги. Владея биткоин-кошельком, вы оказываетесь перед необходимостью пересчитать все непотраченные выходы из транзакций, адресованных вам, просуммировать их, и только после этого узнаете свой общий баланс. Конечно, многие биткоин-кошельки делают это автоматически и показывают конечную сумму, но принцип формирования этого баланса именно таков. Суть подобной аналогии в схожести обычной купюры и адресованного вам выхода транзакции, монеты с которого вы еще не потратили. Вы не можете поделить купюру, когда оплачиваете что-то более дешевое – вам нужно ее разменять, то есть отдать купюру с определенным номиналом и получить сдачу купюрами с меньшими номиналами.

Несмотря на то, что на уровне протокола Bitcoin нет балансов, текущим балансом адреса принято называть сумму всех монет на непотраченных выходах, которые были отправлены на данный bitcoin-адрес. Следует понимать, что для каждого адреса в общем случае существует два баланса: условно (с высокой вероятностью) подтвержденный и неподтвержденный.

В реализации полного узла Bitcoin существует отдельный модуль *coins database* для хранения и обработки актуального состояния всего набора UTXO.

### Получение сдачи и установка комиссии

Допустим, пользователь когда-то принял платеж на 10 монет, а теперь он хочет потратить 3 монеты. Но суть в том, что он не может потратить часть – только всю сумму, то есть 10 монет. Напрашивается вопрос о том, как правильно организовать сдачу в Bitcoin.

Потратить только часть из полученных монет нельзя, но ведь можно добавить нескольких получателей в транзакцию. Решение было найдено: создается транзакция, в которой 3 монеты пользователь отправляет получателю, а оставшиеся 7 монет, которые он не хочет тратить, отправляет себе. Получается, что сдача – это выход, адресованный самому себе. Таким образом, у пользователя появляется новый непотраченный выход на эти 7 монет.

Теперь будет логично прояснить вопрос о комиссии, поскольку описанное выше имеет смысл, если транзакция в итоге будет подтверждена. Нужно каким-то образом мотивировать владельца полного узла валидировать именно вашу транзакцию. Именно для этого и предусмотрена комиссия.

В рассмотренной структуре транзакции нет специального поля, в котором бы указывалось значение комиссии. Однако у каждого пользователя есть возможность задать ее в транзакции самостоятельно.

Для этого важно запомнить одно очень простое и логичное правило в рамках протокола Bitcoin: *сумма всех выходов транзакции не должна превышать сумму всех входов*. Сколько монет было, столько после транзакции и остается – они могут быть только по-другому распределены между адресами.

Биткоин устроен так, что комиссия за транзакцию определяется как разница между суммой входов и суммой выходов. Представьте, что у вас есть 5 монет и вы хотите заплатить 2 монеты. Формируете транзакцию так: указываете один вход – выход некоторой предыдущей транзакции, где вы получили 5 монет, – и два выхода. Первый выход отправляет 2 монеты в качестве платы за услугу, второй отправляет сдачу 2 монеты на ваш другой адрес. В итоге, на входе вашей транзакции 5 монет, на выходе – 4. Тогда 1 монета и будет считаться комиссией.

Оставшаяся разница не принадлежит никому до тех пор, пока транзакция не будет подтверждена и включена в блок. Когда будет сформирован блок, в который будет добавлена эта транзакция, создатель блока сможет присвоить комиссионные сборы в качестве вознаграждения.

### Схема передачи монет на примере 

Допустим, есть пользователь по имени Андрей с одним непотраченным выходом на 100 биткоинов: ему подарили их на день рождения. В определенный момент он решил заплатить этими монетами двум людям, что схематично изображено на рис. 4.6.

![Рисунок 4.6 – Платеж двум получателям в рамках одной транзакции](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.6-transfers-within-tx.png)

Пользователь составляет транзакцию с одним входом, где он ссылается на другую транзакцию, из которой он получил эти 100 монет, и добавляет в транзакцию два выхода: один отправляет 45 монет Алене, а другой – 50 монет Артему. Обратите внимание, что разница между суммой входов и суммой выходов равна 5 монетам, которые и являются комиссией в данном случае.

В свою очередь, Алена и Артем могут потратить полученные монеты по-своему (рис. 4.7). Алена должна заплатить садовнику за работу 20 монет. Она ссылается на транзакцию, где получила 45 монет, полностью их тратит в текущей транзакции, указывая получателем адрес садовника, а вторым получателем указывает свой адрес и отправляет туда 20 монет. 5 монет остается в качестве комиссии. Артем, который получил 50 монет, тоже тратит свои средства: 10 монет он платит стекольщику за новые окна, 35 монет идет на оплату услуг автомастерской по ремонту автомобиля, а 5 монет оставляет в качестве комиссии.

![Рисунок 4.7 – Использование выходов из предыдущей транзакции для проведения платежей](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.7-using-tx-to-make-payments.png)

Однако представьте, что стекольщик и владелец автомастерской оказались приятелями и договорились сделать общему другу подарок. Они решили скинуться по 10 монет и купить картину у местного художника. Тогда они составляют общую транзакцию, где будет уже два входа: 10 и 35 монет, и два выхода: один отправляет художнику 20 монет, второй отправляет 20 монет в качестве сдачи владельцу автомастерской (рис. 4.8). Опять же, оставшиеся 5 монет пойдут на комиссию. В нашем случае ее оплатил владелец автомастерской. Будем считать, что у него был долг перед стекольщиком за новое окно.

![Рисунок 4.8 – Создание транзакции с входами от разных отправителей, которые платят одному получателю](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.8-creation-tx-from-diff-senders.png)

### Формирование транзакций в биткоин-кошельках

Как работает биткоин-кошелек и какие процессы происходят во время работы с ним? В кошельке формируются ключевая пара и биткоин-адреса, а также формируются, хранятся, подписываются и отправляются транзакции. Чтобы получать актуальные данные о новых блоках (о новых подтвержденных транзакциях), в сети Bitcoin выполняется синхронизация всех узлов. Кошелек отображает текущий баланс и составляет список совершенных транзакций. Кроме того, правильно реализованное ПО кошельков придерживается определенных правил при формировании транзакций.

> **Широко применяемые правила для формирования транзакции**
>> * *Для каждого входящего платежа и сдачи создавать новый адрес*
>> * *Оптимально подбирать UTXOs для целевой суммы платежа*
>> * *Сортировать входы и выходы транзакции по общему для всех правилу*
>> * *Включать минимальную комиссию независимо от размера транзакции*

Представим, что у некоторого путешественника есть биткоин-кошелек с набором непотраченных выходов: 1 BTC, 3,5 BTC, 0,3 BTC и 0,4 BTC. Путешественник уже готов покорять новые горизонты и ему осталось только оплатить проезд в общественном транспорте (рис. 4.9). Известно, что билет в один конец стоит 0,5 BTC, но в кошельке путешественника нет монеты подходящего номинала. Поэтому программа-кошелек, используя алгоритм поиска лучшей комбинации, выбирает непотраченные выходы с суммами 0,3 BTC и 0,4 BTC. Далее она формирует новую транзакцию, ссылаясь именно на выбранные таким образом монеты.

![Рисунок 4.9 – Выбор соответствующих непотраченных выходов для проведения платежа](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.9-choosing-proper-outputs.png)

В новую транзакцию будет включено два выхода: нулевой адресован продавцу билетов (0,5 BTC), а первый – самому путешественнику как сдача (0,1 BTC). Очевидно, что комиссия за транзакцию составляет 0,1 BTC.

После того как транзакция будет сформирована и подписана кошельком, она должна распространиться по сети. Для этого в сети Bitcoin предусмотрен простой стандартный механизм, напоминающий распространение интересной новости в реальном мире: если у кого-то появилась новость, он попытается рассказать о ней как можно большему количеству людей, и они, в свою очередь, сделают то же.

Рассмотрим Bitcoin-сеть, узлы которой имеют случайный набор соединений друг с другом (рис. 4.10). Некоторый узел сети получает от программного обеспечения кошелька путешественника новую транзакцию, в которой он хочет оплатить проезд парой монет. Узел независимо проверяет транзакцию, добавляет ее в свой *mempool* (если считает правильной), а далее передает ее другим ближайшим узлам. Каждый из этих узлов, в свою очередь, делает то же (предварительно проверив транзакцию, передает ее другим ближайшим узлам). В результате, транзакция распространяется во всей сети Bitcoin.

![Рисунок 4.10 – Распространение транзакции в сети Bitcoin](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.10-propagation-of-tx.png)

Но этот процесс не может продолжаться вечно. Отметим, что каждая транзакция однозначно идентифицируется по ее хэш-значению. Благодаря этому любой узел, участвовавший в пересылке, может определить, получал ли он данное хэш-значение раньше. Если да, то узел не участвует в дальнейшей рассылке во избежание бесконечного цикла прохождения транзакции.

Ранее упоминалось, что по конкретному адресу можно отследить всю историю платежей в Биткоине: можно отследить всю *историю происхождения монет*. Точно так же, как в примере выше (см. пункт «Схема передачи монет на примере»): было 100 монет, и они определенным образом перераспределялись между разными адресами. Имея полную копию базы данных, вы можете отследить историю транзакций до той транзакции, где она была добыта.

Что можно сделать, чтобы финансовая история пользователя не была полностью раскрыта? Представьте, что каждый пользователь Биткоина использует только один адрес и для получения, и для траты монет. Раскрыв соответствие между этим адресом и личностью конкретного пользователя, можно отслеживать всю его финансовую историю, связанную с Биткоином.

На рис. 4.11 схематически изображена связь между разными транзакциями, которые находятся в цепочке блоков. Очевидно, что восстановить в этом случае историю происхождения монет и отследить цепочку транзакций, по которой пользователь получил платеж, не составит труда.

![Рисунок 4.11 – Связь между разными транзакциями в цепочке блоков](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.11-link-between-txs.png)

> **_Замечание._** *На рис. 4.11 нулевой по счету изображена coinbase-транзакция; она содержит предусмотренное правилами протокола вознаграждение для валидатора, создавшего этот блок (детальнее в 4.3). Coinbase-транзакция имеет специальный параметр coinbase maturity, который согласно правилам протокола Bitcoin равен 100. Это значит, что после блока с coinbase-транзакцией в основную цепочку должно быть добавлено 100 блоков, чтобы участник, добывший этот блок, мог потратить монеты из выхода coinbase-транзакции. На схеме выше coinbase maturity равна 1.*

В большинстве случаев отслеживание финансовой истории посторонними лицами неприемлемо для пользователей. Поэтому существует способ, который существенно усложняет распутывание всех цепочек транзакций, отслеживание истории платежей и установление принадлежности конкретных монет конкретным пользователям. Большинство биткоин-кошельков автоматически создают новый адрес для запроса на новый входящий платеж либо для получения сдачи.

### Механизм locktime

Есть способ ограничить подтверждение биткоин-транзакции по времени, и даже если она будет опубликована в сети, валидаторы не смогут ее подтвердить до наступления определенного момента. С этой целью применяется специальный параметр *locktime*. Он представляет собой 4-байтное значение, которое входит в заголовок каждой транзакции в Bitcoin. Это значение и позволяет указать, до какого момента принятие транзакции будет отложено. Параметр *locktime* может быть задан значением одного из двух типов данных: либо времени в формате Unix timestamp, либо высоты блока. По правилам протокола валидатор не может включить в свой блок транзакцию до определенного момента времени или до появления блока с определенной высотой, если установлен параметр *locktime*.

Так реализуется механизм отложенных транзакций, если предполагается, что по некоторой причине непотраченные монеты так и не потратятся (например, ключ будет утерян либо пользователи не достигнут между собой консенсуса и не будут удовлетворены условия траты монет). В таком случае создаются так называемые резервные транзакции, которые переведут монеты на «запасной» адрес по истечении определенного промежутка времени, но до тех пор монеты могут быть использованы как обычно. Схематически это показано на рис. 4.12.

![Рисунок 4.12 – Транзакция с отложенным подтверждением](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.12-tx-with-delayed-confirmation.png)

Допустим, в восемнадцатом блоке был создан некоторый непотраченный выход. Если транзакция, которая тратит монеты этого UTXO, имеет параметр locktime, равный 404, и прошла предварительную верификацию, то она будет оставаться в mempool как неподтвержденная. Там она может находиться до момента подтверждения в блоке с высотой более чем 404 либо может быть заменена конфликтующей транзакцией (например той, которая тратит монеты того же UTXO и включает комиссию большего размера).

> **_Замечание._** *Пользователь может хранить транзакцию и на бумаге в печатном виде. Например, у него отсутствует интернет-соединение, и он не может восстановить его. В этом случае пользователь может сформировать и подписать транзакцию офлайн, а затем распечатать ее на бумаге. Далее он отправляет распечатку доверенной стороне с интернет-соединением (это может быть и получатель монет), которая перенесет данные (уже подписанной транзакции с адресом получателя) с бумаги на свое устройство и распространит транзакцию в сети для подтверждения.* 

### Off-chain протоколы

Из неподтвержденных транзакций можно заранее построить цепочку траты монет, которая может быть подтверждена в будущем. На рисунке 4.13 справа изображена основная цепочка блоков в виде уже сформированных блоков, содержащих *on-chain транзакции*. Слева изображены *off-chain транзакции* – те, которые уже ссылаются на UTXO определенной on-chain транзакции, но еще не были добавлены в основную цепочку блоков (например ввиду заданного параметра locktime). Далее можно построить сколько угодно транзакций, которые будут ссылаться, соответственно, на выходы off-chain транзакций. В результате, мы получим одну или несколько альтернативных цепочек траты монет. Однако ни одна из off-chain транзакций не может быть добавлена в блок основной цепочки, пока не добавлена предшествующая ей транзакция (та, на выход которой она ссылается).

![Рисунок 4.13 – Принцип функционирования off-chain протоколов](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.13-how-off-chain-protocol-work.png)

Какая именно цепочка off-chain транзакций будет подтверждена, определят сами валидаторы. Кто-то из них создаст новый блок, где будет частично или полностью подтверждена одна из альтернативных цепочек. Таким образом, если транзакция не подтверждена, она не блокирует монеты, а на ее основе можно строить цепочку других транзакций. Собственно, это и есть основной принцип работы off-chain протоколов.

### Signature hash types

Процесс подписания bitcoin-транзакции можно разделить на два шага. Первый шаг – это формирование сообщения, на которое будет наложена цифровая подпись. Второй – собственно вычисление цифровой подписи.

Может случиться так, что пользователям удобно подписать только часть транзакции, тем самым оставляя возможность ее частичной модификации. Чаще всего такая потребность возникает при формировании транзакции с несколькими входами, которыми владеют несколько независимых человек.

Давайте рассмотрим, какая часть транзакции может покрываться подписью, как генерируются шаблоны транзакций для каждого типа подписи и в каких случаях стоит использовать конкретный тип подписи. Существует три базовых типа подписи: SIGHASH_ALL, SIGHASH_NONE и SIGHASH_SINGLE [40].

SIGHASH_ALL – наиболее часто используемый тип подписи. Он покрывает все входы и выходы транзакции, защищая все элементы транзакции от модификации. Единственное, что не подпадает под подпись, – это скрипт самой подписи (scriptSig).

SIGHASH_NONE позволяет подписать все входы, но при этом не подписывать ни один выход. В этом случае кто-угодно может изменить выходы транзакции до тех пор, пока они не будут заблокированы другим типом подписи. Бессмысленно формировать транзакцию с одним входом и типом подписи SIGHASH_NONE. В этом случае майнер просто может переписать выходы, и монеты уйдут не по назначению. Такой подход удобно использовать, если формируется совместная транзакция на несколько входов и достаточно только одному из подписантов использовать SIGHASH_ALL.

SIGHASH_SINGLE позволяет подписать все входы и только один из выходов, индекс которого соответствует индексу входа, содержащего подпись. То есть этот случай подразумевает, что вы готовы заплатить на выходной адрес, но только в том случае, если все остальные участники транзакции также потратят свои биткоины. Для чего это может быть нужно? Например, муж и жена хотят заплатить 5 биткоинов за обучение ребенка. У мужа есть непотраченный выход на 3 BTC, у его жены – выход на 2,5 BTC. Они договариваются и формируют транзакцию. Сначала муж подает свои UTXOs на вход. После он подписывает все входы и выход, в котором указывается сумма 5 BTC и адрес учебного заведения. Жена может задать любой выход и при этом не нарушить подпись мужа. Она устанавливает выход, куда отправляет свои 0,5 BTC, и подписывает транзакцию (либо SIGHASH_ALL, либо SIGHASH_SINGLE).

### Запись произвольных данных в цепь блоков

С ростом популярности учетной системы Bitcoin у пользователей закономерно встал вопрос о том, как записывать в нее не только данные об учете монет, но и совершенно произвольные.

Посмотрим еще раз на формат блока: там есть заголовок блока и данные транзакций. Заголовок блока содержит строго 80 Б данных и каждое поле валидируется – туда произвольные данные невозможно добавить. Поэтому рассмотрим детально структуру транзакций (рис. 4.14). Возможно, здесь найдется место для произвольных данных [41].

![Рисунок 4.14 – Пример транзакции, которая содержит произвольные данные](/resources/img/volume-1/4.1-how-do-bitcoin-transactions-work/4.14-arbitary-data.png)

В *заголовке транзакции* содержится 4 Б данных, с помощью которых указана версия транзакции.

Присутствует также поле *lock_time*, где можно произвольно задать момент времени, до наступления которого транзакцию нельзя добавить в блок. В этом случае нужно помнить, что это может значительно ограничить время подтверждения транзакции. Однако действительно можно манипулировать этим значением, задавая момент времени, который уже наступил. Таким образом получится ввести только около 1 Б произвольных данных, а это мало по сравнению с размером всей транзакции. Следовательно, такой способ неэффективен.

*Входы транзакции* содержат хэш-значения от предыдущих транзакций, которые должны соответствовать уже существующим транзакциям; также должны совпадать номера выходов предыдущих транзакций.

Данные *доказательства владения монетами* должны быть целостными, так что внести изменения в них невозможно.

Что же касается *выхода транзакции*, здесь ситуация более благоприятная. Есть определенная сумма монет, которая предназначается получателю. Значение этой суммы устанавливается произвольно в пределах некоторого допустимого диапазона. Иначе говоря, произвольные данные можно вносить, манипулируя *суммой выхода (output amount)*. Кроме того, есть адрес, для которого в процессе верификации транзакции не проверяется, правильно ли он был сформирован; это просто 20-байтное хэш-значение от тех данных, которые еще не опубликованы. Соответственно, их можно установить произвольным образом. Существует множество примеров, где в транзакцию добавлялись избыточные выходы и вместо адресов встраивались произвольные данные, которые имели некоторый смысл для сторонних приложений (например анонимные сигналы трейдеров, а также песни, стихи и т. д.). Сторонние приложения, в свою очередь, имели возможность проверить, что данные действительно хранятся в учетной системе Биткоин.

Разработчики протокола заметили, что спрос на запись произвольных данных существует, поэтому добавили специальную операцию, с помощью которой можно задавать условия траты монет, позволяющие встраивать в выход произвольные данные. Однако по правилам верификации выход транзакции с такой операцией всегда считается неправильным. Это значит, что монеты таких UTXOs потратить невозможно, сколько бы их там ни было. Называется операция OP_RETURN по аналогии с тем, что функция верификации выхода сразу возвращает значение FALSE. Выход, использующий такую операцию, позволяет добавить до 80 Б произвольных данных [42]. Таким образом, многие приложения (в т. ч. реализующие анонимную передачу данных), которые работали поверх Bitcoin, использовали именно эту операцию.

Одним из них стал протокол Colored Coins – это некоторая добавочная логика над обычной логикой функционирования bitcoin-кошелька. В каждую из транзакций по протоколу Colored Coins добавляются дополнительные (избыточные для Bitcoin) данные, которые показывают особенности этой монеты, то есть «подкрашивают» ее в определенный цвет, который ассоциируется с некоторой дополнительной логикой: во-первых, валидацией транзакции, а во-вторых, – смыслом монет, которые передаются в этой транзакции. Смысл этого действия состоит в том, что какое-то маленькое количество биткоинов было окрашено и теперь они представляют ценность не только как биткоины, но и как, например, акция некоторой компании. Если сохранять эти дополнительные данные, то модифицированные кошельки, которые поддерживают протокол Colored Coins, будут распознавать дополнительный смысл монет и, соответственно, отображать другую их стоимость. В то же время эти монеты можно переводить как «обычные» биткоины.

Существуют протоколы, такие как Omni Layer и Counterparty. Они работают поверх протокола Bitcoin и позволяют пользователям выпускать собственные токены (а также обменивать их и торговать ими). Протоколы поддерживают свою логику транзакций, механизм достижения консенсуса, структуру данных транзакции, а также правила их верификации. Особенность данных протоколов состоит в том, что транзакции в них сериализуются и делятся на 80-байтные последовательности данных. Это нужно, чтобы поместить их в биткоин-транзакции. Однако пользователи этих протоколов платят дополнительную комиссию за хранение своих транзакций в Bitcoin, так как одна такая транзакция в общем случае «привязывается» к нескольким биткоин-транзакциям. Следовательно, цена транзакции в рамках протокола Omni Layer или Counterparty будет выше, чем в Bitcoin.

### Итоги

Один кошелек может обрабатывать неограниченное количество адресов, используя каждый раз новый. Это повышает приватность пользователя за счет усложнения отслеживания истории транзакций его цифрового кошелька для сторонних наблюдателей. Важно понимать, что полученные на один кошелек или один адрес монеты не объединяются вместе и в базе данных не записываются в один баланс, – они используются по отдельности. В одном кошельке можно иметь разные монеты: каждой монете будет соответствовать своя история. Можно использовать их по различному назначению и не раскрывать информацию о принадлежности монет одному пользователю.

Каждый выход транзакции привязан к конкретному адресу. Иначе говоря, монеты заблокированы согласно некоторым условиям их траты. Допустим, можно отправить монеты не на обычный адрес, а на адрес, с которого можно потратить монеты только при выполнении некоторых специфических условий. Можно указать, что монеты может потратить тот, кто предоставит решение уравнения (например, если указано уравнение 5 + 7, потратить монеты сможет тот, кто напишет 12 в *scriptSig*). Условия могут быть разными: предоставление открытого цифрового ключа, прообраза хэш-функции или решения определенной математической задачи (подробнее в 4.5).

**Часто задаваемые вопросы**

*– Блокируют ли неподтвержденные транзакции сумму на счете?*

Нет. До тех пор, пока транзакция не подтверждена, можно создать альтернативную транзакцию, которая будет содержать другие условия траты одних и тех же монет. Валидной и включенной в блок будет считаться только одна транзакция из множества всех альтернативных. Принимать решение о включении той или иной транзакции в блок будет непосредственно валидатор, который создаст блок. Транзакция, включенная в блок, будет считаться подтвержденной, если соответствующий блок примут остальные валидаторы.

*– Может ли получатель транзакции увеличить комиссию, чтобы «подтолкнуть» ее, если она остается неподтвержденной?*

Добавить комиссию в ту транзакцию, из которой получает монеты, он не может, но он может потратить из неподтвержденной транзакции монеты и заплатить за новую транзакцию, в которую еще включит сумму, недостающую для предыдущей транзакции. Такая функциональность уже реализована, и она называется child-pays-for-parent (см. 4.7). Некоторые кошельки и большинство валидаторов ее поддерживают: можно заплатить новой транзакцией за старую, чтобы они теперь обе попали в будущий блок.

*– Как правильно посчитать комиссию?*

Комиссия в Биткоине считается не в виде ставки за факт транзакции или процента от суммы платежа, а зависит от популярности Биткоина, то есть количества транзакций в сети, и от размера транзакции в байтах. В первую очередь вам следует ориентироваться на стоимость записи 1 Б данных в базу Биткоина, а потом эту стоимость умножить на размер транзакции в байтах. В Интернете есть множество ресурсов, которые подсчитывают цену записи данных. Обычно это от 10 до 500 сатоши за байт в зависимости от текущей нагрузки на сеть. В некоторых случаях кошельки используют динамическое значение этой цены, в некоторых – константное значение, а в некоторых случаях пользователь может самостоятельно задать значение комиссии.

*– Может ли валидатор подтверждать транзакции вне зависимости от размера комиссии?*

Валидаторы вольны выбирать самостоятельно транзакции, которые они будут подтверждать. Он может фильтровать маленькие транзакции и добавлять только большие, может добавлять только транзакции друзей, а может выбирать те транзакции, где комиссия меньше – все зависит от владельца мощности, он самостоятельно распоряжается своим ПО. Чаще всего валидаторы в погоне за выгодой подтверждают только те транзакции, которые больше всех платят за единицу объема своих данных. Если же вы – валидатор и хотите подтвердить транзакции с нулевой комиссией, то вы можете это осуществить, самостоятельно подтверждая свои транзакции, которые не платят комиссии. В этом случае вы ничего не выиграете, потому что если вы заплатите большую комиссию, то сами ее заберете. Такие транзакции лучше не распространять в сети, а добавлять только в свои блоки.

*– Почему кошельки не имеют функциональности для отправки монет нескольким получателям одной транзакцией?*

Да, действительно, обычно кошельки предусматривают создание транзакций на два выхода: для платежа и для сдачи. Кошельки редко реализуют функциональность для включения нескольких получателей в одну транзакцию, потому что она актуальна только в редких случаях. Однако если вы возьмете Bitcoin Core, Electrum и еще некоторые desktop-кошельки, то там реализована такая функциональность и вы можете добавить сколько угодно получателей в транзакцию. Вы также можете выбирать монеты из ранее полученных и решать, какие из них тратить. Итак, если вам нужен гибкий способ составления транзакций, то он тоже есть.

*– Если можно усложнить отслеживание цепочек транзакций и принадлежности биткоинов каким-то определенным лицам, для чего существуют тогда миксеры?*

Действительно, генерация новых адресов эффективно усложняет отслеживание цепочек, но не исключает такую возможность. Существуют способы, которые позволяют восстановить с определенной долей вероятности настоящее распределение монет среди пользователей. Централизованные миксеры – лишь один из способов запутывания истории монет, но он считается ненадежным по сравнению с другими способами, потому что не обладает свойством trustlessness (подробнее в 7.2).

*– Можно ли сформировать две разные транзакции, которые будут тратить одни и те же монеты?*

Да, можно. Но тогда мы будем иметь две конфликтующие транзакции. Можно задать правила, согласно которым одна из них будет более приоритетной для добавления в блок, с помощью параметра sequence. Если же таких правил не задавать, то валидаторы добавят одну из них в блок по своему усмотрению.

*– Как формировать транзакции для уменьшения комиссии?*

Нужно оптимальными образом подбирать непотраченные выходы или использовать кошельки, где реализован специальный алгоритм для этого. По аналогии с тем, как люди подбирают купюры, оплачивая товар в магазине наличными. Ведь проще сумму $30 оплатить двумя купюрами (с номиналами $20 и $10), нежели тридцатью купюрами с номиналом $1. Точно так же – с биткоинами: вам нужно выбирать непотраченные выходы, которые наиболее соответствуют своим «номиналам». Если вы хотите заплатить нескольким людям сразу, то лучше сделать это не отдельными транзакциями, а одной. В этом случае размер одной транзакции будет определенно меньше суммарного размера нескольких отдельных, даже если они используют один набор UTXO, поскольку выход для сдачи будет включен только один раз. За счет такой оптимизации данных вы экономите на комиссии.

*– Как достигается атомарность транзакции?*

Дело в том, что популярные децентрализованные учетные системы проверяют транзакции гораздо проще чем популярные централизованные системы за счет отсутствия ограничений на суммы платежей, их количество, а также отсутствия черных списков и запретов получения платежей от конкретных отправителей. Эти и похожие особенности позволяют проверять транзакции узлам децентрализованной системы почти мгновенно и как следствие возможность делать это последовательно избегая конфликтов. В результате транзакции не имеют промежуточных статусов между непроверенными и проверенными.

*– Может быть транзакция, которая платит нуль монет и все 100% входов уходят на комиссию?*

По правилам протокола такая транзакция является правильной и может быть подтверждена, но узлы часто используют дополнительные рекомендации при верификации и распространении транзакций, одна из которых не пропускает транзакции, где есть выход с нулем монет.

*– Возможно ли имея один UTXO отправить одновременно две транзакции на разные адреса?*

Создать такие транзакции можно, но они будут конфликтующими между собой, поэтому при их распространении по сети узлы будут добавлять в свой mempool только одну из них. Соответственно подтверждена будет только одна из конфликтующих транзакций и предугадать какая именно сложно. Есть способ заплатить двум получателям в двух разных транзакциях имея один UTXO. Для этого в первой транзакции нужно предусмотреть выход со сдачей, а во второй потратить эту сдачу.

*– Возможно ли строить цепочки траты на будущее из неподтвержденных транзакций?*

Да, это одно из преимуществ использования атомарных транзакций. Но стоит понимать, что факт существования цепочки таких транзакций не гарантирует их подтверждения в будущем. Поскольку транзакция может быть подтверждена только после либо одновременно с предыдущей. А если предыдущая транзакция потерялась или была подтверждена транзакция, которая конфликтует с ней, то следующая уже не сможет подтвердится.

*–  Как можно быть уверенным в том, что узлы верно распространяют данные сформированной транзакции?*

Дело в том, что если нарушить данные транзакции, то цифровая подпись будет не верна и вся транзакция считается неправильной.

## 4.2 Майнинг в Bitcoin

Одной из задач, которые стояли перед создателем Биткоина, являлось обеспечение синхронизации данных между неизвестным множеством участников, которые не могут быть идентифицированы и не доверяют друг другу. Существующие в то время подходы к достижению консенсуса не подходили для применения в таких условиях, поскольку атакующий мог создать множество фиктивных участников и действовать от их имени, навязывая честным участникам свою версию истории транзакций (так называемая атака Сивиллы, или Sybil attack). В итоге, эта задача была решена способом, который не гарантирует финальность истории транзакций, однако делает атаку экономически невыгодной при нормальных условиях. Идея состояла в том, чтобы вместо того, чтобы проводить голосование за транзакции по принципу большинства участников, требовалось, чтобы голосующие предоставляли доказательство владения физическим ресурсом (то есть доказательство выполненной работы), которое отражало непосредственные затраты реальных денежных средств.

Таким образом, для успешного навязывания своего мнения атакующему было бы необходимо наличие большего количества ресурсов, чем у всех остальных честных участников. В некотором смысле майнинг выполняет роль абсолютно честной лотереи, определяющей победителя (из тех, кто предоставил доказательство своей работы), который получает право сформировать новый блок и получить вознаграждение за свою работу.

В этом подразделе мы рассмотрим механизм майнинга в Bitcoin, его роль в децентрализованной среде, а также его особенности и задачи, которые он решает.

### Цели майнинга в Bitcoin 

*Майнинг в Биткоине – это процесс создания блока и подтверждения транзакций, который вознаграждается монетами* [43]. Этот процесс имеет несколько целей. Одна из них – мотивировать пользователей запускать узлы сети и поддерживать корректную работу платежной системы. Другая важная цель – обеспечение принятия решений в децентрализованной среде. Майнинг защищает историю транзакций в Bitcoin от изменений. Пользователь, который успешно создал новый блок цепочки, получает некоторое количество новых биткоинов, предусмотренное правилами протокола. Майнинг также решил задачу честного первичного распределения биткоинов, ведь участие было доступно любому, у кого был компьютер. 

> **Задачи, которые решает майнинг**
>> * *Принятие решений в децентрализованной среде*
>> * *Выбор основной версии истории транзакций*
>> * *Подтверждение транзакций*
>> * *Осуществление эмиссии*

### Классификация узлов сети

Bitcoin-сеть можно представить схематически, как на рис. 4.15. Независимые люди и организации поддерживают полные узлы, но только некоторые из них занимаются майнингом, т. е. фактически являются узлами-валидаторами.

![Рисунок 4.15 – Схема Bitcoin-сети](/resources/img/volume-1/4.2-mining-in-bitcoin/4.15-scheme-of-bitcoin-network.png)

В сети есть множество пользователей, и каждый из них преследует собственные цели. Кто-то разворачивает полный узел и майнит, активно поддерживая сеть, кто-то просто хранит и обрабатывает все транзакции, кто-то работает оператором платежного шлюза, а кто-то просто пользуется кошельком и непосредственного участия в подтверждении транзакций не принимает. Таким образом, все узлы сети Bitcoin можно разделить как минимум на три группы (рис. 4.16).

![Рисунок 4.16 – Классификация узлов сети Bitcoin](/resources/img/volume-1/4.2-mining-in-bitcoin/4.16-classification-of-nodes.png)

*Полный узел – узел, выполняющий проверку и хранение всех транзакций.*

*Узел-валидатор – полный узел, который создает блоки.*

*Облегченный узел – узел, выполняющий синхронизацию и проверку только своих транзакций.*

### Понятие ресурсоемкая задача

Ресурсоемкая задача в Биткоине состоит в нахождении прообраза хэш-значения, полученного с помощью алгоритма SHA-2 на длине 256 бит. Решение задачи возможно найти только поиском грубой силой, поэтому его нахождение требует большого количества ресурсов. Перебор заключается в поиске такого входного значения, которое при хэшировании на выходе даст значение определенного вида (рис. 4.17).

![Рисунок 4.17 – Перебор значений в поисках прообраза](/resources/img/volume-1/4.2-mining-in-bitcoin/4.17-brute-force-search.png)

Более того, это хэш-значение должно удовлетворить определенному параметру сложности (*difficulty*). Согласно правилам протокола Биткоин с увеличением параметра сложности увеличивается количество нулевых старших шестнадцатеричных разрядов в итоговом хэш-значении.

Перерасчет параметра сложности выполняется один раз в 2016 блоков с определенными ограничениями на максимальное изменение с целью защиты от резких изменений за короткий промежуток времени [44]. Алгоритм пересчета сложности сравнивает время, затраченное на формирование последних 2016 блоков, с двумя неделями (с 1 209 600 секундами). Если на формирование блоков ушло меньше этого значения, то параметр сложности пропорционально увеличивается. Если на формирование блоков ушло больше времени, то сложность пропорционально уменьшается.

> **_Замечание._** *Параметр сложности не может увеличиться или уменьшиться в более чем 4 раза.* 
> 
> *Ресурсоемкая задача уникальна для каждого блока, поскольку данные, которые содержит блок, являются входными для формирования новой задачи.*

> * *Невозможно украсть чужое решение и применить его в своем блоке*
> * *Невозможно создать новый блок, не имея данных предыдущего блока*

В контексте Биткоина ресурсоемкую задачу также называют задачей на формирование proof-of-work (задачей PoW), поскольку ее решение является легко проверяемым доказательством того, что автор блока проделал определенную работу, которая соответствует заданному параметру сложности.

> **Требования к задаче на формирование PoW в Bitcoin**
>> * *Возможность самостоятельно выбрать входные данные для решения задачи* 
>> * *Проверка решения должна быть очень быстрой* 
>> * *Проверить решение может любой желающий* 
>> * *Хэш-значение предыдущего блока заранее не известно* 
>> * *Входные данные к задаче для следующего блока отличаются для всех валидаторов* 
>> * *Сложность задачи одинакова для всех участников* 
>> * *Затраты ресурсов для нахождения решения определяются параметром сложности*

Исходя из вышеизложенного, можно сделать вывод, что возможность создать новый блок первым есть у каждого. Вопрос состоит только о вероятности этого события для разных участников.

Поскольку каждый участник формирует свою версию следующего блока, то и входные данные будут у каждого свои. Однако сложность этой задачи будет для всех одинаковой. Учитывая, что задача решается методом перебора (грубой силой), вероятность решить ее первым будет пропорционально увеличиваться с ростом процента вычислительной мощности, которой обладает участник по отношению ко всей задействованной в сети мощности.

Майнинг вознаграждается биткоинами. Это фактическая плата за поддержание надежной работы децентрализованной учетной системы. Принцип таков: участники, которые не предоставили доказательство решения сложной задачи, не получают права подтверждения транзакций. Чем больше независимых и честных валидаторов работают в сети, тем надежнее Биткоин [45].

В итоге, такой простой механизм мотивации людей к майнингу формирует желание зарабатывать больше и тем самым стимулирует предпринимателей к покупке и запуску большего количества компьютеров. Они конкурируют за вознаграждение, и сложность ресурсоемкой задачи, соответственно, повышается [46].

### Ограничение частоты формирования блоков

Протокол задает среднее время формирования блока, равное 10 минутам. Чтобы обеспечить выполнение этого правила, через каждые 2016 блоков происходит перерасчет параметра сложности, с учетом которого будут формироваться следующие блоки. Если, например, мощность сети резко возрастет и 2016 блоков будут найдены гораздо раньше, чем за 2 недели, то параметр сложности возрастет, и частота появления новых блоков нормализуется. Такая схема позволяет обеспечивать среднее время формирования блока, близкое к заданным 10 минутам, что принципиально важно для Bitcoin.

### Orphan blocks

Очевидно, что над созданием новых блоков работает много валидаторов, которые рассредоточены по разным континентам земного шара [47]. В силу того, что время распространения сообщений через каналы передачи данных не равно нулю, между узлами сети будут задержки синхронизации. Грубо говоря, узлы, которые расположены на одном континенте, получат новый блок от валидатора со своего континента раньше, чем новый блок от валидатора с другого континента, при том условии, что оба блока были созданы в один момент времени. Поэтому неизбежны ситуации, в которых узлы сети будут иметь неодинаковые конечные состояния своих баз данных (ситуация подобна описанной ранее в 2.5 о Капитане Джеке Воробье и его команде).

Как же происходит дальнейшее формирование и добавление следующего блока? Каждый валидатор выбирает блок, который он считает правильным (например тот, что был получен раньше прочих), добавляет его в свою копию базы данных и на основе него начинает создавать новый блок. При этом блоки с одинаковой высотой конкурируют друг с другом за возможность стать продолжением основной цепочки (mainchain). «Побеждает» та версия цепочки, на создание блоков которой было потрачено больше вычислительной мощности. В результате, появляются так называемые *orphan blocks*, то есть валидные блоки, которые, однако, не попадают в основную цепочку блоков. Транзакции, находящиеся в этих блоках, корректные; они могут быть подтверждены и добавлены в блок (и, соответственно, в mainchain) позже.

Иногда возникновение orphan blocks влечет нежелательные последствия. Первое состоит в том, что валидатор, который сформировал orphan block, в конечном счете лишается награды за его добычу. На графике (рис. 4.18) приведена статистика количества сформированных orphan blocks в течение промежутка времени с марта 2014 года по июль 2017 года [48].

![Рисунок 4.18 – График частоты формирования orphan blocks](/resources/img/volume-1/4.2-mining-in-bitcoin/4.18-orphan-blocks-freq.png)

Кроме того, появление большого количества orphan blocks может способствовать проведению атаки 51%. Это связано с тем, что вся вычислительная мощность сети распределяется между альтернативными цепочками, которые, в свою очередь, конкурируют друг с другом, что приводит к ситуации, при которой у злоумышленника становится больше шансов получить контроль большей частью вычислительной мощности, направленной на формирование отдельной цепи. Как упоминалось в 2.5, результатом атаки 51% может быть двойная трата (то есть злоумышленник сможет потратить одни и те же деньги более одного раза). Отметим, что одна из целей, для которой параметр сложности пересчитывается каждые 2016 блоков заключается в выравнивании мощностей валидаторов, благодаря чему не допускается увеличение количества orphan blocks.

> **_Замечание._** *Иногда люди путают два понятия: orphan blocks и stale blocks. На самом деле эти термины различные. Orphan blocks – это блоки, которые созданы правильно и полностью, по стечению обстоятельств они не были добавлены в основную цепочку блоков. Stale blocks – это блоки, над которыми валидаторы прекратили работу ввиду того, что другой валидатор сформировал правильный блок (решил ресурсоемкую задачу раньше).*

### Атака двойной траты

Можно выделить одну атаку, от которой должна быть защищена любая система учета финансов. Это так называемая *атака двойной траты (double-spending attack)*, суть которой состоит в том, что пользователь отправляет одни и те же монеты двум разным получателям и оба принимают платеж. Конечно же, монет в два раза больше не станет, но отправитель может с помощью хитрости заставить получателей поверить, что они уже владеют монетами.

В контексте Bitcoin существует несколько способов, с помощью которых злоумышленник может потенциально реализовать атаку двойной траты. Один из наиболее тривиальных способов – нахождение уязвимости в программном обеспечении большинства узлов, поддерживающих сеть Bitcoin, которая технически может позволить злоумышленнику удвоить монеты. Другой способ – это когда отдельная сторона (группа, организация) владеет вычислительной мощностью, превышающей 51% от общей. В таком случае эта сторона может с легкостью подвергать цензуре транзакции в сети и совершать атаки двойной траты, используя свои вычислительные ресурсы.

В качестве примера можно представить пользователя по имени Тарас, у которого есть 4 монеты и намерение совершить атаку двойной траты. Он собирается купить компьютер в интернет-магазине E1 и смартфон в интернет-магазине E2, причем каждый из товаров стоит по 4 монеты (рис. 4.19). Поскольку у него всего 4 монеты, он собирается рассчитаться ими дважды.

![Рисунок 4.19 – Создание двух транзакций, которые тратят одинаковые монеты](/resources/img/volume-1/4.2-mining-in-bitcoin/4.19-conflicting-txs.png)

Итак, Тарас создает две транзакции. В первой транзакции монеты отправляются на кошелек интернет-магазина E1, а во второй – интернет-магазина E2. Естественно, эти транзакции являются конфликтующими и не могут быть подтверждены одновременно. Поэтому первую транзакцию Тарас сразу распространяет в сеть, а вторую держит в тайне.

Пока интернет-магазин E1 дожидается полного подтверждения первой транзакции, Тарас быстро формирует блок, в который включает свою вторую транзакцию (и неподтвержденные транзакции других пользователей по желанию). Этот блок ссылается на состояние цепочки блоков, когда у Тараса было 4 монеты, поэтому правила протокола распознают вторую транзакцию корректной.

Сразу после этого Тарас начинает майнить, чтобы подтвердить альтернативный блок. Если блок создан успешно, не публикуя его, Тарас сразу начинает создавать следующий блок на его основе. Идея Тараса состоит в том, что он в тайне строит вторую цепочку, где подтверждает транзакцию для E2. Очевидно, что он не будет публиковать ее в сеть, пока E1 не примет платеж (рис. 4.20).

![Рисунок 4.20 – Один из магазинов принимает платеж](/resources/img/volume-1/4.2-mining-in-bitcoin/4.20-acceptance-of-payment-by-the-shop.png)

Согласно правилу самой длинной цепочки ветка Тараса должна быть длиннее, чем у всех остальных валидаторов. Когда интернет-магазин E1 видит, что первая транзакция получила достаточное количество подтверждений, он уверен, что товар оплачен, и отправляет компьютер. Не теряя времени, Тарас публикует свою альтернативную цепочку. Если эта цепь будет превосходить по длине цепочки других валидаторов, все узлы переключатся на нее и будут считать основной цепочкой (рис. 4.21). Это будет возможно только в том случае, если Тарас контролирует более половины вычислительной мощности сети Bitcoin.

![Рисунок 4.21 – Тарас проводит двойную трату](/resources/img/volume-1/4.2-mining-in-bitcoin/4.21-doublespending.png)

Согласно альтернативной цепочке блоков те же 4 монеты теперь принадлежат интернет-магазину E2, который отправит Тарасу смартфон. Тот факт, что прежняя цепочка с первой транзакцией теперь считается недействительной, свидетельствует о том, что интернет-магазин E1 останется без монет (рис. 4.22). Если это так, то мы можем утверждать, что Тарас выполнил атаку 51%, в результате чего потратил свои монеты дважды.

![Рисунок 4.22 – Результат выполнения атаки](/resources/img/volume-1/4.2-mining-in-bitcoin/4.22-result-of-attack.png)

### Появление специального оборудования

Так сложилось, что со временем для эффективного майнинга понадобилось специализированное оборудование [49]. Во времена стремительного роста цены на монеты, майнинг оказался весьма прибыльной деятельностью. Люди старались обзавестись как можно большим количеством вычислительных ресурсов, чтобы иметь возможность конкурировать друг с другом за вознаграждение, решая задачу PoW. Стало понятно, что решать ее на центральном процессоре обычного компьютера неэффективно.

> * *CPU – центральные процессоры (2009–2010)*
> * *GPU – графические процессоры (2010–2012)*
> * *FPGA – программируемые вентильные матрицы (2011–2013)*
> * *ASIC – интегральные схемы специального назначения (2012–настоящее время)*

Появилась идея выполнять вычисления на графическом процессоре, поскольку это позволило бы выполнять перебор в несколько потоков параллельно и с гораздо меньшими затратами электроэнергии. Чтобы этого добиться, решили адаптировать исходный код решения задачи под его выполнение на графическом процессоре. Таким образом, продолжался рост спроса на все более и более энергоэффективное оборудование для майнинга. В результате, даже появились компании, которые спроектировали оптимизированные чипы (ASIC) для решения однотипных задач (поиск прообраза хэш-значения) и освоили их производство (рис. 4.23).

![Рисунок 4.23 – Оборудование для майнинга](/resources/img/volume-1/4.2-mining-in-bitcoin/4.23-mining-equip.jpg)

Первые такие чипы начали появляться в 2012 году. Они существенно превосходили по производительности (в тысячи раз) процессоры обычных компьютеров. Материальная выгода привлекла множество участников, которые наращивали свою мощность (*hash rate*). Постепенно эта тенденция стала напоминать гонку мощностей. На графике ниже (рис. 4.24) отображена зависимость hash rate всей сети Биткоин от времени [50].

![Рисунок 4.24 – График изменения значения hash rate с течением времени](/resources/img/volume-1/4.2-mining-in-bitcoin/4.24-hashrate.png)

Учитывая постоянно подстраивающийся параметр сложности (рис. 4.25) [50], участникам нужно совершенствовать майнинговое оборудование, чтобы решать поставленные задачи более энергоэффективно. Кроме энергоэффективности, в качестве критериев оценки оборудования можно использовать показатели, такие как время нахождения решения конкретным устройством и стоимость этого решения.

![Рисунок 4.25 – Изменение параметра сложности в Bitcoin](/resources/img/volume-1/4.2-mining-in-bitcoin/4.25-difficulty.png)

### Майнинговые пулы и их задачи

Допустим, в сети есть 1 млн одинаковых компьютеров. Вероятность нахождения блока одним компьютером в этом случае равна 0,000001. Соответственно, владелец оборудования с такой мощностью создает один блок в среднем за 10 млн минут, то есть за чуть большее время, чем 19 лет.

Естественно, никого не устраивает сомнительный инвестиционный цикл длительностью 19 лет. Поэтому люди объединяют свои майнинговые мощности, чтобы быстрее решить одну общую задачу и распределить вознаграждение. Таким образом добытчики биткоинов начали объединяться в майнинговые пулы.

*Майнинговый пул (mining pool) – это группа владельцев майнингового оборудования, в которой есть один ведущий.* Он формирует блок и раздает всем участникам группы задания. Если один из участников находит решение, то вознаграждение распределяется между всеми пропорционально мощности задействованного оборудования. В результате, участники пула получают вознаграждения меньшего размера, но достаточно часто (рис. 4.26).

![Рисунок 4.26 – Сравнение одиночного майнинга и майнинга в пуле по частоте нахождения блока и объемом вознаграждения](/resources/img/volume-1/4.2-mining-in-bitcoin/4.26-comparing-solo-and-pool-mining.png)

Касательно такого подхода следует отметить одну деталь: конкретный владелец майнингового оборудования не решает, какие транзакции включать в блок. Его задание заключается только в решении ресурсоемкой задачи. Но когда владелец майнингового оборудования замечает, что ведущий его майнингового пула подозрительно выбирает транзакции для подтверждения, то он выбирает для подключения другой майнинговый пул, который по мнению предпринимателя является более честным и независимым, и в дальнейшем работает уже с ним.

На диаграммах ниже отображено распределение вычислительных мощностей сети Биткоин между валидаторами [51]. Некоторые валидаторы раскрыли свои личности, а некоторые – нет («Unknown»). В идеальном случае с точки зрения *децентрализации и независимости принятия решений* валидаторы должны оставаться анонимными (однако это нельзя считать гарантированным условием; ниже мы объясним почему). Но давайте проанализируем изменение ситуации в пределах небольшого промежутка времени.

Как видно на диаграмме (рис. 4.27), суммарная вычислительная мощность таких валидаторов не превышает 9%. Представленные данные актуальны по состоянию на конец августа 2018 года и позволяют сделать вывод о том, что большая часть блоков формируется от имени публично известных узлов-валидаторов, которые являются ведущими майнинговых пулов. Соответственно, можно видеть, что пулы, такие как BTC.com, AntPool, SlushPool, BTC.TOP, аккумулируют больше половины всей вычислительной мощности. И хотя до этого момента пулы не сговаривались между собой, на самом деле это не идеальная реализация принципов децентрализации.

![Рисунок 4.27 – Распределение майнинговых мощностей в сети Bitcoin на конец августа 2018 года](/resources/img/volume-1/4.2-mining-in-bitcoin/4.27-distributing-the-mining-capacities.png)

Технически пулы могли бы провести атаку 51%, но если бы случилась атака, то в сети это сразу было бы заметно. Скорее всего, сообщество это возмутило бы – и владельцы майнинговых мощностей перешли бы в другую группу с другим ведущим. Участники сговора же утратили бы свою репутацию, своих клиентов и свой бизнес.

Интересным является тот факт, что немного позже, а именно в начале декабря того же года (рис. 4.28) доля анонимных валидаторов возросла до 22,6%. На первый взгляд такое положение благоприятно в контексте децентрализованной системы, но проанализировав возможные угрозы, можно заключить, что тот факт, что валидаторы анонимны, не обязательно означает, что они независимы относительно друг друга. Технически валидаторы могут образовывать анонимные пулы, которые сложно деанонимизировать. Причем владеть таким пулом может как группа валидаторов, так и один человек. Существует вероятность, что, достигнув некоторого порогового размера, такой майнинговый пул может провести атаку двойной траты.

![Рисунок 4.28 – Распределение майнинговых мощностей в сети Bitcoin на начало декабря 2018 года](/resources/img/volume-1/4.2-mining-in-bitcoin/4.28-distributing-th-mining-cap-december.png)

### Mining statistics and estimation of energy consumption

В апреле 2018 года показатель потребленной электроэнергии для майнинга составил 110 ГВт в сутки, а сумма вознаграждений всех предпринимателей, занимающихся майнингом, за сутки – $32 млн [52; 53]. Процент комиссионных сборов от всего вознаграждения составлял 21%, т. е. приблизительно пятую часть, а комиссия за среднюю по размеру транзакцию в течение года колебалась от $0,1 до $40. Размер всех данных в блокчейне Биткоина превышает 175 ГиБ.

Показатель потребленной электроэнергии возрос в следующие несколько месяцев и 31 августа 2018 года для сети Bitcoin составил 200,3 ГВт в сутки, т. е. 73,1 ТВт в год.

Чтобы понять, много это или мало, посмотрим, сколько электроэнергии может произвести самая мощная электростанция в мире. Таковой на конец августа 2018 года считается китайская Three Gorges Dam [113], и за 2017 год ее показатель произведенной электроэнергии составил 97,6 ТВт. График на рисунке 4.29 не менее показателен. На нем изображен уровень энергопотребления Bitcoin в сравнении с некоторыми государствами. Очевидно, что уровень потребления электроэнергии, необходимый для функционирования Bitcoin, превышает потребности Чешской Республики, Чили или Австрии [52].

![Рисунок 4.29 – Траты электроэнергии государств по сравнению с Bitcoin](/resources/img/volume-1/4.2-mining-in-bitcoin/4.29-energy-consumption.png)

Было вычислено, что для подтверждения одной транзакции в Bitcoin потребляется около 921 кВт в сутки. Приблизительно столько же электроэнергии нужно, чтобы обеспечить более 30 среднестатистических домов США на протяжении суток. Если сравнить Bitcoin с платежной системой Visa и проанализировать график на рис. 4.30, несложно вычислить, что 1 транзакция в Bitcoin выходит дороже, чем 500 000 транзакций в системе Visa.

![Рисунок 4.30 – Затраты на транзакцию в Bitcoin по сравнению с затратами на транзакцию в Visa](/resources/img/volume-1/4.2-mining-in-bitcoin/4.30-bitcoin-vs-visa.png)

Потребление электроэнергии в Bitcoin не всегда повышается. Проследив за изменением этого показателя с августа по декабрь 2018 года [54], можно отметить его резкое снижение с середины ноября до значения 53,04 ТВт в год (рис. 4.31).

![Рисунок 4.31 – Потребление электроэнергии в Bitcoin](/resources/img/volume-1/4.2-mining-in-bitcoin/4.31-energy-in-bitcoin.png)

Несмотря на явно расточительное энергопотребление, не все так однозначно, поскольку ценность Bitcoin заключается прежде всего в его свойствах, в т. ч. в *защищенности от цензурирования транзакций*. Более того, ежедневно сообщество поддерживает и развивает протокол, предлагает улучшения и новые способы оптимизации его работы.

**Распространенные мифы**

*После 2140 года майнинг прекратится.*

После 2140 года майнинг не будет прекращен и валидаторы продолжат получать вознаграждение за формирование блоков. Однако вознаграждение будет состоять исключительно из комиссий за транзакции, без новых выпущенных монет.

*Стоимость биткоина полностью зависит от стоимости майнинга.*

На самом же деле прямой зависимости между ценой монеты и затратами на ее добычу нет (по той же причине, по которой цена золота в долларах не определяется напрямую стоимостью добычи золота). Возможна лишь косвенная зависимость: когда цена монет возрастает, появляется больше желающих добывать их.

*Если кто-то купит и запустит больше оборудования, то гарантированно добудет больше биткоинов или даже добудет все монеты, предусмотренные как эмиссия, гораздо раньше 2140 года*

Если использовать больше вычислительных мощностей, то можно увеличить свою долю вознаграждения, но добыть больше монет, чем заранее предопределено, нельзя. Темп эмиссии никак не зависит от того, какая текущая майнинговая мощность всей сети.

*Сложность майнинга всегда повышается.*

Это не так, она может и снижаться. Сложность росла, потому что биткоины дорожали, что влекло рост конкуренции за вознаграждение. Если же вознаграждения в долларовом эквиваленте будут снижаться, то желающих майнить будет меньше. В крайнем случае возможно, что уже работающее оборудование придется отключить, поскольку вознаграждения может не хватать для оплаты электроэнергии и прочих расходов на его обслуживание.

*Если взять суперкомпьютер и начать майнить, то можно всегда первым создавать блок.*

Самый мощный суперкомпьютер в мире не получит и доли процента от всей вычислительной мощности сети Bitcoin, потому что суперкомпьютер использует обычные процессоры широкого назначения, которые не адаптированы под задачу PoW именно в Bitcoin. Поэтому компании, такие как Google или IBM, не могут эффективно использовать свои data-центры, для цензурирования подтверждаемых транзакций.

**Часто задаваемые вопросы**

*– Имея возможность вычислять хэш-значение быстрее всех остальных, разве нельзя перезаписать существующие блоки?*

Можно, но есть особенности. Нужно учитывать процент имеющейся вычислительной мощности относительно мощности всех остальных в сети, затраты на обслуживание оборудования и время, в течение которого придется работать. Поэтому предварительно нужно рассчитать экономическую целесообразность переписывания истории последних блоков, поскольку ключевым показателем в процессе майнинга является его энергоэффективность. В подавляющем большинстве случаев, стоимость атаки по сумме затрат превышает извлеченную пользу.

*– Как посчитали дату добычи последнего биткоина, если частота генерации блока может изменяться во времени?*

На коротких промежутках времени частота генерации блоков действительно может резко отличаться. Однако на длинных промежутках времени она почти одинаковая. По правилам протокола система стремиться к тому, чтобы средний период формирования блока был равен 10 минутам. Это достигается за счет регулирования параметра сложности задачи PoW.

*– Почему такая слабая конкуренция в сфере производства вычислительных машин для добычи биткоинов?*

На момент 2018 года существует 5 крупных компаний, которые проектируют майнинговое оборудование, и 2 крупные компании, которые производят для него специализированные чипы. Такое производство достаточно сложное, нужны инвестиции для разработки чипа и его производства. Это дело на миллионы долларов. Более того, производственный цикл может занять больше года, а область высокорисковая, поскольку эти чипы больше никому, кроме предпринимателей, добывающих биткоины, продать не получится. Естественно, предприниматели неохотно идут в эту отрасль. Тем не менее, конкуренция производителей все-таки присутствует.

*– Каково различие между майнером и валидатором в Биткоине?*

Некоторые люди путают эти термины. Строго говоря, валидатор – это роль участника системы, т. е. это предприниматель, который настраивает оборудование и следит за корректностью его работы. Майнер же – это то, что решает ресурсоемкую задачу, т. е. само оборудование.

*– Как в случае proof-of-work определяется, кто первым найдет блок?*

В процессе решения задачи на proof-of-work невозможно определить кто найдет решение первым. Даже когда на одной высоте цепочки появится несколько решенных блоков, то невозможно определить и тем более доказать какой из блоков был создан раньше. Поэтому в mainchain останется тот блок, на основании которого продолжат строить цепочку.

*– Ресурсоемкую задачу можно решить раньше только за счет повышения вычислительной мощности?*

Если не принимать во внимание везение, что фактически случайность, то да.

## 4.3 Как реализован blockchain в Bitcoin?

Сам подход к хранению данных в связанном виде не является чем-то новым, однако блокчейн стал новым способом организации базы данных целой учетной системы. И это случилось не в результате теоретических научных разработок, а при попытке ответить на угрозы безопасности со стороны участников анонимной распределенной сети. Важно отметить, что существовавшие до этого учетные системы часто опирались на нетехнологические способы защиты информации и разрешение конфликтов – это было возможно в неанонимной среде, где существуют предопределенные стороны, призванные регулировать проблемные ситуации, такие как суды, полиция и т. п. Сатоши, как некоторые другие инженеры, делал попытки создания *финансовой учетной системы*, в которой бы все стали равноправными и могли сохранять приватность. В этом случае уже невозможно прибегнуть к помощи суда (это может быть как плюсом, так и минусом, в зависимости от ситуации и цели пользователя).

Анонимная распределенная сеть, к тому же устойчивая к цензуре, требовала совершенно других подходов к решению проблем – в обычном мире многие нежелательные вещи просто не происходят, потому что существует риск раскрытия преступления, последующей огласки, потери репутации и даже тюремного заключения. Поэтому защита от многих атак просто отсутствует – общество, в котором законы работают эффективно, их попросту не требует. Например, в США при утере банковской карты и PIN-кода к ней банк все равно вернет вам украденные деньги – т. к. все застраховано. И даже если около 4% прибыли банков тратится на страховки, это все равно оказывается дешевле, чем непосредственная защита от всех возможных сценариев мошенничества. В случае Биткоина многие конфликты попросту некому решать. Поэтому он спроектирован таким образом, чтобы *избегать появления конфликтов*, а не создавать механизмы их решения постфактум. В Биткоине невозможно отправить несуществующие монеты, но есть угроза проведения успешной атаки двойной траты [55]. Изучение данной темы даст ответы на вопросы, каким образом впервые была реализована технология blockchain и почему именно так.

Определим понятие *блокчейн* в контексте Bitcoin: это база данных, которая содержит транзакции, и она общая для всех узлов, вовлеченных в систему Bitcoin. Особенность ее состоит в том, что каждый следующий блок подтверждает целостность предыдущего блока, который в свою очередь подтверждает целостность предыдущего по отношению к нему блока и таким образом до *genesis block*. Обеспечивается односторонняя связь всех блоков и подтверждается факт того, что блок был создан после появления предыдущего. Такая организация данных гарантирует, что при создании каждого блока признается вся история транзакций за все время существования Биткоина.

Давайте немного расширим представление о структуре данных в цепочке блоков (рис. 4.32). Вспомним, что каждый блок состоит из двух частей: заголовка блока и включенных транзакций.

![Рисунок 4.32 – Структура цепочки блоков](/resources/img/volume-1/4.3-how-is-blockchain-implemented-in-bitcoin/4.32-structure-of-the-chain-of-blocks.png)

*Genesis block – это первый блок, созданный в цепочке, после которого участники могут создавать последующие блоки*. Особенность genesis block состоит в том, что он не распространяется при синхронизации узлов, так как он встроен в ПО узла сети и имеет порядковый номер 0 [56].

Когда требуется провести поверхностную верификацию децентрализованной учетной системы, узлу достаточно загрузить только заголовки блоков. Это позволяет проверить время создания блока, хэш-значение предыдущего блока, изменение параметра сложности со временем. Однако для более серьезной проверки, например, для проверки на наличие двойной траты, узлу понадобится и тело блока с транзакциями, т. е. полный блок.

### Структура блока

Давайте детально рассмотрим структуру блока, который передается по сети Bitcoin. Соответствующий порядок данных указан в таблице 4.1.

Table 4.1 — Структура блока в Bitcoin

| field        | value                                         | size      |
|--------------|-----------------------------------------------|-----------|
| MagicNo      | 0xD9B4BEF9                                    | 4 Bytes   |
| BlockSize    | number of bytes following up to the end block | 4 Bytes   |
| BlockHeader  | consists of 6 items                           | 80 Bytes  |
| TxCounter    | positive integer                              | 1-9 Bytes |
| Transactions | the (non empty) list of transactions          | N/A       |

В блоке предусматривается несколько полей. Первое из них – *magicNo* – является специальным константным числом. Для протокола Bitcoin оно всегда имеет именно такое значение и занимает 4 байта. Используется оно для идентификации потока данных. Допустим, есть канал передачи данных, где проходят данные от разных протоколов. Чтобы идентифицировать, что в определенный промежуток времени начался блок Биткоина, можно использовать поиск по этому значению. Соответственно, для других протоколов значение будет другим.

После него следует поле *blockSize* (размер блока), которое занимает тоже 4 байта и содержит значение количества байтов в этом блоке, включая все данные транзакций. За ним идет заголовок блока, он состоит из шести полей и всегда равен 80 байтам.

Ниже располагается *txCounter* (счетчик транзакций). Количество транзакций в блоке может быть настолько большим, что счетчик может иметь размер от 1 до 9 байт. После идут данные самих транзакций, их размер не определен. На практике блок может иметь размер от 100 байт и до 1 MB: набор транзакций тоже может быть разным по количеству.

Ключевой составляющей блока является *blockHeader* (заголовок блока). Он содержит 6 полей. Их проверяют все узлы сети, даже облегченные. Верификация каждого поля выполняется по строго определенным правилам, основные из которых вряд ли будут изменены в будущем. Характеристика всех полей представлена в таблице 4.2.

Одно из них называется *nonce*, в котором представлено количество попыток решения ресурсоемкой задачи. Есть также параметр difficulty, который обозначает сложность добычи монет и находится в поле *bits* (присутствует в заголовке блока). Он меняется приблизительно один раз в две недели (один раз за период построения 2016 блоков).

Таблица 4.2 – Структура заголовка блока

| field          | size                                     | updated value                                           | size     |
|----------------|------------------------------------------|---------------------------------------------------------|----------|
| Version        | Block version number                     | You upgrade the software and it specifies a new version | 4 Bytes  |
| HashPrevBlock  | 256-bit hash of the previous blockheader | With the generation of each new block                   | 32 Bytes |
| HashMerkleRoor | 256-bit hash of txes                     | A transaction is accepted                               | 32 Bytes |
| Time           | Current timestamp                        | Every few seconds                                       | 4 Bytes  |
| Bits           | Current target in the compat format      | The difficulty is adjusted                              | 4 Bytes  |
| Nonce          | 32-bit number (starts at 0)              | Increments after each hash is checked                   | 4 Bytes  |

Итак, в первом поле записывается версия – это 4 байта. Она соответствует версии протокола, по которой работал валидатор (создатель блока). Далее следует *hashPrevBlock*, то есть хэш-значение от заголовка предыдущего блока, которое имеет длину 256 бит. Отметим, что это хэш-значение получается в результате применения двойного хэширования с помощью хэш-функции SHA-2. Это поле содержит 32 байта данных. Ниже находится взятое специальным образом (*Merkle tree*) хэш-значение от всех транзакций в блоке – тоже 32 байта, после чего следует временная метка (Unix timestamp), которая обычно устанавливают равной времени создания блока, – 4 байта. После этого следует сжатый параметр сложности – так называемый *bits* – 4 байта. Последний параметр – *nonce*, который называют решением задачи PoW конкретно для этого блока. Он тоже имеет размер 4 байта. В итоге заголовок блока в Биткоине всегда занимает 80 байт.

Итак, мы рассмотрели структуру блока и выяснили, что блоки бывают двух типов: genesis block, то есть нулевой блок в цепочке, и последующие блоки, которые загружает и обрабатывает ПО узла сети.

### Примеры блоков в Bitcoin

Рассмотрим несколько примеров блоков в Bitcoin. В таблице 4.3 представлен genesis block [56]. Его особенность в том, что значение предыдущего блока у него равно 0, то есть все 256 битов этого значения нулевые.

Таблица 4.3 – Genesis block в Bitcoin

| Version             | 01000000                                                         |
|---------------------|------------------------------------------------------------------|
| Previous block hash | 0000000000000000000000000000000000000000000000000000000000000000 |
| MerkleRoot          | 4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b |
| Timestamp           | 1231006505                                                       |
| Bits                | 486604799                                                        |
| Nonce               | 2083236893                                                       |
| Transaction count   | 1                                                                |
| -                   | Coinbase transaction (reward)                                    |

Genesis block был создан 3 января 2009 года. Параметр сложности, который был установлен изначально, Сатоши рассчитал таким образом, чтобы сложность майнинга соответствовала возможностям обычного настольного компьютера. Genesis block тоже был сформирован путем майнинга, а именно нахождением прообраза хэш-функции определенного типа. В этом блоке содержится только одна транзакция, в которой Сатоши в соответствии с правилами протокола отправил себе первые в системе 50 монет. Фактически, хэш-значение от всех транзакций этого блока (*Merkle root*) является хэш-значением *coinbase-транзакции*.

В таблице 4.4 представлен еще один блок, который ссылается на некоторый предыдущий, уже попавший в совместную базу данных Bitcoin. В отличие от примера выше, здесь хэш-значение предыдущего блока установлено. Представленный в таблице блок содержит 63 транзакции, другую версию, соответствующую метку времени, увеличенный параметр сложности, другое nonce.

Таблица 4.4 – Пример блока в Bitcoin

| Version             | 613687296                                                        |
|---------------------|------------------------------------------------------------------|
| Previous block hash | 00000000000000000007c0fb40d7d6225edaa5da8f43490cc56e60c34082e39b |
| MerkleRoot          | 167167cde7164fe0005a71e8b75a8da1e760deb546a944d67d7e3f15dcb60d45 |
| Timestamp           | 1671542973                                                       |
| Bits                | 386397584                                                        |
| Nonce               | 971790600                                                        |
| Transaction count   | 2702                                                             |
| -                   | ...                                                              |

> **_Замечание._** *Другие блоки могут содержать намного больше транзакций (не обязательно 63, как блок в табл. 4.4).*

Рассмотрим детальнее временные метки. Каждый заголовок блока содержит временную метку в соответствии со стандартом Unix timestamp. Unix timestamp – это формат времени, который показывает количество секунд с полуночи 1 января 1970 года (00:00:00 UTC).

Для верификации временных меток в протоколе Bitcoin существуют соответствующие правила. Эти правила, в частности, описывают ограничения для временной метки блока при его верификации. Нижней границей является медианное значение, рассчитанное на основании временных меток одиннадцати последних добытых блоков. Верхняя граница рассчитывается иначе: если узел получает из сети новый блок, ПО выполняет проверку, чтобы временная метка была меньше, чем медианное значение текущего времени на узлах, с которыми данный узел имеет сетевое соединение, плюс 2 часа.

Таким образом, для временной метки каждого нового блока, загруженного узлом из сети, существует довольно широкое окно. Оно позволяет избежать конфликтов в истории транзакций при разнице в текущем времени на разных машинах и обеспечить определенный порядок принятия правильных блоков. Теоретически временная метка предыдущего блока может опережать метку следующего блока, но в небольших диапазонах это нормально. Bitcoin использует эти метки, только на больших промежутках времени для обновления параметра сложности майнинга (difficulty), а на маленьких промежутках это не играет особой роли.

*Coinbase-транзакция – это транзакция, которая является первой в списке (имеет нулевой индекс);* она присутствует в каждом блоке. В ней валидатор, который нашел решение и создал новый блок, выписывает себе вознаграждение за работу и присваивает комиссии со всех транзакций, которые он включил в этот блок.

Coinbase-транзакция вырождена потому, что у нее нет входов: они заполняются другими значениями, а выходы как раз содержат вознаграждения, которые сможет забрать себе валидатор. Напомним, что в Bitcoin используется параметр *coinbase maturity*, определяющий количество подтверждений coinbase-транзакции, необходимых для того, чтобы ее создатель получил возможность тратить заработанные монеты. Сатоши установил значение этого параметра равным 100.

### Понятие mempool в Bitcoin

В протоколе Bitcoin есть ключевое понятие *mempool*: это отдельный модуль каждого полного узла сети, который хранит и обрабатывает неподтвержденные транзакции. Таким образом, каждый узел сети Bitcoin имеет свой mempool, где он хранит очередь транзакций, которые он проверил и считает правильными. Грубо говоря, mempool занимается организацией такой очереди (рис. 4.33), здесь хранятся и сортируются транзакции, перед тем как из них будут формироваться новые блоки.

![Рисунок 4.33 – Функционирование mempool](/resources/img/volume-1/4.3-how-is-blockchain-implemented-in-bitcoin/4.33-operation-of-mempool.png)

Mempool непосредственно отображает состояние пропускной способности сети. За 2017 год средняя загруженность очереди составила 30 000 транзакций, размер которых приблизительно равен 40 MB. Это довольно большая очередь, если учесть, что в сети Bitcoin в среднем каждые 10 минут создается блок размером 1 MB, который подтверждает в среднем 1 500 транзакций (детальнее см. пункт 4.7).

### Жизненный цикл блока
> * *Формирование*
> * *Создание*
> * *Распространение*
> * *Верификация*
> * *Присоединение*
> * *Отсоединение*

*Формирование блока*. Валидатор выбирает транзакции из mempool, вычисляет значение Merkle root, определяет хэш-значение от предыдущего блока, поля *timestamp*, *txCounter* и *blockSize*, после чего объединяет эти данные и формирует блок.

*Создание блока*. Процесс создания блока, по сути, и есть майнинг (детально описан в 4.2).

*Распространение блока*. После создания нового блока узлом-валидатором происходит его распространение по сети Bitcoin. Создатель блока передает его соседним узлам, с которыми имеет непосредственное соединение. При получении блока, каждый узел проверяет соответствие полученного блока правилам протокола. Если блок корректен, то есть не содержит в себе конфликтующих транзакций, то узел добавляет полученный блок в собственную базу данных и распространяет его дальше по сети. При этом узел прекращает работу над добычей собственного блока, все конфликтующие транзакции удаляются, а остальные отправляются обратно в mempool и ожидают дальнейшего подтверждения.

На рисунке 4.34 показано, как происходит процесс распространения нового блока в сети. Процесс не является мгновенным, в результате чего и возникает неоднородность состояния базы данных в сети в конкретный момент времени, когда некоторые узлы еще не приняли последний созданный блок.

![Рисунок 4.34 – Распространение блока в сети](/resources/img/volume-1/4.3-how-is-blockchain-implemented-in-bitcoin/4.34-block-propagation.png)

*Верификация блока*. Чтобы проверить, что конкретная монета не тратится дважды, наряду с основной используют отдельную базу данных, которую ведет каждый узел сети Bitcoin, и называется она *coins database*. Она хранит текущее состояние всех непотраченных выходов.

Во всех существующих транзакциях есть множество выходов: одни из них уже были потрачены, другие – нет. Выходы, которые не были потрачены, хранятся и индексируются ПО отдельно. Когда приходит новый блок (он предварительно был проверен: что структура совпадает, сложность майнинга правильная, задача на PoW решена, цифровые подписи правильные… на самом деле, проверок намного больше, но основные из них таковы), то дополнительно во время присоединения блока в свою локальную копию цепочки базы данных каждый узел сети проверяет каждую транзакцию на предмет того, что она тратит существующие монеты именно из coins database. Таким образом гарантируется защита от двойной траты и оптимизируется этот процесс. Нет необходимости обращаться ко входу каждой транзакции, искать транзакцию, которая тратится, и проверять, не было ли там двойной траты, а просто индексируются все непотраченные монеты. Это ускоряет процесс проверки новых блоков.

*Присоединение блока*. Это важный процесс, который определяет, как блоки верифицируются и сохраняются на каждом узле в локальной копии цепочки. Для этого каждый узел выбирает блок (среди тех, которые получены и считаются корректными), а также соответствующую цепочку, и присоединяет их к своей локальной копии базы данных.

*Отсоединение блока*. Противоположным процессом к присоединению блоков является отсоединение блоков. Рассмотрим ситуацию, когда это может происходить.

Когда узел-валидатор ориентируется на некоторый блок (обозначим его флагом на рис. 4.35), текущее состояние его базы данных соответствует этому блоку, и он работает над созданием следующего блока. Допустим, в сети был опубликован альтернативный блок, который мог появиться по разным причинам. Через некоторое время в сети появляется еще один блок, который был создан на основе альтернативного. На схеме эта ветка изображена снизу. Когда станет известной альтернативная цепочка, которая окажется длиннее той, на которую узел ориентируется в данный момент, то по правилам протокола он должен будет переключиться. Однако на самом деле этот процесс организован не так просто, как может показаться на первый взгляд.

![Рисунок 4.35 – Переключение на альтернативную цепочку](/resources/img/volume-1/4.3-how-is-blockchain-implemented-in-bitcoin/4.35-switching-between-blockchains.png)

Существует процесс, который называется *reorganization*. Он позволяет пользователю отклонить одну версию истории событий и переключиться на другую. Как это работает? Reorganization включает отсоединение блоков, который представляет некоторую ключевую сложность. Узел сети должен вернуть все монеты, потраченные в блоке, который отсоединяется, и снова обозначить их как непотраченные, то есть вернуть их в coins database. Также нужно вернуть все транзакции, которые были подтверждены в этом блоке, в mempool, чтобы они снова получили статус неподтвержденных. Только после этого возможно присоединение альтернативного блока, где, вероятно, те же транзакции станут подтвержденными, а те же монеты станут потраченными. Этот процесс должен быть четко выполнен узлом сети, чтобы иметь конечное состояние локальной копии базы данных, идентичное другим честным узлам.

### Начальная синхронизация узла

Выше мы рассмотрели, что представляет из себя цепочка блоков в Bitcoin, а также какие свойства учетной системы могут быть обеспечены и каким образом (с помощью каких механизмов). Сейчас речь пойдет о том, каким именно образом данные цепочки блоков организованы непосредственно на вычислительных машинах пользователей.

Способ организации цепочки блоков может существенно отличаться среди разных производителей ПО кошельков. Например, разработчики Bitcoin Core используют базу данных LevelDB, которая поддерживает связь *ключ–значение* для организации данных.

Следует также упомянуть, что по умолчанию цепочка блоков находится в «%APPDATA%\bitcoin», если вы используете ОС семейства Windows, либо в «~/.bitcoin», если вы работаете с ОС Linux, либо в «~/Library/Application Support/Bitcoin», если вы используете Mac OC.

Вне зависимости от используемого ПО основным требованием является достижение консенсуса относительно конечного состояния базы данных между пользователями сети. Это значит, что если Алиса отправляет Бобу 7 биткоинов, то эта транзакция должна быть правильно обработана независимо от способа хранения цепочки блоков.

Представим, что пользователь решил запустить узел сети Bitcoin. Поскольку он это делает впервые, то копии совместной базы данных со всеми транзакциями у него нет. Пользователь запускает специальное ПО и начинает загружать всю цепочку блоков, поскольку ему нужно ее верифицировать, чтобы убедиться в актуальности состоянии всех непотраченных выходов, прежде чем продолжить работу с другими узлами. В момент этой синхронизации пользователь подвержен некоторым рискам. Поскольку могут быть использованы уязвимости сетевого взаимодействия (или другие) для проведения ряда атак.

Одна из них – спам неправильными цепочками со стороны злоумышленника. В процессе выкачивания пользователем цепочки блоков, ему могут навязать альтернативные версии состояния базы данных, согласно которым у него монет нет, а у злоумышленника – есть. Таким образом, пользователя могут обманывать, а его ПО в статусе сетевого соединения будет отображать, что все корректно. Почему? Потому что альтернативная цепочка тоже построена по правилам протокола, а корректная версия цепочки от честных пользователей все еще не была загружена.

Вопрос состоит в том, как предотвратить ситуации, в которых узел изолирован от других честных узлов сети? Как можно гарантировать, что скачиваемая пользователем цепочка является изначально правильной и наиболее актуальной? В протоколе Bitcoin это решается с помощью специального механизма, который называется checkpoints. Он действует, как дополнительный уровень защиты от возникновения таких ситуаций.

### Checkpoints

*Checkpoints – это механизм, который связывает хэш-значение существующего блока на определенной высоте с соответствующим ему правильным хэш-значением.* Это сопоставление используется для верификации правильности блоков, которые узел получает от других участников сети в процессе начальной синхронизации.

Эти checkpoints изначально записаны в ядро программного обеспечения узла. Во время начальной синхронизации узел проверяет соответствие между полученными хеш-значениями со значениями checkpoints, которые находятся в программном обеспечении узла. 

На рисунке 4.36 вы можете увидеть, что среди всех блоков, которые загружает узел, только некоторые из них проверяются в соответствии с checkpoints [57]. Если значения совпадают, ПО продолжает работать нормально, если нет – пользователю отправляется уведомление. Такое уведомление свидетельствует о том, что либо checkpoint неверный, либо пользователя на сетевом уровне пытаются обмануть, передавая неверную историю транзакций в Биткоине.

![Рисунок 4.36 – Соответствие checkpoints блокам на определенной высоте](/resources/img/volume-1/4.3-how-is-blockchain-implemented-in-bitcoin/4.36-checkpoints.png)

Автор этих checkpoints – *сообщество*, а именно разработчики, которые создали это ПО. Ввиду этого нужно доверять тому, что они действительно выбрали хэш-значения от правильных блоков, которые уже имеют много подтверждений, а вероятность того, что эта история будет переписана предусмотренным протоколом путем, крайне мала.

Checkpoints не могут быть созданы для тех блоков, которые еще не созданы, либо для тех блоков, которые были опубликованы совсем недавно, потому что для недавних блоков вероятность переписывания истории и появление альтернативной цепочки достаточно высока. И это может быть как раз правильным ходом. Таким образом, при выходе нового ПО, оно содержит все больше checkpoints для использования  при начальной синхронизации с сетью.

### Свойства совместной базы данных Bitcoin

Учитывая тот факт, что Биткоин реализует децентрализованную учетную систему, которую поддерживают десятки тысяч независимых узлов, ее база данных приобрела действительно ценные свойства.

> * *Возможность проверки целостности транзакций*
> * *Синхронизация и резервное копирование в режиме реального времени*
> * *Возможность аудита в режиме реального времени*
> * *Коллективное принятие решений о добавлении записей*
> * *Прозрачность учета*
> * *Trustlessness (минимальный уровень необходимого доверия)*
> * *Неизменяемость (immutability)*

База данных, которая обеспечивает свойства, такие как *целостность данных* и их *доступность*, представляет ценность для некоторых приложений, реализующих, допустим, timestamping или добавление хэш-значений от каких-то важных документов в базу данных Биткоина. Это обусловлено необходимостью иметь доказательства, что данные были добавлены в некоторый определенный промежуток времени, а не позже или раньше.

Существует действительно большой спрос на использование базы данных, которая хранится у множества участников: ее сложно подделать задним числом и невозможно полностью уничтожить, поскольку большое число компьютеров уже хранят и верифицируют ее. Технические аспекты относительно записи произвольных данных в цепочку блоков Bitcoin мы описывали ранее (см. 4.1). 

Правильное использование технологии blockchain может помочь в достижения следующих свойств.

> * *Децентрализация процесса принятия решений* 
> * *Большая отказоустойчивость системы*
> * *Повышение сложности мошенничества*
> * *Более высокий уровень доверия пользователей к системе*
> * *Неизменяемость и необратимость транзакций*

Эти факторы являются основной причиной, по которой люди начинают говорить о технологии blockchain отдельно от криптовалют. Было много предположений, возможно ли применение технологии блокчейн в приложениях помимо Bitcoin. Мы подробнее рассмотрим такие применения далее (см. 5.1 и 5.2).

**Распространенные мифы**

*Если не было ни одной транзакции в сети, то следующий блок не будет сформирован.*

Действительно, с такой точкой зрения можно встретиться. Однако можно ли считать, что майнинг лишается смысла, когда в сети отсутствуют новые транзакции? Вовсе нет, новый блок будет создан, потому что за это предусмотрено вознаграждение. Каждый блок содержит как минимум одну транзакцию (coinbase). Если представить аналогию в контексте голосования, то пользователь может голосовать как за определенные транзакции, если они есть в наличии, так и за их отсутствие. Вне зависимости от того, за что голосует пользователь, голос учитывается. Валидатор может сформировать блок и получить вознаграждение, не добавляя в него ни одной транзакции (кроме coinbase).

*Если у валидатора не достаточно мощное оборудование, то он может создавать маленькие блоки (содержащие мало транзакций).*

Это невозможно. Валидатор может выбирать любые транзакции для подтверждения, причем вне зависимости от мощности оборудования. Чтобы сформировать блок, нужно решить задачу по нахождению прообраза хэш-значения. Эта задача формируется с учетом параметра сложности, который одинаков для всех участников сети. Поэтому вероятность создания блока с помощью конкретного оборудования пропорциональна его доле в суммарной вычислительной мощности сети и, в общем случае, не зависит от размера блока.

**Часто задаваемые вопросы**

*– Чем отличаются блоки версии 1 и 2?*

В момент активации одного из обновлений протокола Bitcoin, версию блока инкрементировали. Были также применены новые правила в соответствии с BIP9 [58], касающиеся формирования версионных байтов в заголовках блоков.

*– Может ли валидатор указать в coinbase-транзакции сумму вознаграждения больше, чем указанная в протоколе? Будет ли такой блок принят сетью?*

Да, валидатор может это указать, он может даже создать такой блок, решив задачу PoW, и распространить его по своим сетевым соединениям. Однако блок будет сразу подвержен верификации другими узлами, несоответствие протоколу будет сразу обнаружено. Этот блок будет отброшен честными участниками и дальше по сети распространяться не будет. Следовательно, он также не будет подтвержден остальными валидаторами.

*– Когда мы запускаем новый узел сети, как он узнаёт о других узлах, где он берет сетевые адреса, для того чтобы впервые соединиться с ними и выкачать?*

Наилучшим вариантом будет при создании нового узла открыть конфигурационный файл и вручную вписать туда сетевые адреса Bitcoin-узлов ваших друзей, знакомых и каких-то сервисов, которым вы доверяете. Если же такой возможности нет, тогда ПО Bitcoin использует Bitcoin seeds, которые оно содержит по умолчанию. Это адреса узлов, которые принадлежат сообществу. Если вы доверяете им, то это один из вариантов. Опять-таки, большинство сетевых соединений проходит именно через них изначально – при их использовании более вероятно, что ваш трафик будет перехвачен и перенаправлен на злоумышленные узлы и т. п.

*– Чему равно максимально допустимое количество записей в coins database?*

Ограничения на максимальное количество записей в coins database нет. Иначе часть транзакций, у которых количество выходов превышает количество входов, не могли бы попасть даже в mempool, не говоря уже о подтверждении.

*– Верно ли, что coins database Bitcoin растет, пока подтверждаются транзакции?*

Она одновременно как растет, так и уменьшается, потому что как создаются новые непотраченные выходы, так же их кто-то и тратит. С увеличением количества пользователей должна увеличиваться эта база данных. Чем больше пользователей, тем больше непотраченных выходов и тем больше, соответственно, эта база данных. Но ограничения предельного размера у нее нет.

*– Имеют ли владельцы полных узлов такое же влияние на состояние сети, как узлы-валидаторы?*

Полные узлы, которые не принимают участие в подтверждении транзакций, не влияют на состояние сети. Они могут верифицировать транзакции для себя или передавать данные другим пользователям в том случае, когда они становятся чьим-то доверенным узлом. Однако реальное влияние на конечное состояние совместной базы данных оказывают только узлы-валидаторы.

*– Как в Биткоине появились блоки с размером более 1 МБ?*

В августе 2017 года было принято обновление протокола, которое позволило отделить доказательства владения монетами от основных данных транзакции – Segregated Witness. Максимальный базовый размер блока так и остался ограниченным верхним пределом в 1 МБ, но размер с учетом доказательств может превышать это значение и достигать 4 МБ (см. 4.6).

*– Может ли появится новый блок, например, с одной транзакцией при непустом mempool?*

Да может, это обусловлено тем, что подготовить заголовок пустого блока для передачи его майнинговому оборудованию проще и быстрее, чем подготовить заголовок блока от полного блока. С одной стороны эта разница во времени не велика, а с другой стороны будет неэффективно, если майнер нашел решение для текущего блока и простаивает в ожидании задачи для следующего.

*– Если валидаторы не подтвердят транзакцию, монеты в кошельке отправителя останутся?*

Да, отправитель может сформировать конфликтующую транзакцию указывая нового получателя. Особенность состоит в том, что если первая транзакция не подтверждается, но все равно остается в mempool других узлов, то создавая конфликтующую транзакцию нужно явно указать ее приоритет для замены и установить комиссию включая оплату факта замены.

*– Возможно ли эмитировать монеты доступ к которым может быть у любого пользователя?*

Да, в случае с Bitcoin это достаточно просто сделать. В ходе формирования coinbase транзакции достаточно использовать такой ScriptPubKey на выходах, которому сможет удовлетворить любой желающий. Например такой, что эмитированные монеты достанутся тому, кто первый назовет число равное 4. Теперь для получения доступа к монетам нужно сформировать транзакцию с входом, который ссылается на такую coinbase транзакцию, а в качестве доказательств владения монет (SсriptSig) указать значение 4.

## 4.4 Подходы к синхронизации с сетью и SPV-узлы

В основе безопасности Bitcoin лежит прозрачность, то есть кто угодно может проверить историю транзакций, надежность хранения этой истории, а также протоколы и их реализации, которые используются для функционирования узла в сети. Обеспечить надежность хранения и достоверность данных в таких условиях является одновременно сложной и амбициозной задачей. Для достижения этой цели необходимо наличие по-настоящему независимых модулей, которые будут проверять работу друг друга. Взаимодействие ПО пользователя с программным обеспечением других узлов сети является критически важной задачей, подходы к решению которой рассмотрены в данной теме.

Ранее мы отмечали, что в сети Биткоина узлы постоянно сверяют соответствие их локальной копии базы данных локальным копиям других узлов и самостоятельно принимают решения в случае несоответствия. Такой подход позволяет пользователю быть уверенным, что он получает всегда актуальные данные и они надежно хранятся. Однако этот простой на первый взгляд процесс устроен сложно и имеет множество тонкостей, которые нужно учитывать при выборе способа синхронизации узлов друг с другом. Именно на этом этапе злоумышленники могут исключать пользователей из общей сети, транслируя им, например, поддельные транзакции [59]. Ниже будут рассмотрены основные подходы к синхронизации кошельков с Bitcoin-сетью и особенности этих подходов.

Если вспомнить основные функции цифрового кошелька и его устройство, то несложно заметить, как часто кошельку нужна связь с сетью для синхронизации актуальных данных.

> **Базовые функциональности цифрового кошелька**
>> * *Резервное копирование личных ключей*
>> * *Прием платежей*
>> * *Отображение баланса* 
>> * *Отображение истории транзакций*
>> * *Отправка платежей*

Для резервного копирования личных ключей нужен только модуль, ответственный за хранение и управление ключами. Однако при использовании остальных функций обязательно нужно будет работать с Bitcoin-сетью. Чтобы получить доступ к общей базе данных с транзакциями и возможность изменять ее, необходимо как минимум стать одним из узлов сети Bitcoin, а также следовать спецификации обработки и обмена данными в ней.

Для корректной работы кошельку необходимо иметь данные обо всех транзакциях, в которых участвовали его адреса. Напомним, что входы транзакции непосредственно связаны с выходами предыдущих транзакций, поэтому важно, чтобы монеты с этих выходов можно было гарантированно потратить. Следовательно, крайне нелогично составлять новую транзакцию и осуществлять платежи, не зная состояния подтвержденности старых транзакций. Статус своих транзакций – это наиболее важное из того, что пользователю должно быть известно во время приема и отправки платежей. Если транзакция не получила достаточного количества подтверждений, то получатель не может считать платеж полностью подтвержденным. Пока транзакция, соответствующая платежу за некоторый товар, не стала полностью подтвержденной, продавец не может отправить товар покупателю, не рискуя остаться ни с чем.

### Сложности работы в распределенной сети

Работа с распределенной сетью является достаточно сложной темой. При ее организации обычно сталкиваются с несколькими проблемами. Как отмечалось выше, все узлы сети регулярно сверяют свое состояние с актуальным для всей сети и синхронизируются в случае несоответствия. Одна из проблем состоит в выборе способа проверки данных, полученных из распределенной сети, а вторая заключается в оптимизации хранения этих данных. Сложность в том, что эти требования в некоторой мере конфликтуют между собой. При этом идеального решения нет, потому что невозможно верифицировать транзакции максимально достоверно и одновременно задействовать для этого минимум ресурсов. Чем более полные данные пользователь имеет, тем более достоверные результаты проверки он может получить. Поэтому приходится искать некоторый компромисс и балансировать между простотой и безопасностью.

Есть еще одна проблема. Если владелец полного узла сети намерен получить историю транзакций по определенному адресу и проверить ее, то ему придется пройтись по всей цепочке блоков (от genesis block до последнего известного блока), что даже при минимальной индексации (по умолчанию в *Bitcoin Core*) достаточно долго. Речь идет о большом объеме данных, а грубый перебор – это малоэффективно. Для оптимизации запросов применяются специальные модули-надстройки над обычным узлом сети, которые помогают индексировать данные всех блоков и кэшировать некоторые из них для ускорения поиска по популярным метрикам. По такому принципу работает любой *обозреватель блоков (block explorer)*. Даже тогда, когда обозреватель блоков реализует публичный интерфейс для всеобщего использования, он способен достаточно быстро возвращать данные почти о любом блоке, адресе, транзакции и т. д.

Рассмотрим несколько принципиально разных подходов к осуществлению взаимодействия и синхронизации цифрового кошелька с распределенной сетью.

### Подходы к синхронизации кошелька с платежной сетью

Есть три основных подхода (рис. 4.37). Первый предполагает, что кошелек сам является полным узлом сети Биткоин. Во втором подходе используется так называемый доверенный узел (обычно это чужой узел сети, но пользователь кошелька ему доверяет). Третий подход подразумевает прямое взаимодействие с остальными узлами сети, но в упрощенном варианте. Для этого используется метод *SPV (Simplified Payment Verification)*, который позволяет с достаточно высокой степенью надежности проверить подтвержденность транзакций, не прибегая к запуску полного узла сети. Остановимся подробнее на каждом из этих подходов к синхронизации.

![Рисунок 4.37 – Подходы к синхронизации кошелька с сетью](/resources/img/volume-1/4.4-approaches-to-network-synchronization-and-spv-nodes/4.37-approaches-for-wallet-synch.png)

### Работа с полными узлами

В этом случае все достаточно просто. Кошелек реализует механизмы хранения и обработки всей цепочки блоков, и модуль сетевого взаимодействия (обмена сообщениями P2P) с другими узлами сети Bitcoin. Поэтому пользователь всегда может проверить новую входящую транзакцию, действительно ли она соответствует правилам протокола, не совершает ли двойной траты и т. д. Владелец полного узла может осуществлять детальную проверку всех данных.

Однако для хранения полной истории всех транзакций, которая постоянно увеличивается, нужно выделить большой объем дискового пространства, что является, скорее, недостатком. Помимо этого, полный узел поддерживает работу сети, и ему нужно бесперебойное сетевое соединение, чтобы постоянно синхронизироваться с остальными узлами и своевременно обновлять ПО.

Пользователи, которые принимают и отправляют платежи на крупные суммы, нуждаются в повышенном уровне надежности (достоверности статусов транзакций), поэтому для них предпочтительным является данный подход. Все крупные сервисы, которые предоставляют возможность централизованного хранения биткоинов, wallet-сервисы, крупные торговцы и т. п., обязательно используют именно такой подход, поскольку они выдвигают высокие требования к безопасности и независимости при работе с Bitcoin.

Итак, поддерживать полный узел или даже несколько таковых (с альтернативными программными реализациями протокола) – наиболее надежный подход к синхронизации с другими узлами сети, причем Bitcoin-сообщество старается поддерживать доступность этого подхода для пользователя с обычным ПК. Для этого просто можно взять готовые бинарные файлы, например файлы Bitcoin Core, и запустить. Опытные пользователи могут задействовать общедоступный исходный код. Существенным недостатком можно считать только требования к дисковому пространству.

### Работа с доверенными узлами

Отличие данного подхода от предыдущего заключается в отделении логики кошелька от логики проверки транзакций. Здесь присутствует так называемый доверенный узел. Это обычный полный узел Bitcoin-сети, которому пользователь доверяет проверку своих транзакций. В частности, это может быть узел сети, который поддерживает друг пользователя.

Весьма часто такой подход используется в мобильных приложениях цифровых кошельков. Допустим, компания, которая разрабатывает подобное приложение, поддерживает доверенные узлы и обещает, что обеспечит корректную проверку транзакций. В таком случае пользователи, которые работают с таким цифровым кошельком, доверяют компании-разработчику, то есть верят обещаниям. Пользователь при этом может самостоятельно хранить свои личные ключи и заверять транзакции на своем устройстве, однако статус подтвержденности транзакций он запрашивает у доверенного узла, а не проверяет самостоятельно.

Какие же преимущества и недостатки этого подхода? Преимущество состоит в том, что пользователю не нужно хранить всю цепочку блоков на своем устройстве. Тем не менее, зависимость от доверенного узла является недостатком, ведь в случае его отказа пользователь не всегда может быстро переключиться на другой доверенный узел.

Можно упомянуть практический случай, когда узел частной компании Blockchain.com отказал в обслуживании на двое суток из-за проблем с DNS (рис. 4.38) [60]. Приложения, которые использовали этот узел в качестве доверенного, не могли синхронизироваться с Bitcoin-сетью и поддерживать нормальную работу.

![Рисунок 4.38 – Отказ в обслуживании одного из сервисов](/resources/img/volume-1/4.4-approaches-to-network-synchronization-and-spv-nodes/4.38-dos.png)

Поскольку проверка транзакций происходит на удаленном сервере, нужно убедиться в надежности канала передачи данных между кошельком и сервером, на котором происходит проверка. При таком подходе появляется угроза атак человека посередине (man-in-the-middle attacks), когда пользователь получает искаженную версию истории транзакций.

Поскольку именно кошелек пользователя (а не доверенный узел) хранит и обрабатывает личные ключи, соответствующие адресам, ПО кошелька должно периодически сообщать доверенному узлу, по каким адресам нужно получить актуальную историю и сведения о текущем состоянии транзакций. Иначе говоря, пользователь зависит от доверенного узла. Причем эта зависимость имеет как минимум два аспекта. С одной стороны, пользователь получает *только* те данные, которые ему транслирует доверенный узел. Поэтому существует вероятность, что узел может передавать на кошелек поддельные данные. С другой стороны, сам факт разглашения кошельком всех своих транзакций владельцу узла свидетельствует о рисках, которые несет пользователь в отношении приватности своих транзакций. Следует понимать, что как только пользователь теряет доступ к доверенному узлу или узел отказывает в обслуживании, возможность актуализации степени подтвержденности транзакций и распространения новых транзакций также теряется. Соответственно, получать и отправлять платежи владелец кошелька в этом случае тоже не может.

Для уменьшения рисков, связанных с зависимостью от одного доверенного узла, можно использовать несколько узлов. На практике это значит, что в нормальных условиях пользователь подключается и работает с одним доверенным узлом, но если случается потеря доступа, то цифровой кошелек автоматически подключается к другому доверенному узлу. По сути, при каждом соединении кошелек случайным образом выбирает один узел из списка доверенных.

Такой способ используют преимущественно мобильные кошельки, потому что он позволяет и верифицировать транзакции, и упростить работу мобильного приложения. Примерами таких мобильных кошельков для Биткоина являются Mycelium и Coinomi. Компания Distributed Lab разработала и поддерживает кошелек Bitxfy, где применен этот подход.

### Работа с SPV-узлами

Третий распространенный подход к синхронизации цифрового кошелька с Bitcoin-сетью – это облегченный узел сети. Речь идет об SPV-узле. В этом подходе может отсутствовать необходимость запуска своих полных узлов или выбора доверенных. Предполагается, что цифровой кошелек напрямую общается с другими узлами сети: выбирает несколько десятков чужих полных узлов и поддерживает с ними соединение. Отличие состоит в том, что облегченный узел общается с другими узлами на равных, обмениваясь с ними сообщениями p2p, но при этом не хранит всю историю транзакций. Здесь для проверки входящих транзакций применяется метод SPV. Облегченный узел проводит только часть наиболее важных проверок из тех, что проводит полный узел сети.

Как происходит работа в этом случае? Вместо того, чтобы получать блоки, как это делает полный узел, SPV-узел получает только заголовки блоков, которые имеют гораздо меньший размер (80 байт). В заголовке содержатся необходимые данные для проверки факта подтверждения конкретной транзакции в этом блоке, не имея при этом всех остальных транзакций блока. Таким образом, цифровой кошелек может убедиться, что транзакция была действительно подтверждена в конкретном блоке.

Почему это нельзя считать полноценной верификацией транзакций? Конечно, пользователь получает независимость от конкретных узлов сети и может напрямую общаться с распределенной сетью. Для этого ему не нужно хранить всю историю транзакций. Но недостаток состоит в том, что облегченный клиент самостоятельно не проверяет транзакцию полностью, потому что у вас нет всех необходимых данных для этого (например, непотраченные монеты). Он проверяет лишь факт подтверждения транзакции валидаторами – т. е. убеждается, что эту транзакцию полностью проверили другие узлы и владельцы большинства вычислительной мощности сети (валидаторы). В этом случае надежность снова сводится к доверию, что большинство вычислительной мощности используются для честной работы. Иначе говоря, вы не сами проверяете транзакцию, а доверяете это большинству.

Особенностью использования цифровых кошельков, которые реализуют подход SPV-узла, является необходимость поддержания сетевого соединения с большим количеством независимых полных узлов сети. Это нужно, чтобы минимизировать вероятность того, что узел будет подключаться и получать данные только от узлов злоумышленника. Тогда злоумышленник может навязать пользователю альтернативное (поддельное) состояние истории транзакций. Как следствие жертва может принять платеж из той транзакции, которая по версии злоумышленника подтверждена, хотя на самом деле нет. Чтобы увеличить шансы получать актуальные данные о реальном состоянии сети, пользователю следует максимально увеличить количество независимых узлов для общения. Чем их больше, тем меньше вероятность, что они все в сговоре против пользователя.

Как вы уже поняли, SPV-узлы менее требовательны к стабильной работе сетевого соединения, тем не менее часто применяются даже в мобильных приложениях. Этот подход синхронизации с учетной системой достаточно широко распространен и используется в ряде популярных Биткоин кошельков. Среди них можно выделить Bitcoin Wallet, Electrum, а также Bread Wallet.

### Функционирование SPV-узлов

Для *начальной синхронизации* клиенту, использующему метод SPV, необходимо загрузить только заголовки всех блоков основной цепочки. Если учесть, что размер заголовка блока равен 80 Б, то несложно посчитать требуемый размер данных для загрузки. Для этого достаточно умножить высоту последнего известного блока на размер его заголовка. Приняв во внимание, что в середине августа 2018 года был добыт блок с высотой 537 000, можно вычислить, что общий размер заголовков всей цепочки не превышал 41 МиБ. Отметим, что в это же время размер локальной копии базы данных Bitcoin был равен 175 ГиБ. Для дальнейшей синхронизации с сетью SPV-узлу также понадобятся только 80-байтные заголовки следующих блоков [61]. Схема, описывающая функционирование SPV-узла представлена на рис. 4.39.

![Рисунок 4.39 – Модель функционирования SPV-узла](/resources/img/volume-1/4.4-approaches-to-network-synchronization-and-spv-nodes/4.39-spv-node.png)

Чтобы SPV-узел считал транзакцию подтвержденной, должны выполняться два условия:
* Транзакция должна быть добавлена в блок.
* Блок с транзакцией должен находиться в основной цепочке блоков.

Для установления первого факта понадобится значение *Merkle root*, которое содержится в заголовке блока. Рассчитывается значение Merkle root следующим образом (рис. 4.40). Прежде всего вычисляются хэш-значения от каждой транзакции, после они попарно конкатенируются, а результат снова подвергается хэшированию. Теперь получилось меньше хэш-значений, они снова попарно конкатенируются и подаются на вход хэш-функции. Так происходит до тех пор, пока не получится одно хэш-значение – Merkle root. Если представить это схематично, то за несколько раундов, промежуточные хэш-значения складываются в древовидную структуру (дерево Меркла), которая и содержит в своей вершине значение Merkle root.

![Рисунок 4.40 – Связь Merkle root с каждой транзакцией в блоке](/resources/img/volume-1/4.4-approaches-to-network-synchronization-and-spv-nodes/4.40-merkle-root.png)

Преимущество здесь в том, что для проверки вхождения транзакции в блок, нам не нужен весь блок. Достаточно значений, которые понадобятся для попарного хэширования и позволят добраться до корня дерева Меркла.

Имея значение Merkle root SPV-узел может запросить у полного узла только требуемые для верификации некоторой транзакции в блоке хэш-значения (*Merkle branch*). С помощью полученных значений пользователь может самостоятельно вычислить значение Merkle root и сравнить его с тем, которое хранится в заголовке блока. Если полученное значение совпадает с имеющимся, то транзакция с достаточно большой долей вероятности включена в этот блок.

Второй факт, в котором пользователь должен быть уверен, это действительное наличие блока в основной цепочке. Убедиться в этом достаточно просто. У пользователя SPV-узла имеются все значения заголовков блоков основной цепочки. Каждый заголовок блока содержит ссылку на предыдущий блок в виде его хэш-значения, поэтому пользователь может проверить, ссылаются ли следующие блоки на проверяемый.

Если вкратце, то описать функционирование SPV-узла можно следующим образом. SPV-узел не верифицирует блоки целиком. Верифицируются только их заголовки. Для проверки корректности транзакции узел должен запросить некоторые значения у полных узлов, которые позволят ему убедится в том, что транзакция действительно находится в блоке. Отметим, что узел проверяет принадлежность каждого блока основной цепочке (mainchain) и только после этого может проверять принадлежность отдельных транзакций этому блоку.

### Итоги

Рассмотрев три основных подхода к синхронизации кошельков с сетью, можно оценить преимущества и недостатки каждого. Наиболее надежным для работы с Bitcoin является полный узел, однако это и наиболее требовательный к ресурсам подход. Взаимодействие с сетью через доверенный узел не требует наличия большого дискового пространства для хранения данных, но приемлемо только тогда, когда пользователь готов доверить приватность своих транзакций владельцу этого узла. Для пользователей, которым не подходит ни первый, ни второй способ, существует метод SPV. В этом случае пользователь может самостоятельно проверить текущий статус подтвержденности нужных транзакций, не загружая при этом содержимое всей цепочки блоков. Такая проверка также требует доверия, но в этом случае речь идет о доверии большинству участников сети. Отметим, что доверие большинству необходимо и при использовании полного узла, но владелец SPV-узла не может верифицировать данные транзакций и блоков, он может проверить только наличие конкретного блока в основной цепочке блоков.

Теоретически можно предположить, что если большинство участников сговорятся между собой, то они смогут транслировать пользователям SPV-кошельков поддельную историю транзакций. Поэтому очень важно понимать важность безопасной синхронизации при работе с цифровым кошельком.

**Часто задаваемые вопросы**

*– Можно ли один и тот же кошелек запустить одновременно на трех разных компьютерах и начать синхронизацию?*

Скорее всего, речь идет о каком-то узле сети: либо SPV-узле, либо полном узле. Было использовано несколько разных компьютеров и один и тот же кошелек. А под кошельком подразумеваются личные ключи. Есть несколько полных узлов, которые реализуют функциональность кошельков. На этих узлах мы вставляем одни и те же личные ключи и начинаем синхронизацию. Скорее всего, при полной синхронизации с сетью на каждом кошельке, который использует свой узел, будет отображен один и тот же баланс. Если же пользователь увидит изменения на одном узле, то после синхронизации с сетью он увидит точно такие же изменения на всех остальных узлах. Транзакция не остается в секрете – она распространяется по всем узлам, которые ее верифицируют и отображают соответствующие изменения, если это касается их адресов. Да, можно использовать одни ключи на нескольких узлах, но все транзакции тоже будут синхронизироваться автоматически. Биткоины точно от этого не удвоятся и, более того, не утроятся.

*– Где можно найти полные узлы, которым можно доверять?*

Достаточно сложно ответить, каким узлам можно доверять. Это вопрос личного предпочтения. Есть сервисы, которые предоставляют открытый доступ к своему узлу, но им редко доверяют, особенно, если речь идет о крупных суммах. Нужно быть очень осторожным в выборе доверенного узла, поскольку он является посредником между пользователем и децентрализованной учетной системой. В этом случае нет универсального сервиса, которому можно доверять. Это, скорее, вопрос социального доверия. Если узел сети принадлежит другу пользователя, то следует иметь в виду степень доверия этому другу. Наиболее надежным вариантом считается использование собственного полного узла в качестве доверенного для остальных своих устройств (например для мобильного кошелька).

*– Какие гарантии дает команда разработчиков кошелька и какова ее ответственность?*

Этот вопрос имеет больше юридический характер, чем технический. У любого ПО, которое распространяется официально, есть *условия использования (terms of use)*, где прописано, что пользователь может предъявить разработчикам в случае возникновения определенных проблем в их ПО. Условия использования разные в разных приложениях. Как и всегда, пользователь выясняет, доверяет ли он разработчикам или нет, прежде чем начать использовать их продукт.

*– Сколько может быть доверенных узлов?*

Вы можете выбрать любое количество доверенных узлов, чтобы минимизировать риск потери доступа к сети. Например, три узла. Если возникнут проблемы с доступом к первому, то вы подключаетесь ко второму и продолжаете с ним работать точно так же.

*– Что произойдет с монетами, если сервера, на которых они хранятся, будут полностью или частично уничтожены землетрясением?*

Здесь нужно сказать не о монетах, а о хранении ключей, которые используются для доступа к этим монетам. Если будет уничтожен сервер, который обеспечивал доступ к сети Биткоин, то это никак не повлияет на функционирование цифрового кошелька. Пользователь временно потеряет доступ к распределенной базе данных, но у него остаются ключи, которые позволяют ему потратить монеты. Если же уничтожен сервер, на котором хранились ключи пользователя, при этом у него нет резервной копии этих ключей, то он не сможет получить доступ к своим монетам.

*– Останется ли доступ к монетам если установить программный кошелек, отправить на него монеты, записать мнемоническую фразу на бумаге и удалить приложение?*

По сути, да. Надежно сохранить мнемоническую фразу – это достаточный минимум. В совместной базе данных хранятся данные о том, сколько монет было отправлено на соответствующие адреса. Грубо говоря, чтобы доказать владение монетами и отправить их на другой адрес достаточно знать личные ключи, в данном случае иметь бумагу с мнемонической фразой.

*– Можно ли локально поставить некоторую надстройку над децентрализованной учетной системой, чтобы иметь возможность детально анализировать актуальные данные в режиме реального времени?*

Да, можно. Любой желающий может использовать любое доступное ему ПО, которое будет выполнять такой анализ. Это может быть ПО, написанное самим пользователем, а может быть готовое решение. Все зависит от целей конкретного пользователя. Если ему нужно оптимизировать запросы по поиску определенных транзакций, привязанных к определенным адресам, как это делает обозреватель блоков, пользователь может применить ПО, которое будет индексировать все блоки и кэшировать определенные данные. Примером такого ПО является BitCore (поддерживается компанией BitPay). BitCore имеет открытый исходный код, и его можно достаточно просто использовать вместе с полным узлом сети.

*–  Почему узлы обязаны проверять/распространять транзакции? Какие штрафы будут за невыполнение этих действий?*

На самом деле узлы не обязаны проверять и распространять транзакции, штрафов и наказаний соответственно нет. Тем не менее полные узлы чаще всего запускают с целью аудита системы и получения ее актуального состояния, а для этого нужно участвовать в обмене данными и выполнять их верификацию. Для некоторых целей пользователи могут запускать узлы в режиме blocks only, в котором они соответственно получают и верифицируют только готовые блоки, что позволяет им экономить сетевой трафик.

## 4.5 Механизм мультиподписи и Bitcoin Script

Умы исследователей давно будоражила идея *программируемых денег*, то есть возможность задавать условия для выполнения транзакций (одной из первых стала публикация Nick Szabo с идеей смарт-контрактов [62]). Но достаточно быстро после появления Биткоина стало понятно, что риск компрометации ключей намного выше, чем может показаться на первый взгляд. Нужно было решить проблему с ключами, прежде чем продолжить работу над реализацией новых возможностей. И это решение было найдено, причем оно оказалось очень элегантным.

Как явление *мультиподпись (multisignature)* существовала столетиями. Для документов на бумажном носителе было привычно, что на контракте нужно поставить несколько подписей, чтобы он стал юридически значимым. Однако для традиционного представления о подписи электронных транзакций это оказалось чем-то новым (вариант коллективной подписи в банковских системах не учитываем, т. к. он реализован не криптографическим способом). Среди криптографов была популярна схема разделения секрета Шамира [63], где ключ математически разделяется на части, некоторое подмножество из которых может восстановить первоначальный ключ. Метод требовал наличия доверенной стороны для изначальной генерации и распределения долей, и был непригоден для анонимной среды. В Биткоине же был предложен максимально простой метод, суть которого состояла в том, что транзакция должна быть заверена несколькими подписями. Попутно этот подход помогает решать и проблему надежного хранения монет, и делает возможным совместное управление балансом кошелька. Идея мультиподписи впоследствии получила широкое распространение в смарт-контрактах.

Рассмотрим механизм мультиподписи, реализованный в протоколе Биткоин. Обратите внимание, что в других цифровых валютах эти механизмы могут быть реализованы по-другому, поскольку многое зависит от модели транзакций.

*Multisignature-адрес* (сокр. *MultiSig-адрес*) – *это такой bitcoin-адрес, к которому привязано несколько пар ключей*. Каждая пара состоит из личного и открытого ключей. Комбинации, в которых можно использовать эти ключи, могут быть различными. Более того, можно установить условия, при которых нужно будет предоставить несколько подписей, чтобы потратить монеты с адреса.

### Bitcoin-транзакция с использованием мультиподписи 

Напомним, что обычный bitcoin-адрес формируется путем двойного хэширования открытого ключа (см. 3.2). Если представить обобщенно, то MultiSig-адрес формируется таким же образом, только уже несколько открытых ключей конкатенируются перед хэшированием. Детально это будет рассмотрено ниже. На рис. 4.41 изображена транзакция, которая тратит монеты с MultiSig-адреса.

![Рисунок 4.41 – Схема MultiSig-транзакции](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.41-multisig-tx-structure.png)

Вверху (рис. 4.41) обозначена область заголовка, который содержит два поля. Слева изображены два входа, а справа – два выхода. В первом входе находятся заполненные поля: записано хэш-значение предыдущей транзакции, которая тратит данные монеты, номер выхода и т. д. Поле *scriptSig* содержит открытый ключ и подпись, что характерно для обычной транзакции.

Обратим внимание на второй вход транзакции. В поле *scriptSig* находится другая комбинация данных: перечислено два открытых ключа и две подписи. Они должны проверяться этими открытыми ключами в соответствующем порядке. Это и есть тот вход транзакции, который тратит монеты с MultiSig-адрес. Именно так будет выглядеть доказательство владения монетами.

На рисунке ниже (рис. 4.42) вы можете увидеть пример настоящей MultiSig-транзакции. Рассмотрим поле *script*. Оно содержит значения подписи и открытые ключи владельцев MultiSig-адреса, на который были отправлены монеты. Если сравнить с полем *script* стандартной транзакции в Bitcoin, то поле *script* в MultiSig-транзакции содержит в себе больше данных и, соответственно, требует больше места, потому что может содержать от 2 до 15 подписей и соответствующих открытых ключей.

![Рисунок 4.42 – Пример MultiSig-транзакции](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.42-real-multisig-tx.png)

Поскольку возможны различные комбинации ключей при использовании MultiSig-адреса, в зависимости от обстоятельств наиболее уместной может оказаться любая. Следует отметить, что максимальной в отношении количества необходимых подписей и открытых ключей будет схема 15-из-15. Мы рассмотрим наиболее часто используемые варианты: 2-из-2, 2-из-3 и 3-из-3.

### Вариант мультиподписи 2-из-2

Комбинация 2-из-2 является самой простой и подразумевает, что есть некоторый MultiSig-адрес, к которому привязано две пары ключей. По сути, получено хэш-значение конкатенации двух открытых ключей как соответствующий адрес. Чтобы потратить монеты с этого адреса, нужно предоставить две подписи, которые будут верифицироваться двумя имеющимися открытыми ключами, конкатенация и хэширование которых в нужном порядке должны давать то же значение адреса. Обобщая вышеописанное, имеются два заранее установленных ключа, а также обязательно нужны две подписи, которые будут проверяться этими ключами соответственно.

Представьте, что муж и жена (рис. 4.43) захотели вести общий бюджет. Они договариваются, что только при согласии каждого из них средства из бюджета будут тратиться на определенные нужды. С помощью Биткоина это можно реализовать достаточно просто. Они создают MultiSig-адрес по такой схеме, где один ключ контролирует жена, а второй – муж. Тогда все доходы семья будет получать на этот адрес, а тратиться монеты смогут только по обоюдной договоренности.

![Рисунок 4.43 – Муж и жена решили создать MultiSig-адрес](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.43-h-and-w.png)

Предугадывая вопрос о сценарии, по которому муж и жена не договорятся, представим, что жена считает необходимой покупку стиральной машины, потому что она устала стирать руками, а муж считает, что это не такая уж и тяжелая работа, а будет целесообразнее потратить все монеты на последнюю модель PlayStation и проводить таким образом досуг. Жена обижается на мужа и съедает бумажный носитель, на котором был записан ее личный ключ, делая невозможной трату с этого адреса вообще. Как избежать такой ситуации и защитить себя от окончательной потери монет?

Существует способ создать транзакцию, которая может тратить все монеты с нужного адреса, несмотря на то что сумма заранее неизвестна. Он состоит в том, что подпись для транзакции создается заблаговременно, а недостающие данные могут быть подставлены позже. Иначе говоря, если неизвестны данные, которые должны быть указаны на входе, их можно будет вписать в уже подписанную транзакцию. Можно даже создать транзакцию, которая потратит монеты из еще не существующей транзакции, подписать ее всеми необходимыми подписями, и отложить. Когда наступит время, например появится нужная транзакция, нужно будет подставить необходимые данные и отправить в Bitcoin-сеть для подтверждения.

В такой транзакции можно задать поле *locktime*, что позволит отложить ее подтверждение на определенное время. Оно позволяет не подтверждать транзакцию сразу, а отложить ее на некоторый срок. Итак, муж и жена сразу после создания MultiSig-адреса, еще до получения любых платежей, могут создать две locktime-транзакции, в которых все будущие монеты будут перенаправлены на обычные адреса мужа и жены. Соответствующие два ключа они хранят и обрабатывают в секрете друг от друга. При этом транзакции будут отсроченными и могут быть подтверждены только, например, через два месяца. Эти транзакции могут быть распечатаны на бумаге и храниться в сейфе у каждого по отдельности.

Если возникнет ситуация, когда монеты находятся на балансе MultiSig-адреса, а ключи потеряны (один или оба), то монеты становятся замороженными. Но есть locktime-транзакция. Тот, кто опубликует такую транзакцию, сможет отправить эти монеты на действующий внешний адрес. Монеты будут сохранены.

Приведенный пример был упрощенным, на практике возможны и более сложные механизмы.

### Вариант мультиподписи 2-из-3

Схема использования MultiSig-адреса 2-из-3 подразумевает, что любые два ключа из трех заранее установленных должны быть задействованы для проверки двух подписей, представленных в качестве доказательства владения монетами. Иначе говоря, чтобы потратить монеты, нужно предоставить две подписи, которые будут проверены двумя открытыми ключами из предустановленных трех.

Допустим, есть группа людей, у которых есть общий бюджет. Они создают MultiSig-адреса, в котором есть три ключа, но для подписи транзакции достаточно двух подписей (рис. 4.44). При согласии участников, которые составляют большинство группы, эти монеты могут быть потрачены. Иначе говоря, любые два участника из трех могут потратить монеты. Им для этого достаточно распространить транзакцию в сеть.

![Рисунок 4.44 – Вариант использования мультиподписи 2-из-3](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.44-2-of-3-multisig.png)

Более интересный способ применения комбинации 2-из-3 можно изобразить на примере wallet-сервиса. Сервис кошелька в данном контексте не стоит путать с bitcoin-кошельком, который пользователь контролирует самостоятельно. Сервис не предоставляет полноценное хранилище для монет и не владеет ими, а только оказывает услуги для удобной работы. Если представить подобную ситуацию схематично (рис. 4.45), то один из личных ключей принадлежит непосредственно сервису, второй генерируется только пользователем (и только ему известен), третий ключ генерируется и хранится тоже пользователем, но отдельно и обычно не используется. После этого из личных ключей вычисляются открытые ключи и создается MultiSig-адрес. Туда поступают монеты и теперь условия траты ограничиваются.

![Рисунок 4.45 – Использование мультиподписи 2-из-3 в случае с wallet-сервисом](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.45-2-of-3-with-involved-wallet.png)

Представим, что мы имеем дело с некоторым веб-сервисом, который позволяет клиенту принимать и отправлять монеты используя браузер. Браузер загружает код, который реализует только часть функциональности bitcoin-кошелька (получение UTXOs, формирование транзакций и заверение их цифровой подписью). Если пользователь хочет потратить монеты, то он прямо в браузере составляет транзакцию и подписывает ее своей (одной из необходимых) подписью.

Заметим, что личный ключ пользователь может получить либо из своего пароля, либо воспользоваться генератором случайных последовательностей, затем зашифровать полученный личный ключ своим паролем и хранить этот ключ в зашифрованном виде на стороне сервиса. В последнем случае пользователь посылает запрос веб-сервису, получает контейнер с зашифрованным ключом, расшифровывает его, используя в качестве ключа свой пароль или хэш-значение пароля, и таким образом получает доступ к своему личному ключу.

Когда пользователь подписывает транзакцию, она отправляется на сторону сервиса, чтобы сервис поставил вторую необходимую подпись и отправил транзакцию. Сервис уточняет факт необходимости подписания транзакции через второй канал аутентификации, который установлен заранее. В качестве этого канала можно рассматривать звонок на мобильный телефон, отправку SMS, сообщение на электронную почту и прочие способы альтернативной коммуникации (вплоть до личного визита, если того требует уровень безопасности). Когда сервис удостоверился, что запрос на подпись транзакции действительно инициирует зарегистрированный пользователь, он ставит недостающую подпись с помощью своего ключа. После этого транзакция становится валидной и может быть распространена в сеть для подтверждения.

Третий ключ используется в тех случаях, когда сервис отказывает в обслуживании. ПО генерирует этот ключ и предлагает его сохранить удобным для вас способом. Пользователь обычно хранит его в надежном месте. Если сервис отказывает в обслуживании, то пользователь может подписать транзакцию своими ключами (вторым и третьим). Если же второй ключ хранился на стороне сервиса, то защищенный контейнер с этим ключом будет заранее отправлен пользователю по альтернативному каналу связи, например на электронную почту. Далее расшифровка ключа не представляет сложности. Пользователь получает два необходимых личных ключа и вводит в специальное ПО, которое сервис предоставил заранее. После этого ПО работает уже автономно на компьютере пользователя, т. е. без участия сервиса. Стоит отметить, что этим ПО следует пользоваться только в крайних случаях, когда сервис действительно отказывает в обслуживании (т. е. его взломали, он поврежден или перестал существовать). Тогда пользователь подписывает транзакцию своими ключами и отправляет монеты по назначению.

### Преимущества wallet-сервисов с мультиподписью 2-из-3

На преимуществах таких wallet-сервисов остановимся подробнее. Это надежный способ хранения, потому что сервис не владеет всем необходимым набором ключей – он владеет только одной частью, которой недостаточно, чтобы завладеть балансом своего клиента. Причем доступа к монетам не имеет ни сам сервис, ни хакер, который его может взломать.

Удобство такого подхода состоит в том, что пользователю не обязательно иметь защищенный доступ к этому сервису. У него может быть обычный персональный компьютер или смартфон. При этом существует риск инфицирования вредоносным программным обеспечением и устройство может контролироваться мошенниками, а данные могут быть скомпрометированы или заменены. Но злоумышленнику недостаточно владеть только этим устройством, потому что из него можно добыть только одну из двух подписей. Еще одно преимущество состоит в том, что даже если сервис отказывает в обслуживании, пользователь не теряет доступ к своим монетам.

Выше были представлены только некоторые из возможных схем использования MultiSig-адресов, которых достаточно для знакомства. Далее разберемся, что такое Bitcoin Script.

### Bitcoin Script

*Bitcoin Script – это основанный на стеках неполный по Тьюрингу язык описания сценария для траты монет.* Неполный по Тьюрингу означает, что язык имеет ограниченную функциональность и не может совершать безусловные переходы по произвольным адресам в программе, циклы и рекурсии. Следовательно, сценарий не может выполняться бесконечно. Такой принцип позволяет ограничить возможности злонамеренных сторон по созданию сложных транзакций и замедлению работы всей системы.

Назначение скрипта – проверка условия, что сторона, которая хочет потратить монеты, имеет все необходимые доказательства владения этими монетами. В каждой транзакции есть поля *scriptSig* и *scriptPubKey*. Поле *scriptPubKey* содержит условия траты монет, а поле *scriptSig* – необходимые данные для разблокировки монет. Перед выполнением скрипта эти поля конкатенируются.

Выполнение скрипта подразумевает под собой последовательное выполнение операций над некоторыми данными, которые содержатся в стеке. Во время выполнения каждой из операций данные достаются из стека, над ними выполняется действие, определенное соответствующим *кодом операции* (также называемым *OP-кодом*), и результат выполнения обратно помещается в стек. Монеты считаются разблокированными только в том случае, если в результате выполнения всего скрипта в стеке остается лишь значение true. Также нужно учитывать, что максимальная вместимость стека при использовании Bitcoin Script ограничена 520 байтами.

OP-коды составляют своего рода команды языка программирования для bitcoin-транзакций [64]. Каждая операция представлена набором битов, который считывается виртуальным процессором и выполняется. Каждый оп-код можно рассматривать из двух частей: префикса «OP_» и непосредственно названием самой операции. Наиболее распространенными операциями являются OP_SHA256, OP_HASH160, OP_EQUALS, OP_CHECKSIG, OP_CHECKMULTISIG, OP_CHECKLOCKTIMEVERIFY [64].

### Концепция P2SH-адресов и преимущества их использования

BIP16 [65] ввело в протоколе Bitcoin новую концепцию – так называемый *pay to script hash (P2SH)*. Это возможность задать условия траты монет не скриптом в открытом виде, где подряд прописываются операнды и некоторые данные, которые потом выполняются рассмотренным выше образом, а в виде хэш-значения от нужного скрипта, то есть контрольной суммы от этих операндов. Стало возможно в выходе транзакции задавать большие и сложные условия траты монет, но сам выход при этом оставался коротким.

Чтобы потратить монеты с такого выхода, пользователю нужно доказать, что он знает условия траты, а также удовлетворить этим условиям. Для этого он публикует эти условия, то есть весь скрипт, а также хэш-значение от этого скрипта. Теперь любой может убедиться, что условия именно такие, просто сравнив полученное хэш-значение от скрипта с тем, что было опубликовано пользователем. Далее отправителю остается только удовлетворить этим условиям траты монет, чтобы все остальные могли верифицировать транзакции в соответствии с правилами протокола.

Это предложение по улучшению Биткоина было принято 3 января 2012 года. Сейчас оно активно применяется для реализации MultiSig-адреса.

Рассмотрим на примере, как это работает. Чтобы разобраться в процессе формирования таких транзакций нужно иметь представление о понятиях, таких как *redeem script*, *locking script* и *unlocking script*, а также правилах заполнения соответствующих полей.

*Redeem script* содержит в себе открытые ключи, к которым будет привязан MultiSig-адрес. В данном случае рассматривается комбинация ключей 2-из-5. Сначала идет значение 2, то есть указывается, что необходимо будет 2 подписи, которые будут проверяться соответствующими открытыми ключами. После этого записывают пять открытых ключей. Далее указывается количество открытых ключей, т. е. значение 5 (когда данные будут считываться в обратном порядке, это значение понадобится, чтобы понять, сколько ключей нужно прочесть). После этого указывается операция проверки мультиподписи (operation check multisignature, OP_CHECKMULTISIG).

*Locking script* – скрипт, который указывается в выходе транзакции, которая платит на MultiSig-адрес. Здесь будет производиться операция получения хэш-значения, например OP_SHA256 или OP_HASH160. Далее следует хэш-значение redeem script, которое в данном случае имеет размер 20 байт. После этого проводится операция по проверке соответствия данных фактическому хэш-значению.

*Unlocking script* является конкатенацией скриптов на входе транзакции со скриптами в выходе транзакции, которая платила на этот адрес. Есть две подписи, необходимые для траты монет, и полный redeem script, который позже будет подан на вход хэш-функции и проверен на предмет соответствия адресу, на который были отправлены монеты. После этого скрипт будет выполняться целиком, в том числе для проверки мультиподписи.

Важно, что есть ограничения на максимальный размер для каждого из перечисленных скриптов – 520 байт. Это число было рассчитано исходя из того факта, что в unlocking script может поместиться максимум 15 подписей, 15 соответствующих открытых ключей, а также несколько OP-кодов для верификации этих данных. Именно так было получено некоторое число, которое при округлении в большую сторону дало 520 байт. Следует сказать, что такой объем данных позволяет использовать по большей мере MultiSig-адрес 15-из-15, что является достаточно разумным пределом на практике. Redeem script при использовании большого количества подписей становится очень большим по размеру. Тот пользователь, который использует MultiSig-адрес или другие P2SH-адреса, при трате монет с них имеет очень большие по размеру транзакции. Это значит, что для подтверждения своих транзакций ему придется платить большие комиссии.

Теперь рассмотрим преимущества P2SH. Первое из них состоит в том, что такие адреса могут быть закодированы в привычный вид с использованием base58, в котором их длина составляет 34 символа. В соответствии с BIP13, которое определяет правила установки версионного байта для bitcoin-адресов [57], закодированных с помощью base58Check, начинаться адрес будет с «3», то есть туда вставляется определенный версионный байт. Ниже представлен пример, как может выглядеть P2SH-адрес.

**3P14159F73E4gFr7JterCCQh9QjiTjiZrG**

Однако стоит заметить, что это может быть не обязательно MultiSig-адрес. Redeem script может описывать и другие в том числе более сложные условия траты монет. Кроме того, P2SH – это не единственный метод реализации мультиподписи в Bitcoin.

Можно воспользоваться и другим методом: указать в выходе, который будет платить на MultiSig-адрес, не хэш-значение от скрипта, а сам скрипт, то есть перечислить прямо в выходе все открытые ключи и задать операцию проверки мультиподписи. Однако этот способ имеет свои недостатки. При отправке монет таким способом пользователь разглашает свои открытые ключи (это снижает его уровень приватности). Другим недостатком является большой размер транзакции, за которую отправителю придется платить большую комиссию, за отправку монет на MultiSig-адрес. Вряд ли отправитель захочет переплачивать за то, что получатель хочет использовать сложные условия траты монет, которые занимают больший объем данных.

P2SH дает возможность переложить эти комиссионные затраты на получателя. Если получатель хочет принимать монеты на MultiSig-адрес, то он сам будет платить за подтверждение больших транзакций, что является более справедливым подходом. Добавим, что P2SH позволяет реализовать разные варианты мультиподписи (2-из-2, 2-из-3 и другие).

### Пример использования P2SH для MultiSig-адреса

Представим, что Алиса хочет заплатить Бобу, который использует только MultiSig-адрес. Для этого Боб локально на своем компьютере (кстати, вместо Боба и Алисы могут быть любые организации) генерирует несколько личных ключей, получает из них соответствующие открытые ключи, которые конкатенируются определенным образом (рис. 4.46). Чаще всего открытые ключи представлены сначала закодированными с помощью base58Check, потом они сортируются в алфавитном порядке, после чего декодируются и конкатенируются, образуя redeem script.

![Рисунок 4.46 – Процесс использования P2SH](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.46-using-of-p2sh.png)

Сортировка необходима, когда требуется перерасчет открытых ключей из личных. Их нужно конкатенировать точно в таком же порядке, потому что следующим шагом будет создание redeem script и его хэширование. Если точно такие же ключи попадут в redeem script, но в другом порядке, мы получим другое хэш-значение и другой адрес. Это повлечет за собой определенные недоразумения. Поэтому перед конкатенацией открытые ключи нужно отсортировать согласно некоторому правилу. Чаще всего используют сортировку по алфавиту base58.

Итак, Боб посчитал хэш-значение от redeem script. Он может его представить в виде 20 байт и отправить Алисе, сказав, что это MultiSig-адрес с использованием P2SH. Боб также может закодировать его с версионным байтом, как обычный адрес, и просто отправить Алисе. Алиса поймет по версионному байту, что это MultiSig-адрес, составит транзакцию и соответствующим образом заполнит ее выход, чтобы Боб получил свои монеты. Далее она распространяет транзакцию в сеть. Они дожидаются подтверждения и Боб принимает платеж от Алисы. Взамен Боб, например, оказывает услугу или передает товар.

Наступает момент, когда Боб хочет потратить эти монеты. Следует понимать, что полный redeem script не был опубликован, пока монеты находились на его MultiSig-адресе. И даже Алиса не видела, какие именно открытые ключи использовал Боб, сколько их там было и т. д. Она вообще не знает, по каким правилам этот P2SH-адрес составлен, MultiSig-адрес ли это или нет и т. д. Соответственно, атаки на цифровую подпись (на эллиптическую кривую) еще невозможны.

Допустим, Боб хочет отправить платеж Еве (рис. 4.47). Тогда она генерирует новый адрес и дает его Бобу. Он создает заготовку транзакции, во входе которой он указывает ту транзакцию, в которой он получил монеты от Алисы, а на выходе – адрес Евы. Теперь он должен предоставить доказательства владения монетами, которые он тратит. Для этого он берет два своих личных ключа (допустим, его MultiSig-адрес предполагает вариант 2-из-5), из которых вычисляет две подписи к данной транзакции. Далее, он добавляет полный redeem script во вход транзакции.

![Рисунок 4.47 – Процесс доказательства владения монетами Бобом](/resources/img/volume-1/4.5-multisignature-mechanism-and-bitcoin-script/4.47-bob-proves-the-ownership.png)

Обратите внимание, что этот redeem script должен храниться у Боба на компьютере целиком либо он должен запомнить порядок, в котором он использовал открытые ключи для составления этого скрипта. Если же он применял определенные правила сортировки, то он должен запомнить их. Он также должен помнить, что к определенным личным ключам привязан MultiSig-адрес. Без этих знаний Боб не знал бы, какими из его личных ключей оперировать и в каком порядке их следует подавать на вход хэш-функции, чтобы получить нужный адрес.

Итак, у него есть две подписи и полный redeem script. Транзакция считается верной; Боб распространяет ее в сети и дожидается ее подтверждения. Это основное из того, что касается траты с MultiSig-адреса.

## 4.6 Особенности обновления Segregated Witness

Обновление Segregated Witness стало, наверное, самым желанным и в то же время трудно достижимым в десятилетней истории протокола Bitcoin. Оно вызвало первый раскол сообщества и показало всему миру нетривиальность осуществления *governance* в децентрализованной анонимной среде, где участники имеют противоречивые интересы. Когда участники сообщества столкнулись с ограниченной пропускной способностью Биткоина на уровне трех-четырех транзакций в секунду, они стали искать решения. Разошлись мнения и по поводу того, кто несет финальную ответственность за принятие новых правил: разработчики, валидаторы или пользователи. Справедливо заметить, что многие проекты после Биткоина (особенно Dash, Cardano, EOS) включили механизмы governance изначально в p2p протокол. Но к счастью или сожалению, при проектировании Биткоина, Сатоши не предусмотрел механизмов решения таких споров.

> **Проблемы оригинальной архитектуры Bitcoin**
>> * *Низкая пропускная способность учетной системы*
>> * *Transaction malleability (изменяемость неподтвержденных транзакций)*
>> * *Объединение бизнес-логики и доказательств владения монетами*
>> * *Ограничение для внедрения off-chain протоколов*

Segregated Witness привнес большие изменения в протокол и существенно улучшил формат транзакций. В этом подразделе рассматриваются его влияние на пропускную способность учетной системы, новые форматы адресов и транзакций, возможность отделить данные с доказательствами, новые форматы входных и выходных скриптов.

Рассмотрим, чем сериализованная транзакция с применением Segregated Witness (segwit-транзакция) отличается от обычной bitcoin-транзакции в сериализованном виде, которая изображена на рисунке 4.48. 

![Рисунок 4.48 – Пример обычной транзакции в сериализованном виде](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.48-serialized-tx.png)

На рисунке 4.49 изображена Segregated Witness транзакция. Разница между этими транзакциями заключается в *данных доказательства владения монетами (witness data)*, которые выделены на рисунке и могут быть отделены от остальных данных транзакции (в отличие от стандартной транзакции). Узлы, которые обновили свое программное обеспечение, получают в этом случае все данные (включая данные доказательства владением монетами), в то время как не обновленные узлы получают только транзакцию без witness data и считают ее корректной по умолчанию (считается, что каждый может потратить эту транзакцию). Позже мы рассмотрим, почему именно так происходит.

![Рисунок 4.49 – Пример SegWit-транзакции в сериализованном виде](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.49-serialized-sewit-tx.png)

Дословно Segregated Witness переводится с английского как *отделенный свидетель*. В сущности, главная идея обновления такова: *данные доказательства владения монетами хранятся отдельно от основных данных транзакции* (рис. 4.50).

![Рисунок 4.50 – Отделение доказательств владения монетами от других данных транзакции](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.50-segregation-of-coin-ownership.png)

Кроме того, обновление включает множество других улучшений. SegWit позволяет увеличить пропускную способность сети, отделить данные доказательств владения монетами от остальных данных транзакции, исправить недостатки формата транзакций, связанные с возможностью модификации данных в подписанных транзакциях (*transaction malleability*), и при этом сохранить обратную совместимость с предыдущими версиями протокола. Наибольшая ценность данного обновления состоит в том, что оно позволяет реализовать множество очень важных off-chain решений поверх протокола Bitcoin (детальнее в 4.8).

### Увеличение пропускной способности и обратная совместимость

Поскольку размер блока ограничен, то ограничено и количество транзакций, которые можно в него поместить, а от этого зависит пропускная способность системы. Разумеется, когда возник вопрос о повышении пропускной способности, в первую очередь ответ начали искать в способах увеличения максимального размера блока. Но эта идея не получила поддержки большинства участников сети.

Любое предложение тщательно проверяет и тестирует команда разработчиков протокола Bitcoin. Если согласие комьюнити достигнуто и решено внедрить предложение в протокол, выходит обновление. Рассмотрим два основных способа решения проблемы увеличения пропускной способности учетной системы.

*Hardfork*. Самый простой подход к обновлению и заключается в увеличении размера блока. Предполагается, что один блок будет вмещать больше транзакций, повышая пропускную способность. Однако такой блок не будут принимать узлы, работающие по старому протоколу, в правилах которого записано, что максимальный размер блока не может превышать 1 МБ. Такое изменение требует hardfork, который организационно более сложен, чем softfork.

*Softfork*. Segregated Witness позволяет нам решить эту проблему при помощи softfork. Как именно? Он позволяет нам разделить блок на две части, в первой из которых хранятся транзакции, а во второй – доказательства. При этом новые узлы сети получают обе части, а старые – только блок транзакций с размером 1 МБ. Старые узлы не могут получать блоки с доказательствами и, соответственно, не могут валидировать транзакции, которые получают, но это позволяет им участвовать в достижении консенсуса и не прибегать к hardfork, а постепенно переходить к новому ПО.

Согласно старым правилам блок содержит транзакции со встроенными доказательствами и его максимальный размер ограничен 1 МБ. В то же время новые правила предполагают, что максимальный базовый размер блока – 1 МБ, но дополнительно существует структура данных с доказательствами. Соответственно, итоговый размер нового блока превышает 1 МБ.

С целью обратной совместимости правила работы протокола позволяют работать старым узлам с новыми блоками, но они будут получать блок только в базовой комплектации с максимальным размером 1 МБ. Им недоступна структура witness. Новые же узлы получают полноценный блок с транзакциями и доказательствами. Ознакомиться с этим вопросом поможет рис. 4.51.

![Рисунок 4.51 – Результат обновления протокола](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.51-result-of-segwit-update.png)

Слева представлена схема работы протокола Биткоин до активации Segregated Witness. Блок имел максимальный размер 1 МБ, и он распространялся между различными узлами сети в одном виде.

### Новшества Segregated Witness

Первым и самым важным новшеством Segregated Witness стала новая структура транзакций. Кроме уже известных полей, в новой транзакции присутствуют три новых: *marker* и *flag*, которые применяются для версирования (в данном случае они строго заданы, но в следующих протоколах они могут меняться), а также поле *witness*. *Witness data – это набор доказательств владения монетами, которые вынесены за пределы основной части транзакции.* Структурно он выглядит, как набор входов, при этом каждый элемент witness data соответствует входу с определенным номером, что позволяет сопоставить доказательства с конкретными потраченными монетами.

Каждая транзакция имеет свой уникальный идентификатор, *txid*, по которому можно ее найти. Чтобы получить идентификатор транзакции, нужно привести саму транзакцию к одной последовательности данных, а потом получить хэш-значение от этой последовательности. С введением Segregated Witness появился и новый идентификатор (*wtxid*), и новый формат сериализации. Для старых транзакций, которые тратят монеты, не используя Segregated Witness, *wtxid* такой же, как *txid*. На рис. 4.52 указано, какие из полей транзакции участвуют в формировании *wtxid* (соответственно, для стандартной и SegWit-транзакции).

![Рисунок 4.52 – Различие между идентификаторами транзакций](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.52-diff-between-txs.png)

*Wtxid* нужен, чтобы построить альтернативное дерево Меркла для доказательств. Строится оно точно так же, как и для обычных транзакций, только вместо хэша транзакции здесь применяется *wtxid*. Соответственно, *wtxid* попарно хэшируются и дают в результате Merkle root.

Отметим, что Merkle root вставляется в coinbase-транзакцию, а не в заголовок блока. Если бы он находился в заголовке блока, то изменилась бы структура блока. Узлы, которые поддерживают старый протокол, не могли бы работать с такими блоками, и это препятствовало бы сохранению обратной совместимости. Поэтому Merkle root вставляется в один из выходов coinbase-транзакции. Когда все узлы перейдут на Segregated Witness, эта ситуация может измениться и будут рассматриваться новые подходы.

Рассмотрим подробнее проблему *изменяемости транзакций (transaction malleability)*. В Биткоине есть возможность изменить определенные данные транзакции, оставляя при этом саму транзакцию корректной: монеты будут уходить с того же адреса и приходить на прежний [67]. Эти изменения могут быть незначительными, но их будет достаточно, чтобы повлечь за собой изменение результата хэширования. По сути, это будет уже совсем другая транзакция, хотя делает она то же, что и оригинальная. Провернуть подобное можно только с неподтвержденными транзакциями, однако даже для неподтвержденных транзакций неизменяемость данных очень важна, потому что неопределенная вероятность такого изменения мешает реализации off-chain протоколов, которые построены на возможности создания цепочек из неподтвержденных транзакций.

Как это работает? При составлении bitcoin-транзакции, подписываются не все данные. Как минимум нельзя подписать scriptSig, поскольку это и есть поле, в которое будут записаны данные цифровой подписи, которую пользователь будет формировать. Такая уязвимость позволяет провести несколько видов атак. Рассмотрим основные.

Первая из них – это изменение формата подписи. Так сложилось, что в протоколе Биткоина формат подписи, которая помещается в scriptSig, утвержден нестрого и зависит от реализации OpenSSL, который также не предусматривает строгого формата. Третья сторона может перехватить транзакцию и незначительно изменить ее, при этом оставив ее валидной. Хэш-значение транзакции изменится, и это будет совершенно другая транзакция.

Вторая атака заключается в воздействии непосредственно на scriptSig. Поскольку scriptSig – это набор команд, который позволяет пользователю доказать владение монетами, можно указать в нем большое количество дополнительных операций. Существует возможность добавить к изначальным данным в scriptSig несколько ничего не значащих операций, которые никак не повлияют на результат выполнения этого скрипта, но изменят результат хэширования транзакции.

Что же плохого в изменении хэш-значения транзакции? Вопрос справедливый, поскольку к неподтвержденным транзакциям нет доверия, то есть пока транзакция не подтвердится, полагаться на данные, которые в ней содержатся, не следует. Однако проблема изменяемости транзакций важнее, чем кажется на первый взгляд. Во-первых, потому что существует возможность создать точно такую транзакцию, как оригинальная, но на деле она будет восприниматься узлами сети как другая (новая), потому что будет иметь другое хэш-значение. Следовательно, оригинальная будет конкурировать с альтернативной, в результате невозможно надеяться на подтверждение транзакции с сохранением ее оригинального хэш-значения. Во-вторых, проблема изменяемости транзакций важна для реализации самих протоколов, потому что эти протоколы как раз и построены на том, что мы формируем цепочку из неподтвержденных транзакций. Если изменяется хэш-значение хотя бы одной транзакции из этой цепочки, то вся последующая цепочка транзакций станет невалидной. Таким образом, изменить хэш транзакции можно, не имея доступа к личным ключам.

Обновление SegWit решает проблемы, связанные с transaction malleability, именно для транзакций нового формата, где были определены строгие правила заполнения полей. Это позволило задавать данные и сериализовать их однозначно, исключая разночтения.

### Пример SegWit-транзакции

Рассмотрим пример подтвержденной segwit-транзакции в формате JSON (рис. 4.53), чтобы увидеть содержимое ее полей.

![Рисунок 4.53 – Пример segwit-транзакции](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.53-real-segwit-tx.png)

Для начала обратим внимание на то, что поля *scriptSig* пустые. Соответствующие *доказательства владения монетами* в этом случае находятся в дополнительных полях: witness. И как в обычных bitcoin-транзакциях эти поля состоят из данных цифровой подписи и данных открытого ключа. Разница лишь в том, что поле *scriptSig* входит в базовую структуру транзакции, а поле witness не входит. Это позволяет не передавать эти данные по сети, не проверять и не хранить в памяти, когда они не нужны, потому что доказательства владения монетами уже были проверены.

Фактически *witness data* это отдельная часть транзакции, которая в некоторых случаях может не использоваться и даже вовсе отсутствовать не изменяя при этом базовую структуру транзакции и ее хэш-значение. Тем не менее при выводе транзакции на экран или представлении в формате JSON *witness data* удобно показывать во входах этой транзакции.

### Новые понятия вес и размер

Еще одно новшество обновления Segregated Witness, – внедрение понятий, такие как вес *транзакции* и *вес блока*. До Segregated Witness обычно говорили только о размере транзакции и размере блока. Все, что с этим было связано (например комиссия за транзакцию), определялось согласно размеру. При этом размер блока был ограничен 1 МБ. С внедрением Segregated Witness появилась необходимость обрабатывать транзакции старого типа вместе с транзакциями нового типа.

Кроме того, нужно было уменьшить стоимость обработки дополнительной части блока (witness data). Для решения этой проблемы было введено понятие веса транзакции и соответствующих *весовых единиц* (*weight units*). Размер основной части транзакции теперь рассчитывается с коэффициентом 3, а размер witness data – с коэффициентом 1. Как можно догадаться, любые данные, которые включались в witness data, требовали в 3 раза меньшей комиссии, чем основные данные транзакции. Такой подход позволяет валидаторам определить более выгодную транзакцию в контексте занимаемого места в блоке и получаемого вознаграждения. Вес транзакции рассчитывается по формуле ниже.

**transaction weight = base size * 3 + total size**

* transaction weight – вес транзакции (измеряется в весовых единицах);
* base size – базовый размер транзакции (измеряется в байтах);
* total size – итоговый размер транзакции (измеряется в байтах).

Вне зависимости от того, по новым ли или по старым правилам сериализована транзакция старого образца, размер у нее всегда будет одинаковый. Следовательно, вес транзакции увеличится ровно в 4 раза. А для SegWit-транзакции вес будет чуть меньше, потому что она не будет содержать данные доказательств владения монетами.

Вместе с весом было введено понятие *виртуальный размер (virtual size)*, который вычисляется путем деления веса на 4. Виртуальный размер используется, чтобы рассчитать комиссии для транзакций и чтобы валидаторы могли понять, насколько им выгодно включать определенную транзакцию в блок, используя привычную цену записи, которая измеряется в единицах *spb (satoshi per byte, сатоши на байт)*.

**virtual size = weight units / 4**

Поскольку вес транзакции старого образца будет в 4 раза больше, чем размер, то виртуальный размер транзакции будет равен обычному размеру. Соответственно, для старых транзакций подсчет комиссии не изменится. Для новых транзакций он будет чуть меньше за счет того, что мы выносим подписи в отдельную структуру. Таким образом, за них можно платить меньшие комиссии, но иметь тот же приоритет у валидаторов при включении в блок. При этом, максимальный размер блока без witness data (base size) остался 1 МБ, а максимальный вес блока равен 4 МБ.

Каким будет итоговый размер блока вместе с witness data? Абсолютно точно сказать невозможно. Очевидно, что это значение будет находиться в пределах от 1 МБ до 4 МБ (условных весовых единиц, которые соответствуют 1 МБ фактического размера). Но можно сделать более точную теоретическую оценку. Получится около 1,8 МБ. Откуда это значение? Типичный блок с транзакциями на текущий момент состоит примерно на 60% из данных доказательств владения монетами. Рассчитаем вес блока с размером 1 МБ, состоящего на 60% из данных доказательств владения монетами.

**400,000 bytes * 4 = 1,600,000 условных весовых единиц**

**600,000 bytes * 1 = 600,000 условных весовых единиц**

**1,600,000 + 600,000 = 2,200,000 условных весовых единиц** (Эта величина соответствует 1 МВ фактического размера.)

Теперь, учитывая максимальный вес блока в 4 000 000 условных единиц (определенного по правилам протокола), можно определить, насколько это позволит увеличить итоговый размер блока вместе с witness data.

**4,000,000 / 2,200,000 = 1.8** (Значит, размер блока будет составлять 1,8 МБ.)

То есть можно предполагать, что максимально эффективный размер блока будет составлять около 1,8 МБ (не путать реальный размер блока с его весом). Но очевидно, что на практике это значение будет полностью зависеть от состава транзакций в этом блоке.

### Статистика адаптации обновления

По состоянию на ноябрь 2018  года количество SegWit-транзакций преодолело отметку 40% от общего количества в Биткоине. Более того, если учесть общее количество переведенных биткоинов, то около 55–60% из них было переведено при помощи SegWit-транзакций. При этом основные сервисы для работы с Биткоином и цифровые кошельки, такие как Electrum и Bitxfy, реализовали поддержку Segregated Witness незадолго до начала 2018 года.

В динамике итогового размера блока после активации обновления также можно заметить существенные изменения (рис. 4.54). В моменты увеличения потока новых транзакций почти все блоки получаются больше 1 МБ, а в некоторых случаях даже больше 2 МБ. Совершенно очевидно, что после активации SegWit вопрос о необходимости срочного решения проблемы низкой пропускной способности уже не казался таким острым [68].

![Рисунок 4.54 – Изменение размера блока после активации SegWit](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.54-block-changing-after-adoption.png)

Если посмотреть на зависимость средней комиссии за транзакцию от количества транзакций нового формата, то тоже можно заметить очень сильную корреляцию в изменениях этих величин (рис. 4.55).

![Рисунок 4.55 – Зависимость средней комиссии за транзакцию от количества транзакций](/resources/img/volume-1/4.6-features-of-the-segregated-witness-update/4.55-average-tx-fee.png)

Также не следует забывать, что обновление Segregated Witness сделало возможным развитие off-chain решений поверх протокола Bitcoin. Одно из таких решений – протокол Lightning Network. Заранее отметим, что адаптация Lightning Network намного сложнее, чем реализация SegWit. Тем не менее, работа в этом направлении идет полным ходом и уже есть значительные достижения (см. 4.8).

**Часто задаваемые вопросы**

*– Правильно ли утверждать, что для SegWit-транзакций не будет работать RBF (replace-by-fee)*

Нет, replace-by-fee будет работать для SegWit-транзакций, потому что он основан не на том, какие у вас правила траты, а на том, что вы используете одни и те же монеты и указываете sequence входа транзакции. Если вы увеличиваете значение на входе, используя те же монеты, и указываете корректные доказательства того, что вы владеете этими монетами, то вы точно так же можете заменить предыдущую транзакцию.

*– Как можно изменить хэш от неподтвержденной транзакции?*

Хэш от транзакции – это результат вычисления хэш-функции от всех данных, которые хранятся в транзакции. ScriptSig, который содержится в транзакции, участвует в подсчете хэша, но не может быть подписан. Незначительные изменения в этом поле, которые не повлекут за собой изменения правил проверки подписи, вызовут изменения хэш-значения транзакции. Это значит, что подпись и транзакция остаются валидными, но хэш-значение от транзакции изменится.

*– Как в транзакции хранятся witness data?*

Как было отмечено ранее, транзакции в Segregated Witness имеют новую структуру: набор входов, набор выходов, а также доказательства, в которых, соответственно, хранятся witness data. Максимально просто это можно представить так: у пользователя есть просто набор данных, где написано, что имеется два входа транзакции (байты первого входа и байты второго входа), два выхода, а после них еще два набора witness data, которые точно так же записаны в виде последовательности байтов.

## 4.7 Механизм комиссий в Bitcoin

В этой теме детально описана основная задача комиссий в Биткоине, как они работают и на что влияют. Объяснены причины волатильности комиссий, задержки в подтверждении транзакций и описаны подходы к решению этих проблем. Кроме того, обозначено, как именно обновление Segregated Witness способствует снижению стоимости транзакций. В завершение приведены мысли по поводу того, как дружба с валидаторами снижает комиссии до нуля и к чему такая тенденция может привести в будущем.

Согласно правилам протокола Bitcoin, чтобы подтвердить транзакцию, владельцы большей части вычислительной мощности должны создать блок, который будет содержать эту транзакцию, и далее продлевать цепочку, основанную на данном блоке. Другими словами, на основе блока, в котором транзакция получила первое подтверждение, должно быть построено еще несколько блоков (рис. 4.56). Важно, что эта цепочка должна быть самой длинной и конкурентных цепочек быть не должно. Необходимое количество следующих блоков (подтверждений транзакции) определяет сам получатель платежа на свое усмотрение. Он руководствуется таким правилом: *чем больше подтверждений у транзакции, тем меньше вероятность ее последующей отмены*.

![Рисунок 4.56 – Процесс включения транзакции в блок](/resources/img/volume-1/4.7-fees-mechanism-in-bitcoin/4.56-inclusion-the-transaction-in-the-block.png)

С ростом популярности Биткоина значительно увеличился поток новых транзакций в сети. Известно, что размер блока определен правилами протокола и строго ограничен. В Биткоине максимальный размер блока составляет 1 МБ, а время создания блока в среднем составляет 10 минут, следовательно, пропускная способность ограничена (1,7 кБ/с). Если поток новых транзакций превышает пропускную способность, то не все из них будут обработаны. И такие ситуации случаются нередко. Какие транзакции получат подтверждение первыми, а какие останутся ждать – это вопрос, который требует четкого ответа. Суть этого вопроса состоит в конкурировании транзакций между собой за право быть добавленными в блок.

Механизм комиссий в Биткоине необходим для оплаты услуг распределенной сети, где услугой сети, по сути, является надежное хранение данных. Пользователи Биткоина платят за каждый байт данных, добавленных в общую базу. В силу того, что пропускная способность этой базы данных ограничена, пользователи конкурируют между собой за приоритет записи.

Формируя транзакции, пользователи устанавливают комиссию в виде некоторого количества сатоши за один байт данных. При этом каждый узел-валидатор выстраивает все неподтвержденные транзакции в очередь таким образом, что сначала он подтверждает транзакции, которые платят большую комиссию за единицу своего размера (весовую единицу). Очевидно, что те транзакции, которые попадают в конец очереди, могут долго оставаться неподтвержденными (рис. 4.57).

![Рисунок 4.57 – Конкуренция за место в mempool](/resources/img/volume-1/4.7-fees-mechanism-in-bitcoin/4.57-competition-for-the-space.png)

Еще одна важная задача, которую решает механизм комиссий, – это «*трагедия общин*». В контексте Биткоина подразумевается защита от спама транзакциями. Наличие обязательных комиссий означает, что злоумышленнику дорого обойдется на протяжении длительного времени засорять сеть поддельными транзакциями, если у него будут такие намерения.

### Волатильность цены записи данных

Пользователи сети Биткоин время от времени сталкиваются с непривычно высокой волатильностью комиссий. Например, в 2017 году усредненная цена записи одного байта данных в базу Биткоина колебалась в диапазоне от 1 до 500 сатоши. Очередь неподтвержденных транзакций же варьировалась от нескольких КиБ до десятков и даже сотен МиБ.

Ввиду того, что цена на запись данных в учетную систему Bitcoin может резко измениться, пользователи вынуждены конкурировать друг с другом почти вслепую. Это обусловлено тем, что практически транзакция будет подтверждена в среднем в течение 8 минут, тогда как комиссию за обработку нужно установить еще до ее подписания. Поэтому вопрос правильно установленной комиссии все равно остается актуальным, потому что все хотят быстрого подтверждения своих транзакций с минимальными затратами. Естественно, платить больше 50 USD за типичную транзакцию – не лучший вариант, особенно, когда можно сэкономить до 90% этой суммы, грамотно рассчитав комиссию.

Последствиями резкого увеличения потока новых транзакций является возникновение большой очереди ожидающих добавления в блок транзакций. Среди них и те транзакции, отправители которых либо не обратили внимание на изменение цены записи, либо сформировали транзакцию в момент перед резким повышением. Зачастую проблема кроется не в поведении самого пользователя, а в программном обеспечении кошелька или сервисе управления биткоинами. Более того, во многих программных продуктах для работы с Bitcoin управление комиссиями вообще скрыто от пользователя.

### Решение проблемы с волатильностью комиссий

Вне зависимости от наличия возможности ручного управления приоритетом записи формируемых транзакций, биткоин-кошельки могут использовать механизмы оценки текущей цены записи данных, вместо использования константных или обновляемых вручную значений. Это дает большое преимущество кошельку с точки зрения управления приоритетом записи транзакции в общую базу и экономии средств на комиссию.

Стоит отметить, что прогнозирование цены на запись также возможно, но зачастую такие прогнозы работают только на очень коротких промежутках времени (в среднем несколько минут). Если же прогноз устарел, а транзакция не подтвердилась, то вполне вероятно, что ожидать ее подтверждения можно еще долго – чаще всего несколько часов, а иногда и суток.

**transaction fee = transaction size * byte price**

Динамический, или адаптивный, расчёт комиссии за транзакцию означает автоматическую оценку итогового размера транзакции в байтах и оценку цены записи одного байта данных в базу Биткоина на ближайшие несколько часов. Для обеих оценок существуют специфические алгоритмы анализа транзакций и активности в сети. После получения оценки размера транзакции в байтах и цены записи одного байта эти значения перемножаются, и получается сумма в биткоинах, которую нужно добавить в транзакцию в качестве комиссии.

Преимуществом подхода с адаптивной оценкой является включение в транзакцию более точной комиссии, которая будет выше минимального порога, но не слишком высокой, что экономит монеты пользователя. Более того, вероятность, что транзакция окажется глубоко в очереди неподтвержденных, минимальная. Тем не менее, бывают исключения, поэтому рассмотрим подробнее, что можно сделать в экстренной ситуации.

### Повышение комиссии после отправки транзакции

Отметим, что протокол Биткоин весьма гибкий и в отношении комиссий. Есть два улучшения протокола, которые позволяют повысить комиссию уже сформированной и отправленной транзакции: *replace-by-fee* [69] и *child-pays-for-parent* [70]. К сожалению, немногие кошельки реализуют эту функциональность для удобства своих пользователей, хотя со временем их становится больше.

*RBF (replace-by-fee)* позволяет заменить неподтвержденную транзакцию альтернативной транзакцией с более высокой комиссией. Это значит, что пользователь может заново создать транзакцию, которая идентична неподтвержденной, увеличить размер комиссии в ней и отправить снова в сеть. Существует набор правил, которые определяют, как создать такую транзакцию и как узлы сети должны ее обработать (совершить замену). После создания такой транзакции, она будет конфликтовать с той, которая была выпущена ранее, а значит, из обеих транзакций может быть подтверждена только одна (естественно, валидатору выгодно включить в блок транзакцию с более высокой комиссией).

В случае *CPFP (child-pays-for-parent)* вам нужно создать новую дочернюю транзакцию, которая будет платить монеты за вашу неподтвержденную родительскую транзакцию. Для этого в дочернюю транзакцию вы включаете комиссию, которая очень выгодна для валидаторов. Но чтобы ее подтвердить и получить соответствующее вознаграждение, валидаторам необходимо для начала подтвердить родительскую транзакцию и добавить обе транзакции в один блок. Такой метод был предложен в августе 2016 года [71]. Данный подход имеет ряд технических нюансов и организационных требований для его корректного использования. Одно из таких требований состоит в том, что пользователь (или ПО в автоматическом режиме) должен заново переоценить комиссию транзакции, сформировать и подписать новую (альтернативную) транзакцию, распространить ее в сеть и продолжить наблюдение за ее состоянием.

Пример транзакции, подтвержденной с помощью метода child-pays-for-parent, представлен на рис. 4.58, где изображены две соответствующие транзакции (родительская и дочерняя), которые были подтверждены в одном блоке.

![Рисунок 4.58 – Механизм child-pays-for-parents](/resources/img/volume-1/4.7-fees-mechanism-in-bitcoin/4.58-child-pays-for-parent.png)

Как видим, проблема увеличения комиссии может быть решена, однако решения имеют некоторые неудобства. Несмотря на то, что опции RBF и CPFP протокол поддерживает довольно долго, их внедрение в ПО bitcoin-кошельков происходит довольно медленно.

### Как Segregated Witness помогает снизить комиссии?

Напомним, что одно из изменений протокола, которые были внесены с обновлением Segregated Witness, – введение нового формата транзакции и *ее веса* (*transaction weight*). До появления Segregated Witness при расчете комиссии обычно учитывали только размер транзакции. Теперь важными являются и размер, транзакции и ее вес. Новая транзакция хранит доказательства владения монетами в отдельной структуре (witness data). Чтобы перевести *размер транзакции (total size)* в ее вес, размер witness data умножается на меньший коэффициент, чем остальные данные транзакции. Вес транзакции рассчитывается по формуле ниже.

**transaction weight = base size * 3 + total size**

В этом случае *base size* – это размер транзакции без учета размера witness data. Как можно догадаться, любые данные, которые включаются в witness data, требуют в 4 раза меньшей комиссии, чем остальные данные транзакции. Подобный подход позволяет валидаторам определить более выгодную транзакцию в отношении занимаемого в блоке места и получаемого вознаграждения.

Известно, что около 60% всех данных транзакции составляют именно данные доказательства владения монетами (т. е. такие, которые можно записать в witness data). Соответственно, вес транзакций нового формата значительно уменьшится. Таким образом, пользователь может платить меньше за подтверждение новой транзакции, при этом она будет иметь тот же приоритет у валидаторов при включении в блок, что и старая транзакция с большей комиссией.

На рис. 4.59 отображена зависимость цены записи одного байта данных в совместную базу данных Биткоина от нагрузки (потока неподтвержденных транзакций), выраженной в байтах в секунду (byte per second). Вывод можно сделать очень простой: если поток новых транзакций ниже или равен пропускной способности учетной системы, то цена записи практически нулевая. А если поток новых транзакций превысит пропускную способность, то цена резко устремляется вверх.

![Рисунок 4.59 – Зависимость между пропускной способностью системы и размером комиссии](/resources/img/volume-1/4.7-fees-mechanism-in-bitcoin/4.59-dependence-of-fees-and-capacity.png)

### Вариант с другом-майнером

Представьте, что у вас есть друг, который занимается майнингом и контролирует 10% всей вычислительной мощности Биткоина. В среднем он создает блок один раз в 100 минут. В этом случае вы можете сформировать свою транзакцию, в которой установите нулевую комиссию, после чего отправите эту транзакцию своему другу для подтверждения (рис. 4.60).

![Рисунок 4.60 – Ситуация с другом-майнером](/resources/img/volume-1/4.7-fees-mechanism-in-bitcoin/4.60-friend-miner-case.png)

В среднем, первое подтверждение с вероятностью близкой к 100% ваша транзакция получит в течение 100 минут, а полное подтверждение – через 50 минут после первого. В итоге, ваши транзакции будут получать полное подтверждение приблизительно в течение 150 минут. Если бы у вас такого друга не было, полное подтверждение транзакция получала бы приблизительно в течение 60 минут, но уже с оплатой полноценной комиссии.

Как видите, если речь идет об экономии средств, то вам повезло, если у вас есть друг валидатор, который контролирует значительную часть всей майнинговой мощности в Bitcoin. Но если такого друга нет, то могут существовать альтернативные варианты оплаты места в блоке.

### Вариант с продажей мест в очереди на подтверждение

Обычно валидатор действует по стандартной схеме и сортирует транзакции по цене записи 1 байта данных. Похоже, что сейчас так реализовано практически все программное обеспечение для майнинга. Однако не исключено, что у валидатора может быть лучшая мотивация. Он может самостоятельно формировать политику монетизации своей активности. Иначе говоря, он может действовать нестандартно в отношении транзакций при их записи в свой блок. Если найдутся более выгодные условия, чем просто взять комиссию за вашу транзакцию, вероятнее всего, он изменит свою политику. Такой подход предполагает, что пользователи будут платить валидатору за подтверждение своих транзакций не через заранее установленную комиссию, а непосредственно (по собственной схеме).

На практике любой достаточно крупный майнинговый пул может вести свою кампанию с целью повышения прибыльности и использовать для этого нехитрые механизмы, например:
* Определить свои приоритеты сортировки транзакций
* Заключить партнерство с некоторым сервисом (биржа, магазин, браузер и т. д.)
* Продавать гарантии на некоторое место в последующем блоке

Более того, пул может даже начать предпродажу сертификатов на свободное место в своих блоках, как обязательство на предоставление определенной пропускной способности учетной системы в будущем (подробнее о *токенизации* в 6.4).

**Часто задаваемые вопросы**

*– Как отправить транзакцию с нулевой комиссией другу-майнеру?*

Как обычная транзакция, в сети она вряд ли распространится, поскольку по умолчанию конфигурация узлов имеет параметр *minRelayFee*, который не равен нулю. Это означает, что транзакция должна обязательно иметь комиссию больше некоторого порогового значения, чтобы узлы могли отреагировать на нее и передать дальше (для предотвращения спама). Поэтому в данной ситуации пользователю необходим другой подход к доставке «необычной» транзакции своему другу-майнеру. Один из вариантов состоит в том, чтобы насильно соединить узел пользователя с узлом-валидатором друга, вручную вписав сетевой адрес в файл с конфигурацией узла пользователя, а на узле-валидаторе установить minRelayFee равным нулю. Но есть проблема: узел друга должен отличать «необычные» транзакции от транзакций других пользователей. Поэтому другой вариант решения – это использование API собственного производства в кошельке пользователя и на узле-валидаторе друга-майнера.

*– В чем состоит выгода валидатора брать меньшую комиссию, продавая сертификаты на место в блоке, если он может взять больше биткоинами?*

Выгода состоит в том, что валидатор может продавать место в блоках заранее, если, например, деньги ему нужны сегодня больше, чем завтра, в отличие от других валидаторов. Также может быть важна фиксированная цена для пользователей биткоин-кошельков: иногда им нужно точно знать свои затраты на несколько месяцев вперед. К тому же, это хоть какая-то гарантия того, что для транзакций пользователя найдется место в последующих блоках по заранее известной цене.

## 4.8 Платежные каналы и Lightning Network

Идея *платежных каналов* (и ее развитие в *Lightning Network*) стала, несомненно, революционной для мира электронных платежей. Ее применение не ограничивается использованием в криптовалютах. Важными проблемами любой финансовой учетной системы являются ограничения по пропускной способности, а также беспокойства относительно приватности пользователей. До появления систем цифровой связи эти проблемы были неактуальны: разумеется, операция по передаче бумажной банкноты из рук в руки не требовала обращения к серверу, а также не отслеживалась и не цензурировалась. Появление цифровых учетных систем предоставило возможность быстрого перемещения денежных средств, при этом избегая ограничений, связанных с физическим перемещением золота или банкнот. С другой стороны, теперь каждая новая транзакция должна быть как можно раньше добавлена в общедоступную базу данных, чтобы обе стороны могли убедиться, что платеж выполнен. К тому же, имеющий доступ к истории всех транзакций субъект (например правительство) получал бы огромный рычаг влияния на жизнь людей, если бы мог анализировать эту историю и отслеживать деятельность граждан.

Появление off-chain платежных каналов и Lightning Network (LN) [72] сделало возможным появление платежных систем с высокой масштабируемостью, безопасностью, низкой стоимостью поддержки, работающих по принципу p2p. Ниже мы разберем основные принципы обоих механизмов, их особенности в контексте Bitcoin и рассмотрим, как они работают.

## Что такое платежный канал?

Впервые идею платежных каналов описал сам Сатоши Накамото в личном письме одному из активных разработчиков протокола много лет назад. Тогда еще в Биткоине не было принято достаточно важных обновлений, позволяющих проектировать надежные платежные каналы. Однако позже это стало возможно, и в 2013 году вернулись к этой воистину перспективной идее. Мы рассмотрим основные методы реализации платежных каналов.

*Платежный канал – это метод проведения множества платежей без добавления транзакций для каждого из них в цепочку блоков.* Для открытия и закрытия платежного канала контрагентам нужно осуществить on-chain транзакции: открывающую и закрывающую. При этом участники канала взаимодействуют только друг с другом [73]. Наличие дополнительных валидаторов или третьих доверенных сторон не требуется.

Процесс использования платежного канала аналогичен процессу учета займа на бытовом уровне (запись на бумаге), но с той разницей, что благодаря платежным каналам появилась возможность гарантированного выполнения обязательств всеми сторонами (чего запись на бумаге, конечно же, не может обеспечить).

Ниже мы разберемся с принципами работы платежных каналов и с протоколом, который позволил развить и применить эту концепцию для совершенствования Bitcoin, – Lightning Network.

## Зачем нужны платежные каналы?

Основными ограничениями в Bitcoin являются большое время подтверждения транзакций и достаточно высокие (а также непредсказуемые) комиссии, которые делают микроплатежи (на сумму несколько центов или долларов) нецелесообразными. Какие же преимущества предоставляет пользователю платежный канал по сравнению с обычными транзакциями? В рамках платежного канала участники проводят платежи между собой, не публикуя транзакции в сети Bitcoin. Сторона-получатель выполняет быструю независимую проверку и принимает платеж. В базовом варианте комиссий нет. Соответственно, микроплатежи имеют место. Именно из-за этой особенности платежные каналы также называют *micropayment channels* [74].

Взаимодействие участников канала по умолчанию приватно: детали каждого микроплатежа останутся в тайне от всех остальных, хотя сам факт использования платежного канала между конкретными bitcoin-адресами будет известен всем.

## Платежный канал: пошаговый пример

В упрощенном варианте работу платежного канала можно изобразить на такой схеме (рис. 4.61). У Алисы и Боба есть bitcoin-кошельки с дополнительными модулями, которые поддерживают работу с платежным каналом. Эти модули обмениваются данными, необходимыми для проведения платежей (например данными о распределении монет, актуальными данными подписей и т. д.).

![Рисунок 4.61 – Схема функционирования платежного канала](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.61-operation-of-payment-channel.png)

Предлагаем рассмотреть более подробно, каким образом перераспределяются монеты в платежном канале (рис. 4.62).

![Рисунок 4.62 – Взаимодействие в пределах платежного канала](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.62-interaction-within-payment-channel.png)

*Шаг 0*. Для открытия канала Алиса и Боб создают MultiSig-адрес и оба переводят свои деньги на него (предположим, по 5 BTC каждый). Теперь на адресе хранится 10 монет; 5 из них «принадлежат» Алисе, а 5 – Бобу (фактически сумма находится на общем адресе, а принадлежность монет определяется закрывающей транзакцией).

*Шаг 1.* Представим, что Алиса хочет заплатить Бобу 2 BTC за некоторые услуги. Она создает транзакцию, которая распределяет монеты в платежном канале так: 3 BTC Алисе, 7 BTC Бобу.

*Шаг 2*. Алисе снова нужно заплатить Бобу, например, 1 BTC. Для передачи ценности Бобу, Алиса вновь создает off-chain транзакцию, которая распределяет монеты – 2 BTC Алисе и 8 BTC Бобу.

*Шаг 3*. Теперь Боб хочет заплатить Алисе 7 BTC и поэтому он создает новую транзакцию с новыми правилами распределения монет: Алиса получает 9 BTC, а Боб 1 BTC.

*Шаг 4*. После этого Алиса и Боб решают, что платежей между ними больше не будет, и закрывают канал. Они публикуют последнюю сформированную транзакцию (которую сформировал Боб на шаге 3) в Bitcoin-сеть. На входе этой результирующей транзакции будут 10 BTC с MultiSig-адреса, на выходе эта транзакция заплатит 9 BTC на адрес Алисы и 1 BTC на адрес Боба.

Следует отметить, что только 2 транзакции (из всех, которые были сформированы) были отправлены в Bitcoin-сеть и добавлены в цепочку блоков: это открывающая (шаг 0) и закрывающая (шаг 4) канал транзакции. Остальные транзакции были off-chain и, следовательно, не нагружали сеть Bitcoin. Соответственно, Алиса и Боб не платили комиссию за эти транзакции. Внутри платежного канала они просто обменивались друг с другом идентичными транзакциями (с различием только в суммах выходов). Когда настает момент закрытия канала, один из его участников публикует в сети последнее обновленное состояние транзакции и тем самым инициирует закрытие платежного канала.

### Особенности платежного канала

Нельзя сказать, что у платежных каналов есть серьезные недостатки по сравнению с обычными транзакциями, но есть некоторые характерные особенности.

Платежный канал нужно открыть и, соответственно, рано или поздно закрыть. Эти процессы сопровождаются отдельными on-chain транзакциями. Для них неизбежна оплата комиссии, и необходимо ожидать их подтверждения. Для открывающей транзакции лучше дожидаться полного подтверждения.

Внутри конкретного канала платежи доступны только в рамках предопределенной суммы (согласно нашему примеру выше это значит, что Алиса и Боб могут действовать только в пределах суммы, на которую открыт канал, то есть 10 BTC). Ее задают сами участники, замораживая нужную сумму с помощью специального скрипта.

Платежные каналы могут быть *однонаправленными (unidirectional)* и *двунаправленными (bidirectional)*. Это зависит от метода реализации канала.

Период существования канала и максимальное количество платежей в канале могут быть неограниченными. Однако в зависимости от метода эти параметры канала можно ограничить. Соответственно, каналы могут быть закрыты по наступлению определенного времени или досрочно. Причем закрыть канал можно как по обоюдному согласию участников, так и по желанию одного из них, но с некоторыми особенностями.

### Методы реализации платежных каналов

Как упоминалось в примере с Алисой и Бобом, у пользователей есть специальный модуль, который позволяет им действовать в рамках платежного канала. В зависимости от реализации, эти модули могут поддерживать различные методы функционирования платежных каналов. Мы приведем список наиболее популярных из них.

*Spillman-style payment channel* – это максимально простой вариант однонаправленного канала с ограниченной длительностью работы и неограниченным количеством платежей.
Позже было принято еще одно усовершенствование протокола Биткоин и стали возможны *CLTV-style payment channels*, которые представляют собой усовершенствование предыдущего метода.

*Poon-Dryja payment channel* – это метод двунаправленных каналов с неограниченным временем работы. Они требуют еще нескольких обновлений протокола Биткоина, которые недавно были приняты. Эти каналы используются при проектировании Lightning Network.

*Decker-Wattenhofer duplex payment channel* – это вариант использования двух однонаправленных каналов одновременно, который усовершенствовал их свойства за счет формирования не последовательной цепочки заменяемых транзакций, а целого дерева заменяемых транзакций. В таких каналах может быть больше двух участников.

Рассмотрим детальнее реализацию Spillman-style, поскольку она наиболее проста и доступна для понимания.

### Spillman-style payment channels

Итак, *Spillman-style payment channel* – это метод создания однонаправленных платежных каналов, где есть роль отправителя и роль получателя. Длительность работы такого канала устанавливает отправитель произвольно, при этом получатель может досрочно закрыть канал. Давайте разберем основные шаги работы такого канала на схеме (рис. 4.63).

![Рисунок 4.63 – Схема функционирования Spillman-style payment channels](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.63-spillman-style-payment-channel.png)

Для удобства восприятия представим, что есть некоторый сервис, который торгует доступом к глобальной сети через точку доступа Wi-Fi, и некоторый клиент, который хочет получить доступ в сеть на сутки. Услуга будет стоить один монету. Очевидно, что клиент не доверяет сервису на такую сумму и хочет оплачивать трафик посекундно.

Тогда они решают открыть платежный канал на сутки с суммой в один биткоин. Сервис генерирует новую пару ключей для цифровой подписи и передает открытый ключ клиенту. Клиент, в свою очередь, генерирует новую пару ключей и использует свой открытый ключ и открытый ключ сервиса для формирования MultiSig-адреса 2-из-2. Далее, клиент формирует транзакцию номер один, в которой он отправляет один биткоин на MultiSig-адрес, подписывает ее, но не распространяет в Биткоин сеть, поскольку сервис может подставить клиента и отказаться подписывать любые транзакции для дальнейшей передачи одного биткоина.

Поэтому клиент формирует транзакцию номер два, где монеты с MultiSig-адреса отправляются на адрес, который он контролирует сам. Причем устанавливает такое значение параметра locktime, чтобы транзакция могла быть подтверждена через сутки. Эту транзакцию он не подписывает, а отправляет сервису. В свою очередь, сервис соглашается с тем, что клиент может забрать монету целиком себе, но не раньше, чем через сутки, и подписывает транзакцию своим ключом. Подпись он передает клиенту, клиент ее проверяет. Теперь он имеет возможность доподписать транзакцию своим ключом и гарантированно забрать монету обратно, если сервис решит отказать в обслуживании. Таким образом, вторая транзакция страхует от мошенничества и должна быть подписана еще до того, как средства будут отправлены сервису. Такой способ страхования становится возможным благодаря правильному использованию механизма locktime. Именно этот механизм позволяет нам утверждать что пользователь фактически владеет определенным количеством монет с MultiSig-адреса.

Следующим шагом клиент распространяет транзакцию 1 в сети Биткоина или передает ее сервису для распространения, если у него самого соединения нет. После подтверждения этой транзакции платежный канал считается открытым.

Здесь транзакция 1 называется *funding transaction*, а транзакция 2 – *refunding transaction*.

Каким же образом выполняется взаимодействие при расчетах в рамках платежного канала? Давайте рассмотрим схему на рис. 4.64.

![Рисунок 4.64 – Расчеты в канале после проведения платежа](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.64-coins-settlement.png)

Для отправки первого платежа клиент запрашивает биткоин-адрес сервиса, который тот контролирует самостоятельно. Далее клиент формирует транзакцию 3, в которой монета с MultiSig-адреса распределяется между двумя выходами: первый – это платеж на адрес сервиса за одну секунду работы точки доступа Wi-Fi, а второй – это сдача на собственный адрес клиента. Клиент подписывает транзакцию 3 своим ключом и передает сервису. Сервис проверяет правильность транзакции и подписи и затем принимает платеж, потому что он может гарантированно получить оплату первой секунды трафика, если доподпишет эту транзакцию своим личным ключом в течение суток. Но если сервис намерен дальше предоставлять обслуживание клиенту и получать оплату в рамках канала, то он просто сохраняет транзакцию 3 локально до закрытия канала.

Для отправки всех последующих платежей клиент изменяет выходные значения транзакции 3, соответственно, переподписывает ее и передает сервису уже только саму подпись и сумму изменения. Сервис также проверяет полученные данные и сохраняет уже новую версию транзакции номер три, т. к. в этой версии он получает уже больше монет (рис. 4.65).

![Рисунок 4.65 – Опубликование результатов в сети Bitcoin](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.65-publication-to-the-bitcoin.png)

Как же выполняется закрытие канала? На схеме видно, что сервис должен успеть опубликовать в сети Bitcoin последнюю версию транзакции 3 до завершения времени работы канала. В противном случае отправитель может схитрить и забрать всю сумму на свой адрес, доподписав и опубликовав транзакцию 2.

Стоит отметить, что клиент может опубликовать refunding transaction в любое время работы канала и установить любую сумму перевода в пределах одного биткоина (сумма, на которую канал был открыт). Если refunding transaction публикуется в mainchain и время, которое установлено в поле locktime, наступило, транзакция может быть подтверждена. Поэтому сервис постоянно следит за появлением refunding transaction в сети и, если обнаруживает ее, разрывает договор с клиентом (закрывает канал) досрочно (раньше времени, заданного в locktime), публикуя последнюю версию транзакции 3. Так сервис может быть уверен, что клиент не сможет его обмануть и украсть деньги.

### Применение платежных каналов

Существует два варианта применения платежных каналов: либо в чистом виде для осуществления регулярных платежей между заранее установленными сторонами, либо формирование Lightning Network за счет коммутации каналов между собой.

Коммутация означает возможность проведения платежа между пользователями, которые не открыли платежный канал друг с другом, но имеют открытые каналы с другими узлами сети. Тогда монеты будут передаваться через цепочку каналов незнакомых пользователей, если такая существует.

В случае Lightning Network есть дополнительные сложности и особенности. Это выработка общепринятого формата коммутации каналов и протокола общения узлов. Также важно, чтобы кошельки от одних разработчиков могли работать с кошельками от других. Еще одной сложностью является вопрос маршрутизации в этой сети: нужно найти наиболее короткий путь передачи ценности с учетом того, что в каждом канале есть ограничения на сумму перевода по каждому из направлений.

### Особенности работы сети Bitcoin и Lightning Network

В сети Bitcoin узлы обмениваются данными о транзакциях и блоках, а также сетевыми адресами друг друга. При этом достигается консенсус и формируется общая база данных.

Lightning Network подразумевает надежную маршрутизацию платежа от отправителя к получателю через множество двунаправленных платежных каналов, которые открыты, в том числе, между посторонними участниками, которые не знакомы с отправителем и получателем этого платежа. Узлы Lightning Network не обмениваются готовыми (соответствует протоколу и может быть подтверждена валидаторами) транзакциями и не достигают консенсуса. Поэтому каждый узел этой сети должен либо напрямую получать актуальные данные о своих транзакциях от узлов сети Bitcoin, либо от доверенных источников.

Идея Lightning Network начала формироваться вместе с появлением платежных каналов в Биткоине [73]. Примерно тогда же, когда было предложено использование платежных каналов, разработчики *Bitcoin Core* Питер Тодд (Peter Todd) и Гэвин Андресен (Gavin Andresen) начали рассматривать создание платежных сетей поверх основной учетной системы. Однако только в 2015 году мир увидел работу под названием «The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments» [72].

На момент публикации whitepaper LN описанная идея была несовместимой с текущей версией Bitcoin. Поэтому потребовались некоторые изменения в протоколе. Первыми изменениями стали добавления операций OP_CHECKLOCKTIMEVERIFY и OP_CHECKSEQUENCEVERIFY, которые позволяли блокировать монеты на некоторое время. Также необходимым стало обновление SegWit, активированное летом 2017 года (см. 4.6). Официально альфа-стадия LN началась в январе 2017 года [76]; тогда же вышла первая полная реализация LN [77; 112].

Как упоминалось ранее, летом 2017 года было выпущено обновление SegWit, которое легло в основу для внедрения LN. Спустя три месяца Blockstream объявила о первой успешной транзакции при помощи LN [114]. В ноябре был совершен первый перевод монет между учетными системами Bitcoin и Litecoin. А в декабре ведущие команды, такие как Blockstream, Lightning Labs и ASINQ, объявили о полной совместимости между их реализациями.

На рис. 4.66 ребрами обозначены сетевые соединения между узлами сетей, и стрелочками – их взаимодействие для актуализации состояний. Также узлам Lightning Network необходимо обновлять информацию о состоянии друг друга и обмениваться сообщениями для поддержания работы платежных каналов.

![Рисунок 4.66 – Обмен сообщениями между сетью Bitcoin и Lightning Network](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.66-message-exchanging.png)

### Как работает Lightning Network?

Для понимания базовой идеи LN приведем следующий пример. Предположим, в городе есть продуктовый магазин, который позволяет своим клиентам платить за товары при помощи биткоинов. Более того, этот магазин предоставляет постоянным покупателям возможность открытия двустороннего платежного канала для экономии на комиссии и времени подтверждения оплаты. Предположим, что Алиса и Боб являются постоянными покупателями и имеют открытые каналы с магазином.

Идея LN состоит в том, что Алиса и Боб могут не только осуществлять платежи стороне, с которой они непосредственно открыли канал (в нашем случае это магазин с продуктами), но также могут передавать монеты друг другу, используя магазин в качестве посредника. Важная особенность такого взаимодействия – отсутствие у клиента необходимости доверять посреднику (на практике часто количество таких посредников больше одного).

Как мы описывали ранее, реализация платежных каналов разработана таким образом, что позволяет предотвратить мошенническое поведение в корне (попытка украсть монеты у взаимодействующей стороны может привести к потере всех своих средств в канале). Функционирование Lightning Network использует те же принципы. Посредники, которые передают ваши деньги, на уровне протокола лишены возможности их украсть. Это и делает платежи в Lightning Network атомарными – передача монет происходит либо полностью успешно, либо не происходит вообще. Основой для такого trustless взаимодействия стало использование механизма locktime в протоколе LN (более подробно мы рассмотрим это в следующей части книги).

Теперь для лучшего понимания работы LN рассмотрим пример (рис. 4.67), который показывает, как монеты переходят от Алисы к Бобу, причем у них нет открытого платежного канала между собой непосредственно.

![Рисунок 4.67 – Расположение узлов Lightning Network в примере](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.67-simplified-example.png)

На рисунке выше схематически представлена небольшая сеть из шести пользователей, у каждого из которых есть узел. На практике таких узлов могут быть сотни. Предположим, что Алисе необходимо переслать Бобу 2 BTC. В таком случае программное обеспечение ее узла должно найти наиболее оптимальный путь для передачи монет. Поскольку узлы в сети постоянно синхронизируются между собой, узел Алисы знает необходимую информацию о других открытых каналах (количество монет в каналах, время, на которое открыт определенный канал и т. д.).

Программное обеспечение узла Алисы определяет пути, по которым можно передать 2 BTC Бобу. В канале Алиса–Кен состояние балансов – 6|10. Это значит, что у Алисы есть 6 BTC, а у Кена – 10 BTC в рамках платежного канала, то есть перевод возможен. В канале Кен–Дэйв состояние балансов – 1|4, а значит, цельный перевод в 2 BTC невозможен через этот канал. Заметим, что если бы в канале Кен–Дэн состояние балансов было противоположным, а именно 4|1, то перевод был бы возможен.

![Рисунок 4.68 – Отправка платежа от Алисы к Бобу](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.68-sending-the-payment.png)

Есть и другой путь. В канале Алиса–Ева состояние – 17|43, а значит, платеж возможно провести. В канале Ева–Дэйв на балансе Евы находится 4 BTC, а на балансе Дэйва – 1 BTC. И в этом случае платеж может быть свободно проведен (да, у Дэйва всего лишь 1 BTC на балансе, но возможность передачи платежа полностью зависит от баланса стороны-отправителя в платежном канале, а в этом случае – от баланса Евы). Чтобы закончить перевод, платеж должен пройти по каналу Дэйв–Боб. Балансы на этом канале равны 17|15, а значит, платеж пройдет без проблем. В итоге, для передачи монет Бобу одним платежом в 2 BTC Алиса может использовать верхний путь и двух посредников. На рисунке 4.69 показано, как изменилось состояние балансов в платежных каналах после перевода.

![Рисунок 4.69 – Изменение состояний платежных каналов после проведения платежа](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.69-state-of-channels.png)

На самом деле в этой ситуации возможен и другой способ отправки платежа в 2 BTC от Алисы к Бобу. Для этого Алисе необходимо разделить платеж на две части по 1 BTC и отправить их разными путями (1 BTC через Еву и Дэйва, и 1 BTC через Кена и Дэна), как показано на рисунке 4.70.

![Рисунок 4.70 – Отправление платежа при помощи двух путей](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.70-sending-the-same-payment.png)

На рисунке 4.71 вы можете увидеть, как изменится состояние балансов в платежных каналах после проведения платежа таким способом (если Алиса делит монеты и отправляет их разными путями).

![Рисунок 4.71 – Изменение состояний каналов после проведения платежа](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.71-end-state.png)

На практике, количество узлов-посредников и возможных путей может быть гораздо большим. Более того, LN, как и сеть Bitcoin, неоднородна. Это значит, что в сети присутствуют узлы с большей и меньшей нагрузкой, а также узлы с непостоянной активностью. На рисунке 4.72 вы можете увидеть актуальное состояние LN в декабре 2018 года [78].

> **Статистика Lightning Network в 2018 году**
>> * *Около 4 500 узлов*
>> * *В среднем около 14 000 открытых каналов*
>> * *479,70 BTC заблокировано в Bitcoin (используются в LN)*

![Рисунок 4.72 – Состояние LN на конец 2018 года](/resources/img/volume-1/4.8-payment-channels-and-lightning-network/4.72-state-of-ln.png)

Для открытия каждого платежного канала нужно заморозить определенное количество монет. Прием и отправка платежей в каналах возможны только в рамках ограниченной суммы. Если обычный пользователь разделит свои монеты на несколько частей и откроет несколько каналов, то он получит очень малое окно для платежа в каждом из каналов по сравнению с изначальной суммой. В то же время, хабами будут выступать крупные организации, например, разработчики кошельков, централизованные биржи или популярные мерчанты. Они могут себе позволить поддержание большого числа каналов, открытых на крупные суммы и продолжительные промежутки времени, не уходя в офлайн. Обычные же пользователи будут открывать в лучшем случае один или два платежных канала с одним из таких хабов.

Исходя из вышеописанного, давайте определим основные функции узлов LN.

> * *Маршрутизация*
> * *Открытие каналов*
> * *Проведение платежей между другими узлами*
> * *Закрытие каналов*

Маршрутизация – одна из сложнейших функций узлов LN. Каждый узел LN занимается расчетом оптимального пути следования платежа и ему необходимо учитывать для этого многие факторы, такие как пропускная способность определенного канала, сумма, на которую он открыт, как эти параметры могут измениться после прохождения платежа в сети и что делать, если некоторые каналы внезапно закроются.

Также каждый  узел сети должен заботиться о наличии каналов с другими узлами. Некоторые каналы являются особенно важными для сети в целом и их потеря может привести как к нарушению функционирования так и к разрыву сети. Во избежание подобной ситуации каждому узлу рекомендуется поддерживать связи с наибольшим возможным количеством других узлов.

Пожалуй, первостепенной функцией узлов сети является как раз проведение платежей. Размер и количество платежей, которые способен провести узел всецело зависят от ширины каналов, которые были открыты этим узлом.

Наконец, на узлах лежит функция закрытия платежных каналов. В LN существует несколько так называемых доминантных узлов (с огромным количеством открытых каналов). Такие узлы могут в некотором роде манипулировать движением средств путем открытия и закрытия своих платежных каналов. Такую проблему тоже можно решить путем увеличения количества каналов между всеми узлами LN, однако такой подход довольно дорого обойдется их владельцам (комиссии за открытие и закрытие каналов и средства, которые будет заморожены для функционирования каждого из каналов).

**Часто задаваемые вопросы**

*– Насколько платежи в каналах надежны по сравнению с обычными bitcoin-транзакциями?*

По надежности платежи в каналах можно сравнить с обычными, т. е. монеты не отберут, а платеж не отменят. Но существует ряд особенностей вроде необходимости своевременного открытия и закрытия каналов, ограничения на сумму внутри канала, необходимости постоянной синхронизации с Биткоин сетью, вероятности заморозки монет на некоторое время.

*– Ограничена ли пропускная способность в каналах и Lightning Network?*

Дело в том, что ограничения никакого нет, но могут быть задержки, связанные с обработкой данных канала, разведкой сети и построением маршрута, которые зависят от производительности конкретных узлов сети. Следует также учесть, что узлы могут непредсказуемо становиться офлайн, а это может повлечь определенные ограничения в осуществлении платежей другими участниками.

*– Должны ли участники канала доверять друг другу?*

Нет, механизм платежных каналов предусматривает защиту от злонамеренных действий взаимодействующих сторон в рамках протокола.

*– Какая польза от каналов человеку, который хочет отправить только один платеж?*

Если человек хочет избавиться от последних монет и больше не планирует принимать и отправлять платежи, то ему следует не открывать канал, а отправить обычную, on-chain транзакцию. Во всех остальных случаях открытие канала будет полезным, например, позволит уменьшить комиссию и сократить время подтверждения транзакции.

*– В чем состоит отличие sidechains от платежных каналов?*

*Sidechain* представляет собой отдельную цепочку блоков, которая учитывает монеты из mainchain. Правила работы в нем могут отличаться от правил в mainchain и определяться новым протоколом. Sidechain не имеет базовой валюты, но реализует механизм перевода монет из основной цепочки блоков. В то же время платежный канал не является отдельной цепочкой блоков и не реализует перевод монет из mainchain. Он просто представляет собой метод проведения множества платежей без обработки транзакций валидаторами. Точнее, валидаторы подтверждают только две транзакции для каждого платежного канала: открывающую и закрывающую.

*– По каким критериям происходит валидация транзакций в рамках платежного канала в Bitcoin?*

Участник канала просто проверяет корректность цепочки off-chain транзакций. По сути, ему нужно убедиться в том, что он гарантированно получит свои монеты из канала, если опубликует нужные транзакции из этой цепочки. Участник самостоятельно решает, считать ли эти off-chain транзакции правильными или нет. Кроме того, это решение зависит от текущего состояния учетной системы, над которой работает платежный канал, то есть от on-chain транзакций.

*– Фиксируется ли история транзакций при использовании платежного канала? Можно ли скрыть транзакцию от сторонних наблюдателей, «спрятав» ее в платежный канал?*

История транзакций не фиксируется в открытой распределенной базе данных; ее фиксируют только участники платежного канала. В общем случае остальные пользователи не могут ни подтвердить, ни опровергнуть подозрения касательно факта проведения платежа или суммы платежа внутри канала. Они могут видеть только закрывающую транзакцию и ее сумму, то есть разницу между состоянием базы данных до открытия канала и таковым после закрытия канала.
Если по закрытии платежного канала его участники уничтожат все промежуточные данные, детали их взаимодействия никогда не будут раскрыты. Это справедливо только для отдельного платежного канала, в котором обычно взаимодействуют два участника. Отметим, что Lightning Network работает с множеством платежных каналов и множеством участников-посредников – в этой сети уровень конфиденциальности off-chain транзакций гораздо ниже.

*– Дорого и затратно ли содержать свой узел lightning network? Получают ли владельцы узлов доход?*

Узел lightning network сравним с полным узлом сети Bitcoin по потреблению ресурсов во всех аспектах, кроме дискового пространства, тут он потребляет гораздо меньше. Но стоит отметить, что узел lightning network не может работать без актуального состояния самого Bitcoin, поэтому чаще всего пользователи поддерживают работу одновременно обоих узлов. Для получения дохода в lightning network нужно открыть платежные каналы и установить конкурентоспособную комиссию за прохождение платежей через них. Причем открыть каналы с такими узлами, чтобы платежи остальных пользователей достаточно часто маршрутизировались через получившиеся каналы.

[ТЕХНОЛОГИЯ BLOCKCHAIN](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-1/ru/5-blockchain-technology.md)    