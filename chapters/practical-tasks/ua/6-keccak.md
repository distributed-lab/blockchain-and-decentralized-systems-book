# 6. –ê–ª–≥–æ—Ä–∏—Ç–º Keccak
Keccak (SHA-3) ‚Äì –∞–ª–≥–æ—Ä–∏—Ç–º –≥–µ—à—É–≤–∞–Ω–Ω—è –∑–º—ñ–Ω–Ω–æ—ó —Ä–æ–∑—Ä—è–¥–Ω–æ—Å—Ç—ñ. –ì–µ—à-—Ñ—É–Ω–∫—Ü—ñ—è –ø–æ–±—É–¥–æ–≤–∞–Ω–∞ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—ó –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ—ñ—á–Ω–æ—ó 
–≥—É–±–∫–∏, –≤ —è–∫—ñ–π –¥–∞–Ω—ñ —Å–ø–æ—á–∞—Ç–∫—É –≤–±–∏—Ä–∞—é—Ç—å—Å—è –≤ –≥—É–±–∫—É, –ø—Ä–∏ —Ü—å–æ–º—É –≤–∏—Ö—ñ–¥–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è M –∑–∞–∑–Ω–∞—î –±–∞–≥–∞—Ç–æ—Ä–∞—É–Ω–¥–æ–≤–∏—Ö –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫ f, 
–∞ –ø–æ—Ç—ñ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç Z ¬´–≤—ñ–¥–∂–∏–º–∞—î—Ç—å—Å—è¬ª –∑ –≥—É–±–∫–∏. –ù–∞ –µ—Ç–∞–ø—ñ ¬´–≤–±–∏—Ä–∞–Ω–Ω—è¬ª –±–ª–æ–∫–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è —Å—É–º—É—é—Ç—å—Å—è –∑–∞ –º–æ–¥—É–ª–µ–º 2 –∑ –ø—ñ–¥–º–Ω–æ–∂–∏–Ω–æ—é 
—Å—Ç–∞–Ω—É, –ø—ñ—Å–ª—è —á–æ–≥–æ –≤–µ—Å—å —Å—Ç–∞–Ω –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î—Ç—å—Å—è –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —Ñ—É–Ω–∫—Ü—ñ—ó –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ f. –ù–∞ –µ—Ç–∞–ø—ñ ¬´–≤—ñ–¥–∂–∏–º–∞–Ω–Ω—è¬ª –≤–∏—Ö—ñ–¥–Ω—ñ –±–ª–æ–∫–∏ 
–∑—á–∏—Ç—É—é—Ç—å—Å—è –∑ –æ–¥–Ω–æ–≥–æ —ñ —Ç–æ–≥–æ –∂ –ø—ñ–¥–º–Ω–æ–∂–∏–Ω–∏ —Å—Ç–∞–Ω—É, –∑–º—ñ–Ω–µ–Ω–æ–≥–æ —Ñ—É–Ω–∫—Ü—ñ—î—é –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫ f.

–û—Å–Ω–æ–≤–æ—é —Ñ—É–Ω–∫—Ü—ñ—ó —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è –∞–ª–≥–æ—Ä–∏—Ç–º—É —î —Ñ—É–Ω–∫—Ü—ñ—è f, —â–æ –≤–∏–∫–æ–Ω—É—î –ø–µ—Ä–µ–º—ñ—à—É–≤–∞–Ω–Ω—è –≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ–≥–æ —Å—Ç–∞–Ω—É –∞–ª–≥–æ—Ä–∏—Ç–º—É. –°—Ç–∞–Ω A 
–ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—î—Ç—å—Å—è —É –≤–∏–≥–ª—è–¥—ñ –º–∞—Å–∏–≤—É 5√ó5, –µ–ª–µ–º–µ–Ω—Ç–∞–º–∏ —è–∫–æ–≥–æ —î 64-–±—ñ—Ç–æ–≤—ñ —Å–ª–æ–≤–∞, —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω—ñ –Ω—É–ª—å–æ–≤–∏–º–∏ –±—ñ—Ç–∞–º–∏ (—Ç–æ–±—Ç–æ —Ä–æ–∑–º—ñ—Ä 
—Å—Ç–∞–Ω—É —Å—Ç–∞–Ω–æ–≤–∏—Ç—å 1600 –±—ñ—Ç—ñ–≤). –§—É–Ω–∫—Ü—ñ—è f –≤–∏–∫–æ–Ω—É—î 24 —Ä–∞—É–Ω–¥–∏, —É –∫–æ–∂–Ω–æ–º—É –∑ —è–∫–∏—Ö –≤–∏—Ä–æ–±–ª—è—é—Ç—å—Å—è –ø–æ–∫—Ä–æ–∫–æ–≤—ñ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è Œ∏, œÅ, œÄ, 
œá, Œπ.

–ù–∞ –ø–æ—á–∞—Ç–∫—É –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è padding (–∑–∞–ø–æ–≤–Ω–µ–Ω–Ω—è/–¥–æ–¥–∞–≤–∞–Ω–Ω—è). Padding –Ω–µ–æ–±—Ö—ñ–¥–Ω–∏–π –¥–ª—è –ø—Ä–∏–≤–µ–¥–µ–Ω–Ω—è –≤–∏—Ö—ñ–¥–Ω–æ–≥–æ 
–ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –¥–æ —Ä—è–¥–∫–∞ —Ñ—ñ–∫—Å–æ–≤–∞–Ω–æ—ó –¥–æ–≤–∂–∏–Ω–∏. –ü–æ—Ç—ñ–º –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è —Ñ—É–Ω–∫—Ü—ñ—è ¬´Absorb¬ª. –¶—è —Ñ—É–Ω–∫—Ü—ñ—è –ø—Ä–∏–∑–Ω–∞—á–µ–Ω–∞ –¥–ª—è —Ä–æ–∑–±–∏—Ç—Ç—è 
–≤—Ö—ñ–¥–Ω–æ–≥–æ (—â–æ –ø—Ä–æ–π—à–ª–∞ —á–µ—Ä–µ–∑ padding) —Ä—è–¥–∫–∏ –Ω–∞ —Å–∫–ª–∞–¥–æ–≤—ñ, —è–∫—ñ –±—É–¥—É—Ç—å –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏—Å—è –¥–ª—è –Ω–∞—Å—Ç—É–ø–Ω–∏—Ö 
–ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω—å:
- Œ∏ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è; 
- œÅ —ñ œÄ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è; 
- œá –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è; 
- Œπ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è. 
- –ü—ñ—Å–ª—è —Ü—å–æ–≥–æ –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –ø—Ä–æ—Ü–µ–¥—É—Ä–∞ Squeezing (—Å—Ç–∏—Å–Ω–µ–Ω–Ω—è / –≤–∏–¥–∞–≤–ª—é–≤–∞–Ω–Ω—è). –¶—è –ø—Ä–æ—Ü–µ–¥—É—Ä–∞ –Ω–µ–æ–±—Ö—ñ–¥–Ω–∞ –¥–ª—è –æ–±—á–∏—Å–ª–µ–Ω–Ω—è 
- –∫—ñ–Ω—Ü–µ–≤–æ–≥–æ –≥–µ—à-–∑–Ω–∞—á–µ–Ω–Ω—è.

```
Pseudo-code:

Keccak[r,c](Mbytes || Mbits) {
  # Padding
  d = 2^|Mbits| + sum for i=0..|Mbits|-1 of 2^i*Mbits[i]
  P = Mbytes || d || 0x00 || ‚Ä¶ || 0x00
  P = P xor (0x00 || ‚Ä¶ || 0x00 || 0x80)

  # Initialization
  S[x,y] = 0,                               for (x,y) in (0‚Ä¶4,0‚Ä¶4)

  # Absorbing phase
  for each block Pi in P
    S[x,y] = S[x,y] xor Pi[x+5*y],          for (x,y) such that x+5*y < r/w
    S = Keccak-f[r+c](S)

  # Squeezing phase
  Z = empty string
  while output is requested
    Z = Z || S[x,y],                        for (x,y) such that x+5*y < r/w
    S = Keccak-f[r+c](S)

  return Z
}
```

–ü–æ—Å—Ç—ñ–π–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –¥–ª—è RC[i]:

```
RC[0]		0x0000000000000001		RC[12]		0x000000008000808B
RC[1]		0x0000000000008082		RC[13]		0x800000000000008B
RC[2]		0x800000000000808A		RC[14]		0x8000000000008089
RC[3]		0x8000000080008000		RC[15]		0x8000000000008003
RC[4]		0x000000000000808B		RC[16]		0x8000000000008002
RC[5]		0x0000000080000001		RC[17]		0x8000000000000080
RC[6]		0x8000000080008081		RC[18]		0x000000000000800A
RC[7]		0x8000000000008009		RC[19]		0x800000008000000A
RC[8]		0x000000000000008A		RC[20]		0x8000000080008081
RC[9]		0x0000000000000088		RC[21]		0x8000000000008080
RC[10]		0x0000000080008009		RC[22]		0x0000000080000001
RC[11] 		0x000000008000000A		RC[23]		0x8000000080008008
```
```
Pseudo-code of Keccak-f:

Keccak-f[b](A) {
    for i in 0‚Ä¶n-1   				// n=24
        A = Round[b](A, RC[i])
        return A
}

Round[b](A,RC) {
    # Œ∏ step
    C[x] = A[x,0] xor A[x,1] xor A[x,2] xor A[x,3] xor A[x,4],   	for x in 0‚Ä¶4
    D[x] = C[x-1] xor rot(C[x+1],1),                             	for x in 0‚Ä¶4
    A[x,y] = A[x,y] xor D[x],                           		    for (x,y) in (0‚Ä¶4,0‚Ä¶4)

    # œÅ and œÄ steps
    B[y,2*x+3*y] = rot(A[x,y], r[x,y]),                 		    for (x,y) in (0‚Ä¶4,0‚Ä¶4)

    # œá step
    A[x,y] = B[x,y] xor ((not B[x+1,y]) and B[x+2,y]),  		    for (x,y) in (0‚Ä¶4,0‚Ä¶4)

    # Œπ step
    A[0,0] = A[0,0] xor RC

    return A
}
```
–ü–æ—Å—Ç—ñ–π–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è r[x,y]:

![–ü–æ—Å—Ç—ñ–π–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è r[x,y]](/resources/img/practical-volume/6/1-keccak.png)

–°–∞–º —Ç–µ–∫—Å—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç—É —Ç–∞ —Ç–µ—Å—Ç–æ–≤—ñ –≤–µ–∫—Ç–æ—Ä–∏ –≤–∏ –º–æ–∂–µ—Ç–µ –∑–Ω–∞–π—Ç–∏ –∑–∞ –Ω–∞—Å—Ç—É–ø–Ω–∏–º –ø–æ—Å–∏–ª–∞–Ω–Ω—è–º:
https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf

‚úØ –°–ø—Ä–æ–±—É–π—Ç–µ —Ä–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –∞–ª–≥–æ—Ä–∏—Ç–º Keccak, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ –º–∞—Ç–µ—Ä—ñ–∞–ª —Ü—å–æ–≥–æ —Ä–æ–∑–¥—ñ–ª—É

–ú–∏—Ö–∞–π–ª–æ –Ω–∞–≥–æ–ª–æ—à—É—î –Ω–∞ –Ω–∞—Å—Ç—É–ø–Ω—ñ–π —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó

ü§ñ

```go
package main
import (
    "encoding/binary"
    "fmt"
)
// –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏ Keccak
const (
    rate    = 136
    capacity = 256
    hashSize = capacity / 8
)
// Keccak-256 –≥–µ—à-—Ñ—É–Ω–∫—Ü—ñ—è
func Keccak256(input []byte) []byte {
    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –∑–º—ñ–Ω–Ω–∏—Ö
    state := [5][5]uint64{}
// –û–±—Ä–æ–±–∫–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –±–ª–æ–∫–∞–º–∏
    for len(input) > 0 {
        var block []byte
        if len(input) >= rate/8 {
            block = input[0 : rate/8]
            input = input[rate/8:]
        } else {
            block = make([]byte, rate/8)
            copy(block, input)
            block[len(input)] = 0x01
            input = input[len(input):]
        }

// –î–æ–¥–∞–≤–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö –¥–æ —Å—Ç–∞–Ω—É
        addBlockToState(&state, block)

// –û–ø–µ—Ä–∞—Ü—ñ—ó –Ω–∞ —Å—Ç–∞–Ω—ñ
        keccakF(&state)
    }

// –í–∏–≤–µ–¥–µ–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
    output := make([]byte, hashSize)
    binary.LittleEndian.PutUint64(output[0:8], state[0][0])
    binary.LittleEndian.PutUint64(output[8:16], state[1][0])
    binary.LittleEndian.PutUint64(output[16:24], state[2][0])
    binary.LittleEndian.PutUint64(output[24:32], state[3][0])
    binary.LittleEndian.PutUint64(output[32:40], state[4][0])

    return output
}
// –î–æ–¥–∞–≤–∞–Ω–Ω—è –±–ª–æ–∫—É –¥–∞–Ω–∏—Ö –¥–æ —Å—Ç–∞–Ω—É
func addBlockToState(state *[5][5]uint64, block []byte) {
    for i := 0; i < len(block); i += 8 {
        index := i / 8
        state[index%5][index/5] ^= binary.LittleEndian.Uint64(block[i : i+8])
    }
}
// –û–ø–µ—Ä–∞—Ü—ñ—ó –Ω–∞–¥ —Å—Ç–∞–Ω–æ–º
func keccakF(state *[5][5]uint64) {
    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –∑–º—ñ–Ω–Ω–∏—Ö
    C := [5]uint64{}
    D := [5]uint64{}
    B := [5][5]uint64{}
// –ö—Ä–æ–∫ 1
    for x := 0; x < 5; x++ {
        C[x] = state[x][0] ^ state[x][1] ^ state[x][2] ^ state[x][3] ^ state[x][4]
    }
// –ö—Ä–æ–∫ 2
    for x := 0; x < 5; x++ {
        D[x] = C[(x+4)%5] ^ leftRotate(C[(x+1)%5], 1)
    }
// –ö—Ä–æ–∫ 3
    for x := 0; x < 5; x++ {
        for y := 0; y < 5; y++ {
            B[x][y] = state[x][y] ^ D[x]
}
// –ö—Ä–æ–∫ 4
var T [25]uint64
for x := 0; x < 5; x++ {
    for y := 0; y < 5; y++ {
        T[x+(y*5)] = B[x][y]
    }
}
// –ö—Ä–æ–∫ 5
for x := 0; x < 5; x++ {
    for y := 0; y < 5; y++ {
        state[x][y] = T[x+(y*5)] ^ ((^T[((x+1)%5)+(y*5)]) & T[((x+2)%5)+(y*5)])
    }
}
}
// –¶–∏–∫–ª—ñ—á–Ω–∏–π –∑—Å—É–≤ –ª—ñ–≤–æ—Ä—É—á
func leftRotate(n uint64, d uint) uint64 {
return (n << d) | (n >> (64 - d))
}
func main() {
// –ü—Ä–∏–∫–ª–∞–¥ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
data := []byte("The quick brown fox jumps over the lazy dog")
hash := Keccak256(data)
fmt.Printf("%x", hash)
}
```