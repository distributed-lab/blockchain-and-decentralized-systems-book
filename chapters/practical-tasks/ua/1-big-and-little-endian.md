# 1. Big Endian Ñ‚Ð° Little Endian Ð¿Ð¾Ñ€ÑÐ´ÐºÐ¸ Ð±Ð°Ð¹Ñ‚Ñ–Ð²
Ð”Ð»Ñ Ð¾Ð±Ñ‡Ð¸ÑÐ»ÐµÐ½ÑŒ Ð´Ð°Ð½Ñ– Ð·Ð±ÐµÑ€Ñ–Ð³Ð°ÑŽÑ‚ÑŒÑÑ Ñƒ Ð¾ÐºÑ€ÐµÐ¼Ð¸Ñ… ÐºÐ¾Ð¼Ñ–Ñ€ÐºÐ°Ñ…, ÐºÐ¾Ð¶Ð½Ð° Ð·Ð±ÐµÑ€Ñ–Ð³Ð°Ñ” Ð±Ð°Ð¹Ñ‚ (8 Ð±Ñ–Ñ‚Ñ–Ð²). Ð”Ð»Ñ Ð¾ÐºÑ€ÐµÐ¼Ð¾Ð³Ð¾ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ, Ñ‰Ð¾ Ð¿ÐµÑ€ÐµÐ²Ð¸Ñ‰ÑƒÑ” 
8 Ð±Ñ–Ñ‚Ñ–Ð² Ñ” Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ñ–ÑÑ‚ÑŒ Ð·Ð±ÐµÑ€Ñ–Ð³Ð°Ñ‚Ð¸ Ð¹Ð¾Ð³Ð¾ ÑÐº Ð¿Ð¾ÑÐ»Ñ–Ð´Ð¾Ð²Ð½Ñ–ÑÑ‚ÑŒ Ð±Ð°Ð¹Ñ‚Ñ–Ð². ÐŸÑ€Ð¸ Ñ†ÑŒÐ¾Ð¼Ñƒ Ð²Ð°Ð¶Ð»Ð¸Ð²Ð° Ð¿Ð¾ÑÐ»Ñ–Ð´Ð¾Ð²Ð½Ñ–ÑÑ‚ÑŒ, Ð² ÑÐºÑ–Ð¹ Ð¼Ð¸ Ð·Ð±ÐµÑ€Ñ–Ð³Ð°Ñ”Ð¼Ð¾ Ð±Ð°Ð¹Ñ‚Ð¸ 
(Ð·Ð°Ð»ÐµÐ¶Ð¸Ñ‚ÑŒ Ð²Ñ–Ð´ ÑÐ¸ÑÑ‚ÐµÐ¼Ð¸, Ñ‰Ð¾ Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÑ”Ñ‚ÑŒÑÑ). Ð†Ð½Ð¾Ð´Ñ– Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÑ”Ñ‚ÑŒÑÑ Ð·Ð±ÐµÑ€ÐµÐ¶ÐµÐ½Ð½Ñ Ð¼Ð¾Ð»Ð¾Ð´ÑˆÐ¾Ð³Ð¾ Ð±Ð°Ð¹Ñ‚Ð° Ð² Ð¿ÐµÑ€ÑˆÑƒ ÐºÐ¾Ð¼Ñ–Ñ€ÐºÑƒ Ð¿Ð°Ð¼'ÑÑ‚Ñ–, 
Ð° ÑÑ‚Ð°Ñ€ÑˆÐ¸Ð¹ Ð±Ð°Ð¹Ñ‚ Ð² Ð¾ÑÑ‚Ð°Ð½Ð½ÑŽ. Ð†Ð½Ð¾Ð´Ñ– â€“ Ð½Ð°Ð²Ð¿Ð°ÐºÐ¸. Ð£ Ð´Ð°Ð½Ð¾Ð¼Ñƒ Ð²Ð¸Ð¿Ð°Ð´ÐºÑƒ Ð²Ð°Ð¶Ð»Ð¸Ð²Ð¾, ÑÐºÐ¸Ð¼ Ñ‡Ð¸Ð½Ð¾Ð¼ Ð¿ÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÑŽÑ”Ñ‚ÑŒÑÑ ÑˆÑ–ÑÑ‚Ð½Ð°Ð´Ñ†ÑÑ‚ÐºÐ¾Ð²Ðµ (hex) 
Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ Ð½Ð° Ñ†Ñ–Ð»Ðµ Ð±ÐµÐ·Ð·Ð½Ð°ÐºÐ¾Ð²Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ.

![ÐŸÐ¾Ñ€ÑÐ´Ð¾Ðº Ñ€Ð¾Ð·Ñ‚Ð°ÑˆÑƒÐ²Ð°Ð½Ð½Ñ Ð´Ð°Ð½Ð¸Ñ… Ð² Ð¿Ð°Ð¼'ÑÑ‚Ñ–](/resources/img/practical-volume/1/1-bytes.png)

Ð”Ð»Ñ Ñ€Ð¾Ð·ÑƒÐ¼Ñ–Ð½Ð½Ñ Ñ‚Ð¾Ð³Ð¾, ÑÐº Ð²Ñ–Ð´Ð±ÑƒÐ²Ð°ÑŽÑ‚ÑŒÑÑ Ð¿ÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ, Ð¿Ñ€Ð¾Ð¿Ð¾Ð½ÑƒÑ”Ð¼Ð¾ Ð½Ð°Ð¿Ð¸ÑÐ°Ñ‚Ð¸ Ð±Ñ–Ð±Ð»Ñ–Ð¾Ñ‚ÐµÐºÑƒ, Ñ‰Ð¾ Ð´Ð¾Ð·Ð²Ð¾Ð»ÑÑ”:
* ÐŸÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ HEX Ð´Ð¾ Little Endian Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ 
* ÐŸÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ HEX Ð´Ð¾ Big Endian Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ 
* ÐŸÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ Little Endian Ð´Ð¾ HEX Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ 
* ÐŸÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ Big Endian Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ Ð´Ð¾ HEX Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ

Ð¢ÐµÑÑ‚Ð¾Ð²Ñ– Ð²ÐµÐºÑ‚Ð¾Ñ€Ð¸:

```
Vector 1:
    Value: 0xff00000000000000000000000000000000000000000000000000000000000000
    Number of bytes: 32
    Little-endian: 255
    Big-endian: 115339776388732929035197660848497720713218148788040405586178452820382218977280

Vector 2:
    Value: 0xaaaa000000000000000000000000000000000000000000000000000000000000
    Number of bytes: 32
    Little-endian:	43690
    Big-endian:	77193548260167611359494267807458109956502771454495792280332974934474558013440

Vector 3:
    Value: 0xFFFFFFFF
    Number of bytes: 4
    Little-endian:	4294967295
    Big-endian:	4294967295

Vector 4:
    Value: 0xF000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    Number of bytes: 512
    Little-endian:	240
    Big-endian:	979114576324830475023518166296835358668716483481922294110218890578706788723335115795775136189060210944584475044786808910613350098299181506809283832360654948074334665509728123444088990750984735919776315636114949587227798911935355699067813766573049953903257414411690972566828795693861196044813729172123152193769005290826676049325224028303369631812105737593272002471587527915367835952474124875982077070337970837392460768423348044782340688207323630599527945406427226264695390995320400314062984891593411332752703846859640346323687201762934524222363836094053204269986087043470117703336873406636573235808683444836432453459818599293667760149123595668832133083221407128310342064668595954073131257995767262426534143159642539179485013975461689493733866106312135829807129162654188209922755829012304582671671519678313609748646814745057724363462189490278183457296449014163077506949636570237334109910914728582640301294341605533983878368789071427913184794906223657920124153256147359625549743656058746335124502376663710766611046750739680547042183503568549468592703882095207981161012224965829605768300297615939788368703353944514111011011184191740295491255291545096680705534063721012625490368756140460791685877738232879406346334603566914069127957053440
```

âœ¯ Ð¡Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ñ€ÐµÐ°Ð»Ñ–Ð·ÑƒÐ²Ð°Ñ‚Ð¸ Ð¿ÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ HEX Ð½Ð° Big Endian Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ, Ð¿ÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ Little Endian Ð½Ð° HEX 
Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ, Ð¿ÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ BIG Endian Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ Ð² HEX Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ, Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÑŽÑ‡Ð¸ Ð¼Ð°Ñ‚ÐµÑ€Ñ–Ð°Ð» Ñ‚Ð° Ñ‚ÐµÑÑ‚Ð¾Ð²Ñ– Ð²ÐµÐºÑ‚Ð¾Ñ€Ñ–, Ñ‰Ð¾ Ð½Ð°Ð²ÐµÐ´ÐµÐ½Ð¾ Ð² 
Ñ†ÑŒÐ¾Ð¼Ñƒ Ñ€Ð¾Ð·Ð´Ñ–Ð»Ñ–.

ÐÐ°Ñˆ ÑÑ‚ÑƒÐ´ÐµÐ½Ñ‚ Ð·Ñ– ÑˆÑ‚ÑƒÑ‡Ð½Ð¸Ð¼ Ñ–Ð½Ñ‚ÐµÐ»ÐµÐºÑ‚Ð¾Ð¼ Ð¿Ñ€Ð¾Ð¿Ð¾Ð½ÑƒÑ” Ð²Ð°Ð¼ Ð¾Ð·Ð½Ð°Ð¹Ð¾Ð¼Ð¸Ñ‚Ð¸ÑÑ Ð· Ð¹Ð¾Ð³Ð¾ Ñ€ÐµÐ°Ð»Ñ–Ð·Ð°Ñ†Ñ–Ñ”ÑŽ Ð·Ð°Ð²Ð´Ð°Ð½Ð½Ñ Ð¿ÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ HEX Ð² 
Little Endian Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ

ðŸ¤–

This implementation takes a hex string as input, converts it to Little Endian byte representation, and then converts 
it to a uint64 value using the littleEndianToUint64() function. The reverseBytes() function is used to reverse the 
order of bytes

```go
//The function of converting a HEX string into a binary array:
func hexToBytes(str string) []byte {
    b, _ := hex.DecodeString(str)
    return b
}

//The function of converting a binary array into Little Endian format:
func littleEndian(b []byte) []byte {
    var le []byte
    for i := len(b) - 1; i >= 0; i-- {
        le = append(le, b[i])
    }
    return le
}
//Combining functions into one that accepts a HEX string and returns its representation in //Little Endian format:
func hexToLittleEndian(str string) []byte {
    b := hexToBytes(str)
    le := littleEndian(b)
    return le
}
//Adding test vectors and checking the correct operation of the function:
func main() {
    // Vector 1
    str1 := "ff00000000000000000000000000000000000000000000000000000000000000"
    le1 := hexToLittleEndian(str1)
    fmt.Printf("Value: %s\n", str1)
    fmt.Printf("Number of bytes: %d\n", len(le1))
    fmt.Printf("Little-endian: %d\n", new(big.Int).SetBytes(le1).Int64())
    fmt.Printf("Big-endian: %s\n\n", new(big.Int).SetBytes(b).String())

    // Vector 2
    str2 := "aaaa000000000000000000000000000000000000000000000000000000000000"
    le2 := hexToLittleEndian(str2)
    fmt.Printf("Value: %s\n", str2)
    fmt.Printf("Number of bytes: %d\n", len(le2))
    fmt.Printf("Little-endian: %d\n", new(big.Int).SetBytes(le2).Int64())
    fmt.Printf("Big-endian: %s\n\n", new(big.Int).SetBytes(b).String())

    // Vector 3
    str3 := "ffffffff"
    le3 := hexToLittleEndian(str3)
    fmt.Printf("Value: %s\n", str3)
    fmt.Printf("Number of bytes: %d\n", len(le3))
    fmt.Printf("Little-endian: %d\n", new(big.Int).SetBytes(le3).Int64())
    fmt.Printf("Big-endian: %s\n\n", new(big.Int).SetBytes(b).String())

    // Vector 4
    str4 := strings.Repeat("f0", 256)
    le4 := hexToLittleEndian(str4)
    fmt.Printf("Value: %s\n", str4)
    fmt.Printf("Number of bytes: %d\n", len(le4))
    fmt.Printf("Little-endian: %d\n", new(big.Int).SetBytes(le4).Int64())

//Here's the completed implementation for the Little Endian conversion and the test vectors:
package main
import (
	"encoding/hex"
	"fmt"
)
func hexToLittleEndian(hexStr string) []byte {
	hexBytes, _ := hex.DecodeString(hexStr)

	reversed := make([]byte, len(hexBytes))
	for i := range hexBytes {
		reversed[len(hexBytes)-1-i] = hexBytes[i]
	}
	return reversed
}
func littleEndianToUint64(littleEndian []byte) uint64 {
	var value uint64
	for i, b := range littleEndian {
		value |= uint64(b) << uint(i*8)
	}
	return value
}
func main() {
	testVectors := []struct {
		hexValue        string
		littleEndianHex string
	}{
		{
			hexValue:        "ff00000000000000000000000000000000000000000000000000000000000000",
			littleEndianHex: "ff00000000000000000000000000000000000000000000000000000000000000",
		},
		{
			hexValue:        "aaaa000000000000000000000000000000000000000000000000000000000000",
			littleEndianHex: "aaaa000000000000000000000000000000000000000000000000000000000000",
		},
		{
			hexValue:        "FFFFFFFF",
			littleEndianHex: "FFFFFFFF",
		},
		{
			hexValue:        "F000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
			littleEndianHex: "F0",
		},
	}

	for _, vector := range testVectors {
		littleEndian := hexToLittleEndian(vector.hexValue)
		uint64Value := littleEndianToUint64(littleEndian)
		fmt.Printf("Value: %s\nLittle-endian: %d\nBig-endian: %d\n", vector.hexValue, uint64Value, littleEndianToUint64(reverseBytes(littleEndian)))
	}
}
func reverseBytes(input []byte) []byte {
	for i := 0; i < len(input)/2; i++ {
		j := len(input) - 1 - i
		input[i], input[j] = input[j], input[i]
	}
	return input
}
```

ÐŸÐ¾ÑÐ¸Ð»Ð°Ð½Ð½Ñ Ð½Ð° Ñ€ÐµÐ¿Ð¾Ð·Ð¸Ñ‚Ð¾Ñ€Ñ–Ð¹ Ð· Ñ€ÐµÐ°Ð»Ñ–Ð·Ð°Ñ†Ñ–Ñ”ÑŽ Ð¿ÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ HEX Ð² Little Endian Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ: