# Cryptographic Algorithms
-> In the third chapter of the first part of the textbook "Blockchain and Decentralized Systems", without going
into details, we introduced readers to cryptography as a science, its tasks, and basic mechanisms [...].

Here we want to focus on certain cryptographic primitives. Writing cryptographic algorithms is a complex  but
important task that will allow us to gain a practical understanding of how basic security services are provided in
information systems.

The task will be to understand and implement the proposed algorithms. We will sequentially consider well-known
encryption, hashing, and digital signature algorithms.

# 3. VigenÃ¨re Cipher
The Vigenere cipher uses a simple form of polyalphabetic substitution. A polyalphabetic cipher is any cipher that
is based on substitution using multiple displacement alphabets. The encryption of the plaintext is carried out 
using the Vigenere table. The table consists of alphabets (arrays of characters) written out 26 times in different
rows (for the English alphabet), each alphabet cyclically shifted to the left compared to the previous alphabet.

![VigenÃ¨re Table](/resources/img/practical-volume/3/1-viginer.png)

The encryption is performed as follows:

***Ci = (Pi + Kj) mod 26,***

where ***Kj*** â€“ j-th letter of the key,
***Pi*** â€“ is the i-th letter of the original message, and
***Ci*** â€“ is the i-th letter of the ciphertext.

```
Pseudo-code:

m <-- length of key
for index, character in plaintext:
ciphertext[index] <-- (character + key[index % m]) % 26

return ciphertext
```

You can check the correctness of your Vigenere cipher version on the same vectors (used to test your program) at
the following link: https://cryptii.com/pipes/vigenere-cipher.

The Vigenere cipher is a more advanced version of the Caesar cipher (which uses monoalphabetic substitution). You 
can implement the Caesar cipher instead of the Vigenere cipher. For a description of the algorithm and the ability
to compare your algorithm with reference values, you can use the following source: https://www.dcode.fr/caesar-cipher.

One possible implementation from the AI may look like this:

ðŸ¤–

```go
package main
import "fmt"
func main() {
message := "HELLO WORLD"
key := "SECRETKEY"
encrypted := encrypt(message, key)
fmt.Println("Encrypted message:", encrypted)
decrypted := decrypt(encrypted, key)
fmt.Println("Decrypted message:", decrypted)
}
func encrypt(message, key string) string {
var result string

    for i := 0; i < len(message); i++ {
        char := message[i]
        keyChar := key[i%len(key)]
        result += string((int(char)+int(keyChar))%26 + 'A')
    }
    return result
}
func decrypt(message, key string) string {
var result string
for i := 0; i < len(message); i++ {
char := message[i]
keyChar := key[i%len(key)]
result += string((int(char)-int(keyChar)+26)%26 + 'A')
}
return result
}
```

The encryption function takes a message and a key as input and returns the encrypted message. A for loop is used to
iterate through each character in the message and the corresponding character in the key. The ASCII values of the
two characters are added, taken modulo 26, and then converted to the letter using the character "A" as the starting
point.

The decryption function takes the encrypted message and the key as input and returns the decrypted message.
An analogous loop is used to iterate through each character in the encrypted message and the corresponding 
character in the key. The ASCII value of the key character is subtracted from the ASCII value of the encrypted
character, 26 is added, the result is taken modulo 26, and then converted back to the  letter using the character
"A" as the starting point.

In the main function, we define the message and the key, and then call the encryption function to encrypt the
message using the key. We print the encrypted message, and then call the decryption function to decrypt the
encrypted message using the same key. We print the decrypted message to confirm that the encryption and decryption
were successful.

âœ¯ Try implementing the Caesar cipher yourself. Also, try modifying your code (or the code generated by Mykhailo) so 
that it encrypts and decrypts an arbitrary byte array and accepts an arbitrary byte array as the key. That is, the 
length of the alphabet should not be 26 (the number of letters), but 256 (the number of bytes).