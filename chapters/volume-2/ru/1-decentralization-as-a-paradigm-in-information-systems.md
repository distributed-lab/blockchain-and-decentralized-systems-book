# 1 ДЕЦЕНТРАЛИЗАЦИЯ КАК ПАРАДИГМА В ИНФОРМАЦИОННЫХ СИСТЕМАХ

## 1.1 Пиринговые сети и протокол BitTorrent

Протокол BitTorrent одним из первых показал, каким образом можно децентрализовать файлообменные сервисы. Он работал гораздо быстрее централизованных решений, в которых скорость загрузки ограничивалась производительностью и подключением сервера, и при этом был более устойчив к цензуре. Именно поэтому протокол сыграл одну из ключевых ролей в области децентрализованных технологий, показав, каким образом возможно разделить процесс хранения и передачи данных в системе. Мы рассмотрим основные концепции, которые легли в основу протокола, какие свойства системы они могут обеспечить и как эта технология может развиваться и применяться в системах следующего поколения.

### Традиционная клиент-серверная архитектура

Чтобы понять, как работает BitTorrent, важно рассмотреть работу традиционных (централизованных) файлообменных систем и то, почему такой подход оказывается во многом неэффективным. Для начала стоит ввести три базовых понятия: клиент, сервер и клиент-серверная архитектура. _Клиентом (client)_ является часть аппаратного и/или программного обеспечения (далее – ПО), использующая услуги сервера. _Сервер (server)_ – это программное и/или аппаратное обеспечение, предоставляющее данные другому ПО и/или аппаратным устройствам (то есть клиенту). 

Что же подразумевается под словами «клиент-серверная архитектура»? Если описать функционирование такой архитектуры простым языком, то существуют некоторые серверы, хранящие у себя большие наборы данных. При необходимости клиент обращается к одному из таких серверов с запросом на получение порции данных. Сервер рассматривает запрос клиента и предоставляет (либо не предоставляет) доступ к искомому контенту (рис. 1.1).

<p align="center">
<img src="/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.1-Traditional-client-server-architecture.png" alt="Рисунок 1.1 – Традиционная клиент-серверная архитектура" width="70%"/>
</p>

> **_Замечание._** *В централизованных файлообменных системах роли клиента и сервера строго разграничены и в большинстве случаев не могут пересекаться. Вместе с этим существует ряд ограничений и недостатков таких систем.*

> **Проблемы централизованных систем с клиент-серверной архитектурой**
> * _Подверженность цензуре_
> * _Единая точка отказа_
> * _Ограничение пропускной способности со стороны сервера_
> * _Проблематичное восстановление утерянного набора данных_

Самой большой проблемой является цензурирование контента централизованной стороной (будь то органы власти либо любые другие заинтересованные стороны). Например, во многих странах существует строгая цензура на политические и социальные медиа; вы можете не получить доступ к определенному контенту (фильму, ролику и т. д.), если кто-то, имеющий достаточный уровень политического влияния, решил, что вам это не нужно [1].

Второй и не менее острой проблемой является хранение большого количества данных в едином центре, вероятная атака на который может повлечь за собой если не потерю всех содержащихся на сервере данных, то как минимум блокирование их на неопределенный промежуток времени. Многие сервисы (например, Google) используют предварительное резервирование и дублирование хранимых данных на большом количестве серверов (которые, к тому же, разнесены территориально) [2]. Подобный подход позволяет обезопасить хранимые данные от уничтожения. Однако отметим, что такие меры по карману далеко не каждому сервису, и при этом нужно решить задачу real-time синхронизации данных между серверами. 

Третьим ограничением централизованных сервисов является скорость загрузки данных, которая может зависеть от ряда факторов, таких как тип протокола передачи, пропускная способность сервера, количества активных подключений других клиентов и т. д. 

Так как данные часто хранятся сервером в единственной копии в одном месте, это может сильно снизить общую производительность системы, если множество клиентов обращаются за одним и тем же набором данных.

Также стоит учесть, что некоторый контент может храниться в единственном экземпляре и при отказе сервера (который ранее хранил требуемый контент) и утере контента даже Google не поможет вам его вернуть (рис. 1.2).

<p align="center">
<img src="/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.2-Сontent-becomes-unavailable-when-it-is-lost-by-the-server.png" alt="Рисунок 1.2 – Проблема недоступности контента при его потере на сервере" width="70%"/>
<p>

### Принципы построения одноранговой файлообменной сети

Архитектура одноранговых (пиринговых) файлообменных систем кардинально отличается от традиционных. Каждый узел такой сети одновременно является как сервером, так и клиентом. Каждый из участников сети может заниматься как раздачей файлов другим узлам, так и получением файлов от них (рис. 1.3).

<p align="center">
<img src="/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.3-Principle-of-operation-of-peer-to-peer-file-sharing-system.png" alt="Рисунок 1.3 – Принцип функционирования одноранговой файлообменной системы" width="70%"/>
<p>

Когда ПО узла находит участника сети с требуемым контентом, оно загружает данные непосредственно с этого источника. Когда вы запрашиваете порцию контента, вы являетесь клиентом. Когда же одному из участников необходимо будет получить доступ к данным, которые храните вы, ваше ПО выполнит роль сервера и поделится хранимыми данными.

### История развития BitTorrent

Протокол BitTorrent создал Брэм Коэн (Bram Cohen) в 2001 году [3]. Он сумел решить одну из важнейших задач, которая встала перед обществом с появлением Интернета: надежная передача больших массивов данных в среде с низкой пропускной способностью и периодическим отказом в обслуживании используемых каналов передачи.

Компания BitTorrent была основана в 2004 году. Проект вызвал большой интерес во многих сферах, особенно среди тех, кто занимался нелегальным распространением медиапродукции. Они превратили протокол BitTorrent во второй Napster (сервис обмена mp3-файлами). К большому сожалению, компания BitTorrent не добилась такого успеха, как ее технология. Несколько попыток превращения в медиакомпанию не дали желаемых результатов. Об одном можно сказать довольно точно: протокол BitTorrent стал прорывной технологией, которая показала, как может работать децентрализованная файлообменная система.

В 2019 году протоколом BitTorrent пользуются более 170 миллионов людей: Facebook [4] и Twitter [5] используют BitTorrent для развертывания серверов, Голландский университет  – для обновления рабочих станций [6]. Широкое применение протокола BitTorrent обусловлено тем, что он позволяет обеспечить надежную передачу данных даже в сетях с прерывистым соединением и низкой пропускной способностью.

### Как работает BitTorrent?

Протокол BitTorrent является открытым файлообменным протоколом в одноранговых системах, который предполагает p2p передачу данных между участниками системы и отсутствие центральной серверной стороны.

Для того, чтобы получить доступ к определенному фрагменту данных, участник сети обращается к _трекеру_ – серверу, который отслеживает подключенные к сети компьютеры. Его задачей является предоставление узлам IP-адресов активных участников системы с требуемыми порциями контента. Отметим, что участники никогда не скачивают данные с самого трекера: он занимается только предоставлением необходимых IP-адресов активных узлов.

После получения списка активных узлов пользователь запрашивает у них требуемые фрагменты данных. Отметим, что участник загружает данные небольшими порциями, при этом проверяя их целостность. Это позволяет даже при отключении одного из узлов сохранить отдельные фрагменты требуемого контента и загрузить недостающие фрагменты либо с других источников, либо после восстановления соединения. Таким образом требуемый контент можно получить маленькими частями и с разных источников (рис. 1.4).


<p align="center">
<img src="/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.4-Obtaining-data-fragments-from-system-participants.png" alt="Рисунок 1.4 – Получение фрагментов данных от участников системы" width="60%"/>
<p>

Для достижения большего уровня децентрализации в 2013 году в протокол BitTorrent был добавлен механизм, который реализует DHT (Distributed Hash Table), принцип функционирования которого мы детальнее рассмотрим в подразделе 1.2. Если вкратце, то это улучшение позволило избежать использования централизованных трекеров для поиска узлов, содержащих контент, и сделало взаимодействие узлов более независимым и децентрализованным.

Впрочем, большинству трекеров это обновление пришлось не по нраву, так как оно позволяет устранить всех посредников в децентрализованной файлообменной сети. Для этого трекеры поддержали добавление специального флага в информационную часть торрент-файла. Если пользователь решил убрать этот флаг и использовать DHT, идентификатор торрент-файла менялся полностью. Это разделило пользователей, так как узлы, использующие DHT, не могли получать требуемые файлы от узлов, которые использовали трекеры. Из-за того, что гораздо проще было найти торрент-файлы, использующие трекеры (ведь на этом зарабатывают владельцы медиасайтов), то и в наши дни в приоритете использование централизованных трекеров.

Упомянем, что протоколом BitTorrent предусмотрено поощрение активных участников сети. Чем активнее узел сети участвует в раздаче файлов, тем большей будет его суммарная скорость загрузки. Пользователи, которые практически не участвуют в раздаче файлов (скачивают необходимый контент и уходят с раздачи), напротив, имеют более низкую скорость загрузки контента. Также протокол требует резервировать часть пропускной способности канала, которая не позволяет конкретному узлу заниматься только загрузкой контента, а используется для распространения данных.

Еще одна особенность, предусмотренная в протоколе BitTorrent, – приоритетное распространение редких фрагментов. Например, если одному узлу, который содержит весь набор данных, приходят запросы на получение этого набора, он равномерно распределяет все фрагменты данных между участниками, а не передает каждому из них всю последовательность сначала (рис. 1.5). Эта особенность положительно влияет как на скорость раздачи (узлы, получившие фрагмент, далее сами могут его распространять), так и на распределенность хранения всех фрагментов (чтобы не получилось, что в один момент времени многие узлы хранят только первый из всех фрагментов, и только один узел хранит все остальные фрагменты).

<p align="center">
<img src="/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.5-Arbitrary-transmission-order-of-file-fragments.png" alt="Рисунок 1.5 – Случайный порядок передачи фрагментов файла" width="60%"/>
<p>

### Разделение данных на фрагменты

Многие из читателей знакомы с торрент-файлами (.torrent), однако далеко не каждый знает, как они формируются и что в себе содержат. Ранее мы уже определили, что загрузка контента происходит небольшими порциями (фрагментами). Пришло время рассмотреть, как формируются эти фрагменты и где взять ссылки для их загрузки.

При создании торрент-файла исходные данные разделяются на небольшие порции (размер может варьироваться от 128 KB до 2–4 MB). От каждого полученного фрагмента берется хэш-значение SHA-1, и именно оно помещается в торрент-файл (рис. 1.6) [7].

<p align="center">
<img src="/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.6-Creation-of-a-torrent-file.png" alt="Рис. 1.6 – Создание торрент-файла" width="70%"/>
<p>

> **_Замечание._** *При раздаче большого объема данных размер фрагмента может достигать 32–64 MB.*

Также в торрент-файл помещается ссылка на трекер (либо несколько трекеров) для того, чтобы пользователь, получивший исходный торрент-файл, знал, какой из трекеров может предоставить ему адреса хранителей контента. Участник сети, который первым опубликовал определенные данные в сети и создал торрент-файл, называется _initial seeder_.

Когда один из участников, имея торрент-файл, хочет получить соответствующий ему контент, он обращается к указанному в файле трекеру и запрашивает адреса, узлы которых хранят указанные в торрент-файле фрагменты. После того, как трекер возвращает клиенту список адресов, узел рассылает запросы с хэш-значениями фрагментов на полученные адреса и ждет, пока кто-то пришлет ему требуемые фрагменты. При загрузке фрагментов из сети узел может достаточно быстро и просто проверить, нужные ли фрагменты были скачаны, так как у него есть соответствующие хэш-значения. Такой подход позволяет предотвратить возникновение ошибок при загрузке файлов и проверить целостность всего полученного контента путем проверки целостности его фрагментов.

### Ограничения протокола

Отметим, что наряду с неоспоримыми преимуществами протокол BitTorrent обладает рядом ограничений.

> * _Зависимость скорости загрузки файла от количества активных узлов, которые содержат его копии_
> * _Угрозы, связанные с наличием вредоносного кода в загружаемых фрагментах_
> * _Множество узлов используют протокол только для скачивания, не поддерживая при этом сеть (не занимаются раздачей файлов)_
> * _Невозможность выборочно ограничить распространение контента (нарушение авторских прав)_

Скорость загрузки контента зависит от количества активных узлов системы, которые его хранят. Если контент популярный, то, скорее всего, его хранит большое количество участников сети и получить доступ к нему будет непроблематично. Однако если контент не особо востребован (например, пособие по ловле гусениц) и его хранит только один узел сети, то любой сбой связи или отключение этого узла приведет к невозможности получить доступ к требуемому контенту.

Когда пользователь получает торрент-файл, у него есть только набор хэш-значений и данные о том, откуда можно скачать требуемый контент. Он может только догадываться о том, будет ли скачиваемый контент соответствовать ожидаемому. И хорошо, если вместе с контентом попутно получается скачать несколько браузеров, а не кусочек вредоносного кода. 

Еще одной важной проблемой является отсутствие мотивирования узлов поддерживать сеть. Очень часто узел загружает требуемую порцию контента и не остается на раздаче. Протоколом BitTorrent, конечно, предусмотрен механизм поощрения активных раздатчиков (увеличение пропускной способности для получения контента), однако он оказался не настолько эффективным, так как не измеряется деньгами. Эту проблема частично решается в протоколе IPFS, который мы детальнее рассмотрим в 1.5.

Последней, но не менее важной проблемой, которая касается в большей мере правообладателей, является нарушение авторского права путем передачи пиратского контента. Согласно статистике только из-за пиратства в музыкальной индустрии правообладатели теряют более 10 миллиардов долларов США в год, более 40% ПО пользователей также является пиратским и свыше 75% всех компьютеров в мире имеют как минимум одну нелегально установленную программу [8].

**Распространенные мифы** 

*Нельзя одновременно использовать трекеры и DHT.*

Фактически, каждый пользователь может одновременно использовать оба подхода для одновременной загрузки разных файлов. Ограничение накладывается только на использование двух подходов для загрузки одного файла, так как для этих случаев хэш-значения торрент-файлов будут отличаться. Отметим, что большинство трекеров проверяют наличие флага и добавляют его, если он отсутствует, когда торрент появляется на их сайтах.

*Использование DHT значительно снижает производительность BitTorrent.*

Это один из наиболее распространенных мифов. Более того, многие из читателей, которые использовали и трекеры, и DHT, скажут, что это не миф и производительность системы действительно снижается. Однако это никаким образом не связано с самой технологией. Эффективное использование DHT может даже увеличить производительность, но этому препятствует очень много ограничений: объем оперативной памяти, выделенной для построения DHT, количество узлов, раздающих контент, общий объем контента, влияние централизованных трекеров и т. д.

**Часто задаваемые вопросы**

*– Что такое seeding в BitTorrent?*

_Seeding_ представляет собой процесс раздачи файлов другим узлам сети. Каждый клиент во время загрузки файла получает запросы от других узлов, загружающих тот же файл, и передает им те фрагменты, которые уже есть у него, но нет у них. Таким образом увеличивается эффективность работы сети. Более того, каждый участник для поддержания сети может раздавать файлы и после окончания их загрузки, чтобы другие узлы могли быстрее их скачивать. Процесс, который выполняет этот узел, и называется seeding.

*– Кто такие leechers и peers?*

_Leecher_ – это пользователь, который скачивает больший объем информации, чем раздает в сети. На данный момент в самом протоколе нет наказания за такое поведение, хотя часть сообщества выступает за то, чтобы его ввести. _Peer_ – это пользователь, который подключается к участнику, выполняющему раздачу файла. После того, как peer полностью скачивает файл, он становится _seeder_.

*– Существуют ли опции по обеспечению анонимности пользователей в сети BitTorrent?*

Протокол BitTorrent не обеспечивает анонимность своих пользователей. Любой пользователь может увидеть IP-адреса всех узлов в списке своего торрент-клиента. Благодаря этому в некоторых странах организации, занимающиеся защитой авторских прав, узнают через список узлов IP-адрес пользователя, незаконно распространяющего информацию, ограниченную авторским правом. Впоследствии они сообщают о неправомерных действиях интернет-провайдерам пользователя и другим сторонам, которые отвечают за соблюдение авторских прав.

*– Могут ли интернет-провайдеры ограничить передачу трафика по протоколу BitTorrent и как этому воспрепятствовать?*

Так как BitTorrent составляет значительную часть трафика, некоторые интернет-провайдеры ограничивают (замедляют) передачу BitTorrent. Для решения данной проблемы во многих торрент-клиентах используется шифрование заголовков сообщений (protocol header encryption) и шифрование всего потока сообщений (message stream encryption). Эти методы маскировки трафика помогают затруднить обнаружение трафика BitTorrent, тем самым препятствуя попыткам регулирования со стороны провайдеров.

## 1.2 Принцип работы и применение DHT

Одним из краеугольных протоколов децентрализованных сетей без преувеличения можно назвать DHT (Distributed Hash Table) [9]. Протокол был предложен в конце 1990-х годов для решения задачи индексации и поиска среди большого количества данных. Несмотря на то, что сами данные (файлы и т. д.) могут храниться на разных серверах, таблица ссылок на данные потенциально может быть бесконечно большой, что исключает вариант ее хранения в одном месте. Кроме того, важной задачей была защита от атак на центральный узел-справочник. Как раз для решения этих двух проблем был разработан DHT.

### Задачи, которые решает DHT

DHT решает проблему поиска контента (информации) по его хэш-значению (InfoHash) в децентрализованной сети.

> **Условия, в которых работает протокол DHT**
> * _Участники не идентифицируют друг друга_
> * _Участников может быть неограниченное количество_
> * _Отсутствует центральный сервер_
> * _Контент хранится у самих участников (и заранее не известно, у каких именно)_
> * _Каждый из участников может поддерживать связь только с ограниченным количеством других участников_

Для участника, который ищет данные, задача состоит в том, чтобы получить сетевой адрес другого участника, хранящего порцию контента с определенным InfoHash.

Среда, в которой контент хранится и по которой выполняется поиск, получается полностью распределенной: множество компьютеров, которые запустили определенную версию протокола DHT и ведут независимый обмен сообщениями.

### Как работает DHT?

В соответствии с протоколом, каждый участник в системе имеет глобальный уникальный идентификатор. Этот идентификатор представляет собой число такой же размерности, как InfoHash (обычно 160 бит или больше). Участник сам выбирает идентификатор, поскольку центр принятия решений отсутствует, а все участники независимы. Чтобы начать работу, новому участнику нужно иметь программу с реализацией протокола и сетевой адрес как минимум еще одного активного участника (необходимо для подключения к существующей сети).

В соответствии с правилами протокола каждый участник выделяет память (по умолчанию 5–50 МБ) для собственной таблицы. В этой таблице он хранит соответствия между InfoHash и контентом, а также между идентификаторами участников и их сетевыми адресами (рис. 1.7).

<p align="center">
<img src="/resources/img/volume-2/1.2-Operation-principle-and-application-of-DHT/Figure-1.7-Network-node-s-table.png" alt="Рисунок 1.7 – Таблица узла сети" width="60%"/>
<p>

Все записи в этой таблице отсортированы по первому столбцу (идентификатор или InfoHash), и она постоянно обновляется по следующим правилам:
> 1. Если участник в ходе общения с другими узнает о новом для него участнике (идентификатор + сетевой адрес), то эта запись вносится в таблицу.
> 2. Если участник скачивает или генерирует контент, то от этого контента вычисляется хэш-значение (InfoHash), и это соответствие также вносится в таблицу.
> 3. Если таблица по размеру приближается к пределу выделенной памяти, то из нее удаляются те строки, идентификатор которых больше всего отличается от идентификатора самого участника.

Таким образом, осуществляется удаление только самых верхних и самых нижних строк таблицы (рис. 1.8). Спустя определенный промежуток времени после начала работы участник сформирует собственную таблицу. В ней будут храниться идентификаторы, максимально приближенные к его собственному идентификатору, так как они отсортированы в порядке увеличения. Соответственно, каждый участник хранит список идентификаторов других участников и ссылки на контент, которые максимально приближены к его собственному идентификатору.

<p align="center">
<img src="/resources/img/volume-2/1.2-Operation-principle-and-application-of-DHT/Figure-1.8-Table-row-deletion-scheme.png" alt="Рисунок 1.8 – Схема удаления строк таблицы" width="60%"/>
<p>

Активному узлу сети для поиска необходимого контента нужно знать только соответствующий InfoHash. Процедура поиска участником конкретного контента начинается с обращения в собственную таблицу. Из таблицы выбирается строка, которая по идентификатору максимально приближена к InfoHash. В этой строке будет храниться сетевой адрес того участника, который по идентификатору ближе всего находится к искомому контенту. Тогда ищущий участник открывает соединение по этому адресу и посылает запрос на поиск по InfoHash. В ответ на запрос он получает либо искомую порцию контента, либо сетевой адрес участника, который еще больше приближен к этому контенту (рис. 1.9). Запросы будут повторяться, пока искомый контент не будет получен. В случае неудачи запросы можно повторить через определенный промежуток времени.

<p align="center">
<img src="/resources/img/volume-2/1.2-Operation-principle-and-application-of-DHT/Figure-1.9-Search-request-propagation-scheme.png" alt="Рисунок 1.9 – Схема распространения поисковых запросов" width="60%"/>
<p>

Получается, что каждый участник локально хранит и обновляет такую таблицу соответствия, как показано на рисунке 1.9. Быстрый поиск и вставка новых строк возможны благодаря отсортированному списку. Отметим, что у участников с близкими идентификаторами часть таблицы может совпадать (рис. 1.10).

<p align="center">
<img src="/resources/img/volume-2/1.2-Operation-principle-and-application-of-DHT/Figure-1.10-State-of-tables-of-participants-with-close-identifiers.png" alt="Рисунок 1.10 – Состояние таблиц участников с близкими по значению идентификаторами" width="70%"/>
<p>

Для повышения надежности и скорости поиска запросы выполняются параллельно по нескольким приближенным участникам сети. На практике такой механизм поиска обладает достаточно высокой степенью надежности, не поддается цензуре и хорошо масштабируется. Количество участников в сети и количество порций хранимого контента практически не ограничено. Есть дюжина модифицированных версий этого протокола, нацеленных на повышение различных его свойств, таких как скрытность поиска, увеличенный объем хранимых данных, устойчивость к атакам Сивиллы (Sybil attack), ускоренный поиск популярного контента, обеспечение целостности запросов и ответов.

Протоколы DHT являются незаменимым компонентом многих популярных проектов: I2P, IPFS, GNUnet, BitTorrent, Tox.

До появления DHT подобную задачу поиска контента решали с использованием централизованных сервисов или группы централизованных сервисов, которые синхронизируются между собой. Также у централизованного сервиса реализован публичный API для запросов и, как правило, зарегистрировано доменное имя. По сути, такие сервисы хранят полные таблицы соответствия между InfoHash и сетевыми адресами, которые по объему получались значительно больше 50 МБ. Примером такого сервиса является Torrent Tracker. Как известно, такие трекеры легко поддаются цензуре и могут даже блокироваться.

### Проблема блокирования контента злоумышленником

Самая распространенная атака на протоколы DHT заключается в том, что злоумышленник может почти полностью заблокировать один конкретный контент.

Допустим, некий Тарас решил ограничить доступ узлов системы к подлинной фотографии Сатоши Накамото, потому что получение такой информации заинтересованной стороной может нанести непоправимый ущерб сети Bitcoin.

Для этого он запускает несколько десятков специально модифицированных узлов. Модификация заключается в том, что в качестве идентификатора участника выбирается не случайное число, а число близкое к целевому InfoHash (контент который нужно заблокировать). Также эти узлы иначе реагируют на запросы поиска по этому InfoHash, отдавая в ответ несуществующие сетевые адреса. Тогда получается, что большое количество фейковых узлов окружают идентификатор фотографии Сатоши, за счет чего к ним обращаются практически все участники, которые ищут этот контент (рис. 1.11). Таким образом, доступ к одному конкретному контенту можно временно заблокировать.

<p align="center">
<img src="/resources/img/volume-2/1.2-Operation-principle-and-application-of-DHT/Figure-1.11-Scheme-of-blocking-a-specific-piece-of-content-when-being-searched.png" alt="Рисунок 1.11 – Схема блокировки конкретного контента при поиске" width="70%"/>
<p>

**Распространенные мифы**

*Использование DHT требует большого количества дискового пространства.*

Это не совсем так. Важно отметить, что требование по объему базы DHT всецело зависит от количества узлов в сети. Чем больше узлов в распределенной сети, которая использует технологию, тем меньше требования по объему хранимых в таблице данных.

*DHT работает очень медленно, и его трудно применять в системах, оперирующими большими объемами данных.*

Поиск контента при использовании DHT действительно медленнее традиционных способов, однако такой способ более отказоустойчив и как раз в децентрализованных системах пользуется спросом. Примером тому являются системы, такие как BitTorrent и IPFS (детальнее в 1.5).

*Идентификатор, полученный путем хэширования IP-адреса узла, можно считать безопасным.*

У этого подхода есть одна теоретическая уязвимость перед IP-спуфингом. Концепция IP-спуфинга заключается в том, что злоумышленник модифицирует заголовок IP-пакета таким образом, чтобы выдать себя за другой узел. Если злоумышленнику при этом удастся получить ответ на свой запрос, это означает, что он может присвоить себе практически любой IP-адрес. Следовательно, строить систему, безопасность которой полагается на ограниченном пространстве доступных IP-адресов, может быть крайне опасно.

**Часто задаваемые вопросы**

*— Защищена ли конфиденциальность пользователей, которые используют DHT?*

Нет. Поскольку все хэш-значения таблицы находятся в открытом доступе, то отследить раздачу – действие выполнимое.

*— Какие преимущества привнесла реализация DHT в BitTorrent?*

DHT позволяет снизить нагрузку на трекеры или вообще от них отказаться, так как теперь BitTorrent, используя информацию, встроенную в торрент-файл, может выбрать, перейти к трекеру или пойти по набору узлов из DHT.

## 1.3 Концепция web-of-trust

Сейчас сложно представить современного человека, который бы не пользовался возможностями Интернета: совершение покупок, не покидая пределы своей комнаты, обмен сообщениями в социальных сетях и т. д. Для защиты передаваемых данных используются алгоритмы асимметричного шифрования, цифровой подписи и цифровые ключи.

При всем этом важно правильно сопоставить конкретного пользователя с его открытым ключом во избежание атак типа man-in-the-middle (злоумышленник заменяет передаваемый открытый ключ на свой, после чего может отсылать и подписывать сообщения от имени целевого пользователя).

Для обеспечения надежности применения цифровой подписи и других асимметричных алгоритмов используются центры сертификации ключей (ЦСК). Но централизованный подход имеет свои недостатки, связанные с компрометацией личного ключа корневого центра сертификации, с необходимостью доверия центрам сертификации. В качестве решения этой проблемы используется полностью децентрализованный подход – web-of-trust (WoT).

### Понятие сертификата открытого ключа

Чтобы лучше понять web-of-trust подход, рассмотрим, как организована традиционная инфраструктура открытых ключей.

_Инфраструктура открытых ключей (ИОК, PKI, Public Key Infrastructure) – комплекс средств, методов, политик, необходимых для создания и обработки сертификатов открытых ключей, позволяющий обеспечить надежное функционирование асимметричных криптоалгоритмов_ [65]. 

_Сертификат открытого ключа (public key certificate) – документ, устанавливающий соотношение между открытым ключом и его владельцем; подписывается и выдается одним из ЦСК_ [65].

Структура сертификата открытого ключа согласно стандарту X.509 [64] приведена в таблице 1.1.

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Table-1.1.png" alt="Таблица 1.1" width="60%"/>
<p>

Основными полями в сертификате открытого ключа являются значение открытого ключа субъекта и цифровая подпись, наложенная центром сертификации. Отметим, что при помощи цифровой подписи центр сертификации подтверждает соответствие открытого ключа конкретному лицу.

### Как работает иерархическая ИОК?

Иерархическая ИОК является традиционной моделью организации, которая предполагает, что центры сертификации ключей (ЦСК, CA, Certification Authority) связаны в иерархическую древовидную структуру (рис. 1.12).

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Figure-1.12-Certificate-authorities-hierarchy-scheme.png" alt="Рисунок 1.12 – Схема иерархии центров сертификации
" width="70%"/>
<p>

Для иерархической PKI характерен ряд следующих особенностей:

> * _Каждое отношение между дочерним и родительским ЦСК представлено отдельным сертификатом, подписанным родительским узлом (корневой сертификат является самоподписанным)_
> * _Все ЦСК, за исключением корневого, подчиняются одному вышестоящему (родительскому) ЦСК_
> * _ЦСК могут иметь подчиненные ЦСК и выпускать сертификаты для них или конечных пользователей_
> * _Все пользователи доверяют одному и тому же корневому ЦСК_

Опираясь на перечисленные особенности, достаточно просто объяснить общую модель функционирования иерархической ИОК. На самом верхнем уровне находится корневой центр сертификации ключей. У корневого центра имеется собственная ключевая пара, при помощи которой он может подписать сертификаты для центров сертификации нижнего уровня. При этом у корневого центра сертификации также есть собственный сертификат открытого ключа, который был выработан им же.

При получении сертификата каждый из дочерних ЦСК получает право самостоятельно выпускать сертификаты для своих дочерних ЦСК. Так цепочка сертификатов, где каждый дочерний подписан родительским, продолжается и до конечных пользователей.

Среди преимуществ такого подхода построения ИОК важно выделить простоту построения и проверки цепочек сертификации, так как каждый пользователь и ЦСК имеет сертификат, выпущенный ровно одним родительским ЦСК. При этом цепочки сертификатов сравнительно короткие и однозначно приводят к одному корневому центру сертификации.

Для закрепления материала давайте рассмотрим пример, в котором Алисе необходимо проверить сертификат Боба (для того, чтобы убедиться, был ли полученный квартальный отчет действительно подписан Бобом). При этом сертификаты Алисы и Боба были выданы разными центрами сертификации. Эту схему можно представить следующим образом (рис. 1.13):

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Figure-1.13-Hierarchical-PKI-scheme.png" alt="Рисунок 1.13 – Схема иерархической инфраструктуры открытых ключей" width="50%"/>
<p>

Алиса имеет собственный сертификат открытого ключа, который был подписан и хранится у ЦСК1. Аналогичный сертификат имеется и у Боба (однако, он уже выдан и хранится у ЦСК2). При этом ЦСК1 и ЦСК2 также имеют собственные сертификаты, которые были выданы одним и тем же корневым ЦСК0.

Когда Алиса хочет проверить аутентичность открытого ключа Боба (с помощью которого она проверяла значение цифровой подписи), она получает от него сертификат открытого ключа и проверяет, кем этот сертификат был подписан. Оказывается, что его подписал ЦСК2. Так как Алиса лично не доверяет ЦСК2, то она запрашивает и его сертификат открытого ключа, который был выдан корневым ЦСК0. Алиса доверяет ЦСК0 (потому что этот центр сертификации выдал сертификат ЦСК1) и убеждается, что предоставленный открытый ключ Боба действительно принадлежит ему. Отметим, что в этом примере два сертификата в цепочке (проверяются сертификаты Боба и ЦСК2). Если бы сертификат Боба был подписан ЦСК1, то Алиса могла бы напрямую обратиться к ЦСК1 и сразу убедиться в корректности сертификата.

Преимуществом иерархического подхода также является возможность быстрого реагирования на компрометацию личного ключа конечного пользователя (для этого пользователю необходимо обратиться к родительскому ЦСК).

_Компрометация ключей (key compromise) – факт ознакомления или подозрение в ознакомлении третьей стороны с личным ключом пользователя._ К компрометации также относится потеря физического контроля ключа его владельцем.

Предположим, что личный ключ, которым владел Боб, похитил Тарас. Теперь он может отправлять всем ложные сообщения от имени Боба и подписывать их при помощи личного ключа Боба. В этом случае Боб должен сразу сообщить ЦСК, что его личный ключ был скомпрометирован. ЦСК может быстро отреагировать и пометить сертификат Боба как недействительный, после чего выдать ему новый сертификат с новым открытым ключом.

Если Алиса получает сообщение, подписанное старым ключом Боба, она обращается к ЦСК2. Как и в предыдущем случае, ЦСК2 сообщает Алисе, что сертификат требуемого открытого ключа более не действителен и, скорее всего, ее пытаются обмануть (рис. 1.14).

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Figure-1.14-Alice-verifies-Bob-s-certificate.png" alt="Рисунок 1.14 – Алиса проверяет сертификат Боба" width="50%"/>
<p>

Но что же произойдет, если будут скомпрометированы ключи не конечного пользователя, а одного из ЦСК (например ЦСК2)? В этом случае ЦСК2 сообщает корневому ЦСК0, что его ключи скомпрометированы. ЦСК0 помечает сертификат ЦСК2 как недействительный и выдает ему новый сертификат с новым открытым ключом, тем самым возвращая скомпрометированный центр обратно в иерархию. Но поскольку старый открытый ключ ЦСК2 становится недействительным, при этом теряют валидность все сертификаты, которые выдал этот ЦСК. Поэтому пользователи, находящиеся в скомпрометированном сегменте, теряют возможность пользоваться сервисами ИОК (их сертификаты также становятся недействительными; если пользователи не прекратят взаимодействие или не обновят сертификаты, то они могут быть обмануты злоумышленником, похитившим секретный ключ ЦСК2).

Осталось рассмотреть, что же случится, если вдруг произойдет компрометация личного ключа корневого центра сертификации. В принципе, последствия те же, только гораздо глобальнее: на некоторое время вся инфраструктура должна быть остановлена. Отметим, что критически важно оповещать всех участников системы о компрометации одного из ЦСК, так как злоумышленник в этом случае может выпускать поддельные сертификаты, отзывать действующие сертификаты и т. д.

У иерархических ИОК есть явные преимущества: высокая скорость построения и отслеживания цепочек сертификатов, а также быстрый перевыпуск сертификатов в случае компрометации личных ключей как пользователей, так и ЦСК. Однако такие модели имеют и ряд недостатков.

> **Проблемы иерархической ИОК**
> * _Необходимость проверки всей цепочки сертификатов_
> * _Критичность компрометации личного ключа корневого центра сертификации (риск прекращения функционирования всей инфраструктуры)_
> * _Проблемы связанные с синхронизацией центров сертификации между собой_
> * _Пользователи фактически не управляют своим identity_
> * _Сложности совместимости систем (алгоритмы подписи и т. д.)_

### Принципы функционирования web-of-trust

Web-of-trust – это альтернатива иерархической модели ИОК. Концепция впервые была применена в 1991 году в протоколе PGP для аутентификации открытых ключей пользователей. Также подход web-of-trust можно использовать для механизмов идентификации в децентрализованной среде и системах рейтинга (уже существует множество браузерных надстроек онлайн-рейтинга сайтов, использующих механизм web-of-trust).

В какой-то степени в основе надежной работы модели web-of-trust лежит социальный консенсус: ни один пользователь не будет доверять сертификату другого пользователя до тех пор, пока этот участник не получит подтверждение своего открытого ключа хотя бы от одного участника, находящегося в кругу доверия первого пользователя.

Прежде чем перейти непосредственно к принципам работы web-of-trust, определим два необходимых в дальнейшем понятия, которые довольно тесно связаны друг с другом и на которые опирается вся концепция, – _trust и validity_.

Validity определяет уровень того, насколько хорошо один пользователь знает второго пользователя. Если обозначить уровень validity от 0 до 1, то при значении validity 0 первый пользователь абсолютно не знаком со вторым (в дальнейшем – абсолютно не знает, каким ключом владеет этот пользователь), а при значении 1 – полностью уверен в связи конкретного пользователя и его открытого ключа.

Trust определяет уровень доверия одного пользователя другому, то есть насколько первый доверяет второму идентификацию всех остальных участников системы.

Итак, вернемся к децентрализованной ИОК. У нас есть система, каждый из участников которой владеет ключевой парой. Кроме того, каждый из участников определяет собственный список ключей других участников сети, верификацию которых он провел (например встретился с ними в кафе и лично получил открытый ключ), а также уровень validity и trust этих пользователей. Полученные ключи (иногда и другие данные пользователя) он подписывает при помощи своего личного ключа, другими словами, формирует сертификаты открытых ключей других пользователей. Каждый из пользователей содержит таблицу с примерно следующего содержания (табл. 1.2).

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Table-1.2.png" alt="Таблица 1.2" width="70%"/>
<p>

В этом случае пользователь может безопасно взаимодействовать с теми участниками системы, ключи которых есть у него в списке и чей уровень validity равен 1.

Но что, если нужна коммуникация с участником системы, чьего открытого ключа еще нет у пользователя? В этом случае он обращается к доверенным пользователям (уровень trust которых повыше) и запрашивает у них из контактов открытый ключ нужного пользователя. Таким образом, если у одного из его контактов содержится подписанный открытый ключ требуемого участника сети, то он смотрит свой уровень trust к пользователю и уровень trust и validity пользователя к целевому абоненту. В зависимости от этого он определяет, насколько безопасным будет использование предоставленного открытого ключа целевого пользователя.

### Пример с итальянской мафией

Для простоты понимания приведем пример, в котором главы итальянской мафии – дон Корлеоне, дон Татталья и дон Фануччи – решили организовать совместную сеть для ведения бизнеса и использовать web-of-trust для организации ИОК. Отметим, что ключи в этом случае будут использоваться для шифрования и подписи сообщений.

Для этого они организовывают встречу глав семейств, на которой происходит обмен открытыми ключами (рис. 1.15).

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Figure-1.15-Exchange-of-public-keys-between-heads-of-the-families.png" alt="Рисунок 1.15 – Обмен открытыми ключами между главами семейств" width="50%"/>
<p>

Каждый из донов формирует собственную таблицу, которую заполняет после встречи. Рассмотрим, например, таблицу 1.3, которую сформировал дон Корлеоне.

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Table-1.3.png" alt="Table 1.3" width="70%"/>
<p>

> **_Замечание._** *Уровень validity в этом случае устанавливается равным единице, потому что доны обменялись ключами лично при встрече. Уровень trust к дону Фануччи был определен доном Корлеоне как 0,8, потому что соответствующий открытый ключ был передан без требующего того уважения.*

Теперь дон Корлеоне может отправлять сообщения, зашифрованные на открытых ключах остальных глав семейств, не беспокоясь о том, что их может прочитать кто-то другой (при этом получатели смогут аутентифицировать отправителя по значению цифровой подписи).

Но что если дону необходимо связаться с Солоццо, открытого ключа которого нет в его списке? Для этого он обращается к дону Татталья с запросом, есть ли у него соответствующий открытый ключ. Дон Татталья говорит, что такой ключ есть и что он же его подписал, и при этом уровень validity и trust определен как 1 (то есть дон Татталья полностью верифицировал и полностью доверяет Солоццо). Так как дон Корлеоне полностью доверяет дону Татталья (trust равен 1) и дон Татталья уверен, что открытый ключ принадлежит Солоццо, уровень validity дона Корлеоне к Солоццо равен 1 (и он может уверенно шифровать сообщения, используя полученный ключ).

При этом ввиду старых разногласий дон Корлеоне практически не доверяет Солоццо идентификацию других участников сети и заполняет собственную таблицу (табл. 1.4) следующим образом:

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Table-1.4.png" alt="Таблица 1.4" width="70%"/>
<p>

Этим дон Корлеоне подчеркивает, что для него каждый сертификат, который выпустит Солоццо, будет обладать уровнем validity равным 0,1.

Теперь давайте представим, что есть дон Барзини, открытый ключ которого хранится как у Солоццо, так и у дона Татталья (причем у Солоццо – с уровнем validity 1, а у дона Татталья – с уровнем validity 0,3). Если дон Корлеоне хочет написать Барзини, он запрашивает сертификаты у Солоццо и дона Татталья, каждый из которых присылает ему соответствующий сертификат.

Получив сертификаты, дон Корлеоне рассчитывает уровень validity, то есть уровень того, что полученные открытые ключи соответствуют дону Барзини (кстати, они могут быть разные, если, например, Солоццо хочет обмануть дона и сам прочитать сообщение).
Уровень validity открытым ключам, которых нет в собственном списке, определяется 
так:
> *validity(PK) = validity(PKi) * trust(PK)*, где
> * *validity(PK)* – уровень validity относительно ключа, которого нет в списке
> * *trust(PK)*  – уровень доверия посреднику
> * *validity(PKi)* – уровень validity посредника относительно целевого ключа

Соответственно, дон Корлеоне верит, что полученными ключами владеет дон Барзини с уровнем validity 0,24 (дон Татталья) и 0,1 (Солоццо). Эти значения достаточно малы, и дон Корлеоне не хочет рисковать, шифруя сообщение полученными ключами, потому напрямую отправляется в гости к дону Барзини.

### Преимущества и ограничения технологии web-of-trust

Основным преимуществом web-of-trust является возможность функционирования в полностью децентрализованной среде, где взаимодействующие стороны не хотят доверять центральному органу сертификации. При достаточном уровне связности пользователей (теория шести рукопожатий) web-of-trust позволяет участнику рассчитать относительную репутацию любого другого участника.

Отметим, что при использовании web-of-trust невозможен отказ функционирования всей системы по причине компрометации личного ключа одного либо нескольких пользователей. Если web-of-trust используется в полностью распределенной среде, то выход из строя одного узла может повлиять только на возможность взаимодействия с этим конкретным узлом и не особо повлияет на функционирование остальных узлов между собой.

Однако технология web-of-trust имеет ряд определенных ограничений, которые сильно влияют на работу системы.

> **Ограничения web-of-trust**
> * *Сложность нахождения сертификата открытого ключа с высоким уровнем validity в ряде случаев*
> * *Большая продолжительность и сложность перестройки сети*
> * *Нахождение требуемого сертификата может потребовать более продолжительного промежутка времени*

Первое ограничение относится к специфике протокола web-of-trust. Сеть, которая использует web-of-trust, будет хорошо и эффективно работать только в случае, если все узлы ведут себя честно и имеют максимальные уровни validity и trust. В большинстве случаев уровень доверия пользователей по отношению к другим не максимальный, что влечет за собой лавинный эффект и сложности принятия решения относительно использования конкретного ключа.

В случае компрометации одного из ключей пользователей перестройка сети займет гораздо больше времени, чем централизованный аналог, так как для этого пользователь должен сообщить всем узлам, хранящим его сертификаты, о компрометации (причем сообщать нужно убедительно, так как многие узлы могут воспринять такое сообщение как атаку злоумышленника и оставить сертификат валидным). Также, если пользователь является новым участником сети, ему нужно на протяжении длительного времени вести себя честно, чтобы остальные узлы повысили уровень доверия к нему.

Третье ограничение связано со сложностью нахождения определенного сертификата, если сеть имеет большое количество участников. Эту проблему можно частично решить при помощи использования DHT (детальнее в 1.2), однако это требует дополнительного ПО и ресурсов.

***Распространенные мифы***

*Web-of-trust позволяет гарантированно найти валидный сертификат пользователя, однако может потребоваться большой промежуток времени для его нахождения.*

Это утверждение является мифом из-за особенностей доверия между узлами сети. Очень редко случается, что один узел абсолютно доверяет сертификату второго узла. Уровень доверия часто может быть очень большим, однако весьма редко он равен 100%. Из-за этой особенности может произойти так, что вы не сможете найти сертификат пользователя с достаточным для вас уровнем доверия. К примеру, клиент может настроить свое ПО так, что будет считать валидными только сертификаты, уровень доверия через посредников к которым не менее 95%. Тогда, фактически, может существовать цепочка к конкретному сертификату через 3–4 узла, доверие между которыми, например, тоже равно 95%. Однако из-за особенностей расчета уровня доверия от запрашивающего узла к целевому, может получиться, что окончательный уровень доверия будет равен не более 85%.

*В сети web-of-trust можно повысить уровень доверия к себе (свой рейтинг), создав множество поддельных личностей и, соответственно, открыть большое количество линий доверия к себе с максимальным значением validity.*

Создавать поддельные личности и линии доверия можно, но это никаким образом не повлияет на расчет вашей оценки реальными пользователями, поскольку этот расчет ведется относительно каждого отдельного пользователя и исходящих от него линий доверия. Мнение поддельной личности не принимают во внимание реальные пользователи, поскольку они не открывали линию доверия ей.

***Часто задаваемые вопросы***

*— Может ли один пользователь создать несколько сертификатов для разных своих ключей?*

Такая возможность доступна. А если разные ключи используются в разных кругах общения (например в личном и рабочем), то это не повлияет на уровень подтвержденности сертификатов и не создаст путаницу для собеседников.

*— Подвержен ли протокол web-of-trust атаке Сивиллы и может ли эта атака повлиять на принятие узлом сертификата с изначально низким уровнем доверия?*

Протокол не ограничивает количество узлов в сети, а значит теоретически злоумышленник может создать большое количество «участников», которые полностью доверяют его сертификату. Однако это не может никаким образом повлиять на других участников сети, так как отношение доверия от узла к узлу однонаправленное. Фактически, узлы не будут добавлять себе сертификаты новых участников, если у них нет доверия по отношению к этим сертификатам, а соответственно, их количество не имеет значения.

Однако существует проблема, при которой ранее честный узел с высоким уровнем доверия вдруг начинает вести себя злоумышленным образом и добавляет сертификаты несуществующих участников под именем целевых пользователей. В итоге, сеть может перестать доверять этому пользователю, однако ее перестройка является довольно трудоемким процессом и не может быть выполнена в короткие сроки, чем злоумышленник и может воспользоваться.

## 1.4 Обзор протокола BitMessage

После сообщения Эдварда Сноудена о том, что за более чем миллиардом человек в 60 странах ведется глобальная слежка [10], возникла необходимость создания действительно конфиденциального средства коммуникации.

21 марта 2013 года вышла первая бета-версия клиента BitMessage. Ключевой инновацией протокола BitMessage стало отсутствие центральных серверов или какого-либо центра, который обрабатывает данные пользователей. Протокол работает по схеме peer-to-peer, то есть каждый узел является и клиентом, и сервером одновременно, а единый централизованный сервер отсутствует.

### Принципы функционирования протокола

Для тех, кто заинтересован в сохранении личной или корпоративной конфиденциальности, BitMessage – хорошая альтернатива обычным мессенджерам.

> * *Поддержка end-to-end шифрования передаваемых сообщений*
> * *Отправитель и получатель явно не указаны в сообщении*
> * *Каждый узел хранит все последние сообщения в сети*
> * *Proof-of-work как защита сети от спама*
> * *Поддержка проверки целостности и авторства полученных сообщений*
> * *Поддержка открытых широковещательных каналов*
> * *Поддержка закрытых групповых чатов*

Ключевая идея протокола состоит в поддержании end-to-end шифрования передаваемых сообщений. Это значит, что сообщение может прочитать только отправитель и получатель, и никакие промежуточные звенья не имеют такой возможности. Для шифрования данных сообщения используется алгоритм AES с длиной ключа 256 бит, который работает в режиме CBC (Cipher Block Chaining). В этом случае ключ рассчитывается как общий секрет между отправителем и получателем по схеме ECDH. Такой секрет отправитель может получить автономно – без взаимодействия с получателем. Для этого ему необходимо использовать свой личный ключ и открытый ключ получателя. Получатель, используя свой личный ключ и открытый ключ отправителя, сможет получить точно такой же секрет. Таким образом оба участника имеют одинаковый секрет для шифрования сообщений. Кроме того, для повышения уровня безопасности вместо алгоритма ECDH может использоваться совместный рандомизатор для генерации нового ключа шифрования для каждого нового сообщения.

> **_Замечание._** *Режим CBC (сцепление блоков шифротекста) подразумевает, что для шифрования каждого следующего блока данных используется зашифрованное значение предыдущего блока.*

В сообщениях BitMessage _не указываются идентификаторы_ отправителя и получателя конкретного сообщения. Каким же образом тогда получатель определяет, что конкретное сообщение адресовано ему? Для этого каждый узел сети пытается расшифровать все сообщения, которые проходят через него. Так как ключ шифрования доступен только отправителю и получателю сообщения, только они могут получить доступ к содержимому сообщения.

Как мы отмечали ранее, узел пытается _расшифровать каждое полученное сообщение_. В случае успеха (если сообщение действительно было адресовано пользователю) получатель ознакамливается с его содержимым. Но что делать с сообщениями, которые расшифровать не получилось? Протоколом BitMessage предусмотрено, что каждый узел хранит все полученные сообщения 2 дня. Это сделано для того, чтобы получатель сообщения мог получить к нему доступ даже в случае его отсутствия в сети в момент отправки сообщения. Когда у пользователя появляется интернет-соединение, он запрашивает у соседних узлов все ранее не полученные сообщения и пытается расшифровать их.

В качестве защиты сети от спама используется proof-of-work. Чтобы отправить сообщение, отправителю необходимо решить ресурсоемкую задачу. Сложность proof-of-work зависит от объема сообщения и объема вложений, входящих в сообщение.

Также отметим, что протокол предусматривает возможность использования цифровой подписи для проверки целостности и авторства каждого отправленного сообщения.

Протокол BitMessage предусматривает возможность создания широковещательных каналов и секретных чатов. Широковещательные каналы предусматривают, что отправитель шифрует сообщение хэш-значением собственного открытого ключа. Каждый участник сети, у которого есть открытый ключ отправителя, может расшифровать такое сообщение. Секретные чаты подразумевают создание общего секрета для шифрования между группой пользователей. Отметим, что такой секретный чат не может поддаваться цензуре третьей стороной.

### Адреса в BitMessage

В протоколе BitMessage также предусмотрено наличие адресов у пользователей. Давайте рассмотрим, как генерируется адрес и для чего он нужен.

Каждому BitMessage-адресу соответствуют две пары ключей: одна пара применяется для подписи сообщений (ECDSA), а вторая – для создания общего секрета (ECDH). Для формирования BitMessage-адреса используются оба открытых ключа (рис. 1.16).

<p align="center">
<img src="/resources/img/volume-2/1.4-Overview-of-the-BitMessage-protocol/Figure-1.16-BitMessage-address-generation-scheme.png" alt="Рисунок 1.16 – Схема генерации BitMessage адреса" width="60%"/>
<p>

Открытые ключи конкатенируются и хэшируются с помощью SHA512, а для результата снова рассчитывается хэш-значение, но уже при помощи RIPEMD160. На выходе получается число длиной 160 бит (20 байт). Это значение конкатенируется с Version (значение версии протокола), Stream (поток сообщений; его детальнее рассмотрим ниже) и Checksum (контрольная сумма, которая позволяет предотвратить ошибки при написании адреса). Для обозначения того, что адрес относится к сети BitMessage, используется префикс «BM». В результате BitMessage-адрес выглядит следующим образом:

> *BM-BcbRqcFFSQUUmXFKsPJgVQPSiFA3Xash* 

BitMessage поддерживает 2 типа адресов: детерминистические и случайные адреса.

> **Типы BitMessage-адресов**
> * *Deterministic address (детерминистический адрес)*
> * *Random address (случайный адрес)*

Для получения детерминистического адреса пользователю необходимо задать значение seed для его порождения. Можно провести аналогию с тем, как пользователь задает пароль для входа на сервис.

Поскольку seed задается непосредственно пользователем, с этим связаны некоторые преимущества и риски. Преимуществом является простота восстановления адреса. При использовании другого устройства пользователю нужно просто ввести значение seed (скорее всего, пользователь не захочет определять случайное значение seed, а задаст его значением, которое легко будет вспомнить). После этого устройство самостоятельно генерирует адрес. К рискам можно отнести простоту взлома (атака грубой силы или атака со словарем), ведь seed является не случайным значением, а задан пользователем.

Случайно сгенерированные адреса используют псевдослучайное значение в качестве seed для генерации адреса, и, не зная этого значения, адрес не может быть восстановлен. Важно отметить, что в этом случае пользователю также необходимо ввести seed для восстановления адреса, но так как seed является случайным значением, теряется удобство восстановления, хоть и повышается безопасность при взаимодействии с системой.

### Структура сообщений в BitMessage

Давайте детально рассмотрим структуру сообщений в протоколе BitMessage, приведенную в таблице 1.5.

<p align="center">
<img src="/resources/img/volume-2/1.4-Overview-of-the-BitMessage-protocol/Table-1.5.png" alt="Таблица 1.5" width="70%"/>
<p>

Сообщение содержит 5 полей, которые указаны в таблице. Первое из них – _magic_ – является константным числом, которое используется для идентификации потока данных. По этому значению можно определить, что данные, которые за ним следуют, относятся к сети BitMessage. Такое же значение используется и для протокола Bitcoin (в нем оно  определяется как 0xD9B4BEF9).

Ниже следует поле под названием _command_, в котором содержится тип сообщения. В зависимости от типа, сообщения делятся на broadcast (широковещательное сообщение), private (личное сообщение) или ACK (уведомление о доставке личного сообщения). У каждого из перечисленных типов сообщения имеется свое назначение, о которых мы поговорим далее.

Далее следует поле _length_, в котором указывается длина передаваемого сообщения в байтах. Чем больше длина сообщения, тем более ресурсоемкую задачу необходимо решить его отправителю. Отметим, что максимальный размер сообщения в последней версии протокола ограничен 256 KiB.

Следующая составляющая сообщения – поле _checksum_, в котором содержатся первые 4 байта хэш-значения SHA512 от передаваемых данных.

Ключевым полем сообщения является поле _payload_, содержащее в себе передаваемые данные и значение nonce как доказательство выполненной работы. При получении сообщения узел первым делом вычисляет хэш-значение от поля _payload_, и если полученное хэш-значение удовлетворяет требуемому параметру сложности, такое сообщение сохраняется локально и передается далее по сети. Если хэш-значение не удовлетворяет требуемому параметру, такое сообщение удаляется и не передается далее. 

### Типы сообщений в BitMessage

Как упоминалось ранее, BitMessage поддерживает три типа сообщений.

> **Типы BitMessage-сообщений**
> * *Broadcast message (широковещательное сообщение)*
> * *Private message (личное сообщение)*
> * *ACK message (уведомление о доставке личного сообщения)*

Особенность _broadcast_ сообщения в том, что его может расшифровать любой узел, в списке адресов которого есть адрес отправителя. Broadcast сообщение шифруется хэш-значением открытых ключей отправителя. Узел, которому пришло такое сообщение, определяет, что это сообщение типа broadcast (по полю _command_ в сообщении), и начинает по очереди вычислять хэш-значения всех адресов, находящихся в его списке. С помощью вычисленного хэш-значения узел пытается расшифровать полученное сообщение. Если сообщение не удалось расшифровать, берется следующий адрес. Если сообщение расшифровано успешно, оно отображается пользователю.

Отправив такое сообщение, отправитель не получает уведомлений о доставке. Следовательно, повторная отправка широковещательного сообщения может выполняться только вручную. По умолчанию broadcast сообщения хранятся узлами на протяжении 2 дней.

Для отправки _private_ сообщения используется end-to-end шифрование, которое основано на общем секрете между отправителем и получателем. Прочитать такое сообщение может только получатель (имеющий соответствующий секрет) и сам отправитель.

Узлы по умолчанию хранят private сообщения на протяжении 2,5 дней. Если за это время пользователь, которому было адресовано определенное сообщение, не появится в сети, сообщение будет отправлено повторно. Для каждой повторной отправки сообщения требуется пересчитывать PoW. Поскольку получатель отправляет уведомление отправителю, ПО позволяет ретранслировать личное сообщение автоматически. 

_ACK_ сообщение – уведомление о доставке личного сообщения. ACK сообщение отправляется получателем private сообщения. Такое сообщение шифруется точно так же, как и личное сообщение, и узлы хранят такое сообщение также 2,5 дня.

### Понятие stream в BitMessage 

Ранее мы упоминали значение stream в контексте формирования BitMessage-адреса. Пришло время понять, что определяется этим значением и для чего оно используется в протоколе.

Проблема масштабируемости является ключевой для протокола BitMessage. Несмотря на то, что протокол может обеспечить высокий уровень анонимности и конфиденциальности передаваемых сообщений, использование схемы, при которой каждый участник сети хранит все данные, крайне неэффективное. Представим ситуацию, в которой системой BitMessage будут пользоваться миллионы людей. В этом случае каждому из участников необходимо будет хранить все сообщения остальных участников. Естественно, такая система не сможет надежно функционировать.

Решением является компромисс между анонимностью и масштабируемостью системы, который подразумевает разделение пользователей на так называемые потоки (streams). Каждый поток определяет группу пользователей, которые будут получать и хранить сообщения, соответствующие их потоку.

Потоки представляют собой двоичную структуру, как на рисунке 1.17.

<p align="center">
<img src="/resources/img/volume-2/1.4-Overview-of-the-BitMessage-protocol/Figure-1.17-Scheme-of-the-division-of-network-nodes-into-streams.png" alt="Рисунок 1.17 – Схема разделения узлов сети на потоки" width="60%"/>
<p>

Номер потока содержится в адресе участника системы и определяет, к какому из потоков необходимо подключиться отправителю, чтобы сообщение достигло своего адресата. Отметим, что каждый участник сети хранит сообщения, соответствующие его собственному потоку и дочерним потокам.

***Часто задаваемые вопросы***

*– Какое количество соединений необходимо поддерживать узлу BitMessage для функционирования?*

Чтобы общаться с сетью BitMessage, необходимо соединение как минимум с одним из узлов. Но чем больше соединений с разными узлами других участников, тем более целостная сеть и меньше вероятность потери сообщений. Однако протоколом определено ограничение на максимальное количество исходящих соединений: их может быть не больше 8. В то же время максимальное количество входящих соединений в десятки раз больше.

*– Можно ли отправить сообщение пользователю, у которого на текущий момент отсутствует подключение к сети?*

Да, пользователь может отправить сообщение в сеть BitMessage независимо от того, находится ли его получатель в сети. Отправленное сообщение хранится всеми узлами на протяжении двух дней. При восстановлении соединения получатель заходит в сеть и загружает с подключенных узлов все новые сообщения. Если же получателя не было в сети более двух дней, тогда сообщение удаляется и требует повторной отправки.

*– Каково время доставки сообщения протоколом от отправителя к получателю?*

На практике время передачи сообщения зависит от двух величин: времени распространения по сети и времени ожидания в очереди на расшифрование сообщения. По сети от узла отправителя до узла получателя сообщение может идти до 30 секунд в зависимости от количества узлов-посредников. Ожидать расшифрования в очереди со всеми остальными сообщениями оно будет в среднем около 5 секунд. Таким образом, если узел получателя находится в сети и синхронизирован, он увидит входящее сообщение через 20–30 секунд после его отправки.

*— Как узел может работать в пассивном режиме?*

При возможности слежки или прослушивания сети злоумышленником пользователь может работать в полностью пассивном режиме, не отправляя ACK сообщение (сообщение подтверждения получения). Однако гораздо разумнее с его стороны отправлять ACK сообщение через другой узел, который может даже об этом не подозревать. Например, Боб, который боится, что его сеть прослушивает Ева, вместо того, чтобы отправить Алисе ACK сообщение напрямую, отправляет его своему другу или случайному узлу. Последний в свою очередь распространяет это сообщение и одновременно его подтверждает.

## 1.5 Архитектура и особенности протокола IPFS

В подразделе 1.1 мы рассмотрели, как может работать децентрализованная файлообменная сеть: она не регулируется кем-либо единолично, устойчива к цензуре и поддерживается непосредственно ее участниками. Протоколом организации такой сети выступил BitTorrent, который заложил основные концепции построения, но при этом обладал некоторыми ограничениями и узкой направленностью использования.

10 октября 2018 года был представлен новый протокол организации децентрализованной файлообменной сети под названием IPFS. Он применил ключевые концепции BitTorrent, добавив к ним ряд новых улучшений, позволяющих использовать IPFS в качестве платформы для многих децентрализованных приложений. В этом подразделе мы рассмотрим основные концепции IPFS, преимущества протокола по сравнению с другими протоколами построения децентрализованных файлообменных сетей, как IPFS применяется и как может применяться для реализации децентрализованных приложений.

### Основные принципы протокола

IPFS (InterPlanetary File System) является протоколом децентрализованной файлообменной системы. Протокол использует концепцию DHT (см. 1.2) для распределения и поиска контента между участниками и MDAG (Merkle Directed Acyclic Graph) для организации удобной структуры связи контента. Как и протокол BitTorrent, IPFS не подразумевает хранения всех файлов на каждом из узлов системы: каждый участник системы хранит только ту часть контента, которую считает необходимой.

> * *Распределенное хранение контента*
> * *Древовидная структура связей контента (похожа на традиционную файловую систему)*
> * *Проверка и исключение дубликатов файлов*
> * *Возможность версионирования историй файлов*

Кроме контента, каждый из узлов хранит собственную таблицу хэш-значений. Напомним, что такая таблица содержит в себе связь между конкретным идентификатором и данными, которыми могут быть либо порция контента, либо сетевой адрес другого участника сети. 

Ключевой особенностью IPFS, в отличие от многих других протоколов, является поддержка версионирования контента. Например, вы загрузили документ в децентрализованную сеть (распространили его между другими участниками). После этого вы решили исправить некоторые ошибки и обновить документ. В системах, таких как BitTorrent, вы не можете заменить старый файл новым (теоретически это возможно, только если все узлы сети согласятся удалить старую версию). По сути, вы публикуете в сеть новый документ, который не имеет никакой связи со старым. Это не всегда хорошо по причине того, что многим приложениям, использующим версионирование, крайне неудобно работать с такой системой. IPFS также не позволяет заменить старый файл новым (после добавления файла в сеть удалить его можно, только если все согласятся это сделать). Однако IPFS поддерживает версионирование файлов, то есть при обновлении документа вы можете связать новую версию со старой. В качестве примеров можно привести работу Google Docs или GitHub – для таких продуктов очень важна история изменений и возможность восстановления старых копий.

### Как работает IPFS

IFPS устроен так же, как и BitTorrent, а именно предусматривает модель адресации контента, а не источников контента. Протокол также подразумевает разделение контента на файлы (фрагменты), причем размер одного такого файла не может превышать 256 KB. Каждому файлу соответствует собственный идентификатор – его хэш-значение. При этом протоколом строго не ограничено использование определенной хэш-функции (можно использовать SHA-1, SHA-256, KECCAK, SHAKE, X11, BLAKE, MD5 и т. д.). Отметим, что идентификатор хэш-функции используется как префикс идентификатора файла. Таким образом, пользователь точно сможет убедиться, что он загружает необходимый файл, используя нужный алгоритм хэширования, в зависимости от идентификатора.

Каждый IPFS-файл имеет структуру, приведенную в таблице 1.6.

<p align="center">
<img src="/resources/img/volume-2/1.5-Architecture-and-features-of-IPFS-protocol/Таблица-1.6.png" alt="Table 1.6" width="70%"/>
<p>

Файлы в IPFS можно разделить на четыре основных типа.

> **Типы файлов в IPFS**
> * *Blob (набор данных)*
> * *List (список)*
> * *Commit (состояние)*
> * *Tree (дерево)*

_Blob_ является конечным фрагментом и содержит в себе часть загруженного файла. _List_ содержит список ссылок на blobs (их идентификаторы) и/или ссылки на другие списки (одного списка не хватает для размещения идентификаторов всех частей файла, когда файл больше 8 МB). _Tree_ является файлом, в котором размещены ссылки на другие trees, lists и blobs. Разница между tree и list состоит в том, что list указывает на ссылки одного файла, а tree можно сравнить с каталогом (который содержит в себе множество разных каталогов и файлов). _Commit_ же представляет собой файл, который ссылается на родительский файл и содержит некоторые изменения.

Давайте схематически рассмотрим, что же представляет собой каждый файл в IPFS. Допустим, вы хотите отправить в сеть IPFS небольшой текстовый файл. Если он меньше 256 KB, тогда вы хэшируете файл и отправляете его идентификатор в сеть. Теперь с полученным идентификатором связан ваш текстовый файл, то есть blob (рис. 1.18).

<p align="center">
<img src="/resources/img/volume-2/1.5-Architecture-and-features-of-IPFS-protocol/Figure-1.18-Scheme-of-adding-a-small-file-to-the-blob-structure.png" alt="Рисунок 1.18 – Схема добавления небольшого файла в структуру blob" width="50%"/>
<p>

Рассмотрим, что такое список. Список представляет собой набор ссылок на blobs, из которых можно собрать цельный файл. Допустим, вы хотите отправить в сеть файл, превышающий размер в 256 KB (фотографию, видео и т. д.). Предположим, что для отправки этого файла вам необходимо разделить его на четыре части. После того, как вы это сделали и получили идентификаторы частей, они никак не связаны между собой. По этой причине вы создаете list, в котором указываете все идентификаторы фрагментов (аналогию можно провести с файлом .torrent). В таком случае, чтобы получить доступ ко всему файлу, участнику сети нужно получить list по его идентификатору (рис. 1.19).

<p align="center">
<img src="/resources/img/volume-2/1.5-Architecture-and-features-of-IPFS-protocol/Figure-1.19-Scheme-of-adding-a-large-file-to-the-list-structure.png" alt="Рисунок 1.19 – Схема добавления большого файла в структуру list" width="50%"/>
<p>

Отметим, что идентификатор list полностью зависит от идентификаторов blobs, которые, в свою очередь, зависят от содержимого частей файла. Если хотя бы одна часть подвергается модификации, этот list перестанет на него ссылаться. Однако, как мы упоминали ранее, IPFS предусматривает возможность версионирования, принцип функционирования которого мы рассмотрим далее.

Деревья (trees) представляют собой ссылки на большое количество различного контента. Деревья, как упоминалось выше, могут содержать ссылки на другие деревья, списки (lists) и файлы. Идентификатор дерева полностью зависит от идентификаторов всех его ссылок (поэтому изменение любого из файлов будет заметно). Схематически деревья можно представить следующим образом (рис. 1.20).

<p align="center">
<img src="/resources/img/volume-2/1.5-Architecture-and-features-of-IPFS-protocol/Figure-1.20-Tree-structure-formation-scheme.png" alt="Рисунок 1.20 – Схема формирования структуры tree" width="50%"/>
<p>

Теперь разберемся, что из себя представляют commits. Когда пользователь хочет обновить один из файлов, который он опубликовал в сеть, он не может просто удалить старый файл и добавить новый, так как сеть децентрализована и неизвестно, какой из узлов хранит этот файл. Также пользователь не может переопределить ссылку на старый файл таким образом, чтобы она указывала на новый, потому что идентификатор каждого фрагмента полностью зависит от его содержимого. Поэтому пользователю ничего не остается, кроме как добавить в сеть новый файл. В этом случае он будет обладать новым уникальным идентификатором. В протоколе BitTorrent такие два файла никак не могут быть связаны между собой на уровне протокола (только узлы, которые хранят файлы, могут сообщать другим, что у них хранится 2 или более версии одного файла).

IPFS позволяет связать все версии контента на уровне протокола. Для каждой новой версии создается commit-файл, который ссылается на родительский. Отметим, что если некоторые фрагменты не были изменены, то альтернативные trees и lists тоже ссылаются на эти фрагменты. Схематически commit представлен на рисунке 1.21.

<p align="center">
<img src="/resources/img/volume-2/1.5-Architecture-and-features-of-IPFS-protocol/Figure-1.21-Commit-structure-formation-scheme.png" alt="Рисунок 1.21 – Схема формирования структуры commit" width="50%"/>
<p>

### Использование IPFS

Перечисленные принципы функционирования позволяют строить ряд децентрализованных приложений поверх сети IPFS.

> **Децентрализованные приложения поверх IPFS**
>> * *Мессенджеры и электронная почта*
>> * *Медиаплатформы*
>> * *Системы управления версиями (Git)*
>> * *Сайты*

Как ни странно, одними из первых приложений, построенных поверх IPFS, стали именно мессенджеры. Принцип функционирования таких мессенджеров состоит в том, что изначально пользователь хэширует новое сообщение и отправляет его в сеть. Сообщения в чате связаны между собой в list, версия которого обновляется с каждым новым сообщением (commit). Среди таковых можно выделить чат Orbit [11] и PubSub Chat [66].

Конечно же, IPFS не мог не использоваться для мультимедийных приложений, которые предполагали обмен видео и музыкой. Протокол IPFS позволяет создать децентрализованные прототипы YouTube и Google Play Music, где серверами являются сами участники системы. К таким приложениям можно отнести dTube [12].

Система версионирования в IPFS позволила создание приложений, для которых требуется управление версиями. Представьте себе децентрализованный GitHub, который невозможно цензурировать со стороны государственных органов или коммерческих компаний. Такие проекты уже существуют, хотя и гораздо менее востребованы, чем централизованные продукты [13].

Еще одной областью применения IPFS является создание децентрализованных сайтов. Вместо того, чтобы держать сервер с сайтом, можно создать файл tree со ссылками на все его страницы. Таким образом, имея значение идентификатора файла tree сайта, каждый пользователь может загрузить все его страницы (исполняемые скрипты можно также поместить в отдельные файлы).

> **_Замечание._** *Самое интересное, что сайт IPFS также доступен в IPFS. *

### Filecoin

Несмотря на большое количество преимуществ, которые предоставляет децентрализованная система IPFS, у нее остается одно ключевое ограничение, которое очень сильно препятствует внедрению всех перечисленных приложений, – отсутствие мотивации пользователей хранить данные, которые не представляют для них интерес.

Многие читатели могут вспомнить ситуацию, когда они загружали все фрагменты торрент-файла, после чего останавливали работу узла сети и прекращали раздавать хранимого контента. И это относится к тому контенту, который необходим некоторому пользователю. Что же тогда говорить о тех файлах, к которым пользователь не имеет никакого отношения?

Поэтому компания Protocol Labs (кстати, она же предложила и саму IPFS) представила Filecoin – проект, который способен в какой-то мере решить эту проблему. Давайте рассмотрим основные концепции протокола.

> * *Участники сети платят за хранение и получение данных*
> * *Участники сети получают вознаграждение за хранение данных*
> * *Заявки на выполнение услуг децентрализованной сети*
> * *Хранитель данных регулярно предоставляет доказательство их хранения*

Основная идея Filecoin состоит в том, чтобы участники системы, которые хотят хранить свои данные в системе либо получать доступ к другим данным, оплачивали услуги при помощи встроенной валюты. Задача майнеров в этом случае – обеспечивать хранение данных и их предоставление по запросу за соответствующую плату. Каждый владелец узла-майнера лично определяет объем предоставляемого дискового пространства.

Цена за хранение фрагмента формируется в зависимости от спроса и предложения. Майнеры отправляют свои предложения относительно количества предоставляемого пространства и стоимости записи. Другие же пользователи отправляют предложения с количеством монет, которые они готовы заплатить за хранение своих данных (orders). После того, как предложения сопоставляются, участники создают транзакцию, в которой клиент платит майнеру маленькими частями через определенный промежуток времени. Отметим, что для получения вознаграждения майнер через эти промежутки времени должен доказывать, что контент все еще хранится у него.

### Алгоритм достижения консенсуса в Filecoin

В протоколе Filecoin был предложен алгоритм достижения консенсуса proof-of-spacetime, в котором вероятность добычи блока участником сети зависит не от вычислительной мощности его узла, а от размера хранилища, которое он использует для хранения данных (по отношению ко всем остальным участникам сети). В отличие от классического proof-of-capacity (детальнее в 5.4), алгоритм достижения консенсуса в Filecoin предполагает хранение не произвольных данных (бесполезных, необходимых только для доказательства заполнения хранилища), а тех, которые необходимы пользователям, то есть полезного контента.

Каждый узел сети, который занимается хранением данных, участвует в достижении консенсуса. При этом хранилище каждого майнера является общедоступным, то есть каждый участник сети может получить информацию о выделяемом майнером объеме хранилища и записать туда свои данные. Также хранилище является публично проверяемым: для каждого сегмента хранилища майнеры должны генерировать proof-of-spacetime для подтверждения того, что они действительно хранят соответствующие данные (стоит отметить, что доказательство не раскрывает никакой информации о хранимом контенте, то есть это zero-knowledge proof). В любой момент времени майнер может увеличить объем хранилища и предоставить его для использования участникам сети.

### Преимущества протокола Filecoin

Протокол Filecoin построен таким образом, что позволяет достичь ряда свойств, которые необходимы в децентрализованной файлообменной системе.

> * *Мотивированное хранение данных и наказание недобросовестных участников системы*
> * *Каждый участник сети может проверить, что майнер хранит определенные данные (auditability), при этом не имея доступ к фактическому содержимому (zero knowledge)*
> * *Возможность доступа к хранимым данным с течением времени (retrievability)*
> * *Возможность обеспечения конфиденциальности данных (confidentiality)*

Протокол Filecoin предусматривает получение вознаграждения активными участниками системы. Во-первых, такие участники получают вознаграждение за формирование блоков. Во-вторых, вознаграждение платится за фактическое хранение полезных данных.

***Часто задаваемые вопросы***

*– Могут ли данные, добавленные в IPFS, быть удалены и сколько это займет времени?*

Да, данные могут быть удалены, но при этом существуют некоторые особенности. Процессы добавления и удаления данных в децентрализованной файлообменной системе сильно отличаются от таковых при использовании централизованного хранилища. Особенности заключаются в том, что данные хранятся несколькими независимыми сторонами, и могут быть удалены, только если их удалили все хранители. Чаще всего у хранителей данных нет причин хранить данные, за которые они не получают деньги, поэтому очень часто процесс удаления данных из сети занимает до нескольких минут или часов. Однако если хранители по каким-то причинам не хотят удалять данные, то, фактически, они остаются в сети, и их владелец не может повлиять на их удаление.

*– Могут ли данные, добавляемые в IPFS, быть зашифрованы?*

Да, клиент может зашифровать данные перед отправкой их в сеть и, на самом деле, шифрование данных распространенная практика в сети IPFS. Узлам неважно, в каком виде и какие данные хранить. Зашифрованные данные могут также быть индексированы и помещены в сеть. Единственным отличием является возможность доступа к содержимому хранимых данных только при наличии соответствующего ключа.

*— Можно ли развернуть на основе IPFS частную сеть?*

Да, на основе IPFS можно создать частную сеть [14; 15]. Для этого нужен собственный узел, который будет соединять клиентов друг с другом (подключаться к публичному нет смысла, поскольку в таком случае сеть будет публичной), и _swarm key_, который будет у всех участников сети. Swarm key – это идентификатор, который позволяет узлам IPFS подключаться друг к другу. Например, если два узла пытаются связаться между собой и у одного из них присутствует swarm key, наличие аналогичного ключа проверяется у другого узла. Если ключи есть и совпадают, узлы соединяются.

[КРИПТОГРАФИЯ В ДЕЦЕНТРАЛИЗОВАННЫХ СИСТЕМАХ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-2/ru/2-cryptography-in-decentralized-systems.md)
