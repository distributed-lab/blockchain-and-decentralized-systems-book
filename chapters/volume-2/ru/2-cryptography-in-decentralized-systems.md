# 2 КРИПТОГРАФИЯ В ДЕЦЕНТРАЛИЗОВАННЫХ СИСТЕМАХ

## 2.1 Генерация и обработка ключевых данных

Криптография является наиболее востребованным на сегодняшний день механизмом защиты данных, так как она опирается только на математические законы, а не физическую защищенность каналов передачи или серверов хранения информации. Эффективность криптографии основывается на двух компонентах: стойкость криптографических алгоритмов и защищенность ключевых данных (ключей) [16].

В этом подразделе мы рассмотрим основные моменты, связанные с генерацией и обработкой ключевых данных.

### Основные функции ключей

Прежде чем рассмотреть основные функции ключей, разберем, что такое криптографический ключ. _Криптографический ключ (cryptographic key) – это битовая последовательность, которая контролирует выполнение криптографического преобразования данных (криптографического алгоритма)_ [17]. 

> * _Зашифрование данных_
> * _Расшифрование данных_
> * _Вычисление (генерация) цифровой подписи_
> * _Проверка цифровой подписи_
> * _Вычисление MAC (message authentication code)_
> * _Верификация MAC_
> * _Вычисление общего секрета_
> * _Выработка дополнительных ключевых данных_

Рассмотрим, как безопасность ключей может повлиять на использование перечисленных криптографических алгоритмов. Напомним, что при помощи шифрования можно обеспечить конфиденциальность данных (сокрытие содержания от стороннего наблюдателя). Если криптографический алгоритм является стойким, то доступ к исходному сообщению (plain text) можно получить только при наличии соответствующего ключа расшифрования.

В контексте цифровой подписи ключи также играют важную роль. Напомним, что пользователь при помощи своего личного ключа подписывает исходное сообщение, а вторая сторона, используя открытый ключ пользователя, может проверить подпись. В этом случае, если злоумышленник получит доступ к личному ключу пользователя, он также сможет отправлять сообщения от его имени. Можно только представить, к чему это может привести.

Давайте рассмотрим, что такое _MAC_ (Message Authentication Code, код аутентификации сообщения), и разберемся, почему для этого типа криптографических алгоритмов важна надежность криптографического ключа. Значение MAC концептуально очень близко к значению цифровой подписи, за исключением того, что MAC вычисляется и проверяется при помощи секретного ключа (рис. 2.1).

<img align="center" width="70%" src="/resources/img/volume-2/2.1-Key-data-generation-and-processing/Figure-2.1-MAC-function-operation-scheme.png" alt="Рисунок 2.1 – Схема функционирования MAC-функции"/>

Из объяснения выше (и рисунка) мы видим, что секретный ключ задействован как при вычислении кода аутентификации сообщения, так и при его проверке. Это значит, что если злоумышленник получит ваш ключ, он также сможет отправлять сообщения от вашего имени.

Ключи используются и для формирования общего секрета, когда общий ключ шифрования формируется за счет использования ключей нескольких пользователей. 

Еще один вариант использования ключа – выработка дочерних ключей, которые, в свою очередь, используются в упомянутых криптографических операциях. Такой подход, например, используется в HD wallets.

### Жизненный цикл ключа

Криптографический ключ проходит через последовательность состояний, которые определяют его жизненный цикл (рис. 2.2). Основными состояниями являются:

* ожидание: ключ сгенерирован, но не активируется для использования;
* активное: ключ используется для криптографического преобразования информации;
* постактивное: ключ должен использоваться только для расшифровки или проверки.

<img align="center" width="40%" src="/resources/img/volume-2/2.1-Key-data-generation-and-processing/Figure-2.2-The-lifecycle-of-a-key.png" alt="Рис 2.2 – Жизненный цикл ключа"/>

Рассмотрим процессы, связанные с использованием криптографических ключей:
 * генерация;
 * введение в действие: ключ становится пригодным для криптографических преобразований и распространяется в сеть;
 * приостановление действия: ограничение использования ключа (причиной может быть окончание срока действия ключа или его отзыв);
 * возобновление действия: ранее деактивированный ключ можно вновь использовать для криптографических преобразований;
 * уничтожение: завершение жизненного цикла ключа (происходит логическое уничтожение ключа).

Сначала ключевые данные должны быть сгенерированы, после чего они переходят в состояние ожидания, в котором не используются для криптографических операций. Если на протяжении длительного времени такие ключи не были использованы, они могут быть уничтожены.

Когда ключи используются для криптографического преобразования данных (шифрование, подпись и т. д.), они переходят в активное состояние.

Когда ключи находятся в постактивном состоянии, они могут использоваться только для расшифрования и проверки криптографической подписи (либо значения MAC). Из этого состояния возможен переход в активное состояние (использование ключей для преобразования данных) либо их уничтожение.

### Принципы генерации ключей

Криптографические ключи могут быть получены несколькими способами.
> * _С использованием генератора случайных/псевдослучайных чисел_
> * _Выработка из другого ключа (или пароля)_
> * _Согласование общего ключа_

### Генераторы случайных последовательностей

Структурно основным отличием генератора случайных последовательностей от генератора псевдослучайных последовательностей является то, что в первом источник энтропии обязательно должен иметь физический датчик шума. Подбрасывание монеты, игральные кости, оптоэлектронные системы слежения за броуновским движением – вот примеры случайных механических перемещений, которые снимают простейшими физическими датчиками шума.

Из-за этого основного отличия генераторы случайных последовательностей преимущественно реализованы аппаратно. В современных генераторах случайных последовательностей чаще всего используются электронные датчики шума с широким спектром частот. Случайные изменения параметров (тепловой шум) наблюдаются во всех электронных компонентах при температурах выше абсолютного нуля (по Кельвину), из-за чего как физические датчики шума могут использоваться любые электронные компоненты, такие как резисторы, кремниевые диоды, электронные лампы и т. п. Построить хороший аппаратный генератор, с несмещенными и некоррелированными последовательностями, на деле представляет собой сложный процесс.

### Генераторы псевдослучайных последовательностей

Как мы уже упоминали ранее, псевдослучайная последовательность является последовательностью, характеристики которой приближаются к случайной последовательности, однако которую можно повторить при определенных условиях.

На рисунке 2.3 изображена модель детерминированного (псевдослучайного) генератора последовательностей. По умолчанию каждый из элементов, изображенных ниже, должен присутствовать в генераторе.

<img align="center" width="40%" src="/resources/img/volume-2/2.1-Key-data-generation-and-processing/Figure-2.3-Deterministic-sequence-generator-model.png" alt="Рисунок 2.3 – Модель детерминированного генератора последовательностей"/>

Рассмотрим работу генератора псевдослучайных  последовательностей: 

1. Начальное значение загружается во внутреннее состояние специальной функцией перехода внутреннего состояния (seed), доступ к которой имеют только авторизованные субъекты.

2. Внутреннее состояние модифицируется функцией перехода внутреннего состояния, которая принимает в качестве входных данных нынешнее внутреннее состояние, любые дополнительные входные данные, предоставленные пользователем, и выходные данные источника энтропии.

3. Выходные данные вычисляются функцией генерации выходных данных, которая принимает в качестве входного значения модифицированное внутреннее состояние.

4. Функция перехода внутреннего состояния (re-seed) обновляет внутреннее состояние при подаче нового начального значения, и в зависимости от этой функции текущее внутреннее состояние может как зависеть от предыдущего, так и не зависеть.

Основными требованиями к генераторам псевдослучайных последовательностей являются непредсказуемость, восстановимость, временная сложность, необратимость, статистические свойства, не отличимые от случайной последовательности, и период повторения, который должен быть не менее необходимого.

### Тестирование генераторов случайных и псевдослучайных последовательностей

Стоит учитывать, что для генераторов случайных и псевдослучайных последовательностей требуется проверка случайности выдаваемого результата.

Рассмотрим наиболее распространенный среди разработчиков средств криптографической защиты информации статистический тест NIST STS, который используется для оценки случайности генераторов случайных и псевдослучайных последовательностей. Пакет NIST STS имеет 15 статистических тестов, по которым в результате тестирования формируется вектор вероятности *P = {P<sup>1</sup>, P<sup>2</sup>, …, P<sup>n</sup>}* анализ составляющих *P<sup>i</sup>* которого позволяет указать на конкретные дефекты случайности тестируемой последовательности. Список тестов и общее их описание указаны в таблице 2.1 [67].

Таблица 2.1 — Список тестов и их описания

| # |  Название теста  | Описание теста |
|:-:|-------------|------------------|
| 1 | _Частотный побитовый тест_|Суть этого теста заключается в определении соотношения между нулями и единицами во всей двоичной последовательности. Цель – выяснить, действительно ли число нулей и единиц в последовательности приблизительно одинаковы.|
| 2 | _Частотный блочный тест_| Суть теста – определение доли единиц внутри блока длиной m бит. Цель – выяснить, действительно ли частота повторения единиц в блоке длиной m бит приблизительно равна m/2.|
| 3 | _Тест на последовательность одинаковых битов_ | Суть состоит в подсчете полного числа рядов в исходной последовательности, где под словом «ряд» подразумевается непрерывная подпоследовательность одинаковых битов. Цель данного теста – сделать вывод о том, действительно ли количество рядов, состоящих из единиц и нулей с различными длинами, соответствует их количеству в случайной последовательности.    |
| 4 |_Тест на самую длинную последовательность единиц в блоке_| В данном тесте определяется самый длинный ряд единиц внутри блока длиной m бит. Цель – выяснить, действительно ли длина такого ряда соответствует ожиданиям длины самого протяженного ряда единиц при абсолютно случайной последовательности.|
|5  | _Тест рангов бинарных матриц_  | Здесь производится расчет рангов непересекающихся подматриц, построенных из исходной двоичной последовательности. Целью этого теста является проверка на линейную зависимость подстрок фиксированной длины, составляющих первоначальную последовательность. |
|6  | _Спектральный тест_  | Суть теста заключается в оценке высоты пиков дискретного преобразования Фурье исходной последовательности. Цель – выявление периодических свойств входной последовательности, например, близко расположенных друг к другу повторяющихся участков.|
|7  | _Тест на совпадение неперекрывающихся шаблонов_ |  В данном тесте подсчитывается количество заранее определенных шаблонов, найденных в исходной последовательности. Цель – выявить генераторы случайных или псевдослучайных чисел, формирующие слишком часто заданные непериодические шаблоны.|
|8  | _Тест на совпадение перекрывающихся шаблонов_   | Суть данного теста заключается в подсчете количества заранее определенных шаблонов, найденных в исходной последовательности. Разница между этим тестом и тестом № 7 заключается лишь в том, что если шаблон найден, окно перемещается только на бит вперед, после чего поиск продолжается дальше.|
|9  |_Универсальный статистический тест Маурера_  | Здесь определяется число бит между одинаковыми шаблонами в исходной последовательности (мера, имеющая непосредственное отношение к длине сжатой последовательности). Цель теста – выяснить, может ли данная последовательность быть значительно сжата без потерь информации. |
|10  | _Тест на линейную сложность_ | В основе теста лежит принцип работы линейного регистра сдвига с обратной связью (Linear Feedback Shift Register, LFSR). Цель – выяснить, является ли входная последовательность достаточно сложной для того, чтобы считаться абсолютно случайной.|
|11  | _Тест на периодичность_  | Данный тест заключается в подсчете частоты всех возможных перекрываний шаблонов длины m бит на протяжении исходной последовательности битов. Целью является определение того, действительно ли количество появлений 2m перекрывающихся шаблонов длиной m бит приблизительно такое же, как при абсолютно случайной входной последовательности бит.|
|12  |_Тест приблизительной энтропии_   | Как и в тесте на периодичность, в этом тесте акцент делается на подсчете частоты всех возможных перекрываний шаблонов длины m бит на протяжении исходной последовательности битов. Цель теста – сравнить частоты перекрывания двух последовательных блоков исходной последовательности с длинами m и m+1 с частотами перекрывания аналогичных блоков в абсолютно случайной последовательности.|
|13  | _Тест кумулятивных сумм_  | Тест заключается в максимальном отклонении (от нуля) при произвольном обходе, определяемым кумулятивной суммой заданных (-1, +1) цифр в последовательности. Цель данного теста – определить, является ли кумулятивная сумма частичных последовательностей, возникающих во входной последовательности, слишком большой или слишком малой по сравнению с ожидаемым поведением такой суммы для абсолютно случайной входной последовательности. |
|14  | _Тест на произвольные отклонения_ | Суть данного теста заключается в подсчете числа циклов, имеющих строго k вхождений при произвольном обходе кумулятивной суммы. Цель данного теста – определить, отличается ли количество вхождений определенного состояния внутри цикла от аналогичного количества в случае абсолютно случайной входной последовательности. |
|15  | _Другой тест на произвольные отклонения_  | В этом тесте подсчитывается общее количество вхождений определенного состояния при произвольном обходе кумулятивной суммы. Целью является определение отклонений от ожидаемого количества вхождений различных состояний при произвольном обходе. |

### Функции выработки ключей

_Функция выработки ключей (Key Derivation Function, KDF) – это функция, формирующая один или несколько секретных ключей на основе определенного секретного значения с помощью псевдослучайной функции._ Принципы работы таких функций очень похожи на принципы работы хэш-функций, то есть функция выработки ключей является однонаправленной (очень часто в качестве псевдослучайной функции используют memory hard криптографические хэш-функции). Однонаправленность функций выработки ключей не позволяет узнать информацию об исходном секретном значении или о любом из других сформированных ключей.

Функции выработки ключа на основе пароля часто используются для хэширования паролей и их последующей верификации. В этом случае в качестве параметра, используемого в связке с секретным паролем, используется значение salt.

**Часто задаваемые вопросы**

*– Насколько безопасно использовать пароль для выработки секретного ключа?*

Для выработки ключевых данных из пароля рекомендуется использовать случайный пароль большой длины. Таким образом если вы используете случайный пароль длинной, к примеру, в 20 символов (при этом используете верхний и нижний регистры и числовые значения), то фактически для перебора этого пароля и получение ключевой информации злоумышленнику понадобится около $2^{120}$ попыток, что вполне приемлемо (особенно при использовании memory hard хэш-функций). Однако на практике такой пароль очень сложно запоминать, и очень часто пользователи используют гораздо меньшее значение, которое, вдобавок, не является случайным, а ассоциируется с датой рождения, кличкой домашнего животного и т. д.

*– Какие еще существуют тесты случайных последовательностей помимо NIST STS?*

Помимо NIST STS существует много разных тестов генераторов случайных последовательностей. Вот самые известные из них:

* Diehard: «классический» набор статистических тестов, разработанный George Marsaglia и впервые опубликованный в 1995-м году.
* TestU01: набор статистических тестов, сравнимый с Diehard. Включает в себя реализации «классических» и несколько сторонних, предложенных в литературе статистических тестов.
* Dieharder: набор статистических тестов, включающий в себя все тесты из Diehard, NIST STS и несколько дополнительных тестов, разработанных RGB.

*– Что такое атака компромисса времени и памяти?*

Компромисс времени и памяти – это подход, который позволяет увеличить или уменьшить время требуемое на вычисления за счет, соответственно, уменьшения или увеличения объема используемой для этих вычислений памяти. В криптоанализе данный подход на основе компромисса времени и памяти используется для сокращения времени атаки грубой силы. В качестве примера можно привести таблицы поиска прообраза хэш-функции. Если изначально выполнить исчерпывающий перебор, можно хранить полученные значения в памяти, осуществляя последующий перебор практически мгновенно.

## 2.2 Протоколы обмена ключами

Одна из главных задач при обмене ключами или другими данными – осуществить обмен так, чтобы никакая неавторизованная сторона не могла получить доступ к данным передаваемым в канале. Как правило, это требует наличия доверенной третьей стороны или иного безопасного канала.

*Протоколы обмена ключами (key exchange protocols)* используются для создания защищенного канала связи между пользователями. Они включают в себя протоколы распределения ключей и протоколы согласования ключей.

*Протокол согласования ключей (key agreement protocol)* – установленная последовательность действий пользователей по созданию защищенного канала связи путем формирования общего секретного ключа. Основная особенность состоит в том, что каждая сторона вносит одинаковый вклад в создание общего секретного ключа.

*Протокол распределения ключей (key distribution protocol)* – это установленная последовательность действий пользователей по созданию защищенного канала связи, заключающаяся в генерации и обмене сеансовыми ключами и аутентификации сообщений.

Основной задачей протоколов распределения ключей является выработка участниками (Алисой и Бобом) общего ключа. Вместе с тем, и Боб, и Алиса должны быть уверены в том, что связь ведется именно с собеседником, а не со злоумышленником или подставным лицом. Большинство подобных протоколов основываются на существовании доверенного центра (Трент), и предполагается, что каждому пользователю Трент выделяет секретный ключ. Таким образом, перед началом работы протокола все ключи уже находятся у пользователей.

Все протоколы распределения ключей так или иначе делятся на следующие категории (пересекающиеся):
> * *Протоколы, основанные на симметричной криптографии*
> * *Протоколы, основанные на асимметричной криптографии*
> * *Протоколы, использующие центр сертификации (доверенный центр)*

Также существуют следующие модели распределения ключей:
> * *Передача ключей при личной встрече*
> * *С использованием предыдущего ключа*
> * *С использованием доверенной третьей стороны*

Однако отметим, что все данные методы в конечном счете сводятся к личной встрече субъектов.

При симметричном шифровании два участника, которые хотят обмениваться конфиденциальной информацией, должны иметь один и тот же ключ. Частота изменения ключа должна быть достаточно большой, чтобы у противника не хватило времени для полного перебора ключа. Следовательно, стойкость любой криптосистемы во многом зависит от технологии распределения ключа. Этот термин означает передачу ключа двум участникам, которые хотят обмениваться данными таким способом, чтобы никто другой не мог ни перехватить, ни изменить этот ключ. Для двух участников, Алисы и Боба, распределение ключа может быть выполнено одним из следующих способов:

> * _Ключ может быть создан Алисой и физически передан Бобу (либо наоборот)_
> * _Третья сторона может создать ключ и физически передать его Алисе и Бобу_
> * _Алиса и Боб имеют предварительно созданный и недолго используемый ключ_
> * _Если и Алиса, и Боб имеют безопасное соединение с третьим участником (Кэрол), то он может передать ключ по этому безопасному каналу от Алисы к Бобу_

Первый и второй способы называются ручным распределением ключа. Это самые надежные способы распределения ключа, однако во многих случаях пользоваться ими неудобно или даже невозможно. В распределенной системе любой узел или сервер должен иметь возможность обмениваться конфиденциальной информацией со многими аутентифицированными узлами и серверами. Таким образом, каждый узел должен иметь набор ключей, поддерживаемый динамически. Проблема особенно актуальна в больших распределенных системах.

Количество требуемых ключей зависит от числа участников, которые должны взаимодействовать. Если выполняется шифрование на сетевом или транспортном уровне, то ключ необходим для каждой пары узлов в сети. Таким образом, если есть N узлов, то необходимое число ключей равно $\frac{N(N-1)}{2}$. Если шифрование выполняется на прикладном уровне, то ключ нужен для каждой пары прикладных процессов, которых гораздо больше, чем узлов.

Третий способ распределения ключей может применяться на любом уровне стека протоколов, но если атакующий получает возможность доступа к одному ключу, то вся последовательность ключей будет раскрыта. Более того, все равно должно быть проведено первоначальное распространение большого количества ключей.

Поэтому в больших автоматизированных системах широко применяются различные варианты четвертого способа. В этой схеме предполагается существование так называемого _центра распределения ключей_ (Key Distribution Centre, KDC), который отвечает за распределение ключей для узлов, процессов и приложений. Каждый участник должен разделять уникальный ключ с KDC.

Использование центра распределения ключей основано на использовании иерархии ключей. Как минимум используется два типа ключей: мастер-ключи и ключи сессии.
Для обеспечения конфиденциальной связи между конечными системами используется временный ключ, называемый ключом сессии. Обычно ключ сессии используется для шифрования соединения на транспортном уровне и затем уничтожается. Каждый ключ сессии должен быть получен по сети из центра распределения ключей. Ключи сессии передаются в зашифрованном виде, используя мастер-ключ, который разделяется между центром распределения ключей и конечными пользователями.

Эти мастер-ключи также должны распределяться некоторым безопасным способом. Однако при этом существенно уменьшается количество ключей, требующих ручного распределения. Если существует N участников, которые хотят устанавливать соединения, то в каждый момент времени необходимо $\frac{N(N-1)}{2}$ ключей сессии, но только _N_ мастер-ключей (по одному для каждого участника).

Время жизни ключа сессии, как правило, равно времени жизни самой сессии. Чем чаще меняются ключи сессии, тем более безопасными они являются, так как противник имеет меньше времени для взламывания ключа текущей сессии. С другой стороны, распределение ключей сессии задерживает начало любого обмена и загружает сеть. Политика безопасности должна сбалансировать эти условия для определения оптимального времени жизни конкретного ключа сессии.

Если соединение имеет долгое время жизни, то должна существовать возможность периодически менять ключ сессии.

Для протоколов, не поддерживающих соединение, таких как протокол, ориентированный на транзакции, нет явной инициализации или прерывания соединения. Следовательно, нет четких рекомендаций, как часто надо менять ключ сессии. Большинство подходов основывается на использовании нового ключа сессии для каждого нового обмена. Наиболее часто применяется стратегия использования ключа сессии только для фиксированного периода времени или только для определенного количества подписываемых сообщений.

### Протокол Диффи–Хеллмана

Протокол Диффи–Хеллмана (Diffie–Hellman, DH) – криптографический протокол согласования ключей, позволяющий двум и более сторонам получить общий секретный ключ, используя не защищенный от прослушивания канал связи. Полученный ключ используется для шифрования дальнейшего обмена с помощью алгоритмов симметричного шифрования.

Схема распределения открытых ключей, которую предложили Бэйли Уитфилд Диффи и Мартин Эдвард Хеллман, произвела настоящую революцию в мире шифрования, так как снимала основную проблему классической криптографии – проблему распределения ключей.

В чистом виде протокол Диффи–Хеллмана уязвим для модификации данных в канале связи, в том числе для атаки man-in-the-middle (человек посередине), поэтому схемы с его использованием применяют дополнительные методы односторонней или двусторонней аутентификации.

Рассмотрим протокол Диффи–Хеллмана, который используется при формировании общего секрета долгосрочных ключей. В криптосистеме существуют два больших простых числа как общедоступные параметры _p_ и _g_ (_p_ – значение модуля, _g_ – генератор группы).

Представим, что имеется канал передачи между тремя субъектами: Алисой, Бобом и Кэрол. Алисе и Бобу требуется создать общий секрет, который не будет знать Кэрол, которая при этом видит все, что они передают по каналу связи. Для создания общего секрета:
1. Алиса и Боб случайным образом формируют личные ключи _1 < a < p_ (Алиса) и _1 < b < p_ (Боб).
2. С помощью личных ключей каждый из них создает свой открытый ключ *A = q<sup>a</sup> mod p* (Алиса), *B = q<sup>b</sup> mod p* (Боб).
3. Затем обмениваются ими по незащищенному каналу.
4. Обменявшись открытыми ключами, Алиса и Боб могут сформировать общий секрет *S = B<sup>a</sup>  mod p = A<sup>b</sup> mod p = g<sup>ab</sup> mod p* (рис. 2.4).

<img align="center" width="50%" src="/resources/img/volume-2/2.2-Key-exchange-protocols/Figure-2.4-Diffie-Hellman-protocol-operation-scheme.png" alt="Рисунок 2.4 – Схема функционирования протокола Диффи–Хеллмана"/>                     

Используя общий секрет _S_ и одну функцию формирования ключа (здесь назовем ее _fk_), каждый из абонентов может сформировать согласованный ключ _K_, например, _K = fk(S, par)_, где _par_ – это параметры согласованного ключа. Большей криптографической стойкости можно достичь, отдельно формируя по тому же принципу сеансовые ключи при каждом сеансе связи.

Отметим, что данный алгоритм уязвим для атак man-in-the-middle. Если противник может осуществить активную атаку, то есть имеет возможность не только перехватывать сообще­ния, но и подменять их другими, он может перехватить открытые ключи участников _A_ и _B_, создать свою пару открытого и закрытого ключа и послать каждому из участников свой открытый ключ. Пос­ле этого каждый участник вычислит ключ, который будет общим с противником, а не с другим участником. Если нет контроля це­лостности, то участники не смогут обнаружить подобную подме­ну. Осуществление такой атаки требует большого объема ресур­сов, и в реальном мире такие атаки происходят редко.

### Протокол Диффи–Хеллмана на эллиптических кривых

Также протокол Диффи–Хеллмана может работать на эллиптических кривых (ECDH). В этом случае Алиса и Боб имеют по секретному ключу _а_, _b_ и по открытому ключу *Q<sub>a</sub>*, *Q<sub>b</sub>*. Каждый из открытых ключей сформирован путем проведения _n_-го количества операций суммирования точки _G_.  

1. Алиса и Боб формируют открытые ключи: *Q<sub>a</sub> = а ∗ G*, *Q<sub>b</sub> = b ∗ G*.  
2. Алиса и Боб обмениваются открытыми ключами.
3. Получив открытые ключи друг друга, каждый из них вычисляет (*X<sub>s</sub>*, *Y<sub>s</sub>*) = *a ∗ Q<sub>b</sub> = b ∗ Q<sub>a</sub> = a ∗ b ∗ G*, где точка *X<sub>s</sub>* является общим секретом. Большинство стандартных протоколов, базирующихся на ECDH, используют функции формирования ключа для получения симметричного ключа из значения *X<sub>s</sub>* (рис. 2.5).

<img align="center" width="50%" src="/resources/img/volume-2/2.2-Key-exchange-protocols/Figure-2.5-Scheme-of-interaction-according-to-ECDH-protocol.png" alt="Рисунок 2.5 – Схема взаимодействия по протоколу ECDH"/>                     

Из всей информации, связанной с секретным ключом, Алиса и Боб разглашают только свои открытые ключи. Чтобы Кэрол узнала общий секрет, а также секретные ключи Алисы и Боба, ей понадобится решить задачу дискретного логарифмирования на эллиптической кривой, что может занять довольно продолжительный промежуток времени.

### Протокол EKE

Протокол EKE (Encrypted Key Exchange) является протоколом распределения ключей, который предоставляет возможность защищенного обмена данными между пользователями в сети, используя симметричную и асимметричную криптографию. Протоколом предполагается, что Алиса и Боб владеют общим секретом _S_ (данный секрет может быть даже с низкой энтропией, например, пароль) и что, используя этот протокол, они могут аутентифицировать друг друга и сформировать сессионный ключ _K_ (рис. 2.6). 

<img align="center" width="50%" src="/resources/img/volume-2/2.2-Key-exchange-protocols/Figure-2.6-Scheme-of-operation-of-the-EKE-protocol-participants.png" alt="Рисунок 2.6 – Схема работы участников протокола EKE"/>    

Давайте опишем каждый из шагов функционирования протокола:

1. Алиса генерирует ключевую пару и шифрует открытый ключ _A_ из этой пары общим секретным ключом _S_. После этого Алиса посылает зашифрованное сообщение Бобу. Стоит отметить, что открытый ключ _A_ передается в зашифрованном виде для того, чтобы только Боб имел возможность сформировать зашифрованное на этом ключе сообщение.
2. Боб, получив сообщение от Алисы, расшифровывает его и узнает _A_, после чего он генерирует симметричный ключ _K_, который и будет их общим с Алисой сессионным ключом. Боб шифрует _K_ полученным от Алисы ключом _A_, а потом общим секретным ключом _S_.
3. Алиса, получив ответ от Боба, расшифровывает это сообщение и узнает из него сессионный ключ _K_. После установления сессионного ключа начинается процесс взаимной аутентификации. Алиса генерирует случайное значение *R<sub>a</sub>*, шифрует его с помощью _K_ и посылает Бобу.
4. Боб расшифровывает это сообщение, узнает из него *R<sub>a</sub>* и генерирует свое случайное значение *R<sub>b</sub>*. Далее Боб конкатенирует *R<sub>b</sub>* с *R<sub>a</sub>* и шифрует результат ключом _K_. После чего передает полученное Алисе.
5. Алиса расшифровывает сообщение Боба, убеждается, что *R<sub>a</sub>* такое же, какое она посылала Бобу на шаге 3, и отвечает Бобу зашифрованным при помощи _K_ сообщением с его *R<sub>b</sub>*.
6. Боб расшифровывает ответ Алисы и убеждается, что *R<sub>b</sub>* такое же, какое он посылал Алисе на шаге 4. 
7. Протокол закончен. Обе стороны в дальнейшем для обмена информацией пользуются сессионным ключом _K_.

**Часто задаваемые вопросы**

*— Как выполняется атака человека посередине?*

Как мы упоминали ранее, каждая сторона передает другой свой открытый ключ. Фактически, если отсутствует механизм обеспечения аутентичности передаваемых сообщений, то принимающая сторона не может убедиться, что полученный ключ действительно принадлежит второй стороне. В итоге, злоумышленник может отправить свои значения открытых ключей обеим сторонам и сформировать общий секрет с каждой из них. После этого он может выполнять роль ретранслятора: получать сообщение от одной стороны, ознакамливаться с его содержимым и передавать второму субъекту. Более того, злоумышленник может изменять эти сообщения.

*— Можно ли использовать протокол Диффи–Хеллмана для более чем двух участников?*

Да, этот протокол позволяет выработать общий секрет между любым количеством сторон. Но для большего количества участников протокол взаимодействия более сложный и требует выполнения большего количества последовательных этапов.

*— В чем преимущества использования инфраструктуры открытых ключей совместно с протоколом Диффи–Хеллмана?*

В случае отсутствия механизмов аутентификации при использовании протокола Диффи–Хеллмана нарушитель (в роли которого выступает человек посередине) может выдавать себя за целевую сторону, с которой согласовывается ключ. Таким образом, Алиса обменивается открытыми ключами и формирует совместный секрет не с Бобом, а с нарушителем. Поэтому протокол Диффи–Хеллмана часто используется совместно с инфраструктурой открытых ключей, которая является источником информации об открытых ключах и их владельцах.

## 2.3 Концепция Merkle tree и ее применение

Концепция построения таких деревьев была опубликована в 1979 году Ральфом Мерклом, после чего нашла широкое применение как для проверки целостности больших объемов данных, так и в системах контроля версий и криптографических алгоритмах цифровой подписи.

Мы уже упоминали про деревья Меркла в первой части учебного пособия. В данном разделе мы детально опишем процесс верификации данных при помощи деревьев Меркла, углубимся в свойства, которые такая структура может предоставить и рассмотрим основные сферы применения данной концепции.

### Структура деревьев Меркла

Дерево Меркла – это один из основных способов хэширования больших объемов данных. Структуру дерева Меркла можно разбить на компоненты, как на рисунке 2.7.

>**Структурные компоненты Merkle tree**
>> * _Merkle root (корень)_
>> * _Merkle nodes (узлы)_
>> * _Merkle leaves (листья)_

<img align="center" width="60%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.7-Merkle-tree-structure.png" alt="Рисунок 2.7 – Структура дерева Меркла"/>    

Листья дерева представляют собой хэш-значения от произвольных данных (Data). Каждый из листьев и узлов одного дерева равен по размеру, и этот размер зависит от используемой хэш-функции. Количество листьев в дереве Меркла определяется значением 2<sub>h</sub>, где h – высота дерева Меркла (на рисунке высота дерева Меркла равна 2).

Узел дерева Меркла представляет собой хэш-значение от конкатенации двух дочерних листьев (или узлов). Размер каждого узла идентичен размеру листьев и также определяется параметрами используемой хэш-функции.

Корень дерева представляет собой узел, который находится на вершине дерева. Корневой узел связан со всеми дочерними узлами и листьями: изменение одного из узлов или листьев дерева приведет к изменению значения его корня.

Базовую идею построения дерева Меркла можно описать одним уравнением:

**Hash<sub>i+1, j</sub> = Hash(Hash<sub>i, 2j</sub> || Hash<sub>i, 2j+1</sub>)**

Уравнение простыми словами: для получения узлов следующего уровня, узлы (или листья) на текущем уровне попарно конкатенируются и хэшируются.

Структура дерева Меркла обладает рядом полезных свойств.
> * _Изменение хотя бы одного бита в любом из блоков данных приведет к существенному (и непредсказуемому) изменению значения Merkle root_
> * _При наличии всех листьев дерева можно определить какой из блоков данных был изменен_
> * _Простота аутентификации и небольшой размер доказательства вхождения конкретного блока в структуру дерева Меркла_

### Построение дерева Меркла

Разберем на примере, как именно происходит построение дерева Меркла. Предположим, у нас есть 4 блока данных, содержащих числа: 1, 2, 3 и 4. Для построения дерева Меркла нам необходимо вычислить хэш-значение для каждого из блока данных, как на рисунке 2.8 (в примере была использована хэш-функция SHA-256).

<img align="center" width="40%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.8-Hashing-of-data-blocks.png" alt="Рисунок 2.8 – Процесс хэширования блоков данных"/> 

Полученные хэш-значения – листья дерева Меркла. Далее их необходимо связать в узлы. Для этого пары значений конкатенируются (сцепляются) и полученное значение также хэшируется (рис. 2.9).

<img align="center" width="40%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.9-Obtaining-of-Merkle-nodes.png" alt="Рисунок 2.9 – Получение узлов дерева Меркла"/> 

В результате, мы получаем два узла, которые теперь таким же образом нужно связать в одно значение Merkle root. Корневого значение получается так же, как значение отдельного узла (рис. 2.10).

<img align="center" width="40%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.10-Obtaining-of-Merkle-root.png" alt="Рисунок 2.10 – Получение корневого значения"/> 

Теперь мы получаем одно корневое значение, которое связывает все блоки исходных данных. На этом примере можно достаточно просто объяснить как проверяется целостность всех компонентов дерева Меркла.

Допустим, злоумышленнику захотелось изменить последний блок данных на число 5. Мотивы злоумышленника в этом случае не важны. Важно то, что у него не получится убедить всех, что данные не были изменены. Такое свойство достигается за счет использования хэш-функций в дереве Меркла.

Когда злоумышленник изменяет целевые данные, хэш-значение от них изменяется (соответственно, видно изменение значения листа дерева). Поскольку далее происходит конкатенация этого листа с соседним и хэширование полученного значения, значение узла изменится. Это приводит к полному изменению значения Merkle root (рис 2.11).

<img align="center" width="60%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.11-Merkle-root-value-modification-depending-on-the-input-data-block-modification.png" alt="Рисунок 2.11 – Изменение корневого значения в зависимости от изменения блока исходных данных"/> 

Этот пример можно протестировать и лично убедится, что корневое значение действительно полностью изменяется. Успешно модифицировать данные у злоумышленника получится только при нахождении коллизии (такого набора данных, после хэширования которого получится идентичное целевому хэш-значение) – фактически только при взломе криптографической хэш-функции.

### Аутентификация в дереве Меркла

С помощью дерева Меркла можно провести быструю и нетребовательную к объему данных проверку того, содержит ли структура дерева определенный набор данных. Для этого проверяющему необходимы только значение Merkle root и набор значений под названием Merkle branch.

Что такое Merkle branch? Это набор хэш-значений (листьев и узлов), достаточный для аутентификации конкретного блока данных. Как формируется этот набор значений? Узел, который содержит необходимые блоки данных пересчитывает для них дерево Меркла и выбирает только те значения, которые понадобятся проверяющему для получения Merkle root (попарной конкатенации и хэширования) для конкретного листа, после чего передает выбранные значения. Проверяющий, получив набор значений и имея собственный блок данных, рассчитывает значение Merkle root и сравнивает его с тем, которое хранит сам (рис. 2.12).

<img align="center" width="60%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.12-Merkle-branch-calculation.png" alt="Рисунок 2.12 – Вычисление Merkle branch"/> 

На рисунке изображена проверка набора данных data 3 (в нашем примере это значение 3) на вхождение в структуру дерева Меркла. Проверяющий хранит хэш-значение этого блока (4E0740…) данных и получает Merkle branch, состоящий из хэш-значения соседнего блока данных (4B2277…) и одного из узлов дерева (в данном случае F5FCA…). Проверяющий конкатенирует хранимое значение с первым значением Merkle branch и хэширует результат. Полученное значение конкатенируется со вторым значением Merkle branch, и результат конкатенации снова хэшируется. Полученное значение сравнивается с имеющимся Merkle root. Если значения совпадают, то такой блок данных действительно входит в структуру дерева Меркла.

> **_Замечание._** *Существуют схемы множественной аутентификации, которые позволяют проверить вхождение не одного, а сразу нескольких блоков данных (тем самым увеличить производительность алгоритма). К таким схемам относится, например, схема Octopus Authentication.*

### Области применения Merkle tree

Теперь рассмотрим, в каких областях применяется концепция Merkle tree.

> * _Алгоритмы цифровой подписи_
> * _Децентрализованные файлообменные системы (BitTorrent, IPFS)_
> * _Blockchain и SPV узлы_
> * _Системы управления версиями (Git)_

Цифровые подписи на основе хэш-функций могут потенциально применяться вместо распространенных на сегодня, поскольку классические цифровые подписи уязвимы к атакам квантового компьютера. Особенность этого типа подписей в том, что они не требуют затратных вычислений и основаны только на стойкости используемых хэш-функций.

Другая область применения деревьев Меркла – децентрализованные файлообменные протоколы, такие как BitTorrent и IPFS. Протокол BitTorrent позволяет проверять целостность фрагментов загружаемых файлов путем присвоения каждому блоку данных некоторого цифрового отпечатка (значения хэш-функции SHA-1 от блока данных). Связанная с этим проблема состоит в том, что размеры некоторых блоков данных очень велики и, соответственно, отпечаток этих данных тоже имеет большой размер.

Чтобы размер торрент-файла оставался небольшим, используется схема построения дерева Меркла. С ее помощью мы можем собрать хэши от разных фрагментов в единый корень дерева. В результате, мы получим одно хэш-значение, которое позволит проверить целостность всей совокупности данных. Так же, по иерархической схеме, отдельные узлы дерева Меркла позволяют проверить целостность отдельных блоков. 

В IPFS все данные представляются в виде мерклизованного ориентированного ациклического графа (MDAG), который позволяет пользователю получить весь набор данных (вплоть до содержимого каталогов), связанных с единым уникальным идентификатором.

Больше всего внимания схема построения дерева Меркла получила в криптовалюте Bitcoin. В статье Сатоши Накамото “Bitcoin: A Peer-to-Peer Electronic Cash System” [18] приведена следующая схема (рис. 2.13).

<img align="center" width="50%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.13-Use-of-Merkle-trees-in-Bitcoin.png" alt="Рисунок 2.13 – Использование деревьев Меркла в Bitcoin"/> 

На этой схеме изображено строение блока в Bitcoin. В его заголовке присутствует поле Root Hash. Что же представляет собой это поле?

Каждый блок в Биткоине может содержать до нескольких тысяч транзакций. Эти транзакции хэшируются и образуют листья будущего дерева Меркла. Далее листья попарно конкатенируются и хэшируются, пока не будет получено единое корневое значение. Это и есть Root Hash. Эта схема позволяет проверить вхождение какой-либо транзакции в блок без необходимости иметь все транзакции этого блока.

По этому принципу работает метод SPV (simplified payment verification). Каждый SPV-узел хранит все заголовки блоков (размер которых равен 80 Б). Заголовки блоков содержат значение Merkle root от всех транзакций, которые в этот блок были добавлены. Если SPV узел хочет убедиться, что транзакция была подтверждена, он обращается к полному узлу и запрашивает Merkle branch для конкретной транзакции (рис. 2.14). Получив Merkle branch, проверяющий строит путь аутентификации до корневого значения (которое он хранит, так как он синхронизируется с другими узлами сети).

<img align="center" width="40%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.14-SPV-node-operation-scheme.png" alt="Рисунок 2.14 – Схема функционирования SPV-узла"/> 

**Часто задаваемые вопросы**

*– Зачем использовать дерево Меркла, если мы просто можем хэшировать всю последовательность?*

Если мы будем хэшировать весь набор данных, мы также сможем обеспечить их целостность. Однако в этом случае отсутствует гибкость при раскрытии части из этих данных. Если мы хэшируем весь набор данных, то проверяющий может проверить, что данные соответствуют хэш-значению, имея только полный набор. Использование деревьев Меркла позволяет обеспечить доказуемость того, что один фрагмент данных входит в общую структуру. Такой подход гораздо менее требовательный к общему объему доказательств, а также с его помощью можно обеспечить конфиденциальность всего набора данных при доказательстве целостности только фрагмента.

*– Может ли каждый узел иметь более двух дочерних узлов?*

Мы можем построить дерево, у которого каждый узел будет иметь более двух дочерних. Однако при этом значительно снизится эффективность этого подхода: увеличится размер доказательств для аутентификации конкретного набора данных.

## 2.4 Разновидности цифровых подписей

Цифровая подпись является механизмом, который позволяет обеспечить контроль целостности и авторства подписанного сообщения. Однако некоторые сферы их применения требуют обеспечения дополнительных свойств, которые традиционная цифровая подпись обеспечить не может. Поэтому был предложен ряд новых подходов, которые мы рассмотрим в этом подразделе.

> * _Одноразовая подпись_
> * _Мультиподпись_
> * _Пороговая подпись_
> * _Групповая подпись_
> * _Кольцевая подпись_
> * _Слепая подпись_

### Схемы одноразовой подписи

Схема одноразовой подписи впервые предложил Лесли Лэмпорт (Leslie B. Lamport) в 1979 году. В основе таких схем лежит использование однонаправленных функций (хэш-функций). Одноразовая подпись предполагает использование одной ключевой пары для подписания только одного сообщения. При подписании схемы предполагают публикацию фрагментов личного ключа. Если используется одна и та же ключевые пара несколько раз, то все больше частей личного ключа раскрываются, и тогда они могут использоваться злоумышленником для восстановления чужого личного ключа и формирования подписей для других сообщений от имени целевого пользователя.

Чтобы понять основные принципы работы одноразовых подписей, мы рассмотрим два базовых алгоритма одноразовой подписи OTS (One-Time Signature) [19] и WOTS (Winternitz One-Time Signature) [20], особенности вычисления и проверки подписи в обоих алгоритмах, основные их свойства, а также за счет чего злоумышленник может подделывать подписи от имени пользователя.

### Lamport one-time signature

Прежде всего пользователю необходимо сгенерировать ключевую пару, при помощи которой будут формироваться и проверяться подписи. Схема подписи Лэмпорта [21] предполагает, что личный ключ пользователя состоит из парных наборов случайно сгенерированных секретных значений. Их количество определяется размером подписываемого сообщения (длиной хэш-значения). Если длина выходного значения применяемой хэш-функции равна _n_ битам, то для подписания соответствующего сообщения необходимо сгенерировать _2n_ секретных значений. Личный ключ представлен на рисунке 2.15.

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.15-Private-key-formation-scheme.png" alt="Рисунок 2.15 – Схема формирования личного ключа"/> 

Если мы, например, будем генерировать каждое секретное значение (*X<sub>i</sub>* || *Y<sub>i</sub>*) с длиной 256 бит и использовать хэш-функцию на длине 256 бит, то длина нашего личного ключа в итоге должна быть около 8 кБ, что достаточно большой объем данных по сравнению с используемыми в традиционных схемах ключами с длиной 256–512 бит.

Открытый ключ вычисляется как конкатенированное значение от хэш-значений сгенерированных секретов. Его длина зависит от используемой для его порождения хэш-функции (если выход хэш-функции равен размеру секрета, то в этом случае размеры открытого и личного ключей будут совпадать). Процесс формирования  открытого ключа приведен на рисунке 2.16.

<img align="center" width="70%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.16-Scheme-of-generating-a-public-key-from-a-private-key.png" alt="Рисунок 2.16 – Схема формирования открытого ключа из личного"/> 

После того, как открытый ключ вычислен, он может быть опубликован (передан проверяющему, распространен в сеть или т. п.). Каким образом вычисляется значение подписи в данном случае? После того как сформировано подписываемое сообщение, от него вычисляется хэш-значение. Чтобы подписать сообщение, мы должны опубликовать одно из секретных значений из пары (*X<sub>i</sub>* || *Y<sub>i</sub>*) (рис. 2.17) в зависимости от конкретного бита хэш-значения (0 либо 1).

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.17-Digital-signature-calculation-scheme.png" alt="Рисунок 2.17 – Схема вычисления цифровой подписи"/> 

В результате, мы опубликуем ровно половину из начально сгенерированных секретов. Как проверить валидность подписи? Проверяющий может вычислить хэш-значение сообщения и получить точно такую же битовую последовательность. В зависимости от этой последовательности, верификатор выбирает набор открытых ключей, в соответствии со значением конкретных битов полученного хэш-значения (рис. 2.18).

<img align="center" width="80%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.18-Public-key-selection-scheme.png" alt="Рисунок 2.18 – Схема выбора открытых ключей"/> 

После того, как проверяющий сформировал набор необходимых открытых ключей, он вычисляет хэш-значения от частей цифровой подписи. Если хэш-значения всех этих значений соответствуют сформированному на предыдущем этапе открытому ключу (рис. 2.19), то подпись действительна.

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.19-Signature-verification-scheme.png" alt="Рисунок 2.19 – Схема проверки подписи"/> 

### Почему одноразовая подпись «одноразовая»?

Чтобы на примере разобраться как работает одноразовая подпись Лэмпорта и почему нельзя при помощи одного ключа подписывать несколько сообщений, рассмотрим простой численный пример. В качестве используемой хэш функции примем функцию, которая возвращает четырехбитное значение (опустим алгоритм вычисления: известно только то, что для одинаковых входных данных выход хэш-функции не отличается).

Для начала генерируем личный ключ. Так как длина хэш-функции равна 4 бит, нам необходимо сгенерировать восемь секретных значений (рис. 2.20).

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.20-Example-of-generating-a-private-key.png" alt="Рисунок 2.20 – Пример генерации личного ключа"/> 

После этого необходимо вычислить значение открытого ключа путем хэширования секретных значений (рис. 2.21) и передать его проверяющей стороне.

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.21-Example-of-public-key-calculation.png" alt="Рисунок 2.21 – Пример вычисления открытого ключа"/> 

Когда пользователь формирует сообщение, он вычисляет его хэш-значение. Далее выполняется формирование цифровой подписи. К примеру, полученное в результате хэширования значение равно «0110». В этом случае значение подписи будет представлять из себя части секретного ключа, в зависимости от бит хэш-значения (рис. 2.22).

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.22-Example-of-calculating-the-first-digital-signature.png" alt="Рисунок 2.22 – Пример вычисления первой цифровой подписи"/> 

После публикации этого значения цифровой подписи вместе с сообщением, фактически все узнают половину из сгенерированных вами секретных значений: *X<sub>0</sub>*, *Y<sub>1</sub>*, *Y<sub>2</sub>*, *X<sub>3</sub>*. Эти значения может сохранить злоумышленник, что упростит ему задачу по подбору остальных частей личного ключа жертвы.

Если тот же пользователь использовал ту же ключевую последовательность для подписи другого сообщения, то, соответственно, хэш-значение этого сообщения также будет другим. Следовательно, позиции необходимых для публикации секретов также изменились, а значит с публикацией нового значения цифровой подписи будет разглашена еще одна порция составляющих личного ключа. Если, к примеру, данный пользователь при помощи того же личного ключа во второй раз подпишет сообщение с хэш-значением «1001» (рис. 2.23), то ему необходимо раскрыть секреты, которые находятся на позициях *Y<sub>0</sub>*, *X<sub>1</sub>*,  *X<sub>2</sub>*, *Y<sub>3</sub>*.

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.23-Example-of-calculating-the-second-digital-signature.png" alt="Рисунок 2.23 – Пример вычисления второй цифровой подписи"/> 

Если злоумышленник перехватил оба сообщения и значения их подписей, то он владеет полным набором изначально сгенерированных секретов, а значит может подписывать любые сообщения от имени целевого пользователя. Поскольку владелец личного ключа не заинтересован в его разглашении, то он может использовать один ключ, чтобы сформировать не более одной подписи.

### Winternitz one-time signature

В качестве еще одного примера одноразовой подписи  мы рассмотрим Winternitz OTS [20]. Данный подход имеет очень большое сходство с подписью Лэмпорта, однако предполагает отдельное секретное значение не на каждый отдельный бит подписанного сообщения, а на один блок сообщения. Поэтому изначально определяется параметр (ширина) Винтерница, который определяет размер блоков сообщения. Например, если мы устанавливаем ширину Винтерница равной 16 (4 бита) и используем хэш-функцию SHA-256, то исходное хэш-значение делится на 64 блока длиной по 4 бита.

После этого мы генерируем значения личных ключей. В данном случае количество ключей соответствует количеству блоков (рис. 2.24) и также равно 64.

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.24-Private-key-generation-scheme.png" alt="Рисунок 2.24 – Схема генерации личного ключа"/> 

Открытый ключ вычисляется как конкатенация хэш-значений от частей личного ключа. Причем количество необходимых вычислений хэш-функции равно значению ширины Винтерница. Исходя из этого, фрагменты открытого ключа равны фрагментам личного ключа, от которых 16 раз было вычислено хэш-значение (рис. 2.25).

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.25-Public-key-calculation-scheme.png" alt="Рисунок 2.25 – Схема вычисления открытого ключа"/> 

Открытый ключ сформирован и может быть передан верификаторам. При подписи сообщения, предварительно вычисляется его хэш-значение и разбивается на блоки по 4 бита. После этого, каждый из блоков преобразуется в десятичное значение (рис. 2.26).

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.26-Message-pre-processing-scheme.png" alt="Рисунок 2.26 – Схема предварительной обработки сообщения"/> 

Цифровая подпись является значением личного ключа для каждого блока, которое захэшировано такое количество раз, которое получено при преобразовании блока в десятичное значение (рис. 2.27).

<img align="center" width="80%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.27-Digital-signature-calculation-scheme.png" alt="Рисунок 2.27 – Схема вычисления цифровой подписи"/> 

Когда верификатор получает значение подписи, он предварительно вычисляет хэш-значение от полученного сообщения и так же делит его на блоки. После этого он переводит значение каждого блока в десятичный вид, а затем отнимает от значения ширины Винтерница полученные десятичные значения и получает собственный набор натуральных чисел. Далее верификатор хэширует значения фрагментов подписи в соответствии с полученным набором натуральных чисел (хэширует столько раз, сколько получает в результате вычитания ширины Винтерница и десятичных значений блоков). Если результат каждого хэширования равен соответствующей части открытого ключа, то проверяемая подпись правильная (рис. 2.28).

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.28-Signature-verification-scheme.png" alt="Рисунок 2.28 – Схема проверки подписи"/> 

### Мультиподпись

Мультиподпись является схемой цифровой подписи, которая требует взаимодействия нескольких сторон (с применением их личных ключей) для вычисления подписи. Существует два основных типа мультиподписи. Первый предполагает, что проверка подписи происходит в соответствии с набором открытых ключей. В этом случае взаимодействующие стороны определяют открытые ключи и необходимое их количество для проверки подписи. Сама же подпись состоит из набора значений, каждое из которых проверяется отдельным открытым ключом (рис. 2.29).

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.29-Multisignature-of-the-first-type.png" alt="Рисунок 2.29 – Первый вариант мультиподписи"/> 

Второй тип мультиподписи позволяет агрегировать значения открытых ключей в одно общее значение, при помощи которого будет проверяться единое агрегированное значение подписи. В этом случае взаимодействующие стороны изначально формируют общее значение открытого ключа и публикуют его. В процессе подписания, каждая из сторон отдельно подписывает требуемое сообщение, но полученные значения подписей можно «сложить» и проверить результат при помощи общего открытого ключа (рис. 2.30).

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.30-Multisignature-of-the-second-type.png" alt="Рисунок 2.30 – Второй вариант мультиподписи"/> 

В чем же состоят преимущества такого типа подписей? Главное (и наиболее востребованное) – это уменьшение объема памяти, необходимой для хранения мультиподписи. В отличие от стандартных мультиподписей (размер которых линейно увеличиваются в зависимости от количества подписантов), размер подписи, вычисленной несколькими участниками при помощи, например, алгоритма Шнорра [22] не отличается размером от одиночной подписи.

Еще одним преимуществом является конфиденциальность участников таких схем. Так как общий открытый ключ является агрегированным значением, то третьей стороне достаточно сложно восстановить открытые ключи участников подписи и связать их с владельцами этих ключей. Все участники системы видят только общий открытый ключ и общее значение подписи, а соответственно это визуально не отличается от обычной одиночной подписи.

### Пороговая подпись

Пороговая подпись является разновидностью мультиподписи за исключением одного важного отличия: открытые ключи участников взаимодействия имеют различные весовые значения.

Такой подход часто используется в учетных системах, а именно посредством определения необходимого веса на проведение конкретной операции и выдачу весовых значений открытым ключам. Так пользователь, изначально имея одну ключевую пару с максимальным весовым значением, может создать так называемых «подписантов» (набор открытых ключей) для своего аккаунта, и задать каждому из них собственное весовое значение.

При верификации подписи верификатор проверяет, что сумма весов ключей, которыми сообщение было подписано, удовлетворяет требуемому порогу (рис. 2.31). В этом случае порог равен 1.

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.31-Threshold-signature-verification-scheme.png" alt="Рисунок 2.31 – Схема проверки пороговой подписи"/> 

### Групповая подпись

Групповая подпись – это механизм, который позволяет пользователю подписать конкретное сообщение от имени группы. При этом групповая подпись обладает следующими свойствами:
> * _Только члены группы могут сформировать корректную подпись_
> * _Верификатор может точно убедиться, что конкретная подпись вычислена одним из участников группы_
> * _Верификатор не может определить какой именно участник группы подписал сообщение_
> * _В случае возникновения спора, администратор группы может раскрыть личность подписывающего_

Первый предложенный вариант групповой подписи предполагал наличие полностью доверенного администратора группы.

Администратор группы изначально генерирует большое количество ключевых пар, после чего распределяет личные ключи среди участников группы. После этого он формирует список открытых ключей участников группы и перемешивает эти ключи в случайном порядке, после чего публикует этот список.

Когда один из участников группы хочет подписать документ, он случайным образом выбирает один из своих личных ключей и вычисляет подпись. Когда верификатор проверяет значение подписи, он обращается к списку открытых ключей и перебирает его в поисках того, который соответствует подписи. Если он находит подходящий открытый ключ, это значит, что подпись выработал один из членов группы (рис. 2.32).

<img align="center" width="45%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.32-Group-signature-scheme.png" alt="Рисунок 2.32 – Схема групповой подписи"/> 

Это является самой простой реализацией схемы групповой подписи и она имеет ряд недостатков:
* администратор может подписывать сообщения от имени участников группы;
* сложность добавления нового участника группы;
* подмножество ключей у каждого из участников должно быть большим для усложнения анализа соответствия владельца открытого ключа.

На текущий момент существует большое количество алгоритмов групповой подписи, которые позволяют устранить перечисленные недостатки. Вопрос доверия участников группы администратору решается за счет того, что пользователи лично генерируют свои секреты. При этом администратор предоставляет им только набор значений, которые необходимы для формирования личных ключей и позволяют вычислить подпись, проверяемую открытым ключом группы.

В этом случае верификатор проверяет подпись, используя общий открытый ключ группы, и не может провести никакого соответствия с ним конкретного участника. Такая схема поддерживает простой механизм добавления новых участников в группу. При этом обеспечиваются основные свойства групповой подписи, которые мы рассматривали ранее.

### Кольцевая подпись

Кольцевая подпись (ring signature) – вид цифровой подписи, который позволяет одному из участников группы (называемой кольцом) выполнить подписание некоторого сообщения от имени всей группы. Для формирования такой подписи, пользователь использует открытые ключи других пользователей и свою ключевую пару. Верификатор при проверке подписи может убедиться, что она была вычислена одним из членов кольца, однако кем именно – неизвестно.

Алгоритм кольцевой подписи предложили Ади Шамир, Яэль Тауман, Рон Ривест, и он был анонсирован в 2001 году на интернациональной конференции Asiacrypt [22]. Основатели старались в названии подчеркнуть отсутствие центральной координирующей структуры при формировании этой подписи: «кольцо является геометрической фигурой с однородной периферией и без центра».

В отличие от групповой подписи, в схеме кольцевой подписи нет заранее подготовленной группы участников, не требуется проведение каких-либо подготовительных процедур для создания или изменения такой группы. Главное требование – каждый из участников должен быть ассоциирован с парой ключей. Это позволяет подписанту выбрать произвольное множество возможных подписантов (в которое он включает самого себя) и самостоятельно вычислить подпись, используя открытые ключи других участников из множества возможных и свой секретный ключ.

Представим группу из _n_ пользователей, как на рисунке 2.33. Каждый пользователь имеет свою ключевую пару – личный и открытый ключи (_sk_, _PK_). Личные ключи известны только их владельцам, публичные – всем участникам системы.

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.33-Scheme-of-forming-a-group-for-a-ring-signature.png" alt="Рисунок 2.33 – Схема формирования группы для кольцевой подписи"/> 

Чтобы сформировать подпись от имени группы, пользователю необходимо подать на вход алгоритма открытые ключи всех участников кольца (включая свой), и в качестве секрета использовать собственный личный ключ. Напомним, что открытые ключи каждого из участников являются общедоступными. На рисунке 2.34 схематично показано, как происходит формирование кольцевой подписи пользователем под номером 4.

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.34-Ring-signature-formation-scheme.png" alt="Рисунок 2.34 – Схема формирования кольцевой подписи"/> 

Когда верификатор проверяет значение подписи, он может убедиться, что подпись была выработана одним из участников группы, однако кем именно – неизвестно. Только с вероятностью 1/_n_ он может определить, что подпись вычислил конкретный участник кольца. При этом стоит заметить, что достоверно подписывающий может быть раскрыт только в случае сговора всех остальных участников группы (рис. 2.35).

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.35-Ring-signature-verification-scheme.png" alt="Рисунок 2.35 – Схема проверки кольцевой подписи"/> 

Таким образом, схема кольцевой подписи может быть использована, если требуется обеспечить анонимность подписывающего, а также его независимость от остальных участников, и при этом обеспечить целостность и подлинность подписываемого сообщения (получатель будет уверен, что сообщение поступило от участника некоторой группы, а не от кого-либо вне этой группы).

Стоит упомянуть, что существует такой вид кольцевой подписи, который наделен свойством одноразовости. Такие алгоритмы предполагают использование значения изображения открытого ключа, которое позволяет отследить (связать) все подписи сформированные с помощью одного личного ключа, даже если при этом использовались различные кольца.

Такое свойство востребовано во многих областях: электронные выборы (каждый участник может проголосовать только один раз), цифровые деньги (электронные монеты можно потратить лишь единожды) и т. д.

### Слепая подпись

Механизм слепой подписи используется в тех случаях, когда формирует сообщение одна сторона, а подписывает (заверяет) другая и при этом тот, кто создает сообщение, хочет скрыть некоторые его части от подписывающего. Механизм слепой подписи может применяться в банковских структурах для перевода средств между пользователями. Фактически можно представить такого рода взаимодействие, как ослепленный чек, который передается другой стороне: владелец средств формирует такой чек, а банк, не видя уникального идентификатора чека, подписывает его, после чего этот чек может быть передан любой стороне и та может обналичить его без раскрытия его отправителя.

Механизм слепой подписи работает следующим образом:

> 1. Отправитель формирует _n_ различных транзакций с одинаковой суммой перевода, но с разными уникальными идентификаторами. Перед их отправкой пользователь ослепляет (шифрует) транзакции, используя случайно сгенерированный множитель. После этого все транзакции передаются подписанту.
> 2. Подписант запрашивает у отправителя _n−1_ ослепляющих факторов, которые соответствуют выбранным подписантом транзакциям. Фактически он определяет, какие транзакции хочет вскрыть.
> 3. Отправитель отсылает набор ослепляющих факторов, подписант вскрывает с их помощью ослепленные транзакции и проверяет, чтобы сумма переводов была равна и пользователь имел достаточно средств для ее проведения. 
> 4. Если суммы в некоторых транзакциях не равны, то подписант отказывает пользователю. В другом случае он подписывает оставшуюся транзакцию, не видя ее содержимого, и отправляет ее обратно пользователю.
> 5. Пользователь убирает ослепление с транзакции. При этом подпись остается правильной и для транзакции, с которой убрали ослепление.
> 6. Пользователь может отправить этот «чек» кому угодно. Получатель в любой момент времени может передать этот чек стороне, которая подписала его и получить сумму, которая в нем указана. Проверяющая сторона может только убедиться, что подпись корректна, при этом она не знает кому был выдан чек с таким идентификатором (рис. 2.36).

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.36-Blind-signature-generation-and-verification-scheme.png" alt="Рисунок 2.36 – Схема формирования и проверки слепой подписи"/> 

**Часто задаваемые вопросы**

*— В каких системах на данный момент используются механизмы пороговой подписи и мультиподписи?*

Мультиподписи и схемы пороговой подписи используются в системах для поддержания отказоустойчивости и разделения ответственности за управление процессами. Многие криптовалюты позволяют пользователям блокировать средства на multisignature адресах, что позволяет им получить доступ к своим средствам даже при потере одного (или нескольких) ключей. Также использование мультиподписи позволяет построить большое количество протоколов поверх некоторой уже существующей учетной системы (atomic swap, payment channels и т. п.). Механизмы пороговой подписи используются, когда требуется еще больший уровень разграничения разрешений пользователей. Так можно настроить вес каждого отдельного ключа (часто в зависимости даже от отдельной операции) и за счет этого максимально эффективно настроить политику доступа к услугам учетной системы. Подобный подход используется во многих платформах управления активами, например в Stellar.

*— Как соотносятся уровень анонимности подписанта и размер кольца в случае использования кольцевой подписи?*

При использовании кольцевой подписи верификатор только с долей вероятности может определить, кто подписал конкретное сообщение. Чем больше размер кольца, тем меньше вероятность того, что конкретное сообщение подписал конкретный участник кольца. Например, если кольцо состоит из 10 участников, то предположить, кто конкретно выработал подпись, можно только с вероятностью 10%. Конечно, личность подписанта также может быть раскрыта, но это возможно, только если все остальные участники кольца сговорились между собой.

## 2.5 Разделение секрета по схеме Шамира

Представим ситуацию, когда необходимо защитить какие-либо данные, обеспечивая одновременно и конфиденциальность, и доступность. Например, Алиса владеет пекарней, и у нее есть тайный рецепт вкуснейшего пирога. Предположим, Алиса зашифровала рецепт и хранит ключ при себе. По мере необходимости она предоставляет доступ к рецепту. Но со временем становится понятно, что на практике такое решение неудобно, потому что всякий раз для открытия хранилища требуется ее физическое присутствие. А что насчет отпуска? Или еще хуже: вдруг ключ будет утерян?

Тогда Алиса могла бы сделать копию ключа и доверить его сотруднику пекарни, однако в таком случае увеличивается и риск его кражи.

Есть вариант не создавать дубликат, а разделить оригинальный ключ пополам и отдать часть ключа доверенному человеку. Теперь понятно, что они оба должны физически присутствовать, чтобы собрать ключ и открыть хранилище. Следовательно, чтобы украсть рецепт, злоумышленнику необходимо получить обе части ключа, что гораздо сложнее, чем кража одного ключа. Однако эта схема не намного лучше, чем использование целого ключа: если один из хранителей потеряет половину ключа, полный ключ невозможно будет восстановить.

Алиса осознает, что в идеальном случае нужно разделить ключ между несколькими сотрудниками, чтобы возможность доступа к рецепту не зависела только от одного человека. Она также приходит к выводу, что должен существовать некое пороговое количество сотрудников, чтобы при потере (или недоступности) одной части весь ключ мог быть восстановлен из остальных частей.

Решение данной проблемы было представлено в работе Ади Шамира (Adi Shamir) в 1979 году [78]. Он предложил пороговую схему разделения секрета, которую также называют схемой интерполяционных полиномов.

### Пороговая схема разделения секрета

Пороговая схема разделения секрета – это схема, в которой необходимое количество участников для восстановления секрета может быть меньшим, чем общее количество участников. Допустим, _n_ – общее количество участников, а _t_ – необходимое количество участников для восстановления секрета. Восстановить секрет может любая группа из t и более участников, в то время как меньшее количество участников ничего не смогут узнать о секрете. Порядок выполнения схемы Ади Шамира можно разделить на следующие фазы.

> * _Подготовительная фаза_
> * _Генерация частей секрета_
> * _Восстановление секрета_

Первая фаза – _подготовительная_. Предположим, что есть секрет _S_, который нужно разделить на _n_ частей так, чтобы сам секрет можно было получить только при наличии как минимум _t_ частей. Тогда для начала необходимо выбрать некоторое простое число _p_, где _p > S_, _p > n_; оно будет задавать размер поля. Над этим полем нужно построить полином, который будет проходить через точку (_0_, _S_). Он будет иметь вид **F(x)=(a<sub>t-1</sub>x<sup>t-1</sup> + a<sub>t-2</sub>x<sup>t-2</sup> + ... + a<sub>1</sub>x + S)**, где *a<sub>1</sub>, a<sub>2</sub>, ... , a<sub>t-1</sub>*  – случайно выбранные натуральные числа. Впоследствии секрет можно будет восстановить, если вычислить _F(0)_.

От степени полинома также будет зависеть количество точек, которое может понадобится для восстановления этого полинома. Если нам необходимо, чтобы секрет возможно было восстановить при наличии _t_ частей, то степень полинома должна быть _t − 1_.

Чем это обусловлено? Представим, что у нас есть полином первой степени вида _y=S+a<sub>1</sub>x_, например _y=3+2x_. Ему соответствует график, который мы можем однозначно идентифицировать, имея как минимум две точки. В то же время, имея только одну точку, мы можем провести бесконечное количество прямых через нее (рис. 2.37).

<img align="center" width="50%" src="/resources/img/volume-2/2.5-Shamirs-secret-sharing-scheme/Figure-2.37-A-possible-number-of-straight-lines-that-pass-through-the-necessary-number-of-points-and-through-fewer-points.png" alt="Рисунок 2.37 – Возможное количество прямых, проходящих через необходимое и через меньшее количество точек"/> 

Аналогично, если мы имеем полином второй степени – нам нужно по крайней мере 3 точки, так как через две точки можно провести бесконечное количество кривых второй степени (рис. 2.38).

<img align="center" width="50%" src="/resources/img/volume-2/2.5-Shamirs-secret-sharing-scheme/Figure-2.37-A-possible-number-of-straight-lines-that-pass-through-the-necessary-number-of-points-and-through-fewer-points.png" alt="Рисунок 2.38 – Возможное количество графиков,  проходящих через необходимое и через меньшее количество точек
"/> 

По этой причине нам необходимо построить полином степени _t − 1_, если мы хотим, чтобы секрет можно было восстановить при наличии _t_ частей.

Следующая фаза – генерация частей секрета. Каждая часть секрета – это одна точка, принадлежащая графику, построенному с помощью полинома. Для того чтобы получить очередную точку, необходимо сгенерировать натуральное число, а затем подставить в полином. Таким способом необходимо сгенерировать n различных точек. Эту фазу выполняет владелец секрета самостоятельно, чтобы не допустить его разглашения.

После генерации частей секрета, каждому участнику выдается его часть *(x<sub>i</sub>, f(x<sub>i</sub>))*. Известной для всех участников информацией является степень полинома t − 1 и размер поля p.

Последняя фаза – восстановление секрета. Восстановить секрет можно двумя способами: решить систему линейных уравнений или вычислить интерполяционный полином Лагранжа. Второй метод более прост для программной реализации, а также с помощью него можно вычислить сам секрет, не вычисляя коэффициенты полинома. Данная фаза выполняется любой группой из t участников, когда появляется необходимость узнать секрет.

Формула интерполяционного полинома Лагранжа приведена на рисунке (рис. 2.39). С помощью этой формулы возможно восстановить полином. Затем достаточно вычислить F(0), чтобы восстановить секрет.

<img align="center" width="45%" src="/resources/img/volume-2/2.5-Shamirs-secret-sharing-scheme/Figure-2.39-Lagrange-interpolation-equation-Secret-sharing-example.png" alt="Рисунок 2.39 – Формула интерполяционного полинома Лагранжа"/> 

### Пример разделения секрета

Рассмотрим работу схемы на конкретном примере. Представим, что нужно разделить секрет _S_ = 7 на 6 участников так, чтобы любая группа из 4 участников имела возможность восстановить его.

> Шаг 1. Необходимо выбрать простое число _р_, где _р > S_. Например _p_ = 13. Затем необходимо составить полином такого вида (рис. 2.40), где *a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>* – коэффициенты, случайно выбранные натуральные числа.

<img align="center" width="50%" src="/resources/img/volume-2/2.5-Shamirs-secret-sharing-scheme/Figure-2.40-Making-a-polynomial-with-certain-coefficients.png" alt="Рисунок 2.40 – Составление полинома с определенными коэффициентами"/> 

> Шаг 2. В нашем случае, для того чтобы получить части секрета, нужно подставить в полином 6 различных натуральных чисел, выбранных случайным образом. Для удобства можно взять {1, 2, 3, 4, 5, 6}. Эти числа не обязательно должны идти по порядку – главное, чтобы все они были различны по модулю _p_. В итоге получим 6 точек, которые затем необходимо раздать участникам (рис. 2.41). После этого этапа коэффициенты полинома можно уничтожить, а секрет могут восстановить любые 4 участника из 6. В зависимости от поставленных целей, секрет также может быть уничтожен. Тогда использование частей секрета будет единственным способ восстановить секрет.

<img align="center" width="50%" src="/resources/img/volume-2/2.5-Shamirs-secret-sharing-scheme/Figure-2.41-Calculation-of-secret-parts.png" alt="Рисунок 2.41 – Расчет частей секрета"/> 

> Шаг 3. Теперь используя любые 4 точки можно составить систему уравнений и решить ее, либо же можно восстановить исходный полином, воспользовавшись формулой интерполяционного полинома Лагранжа (рис. 2.42). В примере используются точки _p_.

<img align="center" width="50%" src="/resources/img/volume-2/2.5-Shamirs-secret-sharing-scheme/Figure-2.42-Reconstruction-of-the-polynomial-and-secret.png" alt="Рисунок 2.42 – Восстановление полинома и секрета"/> 

Затем, зная, что _S = F(0)_, можно легко рассчитать секрет: _F(0)_ = 7.

### Преимущества схемы Шамира 

> * _Стойкость_
> * _Динамичность_
> * _Масштабируемость_

_Стойкость_. Для восстановления секрета злоумышленнику необходимо t частей, в то время как при знании меньшего количества частей он не может восстановить даже часть секретного значения. В этом случае злоумышленнику не поможет наличие большой вычислительной мощности, так как он не может проверить корректность подобранных частей.

_Динамичность_. Для одного и того же секрета можно применить схему несколько раз, при этом каждый раз получать разные наборы частей, создавать бесконечное множество различных полиномов, и соответствующих ему точек. Знание частей секрета, основанных на разных полиномах, не поможет злоумышленнику получить какое-либо представление о самом секрете. Тем не менее создание нового набора частей не отменяет возможности восстановить секрет по его старым частям. Представим ситуацию: Алиса собирается оставить завещание на свой тайный рецепт. Для своих родственников она может использовать схему (2, 3), для друзей – (5, 7), а для сотрудников – (10, 14). Тогда получить рецепт смогут либо 2 родственника, либо 5 друзей, либо же 10 сотрудников.

_Масштабируемость_ обеспечивается тем, что количество держателей секрета можно сделать сколь угодно большим за счет выбора полинома соответствующей степени.

### Недостатки схемы Шамира

> * _Во время разделения и восстановления секрет должен находиться на одном устройстве_
> * _Невозможность проверить корректность предоставленной части секрета_

Чтобы разделить секрет с помощью данной схемы, _секрет должен существовать на одном устройстве во время разделения_. Во время восстановления также необходимо наличие частей секрета на одном устройстве. Например, когда Алиса оставляет завещание на рецепт, ей необходимо хранить рецепт целиком до тех пор, пока она не разделит его. Также существует риск кражи секрета после его восстановления. В эти моменты времени особенно велик риск, что конкурент может украсть рецепт.

Владелец одной из частей может предоставить для восстановления неверное значение, тогда секрет будет восстановлен неверно и остальные этого не узнают. У них даже нет возможности проверить, чья часть была неверной.

> **_Замечание._** *Существуют модификации схемы Шамира, в которых используются контрольные суммы, что минимизирует вероятность использования некорректных частей. А также, существуют схемы разделения секрета, где каждый участник может проверить действительность частей секрета (например PVSS – публично проверяемое разделение секрета).*
 
### Применение схемы Шамира

Чаще всего пороговая криптография применяется для хранения личного ключа центра сертификации, а также в облачных средах и схемах электронного голосования. 

Помимо этого, схема Шамира может применяться для иерархических структурах доступа. Такие структуры представляют собой деревья, где каждый узел имеет доступ к меньшему объему данных, чем его родитель. Корень дерева имеет доступ ко всем данным. Один вариант реализации Шамир представил в своей работе [78].

В качестве конкретного примера можно привести применение схемы Ади Шамира парижской компанией SatoshiLabs для решения проблемы хранения личных ключей кошелька. Пользователи могут «разбивать» ключи на несколько частей, а затем восстанавливать их путем объединения некоторого заранее определенного подмножества этих частей. Резервное копирование с использованием алгоритма от SatoshiLabs позволяет создавать до 16 частей (которые, в свою очередь, можно также дополнительно разделить). Это резервное копирование является открытым стандартом, поэтому другие компании в будущем смогут использовать его в своих кошельках.

[ТЕХНОЛОГИЧЕСКИЕ ДЕТАЛИ ФУНКЦИОНИРОВАНИЯ BITCOIN](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-2/ru/3-technological-details-of-bitcoin-operation.md)
