# МЕТОДЫ ДОСТИЖЕНИЯ КОНСЕНСУСА

## 5.1 Proof-of-stake алгоритмы достижения консенсуса

PoS (proof-of-stake) – доказательство владения монетами в некоторой цифровой учетной системе. Алгоритм достижения консенсуса на базе PoS был создан в качестве менее ресурсоемкой альтернативы proof-of-work. В данном подходе построения алгоритма достижения консенсуса вероятность, с которой узел получает право на создание нового блока, зависит от его баланса. В данном подразделе мы рассмотрим основные концепции, которые легли в основу PoS алгоритмов достижения консенсуса, а также особенности применения этого подхода в учетных системах.

### Принцип работы и структура блоков proof-of-stake

В случае использования proof-of-stake алгоритма достижения консенсуса, узел-валидатор выбирается псевдослучайно, на основе комбинации факторов, которые могут включать в себя возраст конкретных монет, определенное случайное значение и состояние узла. Также стоит отметить, что в proof-of-stake системах генерация блоков называется _forging_ или _minting_.

В обобщенном виде порядок формирования нового блока в PoS следующий. На вход некоторой функции подается заголовок блока, текущее время, баланс валидатора (его stake) и другие специфичные данные, например, вычисленный возраст монет или определенная случайная переменная, за счет чего обеспечивается более честный выбор валидатора. Данная функция вызывается с определенным интервалом и, при каждой попытке валидатора выполнить ее, выдает определенный результат (успешно или нет).

К цифровым валютам, использующим алгоритм достижения консенсуса на основе proof-of-stake, относятся следующие.

> * _Peercoin_
> * _Nxt_
> * _NEM_
> * _Novacoin_
> * _Cardano_

При старте системы, в которой применяется proof-of-stake, монеты никак не распределены. Поэтому создатели обычно начинают с предварительного выпуска монет или сначала запускаются на основе proof-of-work, а потом переходят к полноценному proof-of-stake. Но за что в таком случае получают награду валидаторы? В первом случае, поскольку все монеты выпускаются заранее, наградой для валидаторов выступает комиссия с проведенных транзакций. В случае сочетания PoW и PoS, валидаторы могут получать вознаграждение как за генерацию новых монет, так и за подтверждение транзакций.

Для участия в процессе создания новых блоков, нужно, чтобы на балансе участника были монеты – stake (доля). Размер доли влияет на вероятность узла быть выбранным в качестве следующего валидатора для forging блока (рис. 5.1). Соответственно, чем больше доля, тем больше шанс.

<img width="50%" alt="Рисунок 5.1 – Распределение шанса на добавление нового блока среди валидаторов в зависимости от их доли" src="/resources/img/volume-2/5.1-Proof-of-stake-consensus-algorithms/Figure-5.1-Distribution-of-the-probability-to-add-a-new-block-among-validators-depending-on-their-stake.png"/> 

Давайте рассмотрим отличия между структурой блока в proof-of-stake и proof-of-work системах на примере Peercoin (рис. 5.2). Сама система Peercoin будет детально рассмотрена далее.

<img width="50%" alt="Рис. 5.2 – Сравнение структуры PoW и PoS блоков" src="/resources/img/volume-2/5.1-Proof-of-stake-consensus-algorithms/Figure-5.2-Comparison-of-PoW-and-PoS-block-structures.png"/> 

Слева располагается схема блока PoW, в котором находится заголовок, подобный таковому в Bitcoin, _coinbase_ – вырожденная транзакция, где есть только один нулевой вход, не содержащий ссылок, но с неограниченным количеством выходов, сумма значений на которых должна не превышать сумму вознаграждения, которая полагается за создание этого блока. После coinbase транзакции следуют транзакции других пользователей. И по оригинальным правилам Bitcoin эти транзакции платят комиссию, которая прибавляется к вознаграждению за создание блока.

Справа находится блок proof-of-stake. В его заголовке есть уже две вырожденные транзакции: одна из них – coinbase, которая обязательна согласно правилам протокола, а вторая – _сoinstake_, которая нужна тогда, когда блок сгенерирован по правилам PoS. У сoinstake транзакции свои правила формирования. Если сoinbase транзакция здесь содержит один вход и один выход, и оба являются нулевыми, то сoinstake транзакция содержит хотя бы один вход, где указывается ссылка на непотраченный выход транзакции, находящейся на определенной глубине (для этих монет рассчитывают параметр coinage), а также два или больше выхода, первый из которых нулевой, а остальные тратят и перераспределяют монеты. К монетам, которые создатель блока направляет себе в выходах, будет суммироваться и вознаграждение за создание блока по proof-of-stake.

Кроме того, этот блок содержит подпись создателя блока, которая должна проверяться публичным ключом, указанным в первом входе coinstake транзакции. Подпись доказывает, что именно этот участник создал блок. После coinstake транзакции идут пользовательские транзакции, которые тоже подписываются, то есть подписывается весь блок.

Это сделано, чтобы любой посторонний не мог присвоить новый блок PoS и использовать его для подтверждения и распространения своих транзакций. Если пользователь не владеет определенным ключом, он не может сгенерировать нужную подпись.

### Peercoin

Peercoin [38] является первой криптовалютой, в которой был представлен алгоритм proof-of-stake. При этом стоит отметить, что в случае с Peercoin используется комбинация алгоритмов PoS и PoW. В этом случае одни блоки в цепочке созданы с помощью PoW, а другие – с помощью PoS. Оба варианта блоков подтверждают транзакции и предусматривают вознаграждение создателю как сумму комиссий и новые (эмиссионные) монеты. Но для блоков, созданных с помощью PoW, количество новых монет гораздо больше, т. к. вероятность успешно сгенерировать такое доказательство не зависит от баланса валидатора. Также стоит отметить, что параметры сложности для PoW и PoS рассчитываются и изменяются независимо друг от друга. Так же, как и в proof-of-work, сложность в proof-of-stake отвечает за вероятность генерации доказательства с первого раза и используется для регулирования частоты генерации блоков. Таким образом, чтобы на большом промежутке времени частота добавления блоков была постоянной. Например, если за последнее время будет сгенерировано слишком много или слишком мало блоков, сложность увеличится или уменьшится соответственно.

Как уже было упомянуто ранее, шанс узла на forging блока в proof-of-stake зависит от количества монет у него на балансе. Однако, нельзя ограничиваться исключительной этой метрикой, поскольку тогда предпочтение отдавалось бы наиболее богатым валидаторам, которые решили хранить больше монет на своих кошельках. Чтобы избежать этой ситуации, используются дополнительные методы выбора валидаторов.

В Peercoin для этого реализован механизм coinage. Возраст определяется путем умножения количества монет в доле на количество дней, в течение которого они находятся в доле. При этом монета должна пролежать на кошельке 30 дней, прежде чем она сможет принимать участие в forging. Пользователи, хранящие в доле большее количество монет с большим возрастом, вероятнее получат право на forging следующего блока.

После того, как узел провалидировал следующий блок, возраст его монет обнуляется и ему снова нужно ждать 30 дней. При этом вероятность нахождения следующего блока становится максимальной через 90 дней. Это не позволяет доминировать пользователям с очень крупными и давно лежащими монетами.

> **_Замечание._** *Возраст монеты, который расходуется на брошенный блок (orphan block) возобновляется. Из-за этого стоимость атаки на Peercoin весьма мала и злоумышленник может продолжать попытки генерации блоков до тех пор, пока ему это не удастся. Для предотвращения рисков в Peercoin реализован механизм централизованной трансляции checkpoints, которые фиксируют состояние цепочки блоков и уведомляют об опасности альтернативных версий истории.*

Если владелец кошелька хочет, чтобы его монеты перестали участвовать в процессе валидации и вернулись на основной баланс, ему придется подождать определенное время. Это позволяет удостовериться в том, что блоки, добавленные с участием монет, не окажутся невалидными.

### Nxt

Nxt [39] – цифровая валюта, полностью основанная на алгоритме proof-of-stake, здесь нет возможности майнить новые монеты и весь их запас (1 миллиард) доступен с самого начала работы системы. Основное отличие Nxt заключается в том, каким образом система обеспечивает защиту от nothing-at-stake и других видов атак.

Блок генерируется, основываясь на уникальной информации из предыдущего блока, которую легко проверить и практически невозможно предугадать. Шанс узла на форжинг нового блока зависит от его эффективного баланса (у каждого аккаунта он свой), времени, прошедшего с момента добавления прошлого блока, и определенного базового значения. Два последних параметра известны всем узлам системы. Основываясь на этих данных, легко предсказать, кто из валидаторов получит право на генерацию следующего блока.

На эффективный баланс учетной записи начисляются монеты, которые не участвовали в транзакциях в течение времени, необходимого на генерацию 1440 блоков. В процессе forging участвуют только монеты, находящиеся на эффективном балансе. Чтобы не допустить проведения long-range атак, участники могут реорганизовать только 720 блоков, предшествующих текущему. Транзакция при этом считается окончательно верной, если она заключена в блок, который находится на расстоянии 10 блоков от текущего.

*Интересно отметить, что в Nxt вместо механизма UTXO, применяемого в Bitcoin и Peercoin, используется модель аккаунтов и балансов, как, например, в Stellar и Ethereum.*

### NEM

Изначально платформа NEM [40] разрабатывалась как клон Nxt, однако, впоследствии была значительно переработана и переросла в самостоятельную систему. Вместо proof-of-stake в NEM используется его модификация под названием proof-of-importance (PoI).

PoI имеет много сходств с PoS, однако при определении следующего валидатора используются дополнительные факторы. Важность узла определяется тремя характеристиками: количество монет, количество проведенных транзакций и возраст самой учетной записи. Таким образом создатели NEM поощряют не только накапливать монеты, но и активно их использовать.

_Так же, как и в Nxt, в NEM отсутствует майнинг монет. Валидаторы получают награду только от комиссии за подтвержденную транзакцию._

В терминологии NEM получение награды за генерацию блока называется _harvesting_. Чтобы иметь возможность участвовать в процессе генерации блоков, пользователь должен иметь на балансе своей учетной записи не менее 10 000 монет. Важно отметить, что монеты начинают участвовать в процессе не сразу после зачисления на баланс. Каждый день «полноправными» монетами становятся 10% от текущего баланса учетной записи.

Можно заметить, что harvesting во многом похож на forging, присутствующий в других PoS-криптовалютах. Однако, у него есть определенные отличия, главное из которых – устройство участника не должно быть постоянно включено для участия в процессе валидации транзакций.

В NEM присутствует механизм _delegated harvesting_. Принцип его работы заключается в том, что участник может подключить свой аккаунт к существующему supernode и использовать его вычислительные мощности для совместной генерации блоков. Таким образом, можно отдать свой POI-рейтинг в распоряжение другого узла, повысив шансы на генерацию нового блока без необходимости наращивать вычислительную мощность.

Как только в сети NEM появляется новая транзакция, первый узел, который ее обнаруживает, верифицирует ее и оповещает других, тем самым каскадно распространяя информацию по сети.

Для поддержания «системы репутации» среди узлов, в NEM используется алгоритм Eigentrust++. Он распределяет нагрузку по системе и устраняет узлы, которые не участвуют в ее развитии.

### Ouroboros

В 2016 году был разработан протокол Ouroboros [41], призванный избавиться от недостатков систем первого поколения. Ouroboros является первым доказуемо стойким PoS-протоколом. В нем право на генерацию следующего блока также определяется случайным образом, но этот процесс является проверяемым и доказуемо честным. Когда в системе имеется большинство честных участников, злоумышленник не сможет повлиять на случайность алгоритма.

В Ouroboros вводится понятие эпохи. Каждая эпоха, в свою очередь, делится на слоты с длительностью 30 секунд (рис. 5.3). Для каждого слота выбирается лидер, который получает право на добавление блока в текущий слот. Лидеры награждаются вне зависимости от того, выпустили ли они блок. Модель безопасности предполагает, что злоумышленник может продлевать произвольное количество цепочек в свой временной слот.

<img width="50%" alt="Рисунок 5.3 – Эпохи, слоты и лидеры" src="/resources/img/volume-2/5.1-Proof-of-stake-consensus-algorithms/Figure-5.3-Epochs,slots-and-leaders.png"/> 

> **_Замечание._** *В системе Cardano, основанной на протоколе Ouroboros, длительность эпохи составляет 5 дней.*

Выбор лидера слота реализован на основе алгоритма Follow the Satoshi (FTS) [42], суть которого заключается в том, что из всех монет, находящихся в доле, случайным образом выбирается одна и ее владелец становится лидером со всеми вытекающими из этого привилегиями и обязанностями. Следовательно, чем больше монет конкретного узла участвует в доле, тем больше у него шансов стать лидером.

Поскольку лидер имеет значительные полномочия, должен существовать способ, который поможет убедиться в том, что он был выбран действительно случайным образом. Для этого применяется специальный распределенный криптографический протокол, гарантирующий случайные значения на выходе. Так называемые избиратели (пользователи, имеющие определенный размер доли, например, 1% от общего количества монет) производят условное «подбрасывание монеты» и делятся результатом с другими избирателями. Идея заключается в том, что каждый участник генерирует входное значение, и в конечном счете они получают общее случайное значение на выходе, на которое не может повлиять злоумышленник при наличии хотя бы одного честного участника в системе.

Выборы делятся на три этапа:

1. Фаза обещания. Каждый участник генерирует секрет, после чего формирует «обещание», в котором содержатся зашифрованные доли для остальных участников, подписывая его при помощи своего секретного ключа, указывает номер эпохи, а также прикрепляет открытый ключ, чтобы каждый участник сети мог проверить корректность всех данных из его сообщения.
2. Фаза раскрытия. Участники раскрывают свои обещания, сформированные на предыдущей фазе. Это значение добавляется избирателями в цепочку блоков.
3. Фаза извлечения. Если по каким-то причинам часть обещаний осталась нераскрытой (у некоторых участников проблемы с сетью и пр.), то оставшиеся участники объединяют свои доли, полученные на первом этапе, и раскрывают все оставшиеся обещания. В конечном итоге у каждого участника должен быть полный набор обещаний и открытых значений с доказательствами их корректности. Затем на их основе генерируется seed для следующей эпохи. Все избиратели получают одинаковое значение seed, которое и используется в алгоритме FTS.

>**_Замечание._** *Фундаментальное предположение протокола Ouroboros заключается в том, что честных узлов должно быть большинство, а именно как минимум 50% + 1. В таком случае можно гарантировать, что злоумышленникам не удастся нарушить постоянство и живучесть системы.*

### Ouroboros Praos

Ouroboros Praos [43] – первый proof-of-stake протокол, нацеленный на масштабирование для широкого использования. Главное отличие Praos состоит в том, что он работает в сетях, где есть неизвестная верхняя задержка доставки сообщения. Он обеспечивает гарантированную безопасность в ситуации, когда злоумышленник выбирает участников, которые работают по его правилам и генерируют выгодные для него блоки. Однако это возможно только если честных участников больше 50%.

Для обеспечения случайности в Ouroboros Praos используются верифицируемые случайные функции. Получая секретный ключ и входные данные, функция выдает псевдослучайное число и доказательство. Любой, кто имеет открытый ключ и доказательство, может проверить, действительно ли число было получено из заданных входных данных, но не может при этом получить его предварительно.

В Praos для каждой эпохи предварительно утверждается значение nonce, которое все участники обязаны использовать в качестве входных данных для своих верифицируемых случайных функций. В каждом слоте каждый участник использует свою верифицируемую случайную функцию и nonce для генерации случайного числа. Если сгенерированное число меньше, чем пороговое значение, соотносимое с долей участника, он становится лидером для заданного слота. Поскольку случайные значения генерируются независимо каждым участником, может возникнуть ситуация, когда у слота несколько лидеров или их нет вообще. Nonce для следующей эпохи вычисляется из значений верифицируемых случайных функций, встроенных в заголовки блоков предыдущей эпохи.

_Если выбирается несколько лидеров, происходит форк, даже если они все являются честными. В случае форка честные стороны должны выбрать цепочку, которую они получили первой. Это означает, что лидеры, которые быстрее передают свои блоки, имеют больший шанс оказаться в самой длинной цепочке._

### Ouroboros Genesis

Ouroboros Genesis [44] был разработан с целью создать PoS протокол, который будет способен корректно работать в аналогичных с Bitcoin условиях. Для этого было введено понятие Dynamic Availability. Под этим подразумевается анализ блокчейн-протокола в среде со следующими характеристиками.

> * _Стороны присоединяются и отключаются по своему желанию_
> * _Количество онлайн и оффлайн участников динамически меняется_
> * _В любой заданный момент времени мы ничего не знаем априори_

Протокол Ouroboros Genesis нацелен на защиту от дальних атак, суть которых в том, что злоумышленник получает доступ к личным ключам пользователей, которые давно потратили свои монеты, и с их помощью создает альтернативную историю, погружаясь в цепочку блоков гораздо глубже.

Главным усовершенствованием Ouroboros Genesis стал новый принцип выбора цепочек. Лидер выбирает самую длинную цепочку, которая не превышает заданную длину, либо ту, которая имеет больше блоков на интервале расхождения цепочек (рис. 5.4).

<img width="50%" alt="Рисунок 5.4 – Схема выбора главной цепочки" src="/resources/img/volume-2/5.1-Proof-of-stake-consensus-algorithms/Figure-5.4-Main-chain-selection-scheme.png"/> 

### Главные преимущества и недостатки proof-of-stake

Теперь, когда мы рассмотрели основные принципы работы proof-of-stake и конкретные реализации учетных систем на основе этого протокола, давайте выделим его преимущества, которые по большей мере проявляются при сравнении его с proof-of-work.

> * _Нет необходимости в значительных вычислительных мощностях_
> * _Право создания блоков зависит не от вычислительной мощности, а от количества монет на балансе (и в некоторых случаях от характеристик этих монет)_
> * _Для создания блоков не нужно специализированное оборудование_

Главное преимущество proof-of-stake-систем заключается в том, что для участия в процессе валидации транзакций не нужно иметь значительные вычислительные мощности: участвовать в forging может любой персональный компьютер с соответствующим программным обеспечением и достаточным количеством монет на балансе кошелька. При этом, как мы упоминали ранее, в таких системах, как NEM, можно делегировать свои монеты _supernode_; в этом случае участнику даже не надо постоянно держать компьютер включенным.

Следующее достоинство значительно повышает стоимость проведения атаки 51% для злоумышленника. Однако это будет правдой только при разумном выборе характеристик монет, которые учитываются при выборе следующего валидатора, и введения некоторой случайности для защиты от атаки предварительного вычисления. Подробнее об этой и других атаках мы поговорим позже.

Последнее важное преимущество непосредственно связано с предыдущими двумя. Для того, чтобы стать валидатором в proof-of-stake системе, не нужно покупать интегральные схемы специального назначения (ASIC), мощную видеокарту или процессор.

Однако proof-of-stake-системы имеют и следующие недостатки.

> * _Одноразовая эмиссия является более централизованным подходом, чем permissionless добыча монет, которая растянута на определенный период времени_
> * _Системы, основанные на proof-of-ptake, подвержены большему количеству атак, а сами атаки провести проще, чем, например, при proof-of-work_

### Основные виды атак на proof-of-stake-системы

Теперь давайте рассмотрим, какие существуют атаки, нацеленные на алгоритм proof-of-stake.

> * _Nothing-at-stake_
> * _Атака предвычислением_
> * _Fake stake_
> * _Атака накоплением возраста монет_
> * _Ближние атаки_
> * _Дальние атаки_

### Атака nothing-at-stake

Суть атаки nothing-at-stake заключается в предположении, что злоумышленник может легко построить альтернативную цепочку блоков, а другие валидаторы ее поддержат, поскольку это ничего не стоит им в плане вычислительной мощности на продолжение обеих цепочек. То есть, может возникнуть ситуация, когда все валидаторы одновременно работают над несколькими разными цепочками (рис. 5.5, 5.6).

<img width="40%" alt="Рисунок 5.5 – Пример корректного поведения узла в ситуации, когда происходит форк" src="/resources/img/volume-2/5.1-Proof-of-stake-consensus-algorithms/Figure-5.5-An-example-when-the-node-behaves-correctly-in-the-case-of-a-fork.jpg"/> 

<img width="43%" alt="Рисунок 5.6 – Проблема nothing-at-stake, когда узел одновременно работает над несколькими альтернативными цепочками" src="/resources/img/volume-2/5.1-Proof-of-stake-consensus-algorithms/-Figure-5.6-Nothing-at-stake-situation-when-the-node-works.png"/> 

Вторая причина, по которой может произойти подобная ситуация, заключается в том, что для валидатора существует финансовая мотивация работать над несколькими цепочками одновременно, поскольку тогда он минимизирует риски упустить свое вознаграждение.

Однако, стоит отметить, что для реализации атаки nothing-at-stake должны выполняться следующие предположения:

1. Валидатор будет искать выгоду для себя в любой возможной ситуации, даже если при этом под удар будет поставлена безопасность и качество работы сети
2. Ни один из валидаторов не будет вести себя согласно с правилами системы
3. Валидаторы модифицируют свое программное обеспечение, либо используют стороннее, которое заведомо модифицировано для некорректного поведения.

Основной риск, связанный с nothing-at-stake, заключается в том, что злоумышленник может провести двойную трату, имея всего 1% общей доли в системе при условии, что все узлы поддержат форк цепочки. Давайте подробнее рассмотрим эту ситуацию (рис. 5.7).

<img width="55%" alt="Рисунок 5.7 – Двойная трата на основе атаки nothing-at-stake" src="/resources/img/volume-2/5.1-Proof-of-stake-consensus-algorithms/Figure-5.7-Double-spending-based-on-nothing-at-stake.png"/> 

1. Алиса создает форк цепочки и отправляет определенное количество монет на обменник.
2. В основную цепочку Алиса добавляет транзакцию, в которой переводит средства на свой альтернативный аккаунт
3. Алиса обменивает свои монеты, транзакция с обменом записывается в альтернативную цепочку, которая также выглядит валидной, поскольку ее поддерживают все участники.
4. Если обмен будет проведен успешно, Алиса выводит полученные монеты на свой кошелек в другой системе.
5. Алиса прекращает валидировать блоки альтернативной цепочки, вследствие чего она обрывается и отбрасывается.

На самом деле такая ситуация крайне маловероятна, поскольку она предполагает, что абсолютно все валидаторы будут поддерживать каждый новый блок. В действующих системах всегда найдутся честные узлы, которые не станут поддерживать альтернативные цепочки. В таком случае Алиса вынуждена будет подговорить часть валидаторов работать над ее цепочкой или повысить свою долю в системе.

### Атака предвычисления

Если узел-валидатор обладает значительной вычислительной мощностью, он может повлиять на хэш текущего блока, чтобы увеличить шансы формирования следующего. Если вычисления показывают, что следующий блок будет принадлежать другому пользователю, злоумышленник снова меняет параметры транзакции и повторяет попытку. Эффективность этой атаки зависит от размера доли злоумышленника и общего количества валидаторов в системе.

Для предотвращения подобных атак нужно добавить в процесс генерации блоков элемент случайности.

### Атака fake stake

Данная атака полагается на то, что некоторые реализации алгоритма достижения консенсуса на основе proof-of-stake не выполняют проверку coinstake транзакции перед помещением блока в ОЗУ или на жесткий диск. Coinstake транзакция – это специальная транзакция, которую узел отправляет самому себе при формировании блока. Вследствие этого злоумышленник с очень малым количеством монет (или вообще без них) может привести узел-жертву к сбою, заполнив его жесткий диск или ОЗУ поддельными данными.

Проблема в том, что во многих PoS-системах (например, HTMLCoin, Emercoin, Qtum и др.) блоки распространяются по сети, разделяясь на два отдельных сообщения: Блок и Заголовок. Узлы запрашивают Блок только после того, как Заголовок проходит валидацию и попадает в самую длинную цепочку. Поскольку coinstake-транзакция содержится только в Блоке, узел не сможет провалидировать Заголовок без него. Следовательно, ему приходится хранить Заголовок непосредственно в оперативной памяти, что дает злоумышленнику возможность заполнить ОЗУ узла фиктивными транзакциями.

### Атака накоплением возраста монет

Такая атака была осуществима в ранних версиях монет, в которых используется механизм возраста монеты. Злоумышленник, обладающий определенной долей, мог подождать в течение длительного времени и получить практически полный контроль над сетью.

На данный момент в таких системах, как Peercoin, Novacoin и Blackcoin введено ограничение на максимальный возраст монет, равное 90 дням.

### Short-range атаки

Для выполнения ближней атаки злоумышленник создает альтернативную цепочку блоков, начиная с блока, который расположен недалеко от текущего, и пытается перегнать основную цепочку, убедив участников переключиться на свою версию. Валидаторам выгоднее работать над несколькими цепочками одновременно, поскольку это повышает их доход и увеличивает шанс, что они будут работать над правильной версией.

Однако, как вы помните из прошлых разделов, в некоторых PoS-системах, например, Nxt, используются механизмы, которые на основе совокупности определенных характеристик позволяют предугадать, кто будет следующим работать над новым блоком.

Альтернативный подход защиты от ближних атак заключается в том, что валидаторы обязаны «оставить в залог» определенное количество монет прежде, чем получить право участвовать в процессе генерации блоков. Валидаторы, которые подписывают своим ключом соревнующиеся блоки, будут терять сумму своего залога.

### Long-range атаки

Суть long-range атаки заключается в том, что злоумышленник пытается переписать историю блокчейна, начиная с genesis block, поскольку, в отличие от PoW-систем, это не требует значительных вычислительных ресурсов. Кроме того, злоумышленник может попытаться получить доступ к личным ключам первых участников системы, чтобы использовать соответствующие монеты для построения альтернативной цепочки.

Предотвратить подобную атаку можно, ограничив глубину, начиная с которой валидаторы могут создать альтернативную цепочку блоков. Именно таким методом пользуются активные на текущий момент PoS-системы.

**Часто задаваемые вопросы**

*– Почему владелец кошелька, у которого много монет в системе, не может использовать их для мошенничества?*

В случае, когда владелец кошелька с большим количеством монет попытается смошенничать, цена этих монет упадет, а для него это крайне невыгодно.

*– Если 100 узлов сети proof-of-stake раз в секунду сгенерируют и отправят в сеть свои предложения блоков, останется один выбранный блок. Кто именно выберет, какой из этих блоков будет верным, и исключит остальные 99?*

В алгоритме консенсуса будет заложено правило выбора блока. Чтобы все руководствовались этим правилом и выбрали один блок, предусмотрены определенные параметры. Например, в Peercoin это coinage. В случае PoW, если кто-то сгенерировал правильный блок, но вместо него приняли другой, создатели блока впустую потратили вычислительную мощность. В классическом же PoS создатель блока не тратит свои монеты. В том же Peercoin они останутся непотраченными на той же глубине цепочки и их можно будет использовать для следующей попытки генерации блока.

*– Можно ли в PoS-системе защититься от ситуации, когда злонамеренные узлы изменят правила блока?*

Нельзя поменять правила, не изменив исходный код уже запущенных узлов. Децентрализованные системы предполагают наличие определенных правил учета и всегда существуют узлы, которые придерживаются этих правил. Конечно, некоторые злонамеренные узлы могут изменить свое программное обеспечение, но тогда они не смогут работать с честными узлами и всякие попытки изменить протокол или его правила будут неудачными.

## 5.2 Delegated proof-of-stake как алгоритм достижения консенсуса

DPoS (delegated proof-of-stake) – это алгоритм достижения консенсуса в децентрализованной среде, который является альтернативой таким вариантам, как PoW (Bitcoin proof-of-work) и PoS (Peercoin или NXT proof-of-stake). DPoS был разработан в 2014 году в рамках проекта Graphene и впервые был задействован в проекте Bitshares, а позже в проектах Steemit и EOS. DPoS решает основную проблему PoW, а именно высокое потребление энергии данным алгоритмом. DPoS решает данную проблему, предоставляя право формировать блоки только выбранным путем голосования узлам-валидаторам сети с аппаратурой, отвечающей определенным требованиям по вычислительной мощности.

Также DPoS решает основную проблему PoS, а именно надобность запуска пользователем полного узла сети для того, чтоб его монеты принимали участие в достижении консенсуса. В DPoS же данная проблема решена наличием валидаторов с запущенными полными узлами сети, которые обрабатывают транзакции, а пользователю для того, чтоб его монеты принимали участие в достижении консенсуса, достаточно лишь отправить специальную транзакцию с голосом.

В DPoS-системах, в отличии от proof-of-stake систем, монеты, которые находятся у пользователей, могут одновременно участвовать в голосовании и при этом использоваться для переводов. А в результате изменения баланса вес в голосовании будет изменяться соответственно.

Такой тип достижения консенсуса лучше всего подходит для построения учетной системы, которая предусматривает наличие как обычных пользователей (мобильные клиенты), так и множества компаний (полноценные узлы, которые могут играть роль валидаторов). DPoS спроектирован таким образом, что поддерживает высокую частоту генерации новых блоков и способен обрабатывать большое количество транзакций в единицу времени по сравнению с другими алгоритмами достижения консенсуса, которые работают в распределенной среде без доверия. DPoS хорошо подходит для проектирования систем с открытым доступом, где не требуется идентификация пользователей.

### Алгоритм DPoS

Условия, в которых работает данный алгоритм достижения консенсуса, отличаются от условий в которых работает PoW и PoS. А именно, валидаторам необходимо раскрыть свои личности и заявить о готовности бесперебойно поддерживать работу полноценного узла сети, своевременно выполнять верификацию транзакций и формировать новые блоки.

Механизм достижения консенсуса на основе модифицированного proof-of-stake работает по такому правилу, что каждый пользователь по желанию может выставить свою кандидатуру на пост валидатора. Потом среди всех пользователей проводится голосование за кандидатов, где вес каждого голоса определяется суммой активов голосующего. Благодаря тому, что пользователи могут видеть, кто из валидаторов получил возможность формировать новые блоки, они могут составить строгую последовательность из валидаторов и оптимизировать формирование блоков и их проверку. Это позволяет платформе уменьшить время формирования блоков и повысить пропускную способность. На практике было проверено, что при количестве валидаторов несколько десятков можно достичь частоты генерации блока 1–2 Гц.

В зависимости от реализации DPoS, пользователь также может определить вес ставки, но ставка ни в коем случае не может превышать по значению количество имеющихся у пользователя активов. Есть еще одна особенность, наличие которой тоже зависит от реализации DPoS – proxy voting, которая состоит в том, что если пользователь не знает, за какого члена комитета или валидатора нужно голосовать, он может отдать свой вес голоса другому обычному пользователю, которого он считает более компетентным в этом вопросе.

По результатам голосования выбирается N (натуральное число, которое выбирает сообщество, обычно 20–50) кандидатов, которые получают право формировать новые блоки транзакций. Интересно, что члены комитета (если такие присутствуют) и валидаторы неанонимны. В системе определенной цифровой валюты они имеют аккаунты, ассоциированные с их identities. Они имеют определенную репутацию, участвуют в разработке проекта, присутствуют на форумах, предлагают свои улучшения и т. д. Их деятельность видна. Правила протокола гарантируют корректное принятие решений, если большая часть активов, принимающих участие в голосовании, контролируется честными пользователями.

Делегаты, ставшие валидаторами по результатам голосования, псевдослучайно перемешиваются, образуя очередь, и начинают поочередно публиковать блоки. Для перемешивания можно использовать некий общий для всех рандомизатор – число, на основе которого будет определен порядок валидаторов. В качестве рандомизатора может использоваться последнее состояние цепочки блоков – хэш-значение последнего блока. Для всех, кто переключается на правильную по протоколу версию цепочки блоков, хэш-значения будут совпадать. Следовательно, валидаторы будут перемешаны одинаковым для всех образом, но этот порядок невозможно предсказать, поскольку хэш-значение от новых блоков невозможно знать заранее. После того, как последний валидатор в очереди опубликовал блок, заканчивается цикл работы группы валидаторов и начинается новый в том же порядке.

Список валидаторов действителен в течении эпохи, состоящей из циклов работы валидаторов. После каждой эпохи (рис. 5.7) происходит обновление списка валидаторов в соответствии с результатами голосования, голоса пользователей, проголосовавших во время работы валидаторов, вступают в силу. Позже эти действия повторяются.

<img width="50%" alt="Рисунок 5.7 – Этапы достижения консенсуса" src="/resources/img/volume-2/5.2-Delegated-proof-of-stake-as-a-consensus-algorithm.png/Figure-5.8-Consensus-achievement-stages.png"/> 

Валидаторы принимают участие в следующих процессах:
> * _Поддержка полных узлов в стабильном рабочем состоянии_
> * _Сбор и верификация транзакций от всех пользователей_ 
> * _Формирование блоков_
> * _Подпись и публикация блоков_
> * _Верификация блоков других валидаторов_

Валидаторы публикуют блоки с хэш-значением последнего блока, с которым они согласны. Если все валидаторы честны и согласны друг с другом, то цепочка блоков выглядит подобным образом (рис. 5.8 (1)). Если же появляется разногласие, например, валидатор С не согласен с блоком валидатора В, то цепочка блоков будет иметь разветвление (рис. 5.8 (2)). И уже в зависимости от выбора остальных валидаторов, будет определена актуальная цепочка.

<img width="42%" alt="Рисунок 5.8 – Структура цепочки блоков при: (1) – согласии валидаторов; (2) – несогласии валидаторов относительно дальнейшего блока" src="/resources/img/volume-2/5.2-Delegated-proof-of-stake-as-a-consensus-algorithm.png/Figure-5.9-Blockchain-structure-(1)-validators-are-in-agreement-(2)-validators-disagree-about-the-next-block.png"/> 

Делегаты, запустившие полные узлы сети и готовые предоставить свои услуги, но не ставшие валидаторами, остаются в ожидании стать таковыми. Узел делегата фактически является узлом-аудитором, но может в любой момент стать узлом валидатором, если поднимется в очереди кандидатов. 

В зависимости от реализации DPoS, например BitShares, у пользователей также может иметься возможность передать свой вес голоса неким доверенным лицам, единственной целью которых является следить за системой и голосовать. Данная опция называется proxy voting.

При этом стоит заметить, что в том же BitShares пользователи, помимо выборов валидаторов, также имеют возможность выбирать членов комитета (committee members) и рабочих (workers). Члены комитета – пользователи, которые имеют право менять путем голосования параметры протокола, такие как размер блоков, интервалы между ними, и определять комиссию за транзакции. Рабочие – это пользователи предоставляющие свои предложения по выполнению ими определенной фактической работы по обновлению протокола. Если предложение рабочего набрало достаточное количество голосов членов комитета, то _worker_ начинает разработку и получает вознаграждение за каждый этап его выполнения.

В данном алгоритме вес каждого делегата напрямую зависит от пользователей. Голосуя, пользователи могут лишить их веса, перенаправив или сняв с них свои ставки, если те начинают действовать в ущерб системе или перестают выполнять работу. Стоит заметить, что изменения в голосах вступают в действие после конца эпохи работы валидаторов. Поэтому теоретически состав валидаторов может полностью меняться каждую эпоху.

### Как запускается учетная система, использующая DPoS?

Вначале, имея в системе с DPoS только пользователей, не доверяющих друг другу, и не имея среди них валидаторов для публикации блоков, а соответственно, не имея возможности выдвинуться в валидаторы и проголосовать, систему с DPoS запустить не получится. Поэтому в основном перед запуском подобной системы сообществом проводится отдельное голосование на отдельной платформе. В данном голосовании выбираются среди будущих пользователей первая группа валидаторов и остальных ролей. Члены сообщества также могут огласить первый список валидаторов и остальных ролей, состоящий из своих доверенных пользователей.

### Как работает DPoS?

Пользователи, желающие выдвинуть свою кандидатуру на роль валидатора, запускают полный узел сети и заявляют о своей готовности формировать блоки. Для этого они формируют транзакции с операцией создания нового делегата. После выдвижения делегата, пользователи, желающие проголосовать, формируют транзакцию с операцией голосования.

Например, Алиса и Боб хотят стать валидаторами (рис. 5.9), для этого они формируют транзакции с операцией создания нового делегата, которые появляются в ledger с публикацией блока n. Ева имеет 115 монет на счету, а Кэрол 564 монет и они обе хотят проголосовать. Для этого они формируют транзакции с операцией голосования, которые появляются в леджере с публикацией одного из следующих блоков. Например, блока n+1.

<img width="42%" alt="Рисунок 5.9 – Пример голосования" src="/resources/img/volume-2/5.2-Delegated-proof-of-stake-as-a-consensus-algorithm.png/Figure-5.10-Voting-example.png"/> 

Рассмотрим работу DPoS на общем примере с тремя валидаторами и тремя циклами их работы.

Пользователи: Алиса, Боб, Кэрол, Ева, Вилл, Джо и Мари.
Баланс средств: Алиса  – 1, Боб  – 2, Кэрол  – 3, Ева – 4, Вилл – 5, Джо – 6, Мари – 7.

Можно заметить, что среди всех пользователей наиболее влиятельным на этапе голосования является Мари. Далее происходит голосование (рис. 5.10):

За Кэрол проголосовали: Ева (4), Алиса (1), Вилл (5), Джо (6).
За Еву проголосовали: Кэрол (3), Боб (2), Мари (7).
За Алису проголосовали: Кэрол (3), Ева (4), Боб (2), Джо (6).
За Боба проголосовали: Вилл (5).

<img width="30%" alt="Рисунок 5.10 – Результат голосования" src="/resources/img/volume-2/5.2-Delegated-proof-of-stake-as-a-consensus-algorithm.png/Figure-5.11-The-voting-results.png"/> 

В результате голосования Кэрол, Ева и Алиса, имея наибольшее количество голосов, считаются равноправными валидаторами, а Боб, имея меньше голосов, остается делегатом. В этом случае консенсус достигается путем поочередной публикации блоков группой валидаторов. Допустим, некий пользователь хочет провести конфликтующие транзакции ТхА и TxВ. Транзакции проверяют валидаторы: Алиса, Кэрол и Ева публикуют блоки только с транзакциями, с которыми они согласны. Здесь может быть два случая.

#### Случай 1
Валидаторы согласны с ТхВ (рис. 5.11). Ева согласна с ТхВ, Алиса согласна с ТхВ, а значит, согласна и с Евой. Кэрол согласна с ТхВ, а значит, согласна и с Алисой. Цепочка блоков не разветвляется.

<img width="50%" alt="Рисунок 5.11 – Формирование блоков, если каждый из валидаторов согласен с предыдущем состоянием блока" src="/resources/img/volume-2/5.2-Delegated-proof-of-stake-as-a-consensus-algorithm.png/Figure-5.12-Block-formation-if-every-validator-agrees-with-the-previous-block-state.png"/> 

#### Случай 2
Кэрол согласна с ТхА, в то время как Ева и Алиса согласны с ТхВ. Ева формирует блок с выбранной ею транзакцией, после чего Алиса, если согласна с выбором Евы, формирует свой блок, основываясь на блоке Евы, в ином же случае Алиса формирует отдельный удовлетворяющий ее блок. Далее Кэрол формирует блок, основываясь на одном из блоков Евы или Алисы, с которым она согласна. Таким образом, цепочка блоков разветвляется. Теперь для всех узлов сети есть две альтернативные цепочки блоков на выбор. Если они обе соответствуют правилам протокола, то честные узлы заинтересованы сделать одинаковый выбор. Для этого в протоколе существует правило, которое гласит, что приоритетной является та цепочка, которая поддерживается большим количеством валидаторов. В этом примере (рис. 5.12) Алиса и Ева предпочли транзакцию TxB. Поскольку это большинство валидаторов, цепочка с ТхВ считается актуальной, а цепочка с ТхА считается ответвлением.

<img width="50%" alt="Рисунок 5.12 – Формирование блоков в случае несогласия одного из валидаторов относительно набора транзакций" src="/resources/img/volume-2/5.2-Delegated-proof-of-stake-as-a-consensus-algorithm.png/Figure-5.13-Block-formation-while-one-of-the-validators-disagree-with-the-transaction-set.png"/> 

Допустим, произошел случай №2 и был опубликован блок с ТхА, а не с ТхВ. Кэрол дискредитировала себя перед пользователями сети – и они решили перераспределить голоса (рис. 5.13):

За Кэрол проголосовали: Боб (2).
За Еву проголосовали: Кэрол (3), Алиса (1), Вилл (5), Джо (6).
За Алису проголосовали: Ева (4), Вилл (5), Джо (6).
За Боба проголосовали: Вилл (5), Джо (6), Мари (7).

<img width="30%" alt="Рисунок 5.13 – Результаты второго голосования" src="/resources/img/volume-2/5.2-Delegated-proof-of-stake-as-a-consensus-algorithm.png/Figure-5.14-Second-vote-results.png"/> 

В результате, Боб, Ева и Алиса, имея наибольшее количество голосов, считаются равноправными валидаторами и Кэрол, имея меньше голосов, перестала быть валидатором. Список валидаторов обновляется и весь процесс повторяется.

## 5.3 Алгоритмы, относящиеся к BFT-классу

Не все учетные системы требуют такого уровня децентрализации, как в Bitcoin, но при этом нуждаются в гораздо более высокой пропускной способности и малом времени подтверждения транзакций. Более того, очень часто имеет смысл создания учетной системы permissioned характера с возможностью назначения валидаторов исключительно в ручном режиме. В таких условиях и работают BFT-протоколы достижения консенсуса.

В данном разделе мы рассмотрим принципы функционирования наиболее используемых протоколов такого класса, проведем сравнительную характеристику рассмотренных протоколов, а также объясним, чем обеспечивается отказоустойчивость систем BFT-типа.

### Practical BFT algorithm

Practical Byzantine Fault Tolerance (pBFT) [45] алгоритм достижения консенсуса предназначен для функционирования в асинхронных децентрализованных системах. Все узлы в системе связаны между собой, причем в каждый момент времени один из узлов является лидером. Целью протокола является достижения согласия между всеми честными узлами, когда количество failed узлов не больше _(n − 1) / 3_, где _n_ – это общее количество узлов-валидаторов в системе. В контесте BFT под failed узлами подразумеваются не только те, которые бездействуют или ведут себя непредсказуемо, а еще и те, которые намеренно вступили в общий сговор с целью нарушения работы честных узлов.

Алгоритм состоит из 5 основных этапов, начиная от предложения добавления транзакций до конечного обновления состояния учетной системы.

> * _Request_
> * _Pre-prepare_
> * _Prepare_
> * _Commit_
> * _Reply_

Далее мы рассмотрим особенности каждого из этапов достижения консенсуса при помощи pBFT, после чего разберемся, как количество честных узлов влияет на способность системы достичь согласия относительно обновления состояния учетной системы.

На этапе _request_ происходит получение узлом лидером транзакций для подтверждения (рис. 5.14). При получении транзакций, узел-лидер выполняет их проверку и объединяет в блок. После этого блок подписывается и может быть распространен остальным валидаторам платформы.

<img width="40%" alt="Рисунок 5.14 – Схема получения транзакций лидером" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.15-Leader-receives-transactions.png"/> 

Далее наступает _pre-prepare_ этап, во время которого узел-лидер рассылает всем остальным валидаторам сформированный блок (рис. 5.15). Блок подписан валидатором-лидером и отправлен вместе с pre-prepare сообщением, в результате чего остальные узлы могут аутентифицировать отправителя и понять, к какому этапу достижения консенсуса относится этот блок. Отметим, что общее количество сообщений, передаваемых на этом этапе, равно _n − 1_, где _n_ – общее количество валидаторов.

<img width="40%" alt="Рисунок 5.15 – Схема передачи блока валидаторам" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.16-Block-transmission-scheme.png"/> 

На протяжении следующего этапа (_prepare_) остальные валидаторы обмениваются полученным блоком с друг другом (каждый валидатор отправляет блок всем остальным валидаторам). Блок отправляется вместе с сообщением prepare и подписью отправившего его валидатора (рис. 5.16). Таким образом каждый валидатор сообщает, что он верифицировал данный блок и готов его подтвердить. Максимальное количество сообщений на этом этапе равно _(n − 1) * (n − 1)_, где _n_ – общее количество валидаторов. Если некоторые узлы отказывают в обслуживании и не отвечают, минимальное количество сообщений в сети равно _(n − 1 − f) * (n − 1)_, где _f_ – количество failed узлов _(f<sub>max</sub> = (n − 1) / 3)_.

<img width="40%" alt="Рисунок 5.16 – Схема обмена блоками между валидаторами" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.17-Block-exchange-scheme.png"/> 

На этом этапе важно отметить, что сеть является асинхронной, то есть фактически будут присутствовать задержки при передаче сообщений между валидаторами. В таких условиях решения о переходе к следующему этапу решается независимо каждым отдельным узлом согласно получения _2f + 1_ подтверждений от других валидаторов. Иначе говоря, как только один из узлов получил prepare сообщение (относительно одного и того же блока) от _2f + 1_ различных валидаторов, он может переходить к следующему этапу.

Когда необходимое количество подтверждений получено, узел переходит к _commit_ этапу, на котором он заявляет о подтверждении конкретного блока. На этом этапе он формирует commit сообщение, подписывает и пересылает его всем остальным валидаторам (рис. 5.17). Как только отдельный узел получает commit сообщения от _2f + 1_ валидаторов, он обновляет локальное состояние базы данных в соответствии с подтвержденными транзакциями. Максимальное количество сообщений на этом этапе равно _n * (n − 1)_, а минимальное _(n − f) * n_.

<img width="40%" alt="Рисунок 5.17 – Схема обмена commit-сообщениями" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.18-Commit-messages-exchange-scheme.png"/> 

После того как локальные копии баз данных валидаторов обновлены, пользователи могут запросить у них актуальное состояние и убедиться в том, что очередной блок был подтвержден большинством валидаторов (рис. 5.18). Отметим, что pBFT алгоритм достижения консенсуса гарантирует, что если валидаторы добавили очередной блок в цепочку блоков, то этот блок не может быть изменен/заменен.

<img width="40%" alt="Рисунок 5.18 – Схема распространения нового состояния системы" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.19-New-system-state-distribution-scheme.png"/> 

Некоторым ограничением протокола practical BFT является большое количество сообщений, которыми валидаторы обмениваются между собой. Отметим, что максимально возможное и минимальное количество таких сообщений, когда возможно достижение консенсуса, равно:

$$Messages_{max} = n + (n − 1) * (n − 1) + n * (n − 1),$$

$$Messages_{min} = n + (n − 1 − f) * (n − 1) + (n − f) * (n − 1),$$

где $n$ – количество всех валидаторов, $f$ – максимальное количество failed узлов (табл. 5.1).

Таблица 5.1
<img width="50%" alt="Таблица 5.1" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Table-5.1.png"/> 

Давайте детальнее рассмотрим, как узлы достигают консенсуса, и что происходит в случае, если несколько узлов-валидаторов отказывают в обслуживании или ведут себя злонамеренно.

### Процесс достижения консенсуса

Представим ситуацию, когда в достижении консенсуса при помощи pBFT протокола принимают участие 5 валидаторов, среди которых один является лидером. В таких условиях наибольшее количество failed узлов равняется 1 (если откажут 2 или более узлов – консенсус достигнут не будет).

Для начала рассмотрим случай если все из узлов являются честными и ни один из них не отказал в обслуживании (рис. 5.19). Процесс достижения консенсуса можно разбить на следующие шаги.

1. _Request_. На первом этапе узел-лидер получает транзакции от пользователей системы, проверяет их в соответствии с правилами протокола и формирует блок.
2. _Pre-prepare_. Далее узел-лидер распространяет этот блок остальным валидаторам. Так как узел-лидер ведет себя честно, все остальные валидаторы получают один и тот же блок.
3. _Prepare_. Узлы обмениваются между собой полученным блоком. Так как все узлы честные и не отказывают в обслуживании, то по окончании этого этапа каждый валидатор имеет одинаковые подтверждения блока от всех остальных узлов. Поэтому они могут перейти к этапу commit.
4. _Commit_. Валидаторы обмениваются значением блока, которое они готовы подтвердить. По окончании этого этапа каждый из валидаторов получает абсолютное большинство подтверждений единого блока и обновляет свое состояние реестра.
5. _Reply_. Пользователи системы обращаются к валидаторам за актуальным состоянием. Поскольку все валидаторы обновили свое состояние реестра на основании одного и того же блока, то остальные участники (аудиторы и обычные пользователи) могут обновлять свое локальное состояние.

<img width="50%" alt="Рисунок 5.19 – Схема обмена сообщениями между честными валидаторами" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.20-Message-exchange-scheme-for-honest-validators.png"/> 

Теперь рассмотрим ситуацию (рис. 5.20), когда один из пяти валидаторов попытается помешать достижению консенсуса (фактически этот узел может просто отказать в обслуживании, но мы рассмотрим ситуацию когда узел ведет себя злонамеренно – оба случая на уровне достижения консенсуса не отличаются друг от друга).

1. _Request_. Лидер получает транзакции и формирует из них блок.
2. _Pre-prepare_. В данном примере узел-лидер является честным узлом, соответственно, он отправляет всем остальным узлам одинаковое значение блока.
3. _Prepare_. Узлы обмениваются сообщениями между собой и каждый ждет _2f + 1_ подтверждений конкретного блока (от _2f + 1_ честных валидаторов). Отметим, что несмотря на злонамеренное поведение одного из валидаторов и то, что он отправляет всем остальным узлам значение блока, которое отличается от исходного, остальные честные валидаторы могут получить необходимое количество подтверждений и перейти к следующему этапу.
4. _Commit_. Валидаторы еще раз обмениваются друг с другом сообщениями, содержащими подтверждаемый блок. Даже когда злоумышленный валидатор отправляет всем не валидное значение блока, остальные валидаторы все равно получают требуемое количество подтверждений и обновляют локальное состояние реестра.
5. _Reply_. При обращении к валидаторам, пользователи ориентируются на блок, который был подтвержден большинством, а соответственно не валидный блок, отправленный злоумышленником, учитываться при обновлении состояния реестра не будет.

<img width="50%" alt="Рисунок 5.20 – Схема обмена сообщениями между валидаторами с одним нечестным" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.21-Message-exchange-scheme-with-one-malicious-validators.png"/> 

Действительно проблемной для данного примера становится ситуация, при которой больше одного злоумышленного узла (рис. 5.21). В этом случае оставшиеся узлы не смогут достичь консенсуса (хотя их и больше, чем злоумышленников). Поэтому мы рассмотрим функционирование той же системы, но уже при наличии двух злоумышленных валидаторов.

1. _Request_. Лидер получает транзакции и формирует из них блок.
2. _Pre-prepare_. Узел-лидер все еще честный узел, соответственно, он отправляет всем остальным узлам одинаковое значение блока.
3. _Prepare_. Узлы обмениваются сообщениями между собой и каждый ждет _2f + 1_ подтверждений. Однако количество злоумышленных узлов превышает значение _f_, честные узлы не получат достаточное количество подтверждений и не смогут перейти к следующему этапу достижения консенсуса (этапы commit и reply пропускаются, новый блок не создается и узлы повторяют попытку заново).

При этом важно отметить, что если бы узел-лидер гарантированно был честным, то сеть могла бы достигнуть консенсуса (ведь каждый из остальных честных узлов имел бы три подтверждения из пяти). Но поскольку узлы не уверены, что лидер ведет себя честно (фактически он может поменять свое решение), то в таких условиях консенсус не может быть достигнут.

<img width="50%" alt="Рисунок 5.21 – Схема обмена сообщениями между валидаторами с двумя нечестными" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.22-Message-exchange-scheme-with-two-malicious-nodes.png"/> 

В качестве последнего варианта развития событий рассмотрим ситуацию, когда злоумышленником является лидер (рис. 5.22). В этом случае он может передавать всем остальным узлам различное значение блоков и, соответственно, согласие достигнуто не будет.

1. _Request_. Лидер получает транзакции и формирует 4 различных блока.
2. _Pre-prepare_. Узел-лидер передает всем остальным узлам разные значения блоков. На данном этапе узлы не знают, что получили различные значения блоков, и поэтому они переходят к следующему этапу.
3. _Prepare_. Узлы обмениваются сообщениями между собой (каждый отправляет каждому) и каждый ждет _2f + 1_ подтверждений. Так как все из них получили различное значения блоков, они и обмениваются различными значениями, что в итоге приводит к тому, что все из них не смогут дождаться необходимого количества подтверждений и не смогут перейти к следующим этапам достижения консенсуса.

<img width="50%" alt="Рисунок 5.22 – Схема обмена сообщениями между валидаторами с нечестным лидером" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.23-Message-exchange-scheme-with-a-malicious-leader.png"/> 

### HotStuff как алгоритм достижения консенсуса

HotStuff [46] также является BFT-подобным алгоритмом достижения консенсуса, который также подразумевает наличие лидера. Однако в этой схеме каждый шаг достижения консенсуса зависит от лидера. Каждый узел не обменивается сообщениями между всеми остальным узлами, а передает его лидеру, который в дальнейшем занимается его распространением. На каждом этапе лидер предлагает изменение состояния достижения консенсуса (переход на новый этап), а остальные узлы подтверждают либо отклоняют его.

Подобный подход позволяет значительно снизить нагрузку на сеть в целом путем уменьшения количества передаваемых узлами сообщений.

Алгоритм подразумевает 4 этапа, по прохождению которых узлы достигают консенсуса относительно изменения состояния реестра (рис. 5.23).

> * _Prepare_
> * _Pre-commit_
> * _Commit_
> * _Decide_

На каждом из этих этапов узел-лидер формирует так называемый quorum certificate который содержит подписи остальных валидаторов. Здесь используется механизм пороговой подписи: узлы переходят к следующему этапу взаимодействия, когда сертификат набирает количество подписей, превышающее необходимый порог _2f + 1_. Перед началом каждого следующего этапа лидер передает всем валидатором сертификат предыдущего этапа. Узлы проверяют, что необходимый порог в сертификате достигнут, и могут голосовать относительно следующего этапа достижения консенсуса.

<img width="50%" alt="Рисунок 5.23 – Схема передачи сообщений между валидаторами" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.24-Message-exchange-scheme.png"/> 

_Prepare_ подразумевает получение узлом-лидером набора транзакций из сети, формирование блока для подтверждения и распространение этого блока остальным узлам валидаторам вместе с prepare сообщением.

На этапе _pre-commit_ узлы проверяют, что полученный на предыдущем этапе блок удовлетворяет правилам протокола, после чего отправляют узлу-лидеру подтверждение о своей готовности завалидировать этот блок. Лидер получает prepare голоса валидаторов и объединяет их в pre-commit quorum certificate, после чего распространяет его остальным валидаторам для подтверждения вместе с pre-commit сообщением. 

На этапе _commit_ валидаторы проверяют pre-commit сертификат, и если они с ним согласны, то подписывают pre-commit сообщение и возвращают его лидеру. Чтобы этот pre-commit сертификат считался валидным, он должен быть подписан пороговым количеством валидаторов. Подписью валидатора покрываются все транзакции, поэтому фактически лидер собирает голоса валидаторов относительно целого блока и не может изменить его в дальнейшем, поскольку при этом подписи перестанут быть валидными.

После получение достаточного количества подтверждений лидер снова формирует quorum certificate, однако уже для этапа commit, и отправляет его остальным валидаторам, после чего узлы переходят к следующему этапу голосования.

На этапе _decide_ происходит аналогичный процесс. Валидаторы получают commit quorum certificate от лидера, проверяют что он валиден и содержит подписанный необходимым количеством валидаторов сертификат предыдущего этапа, после чего подписывают и его. После того как лидер получает достаточное количество подтверждений commit quorum certificate, он формирует decide certificate и передает его всем узлам валидаторам.

При получении такого сертификата, валидаторы считают что все этапы достижения консенсуса пройдены и обновляют свое состояние реестра в зависимости с транзакциями.

Теперь давайте рассмотрим количество сообщений, которые передаются между валидаторами системы в этом случае (табл. 5.2).

Таблица 5.2
<img width="50%" alt="Таблица 5.2" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Table-5.2.png"/> 

Как видно из графика, протокол HotStuff позволяет во много раз уменьшить количество передаваемых сообщений, по сравнению с pBFT. Для сравнения приведем график соотношения количества валидаторов и количество передаваемых между узлами сообщений (рис. 5.24).

<img width="35%" alt="Рисунок 5.24 – График зависимости количества передаваемых сообщений от используемого алгоритма" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.25-Relationship-between-the-number-of-transmitted-messages-and-the-algorithm-used.png"/> 

При этом необходимо понимать, что в случае, если на одном из этапов достижения консенсуса откажет в обслуживании узел-лидер, то:

* pBFT протокол подразумевает, что консенсус все равно будет достигнут, если количество честных узлов достаточно (и если отказ лидера не происходит на самом первом этапе):
* HotStuff подразумевает, что консенсус не может быть достигнут, так как переход на каждый следующий этап инициируется лидером и не может быть инициирован никем другим.

**Часто задаваемые вопросыs**

*– Что произойдет, если узел лидер откажет в обслуживании на продолжительное время?*

Очень часто протоколом достижения консенсуса предусматривается, что роль лидера передается каждому новому узлу на каждом этапе формирования нового блока. Таким образом, если валидатор, который является лидером, откажет в обслуживании и консенсус относительно одного из блока достигнут не будет, то следующий блок будет инициирован уже следующим узлом.

*– Чем ограничено максимальное количество валидаторов для алгоритмов достижения консенсуса из класса BFT?*

В теории нет строгого ограничения, однако наиболее эффективным количеством валидаторов BFT-based алгоритмов достижения консенсуса являются: до нескольких десятков валидаторов в случае pBFT подобных алгоритмов; или для нескольких сотен в случае использования HotStuff и схожих с ним протоколов. Эти показатели являются наиболее оптимальными с точки зрения безопасности учетной системы, и при этом позволяют сохранять небольшим количество передаваемых сообщений и время достижения консенсуса. 

*– Что обычно нужно, чтобы стать валидатором в системе на основе алгоритма достижения консенсуса, принадлежащего классу BFT?*

Чтобы добавить или удалить валидатора, необходимо согласие на это _2f + 1_ всех текущих валидаторов. Поэтому, чтобы стать валидатором, необходимо получить согласие у текущих валидаторов и установить соединения с ними.

## 5.4 FBA как подход к достижению консенсуса

FBA (Federated Byzantine Agreement) – это алгоритм достижения консенсуса, который строится на основе BFT. Главное отличие FBA – взаимодействие узлов в системе определяется динамически самими участниками. То есть, узел становится валидатором для тех, кто ему доверяет. В области финансовых технологий впервые алгоритм FBA был успешно использован на платформе Stellar.

В FBA владелец узла самостоятельно должен выбрать группу узлов, владельцам которых он доверяет (ожидая что они не нарушат правила). При этом доверие может быть установлено в одну сторону, т. е. узел A может доверять решениям узла В, но В не обязательно будет верить А.

FBA позволяет достигать консенсус среди неограниченного количества валидаторов, которые не знают друг друга, а общее их количество может быть не известно.

### Понятия quorum, quorum slice и quorum intersection

Множество, в которое входит конкретный узел и узлы, которым он доверяет, называется _quorum slice_. При этом у одного узла может быть несколько slices.

Quorum для узла А – это все узлы из его slice и узлы, состоящие в slices этих узлов. Другими словами – все, кому доверяет А и те, кому доверяют они. Более того, quorum может быть более глубоким, включая тех, кому доверяют узлы, которым доверяет А. Quorum – это замкнутое множество узлов, которого достаточно для достижения соглашения в распределенной системе.

Quorum intersection – это узел или несколько узлов, которые принадлежат одновременно нескольким slices. Quorum и quorum slice – относительные множества, которые определены для каждого из узлов отдельно. Таким образом, число всех возможных quorum (или slice) может быть больше количества узлов во всей сети.

На рисунке 5.25 показан пример сети с quorum slice и quorum относительно узла F. Стрелками показано направление доверия. Если между узлами есть две противоположные стрелки – они взаимно доверяют друг другу. Если стрелка одна – второй узел не доверяет первому.

<img width="42%" alt="Рисунок 5.26 – Пример quorum intersection" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.26-Quorum-slices-and-quorum.png"/> 

Рисунок 5.26 демонстрирует quorum intersection, где узел B является пересечением {A, B, C} и {G, D, E, F}, а узел G – пересечением {H, I} и {G, D, E, F}.

<img width="42%" alt="Figure 5.27 – An example of quorum intersection" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.27-An-example-of-quorum-intersection.png"/> 

На практике узел может принадлежать нескольким quorum slices, а сам quorum slice может содержать в себе другой quorum slice. Когда узлы пытаются достичь соглашения, они обмениваются друг с другом сообщениями и соглашаются только в том случае, если количество согласившихся превышает заданный порог. Порог при этом должен быть не меньше, чем ⅔ от количества узлов в quorum slice.

### Blocking set

Также в FBA существует понятие _blocking set_. Blocking set для определенного узла _N_ является множеством, в котором присутствует как минимум один узел из каждого quorum slice, в котором он состоит (рис. 5.27). Blocking set может убедить участника принять определенное решение.

<img width="30%" alt="Рисунок 5.27 – Пример blocking set, состоящего из узлов B, D, F" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.28-An-example-of-a-blocking-set-consisting-of-nodes-B,D,F.png"/> 

### Disjoint quorums и divergent state

_Disjoint quorums_ – два quorum slices, которые не имеют прямо или косвенно пересекающихся узлов, формируют отдельные кворумы и в результате приходят к различным решениям, из-за чего возникает _divergent state_. Divergent state – это состояние, в котором находится система после разделения на несколько независимых _quorums_, каждый из которых ведет свою историю транзакций и не влияет на остальных.

В PBFT-системах отказоустойчивость обеспечивается, если количество неисправных узлов не превышает ⅓ от общего количества узлов в системе. В случае с FBA эта цифра варьируется от 0 до ⅓ в зависимости от структуры quorum slices. Отказоустойчивость FBA будет стремиться к нулю, когда большое количество узлов создает quorum slices с одними и теми же несколькими узлами. Если эти несколько узлов выйдут из строя, система прекратит функционирование.

Пример подобной ситуации приведен на рисунке 5.28. В данном случае два quorum slices имеют всего один общий узел. Если он попадет под контроль заинтересованной стороны или по определенным причинам перестанет работать, остальные узлы не смогут достичь консенсуса.

<img width="42%" alt="Рисунок 5.28 – Пример disjoint quroums" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.29-An-example-of-disjoin-quorums.png"/> 

### Federated voting

Для достижения консенсуса в FBA-системах используется механизм federated voting (рис. 5.29), состоящий из трех этапов: голосование, принятие и подтверждение [46; 47]. Сначала каждый узел может _проголосовать_ за определенное заявление, касающееся, например, добавления нового блока транзакций. Проголосовав за заявление, узел (при условии, что он не является злоумышленником) никогда не будет голосовать за противоречащее ему.

После этапа голосования узлы переходят к этапу _принятия_. Узел может принять заявление, если он не принимал противоречивое заявление ранее и существует кворум, каждый участник которого проголосовал за или принимает это заявление. Вне зависимости от решения кворума, узел принимает то же заявление, что и его blocking set. Из этого следует, что узел может проголосовать за одно заявление, но принять другое.

Впрочем, блокирующее множество не является кворумом, поскольку тогда заинтересованная сторона могла бы навязывать узлу свои решения, взяв под контроль узлы из его блокирующего множества. По этой причине существует еще один этап – _подтверждение_. Его суть в том, что узел должен обнаружить quorum, все узлы которого принимают данное утверждение. Узел подтверждает заявление, если все узлы кворума, в котором он состоит, также подтверждают его.

<img width="40%" alt="Рисунок 5.29 – Возможные состояния узла в процессе федеративного голосования" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.30-Possible-node-stated-in-the-federated-voting-process.png"/> 

### Применение FBA в Stellar

SCP (Stellar Consensus Protocol) [47] – протокол достижения консенсуса, построенный на основе FBA. Stellar Consensus Protocol использует механизм федеративного голосования, чтобы обеспечить согласованность результатов и работоспособность системы. В процессе работы проводится большое количество раундов федеративного голосования для разных утверждений до тех пор, пока одно из них не пройдет все этапы.

Первый раунд федеративного голосования проходит в фазе _номинации_ (nomination), когда узлы голосуют за принятие определенного блока транзакций. На первом этапе узлы вырабатывают значения-кандидаты путем проведения федеративного голосования. Значение считается кандидатом, если узел _подтвердил_ его номинацию. Узел, у которого нет кандидатов, может номинировать любое значение. После этого он может только принимать и подтверждать заявления о номинации от других узлов согласно с процедурой федеративного голосования.

Чтобы сократить количество кандидатов, используется механизм временных приоритетов. Изначально узел определяет quorum slices, в которых он состоит, и выбирает из этого множества узлов наиболее приоритетный, т. е. тот, чье значение он будет номинировать. Узел может номинировать свое собственное значение только если не найдет более приоритетных соседей. Для расчета приоритета используется хеш-функция, на вход которой подается номер блока и публичный ключ заданного узла. Чем чаще узел появляется в quorum slices соседей, тем выше будет его приоритет.

Под влиянием блокирующего множества узел может проголосовать и принять номинацию разных кандидатов, но подтвердит только одного. Наглядный пример рассмотрен на рисунке 5.30.

<img width="40%" alt="Рисунок 5.30 – Пример проведения процесса номинации при условии, что узел изначально голосовал за номинацию А" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.31-An-example-of-the-nomination-process.png"/> 

В процессе номинации может получиться несколько подтвержденных кандидатов, которые потом объединяются в _composite_. Метод объединения зависит от конкретной системы. Например, в Stellar происходит объединение множеств транзакций, а полученному композиту присваивается максимальный timestamp из всех, которые есть в полученном множестве транзакций.

Когда в результате номинации был получен композит, узлы переходят к баллотированию (рис. 5.31). Баллотирование проводится в три этапа: _prepare_, _commit_, _externalize_. Последний этап, по сути, является исполнением команды, за которую голосуют узлы, например, выполнение операций блока транзакций. Сначала узлы должны _проголосовать_, _подтвердить_ и _принять_ статус _prepare_ для бюллетеня, а затем пройти эти три этапа для статуса _commit_ (т. е. для бюллетеня проводится федеративное голосование, описанное выше).

Сам бюллетень представляет собой структуру, состоящую из двух полей: целочисленный неотрицательный счетчик и объект класса Vote, в котором содержится значение-кандидат с прошлого этапа.

Если по определенным причинам бюллетень застревает в неопределенном состоянии, для него выполняется _abort_, счетчик инкрементируется и узлы переходят к следующему бюллетеню (значение счетчика которого выше). При обмене информацией о состоянии бюллетеней узлы могут прикреплять к сообщению диапазон бюллетеней вместо одного конкретного.

Бюллетень получает статус _prepared_, когда узел уверен, что остальные не проголосуют за _commit_ для бюллетеней с другими значениями. При этом для всех бюллетеней с меньшими значениями счетчика выполняется _abort_. Когда _prepare_ для бюллетеня будет _подтвержден_, узлы переходят к голосованию касательно статуса _commit_. Это позволяет убедиться в том, что все согласны с этим бюллетенем и в конечном счете его директивы будут выполнены.

После прохождения всех раундов федеративного голосования и подтверждения _commit_, узлы выполняют директиву, указанную в бюллетене.

<img width="40%" alt="Рисунок 5.31 – Пример проведения процесса баллотирования" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.32-The-example-of-the-balloting-process.png"/> 

### Проблема централизации

Количество узлов-злоумышленников, при котором FBA-система будет способна достигать консенсуса, варьируется от 0 до ⅓ от общего количества участников в зависимости от структуры _quorum slices_. Отказоустойчивость будет стремиться к нулю, когда большое количество узлов создает _quorum slices_ с одними и теми же несколькими узлами. Если эти несколько узлов выйдут из строя, система не сможет работать. Пример подобной ситуации приведен на рисунке 5.32. В данном случае несколько _quorum slices_ имеют всего один общий узел и если он попадет под контроль заинтересованной стороны или по определенным причинам перестанет работать, остальные узлы также не смогут функционировать.

<img width="30%" alt="Рисунок 5.32 – Пример сети с одним общим узлом" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.33-Example-of-a-network-with-one-common-node.png"/> 

### Уровень децентрализации сети Stellar

При анализе взаимодействий узлов Stellar на момент 2019 года видно, что присутствует около 35 активных валидаторов, месячный uptime которых выше 90%. При этом более половины _quorum slices_ состоят из 10 или менее валидаторов [73]. Первая причина малого количества валидаторов – отсутствие мотивации для участия в системе в этой роли.

Большинство активных валидаторов принадлежат либо непосредственно Stellar Development Foundation, либо компаниям-партнерам. Например, IBM использует Stellar в платежной системе на основе blockchain, а Satoshi Pay и tempo.eu.com разрабатывают приложения на платформе Stellar. Для них мотивацией поддерживать работоспособность узлов является то, что их сервисы зависят от функционирования системы Stellar. При этом они не получают никакой фактической награды, как, например, в proof-of-work или proof-of-stake системах.

Вторая причина малого количества валидаторов – зависимость системы от доверия к валидаторам. Согласно со структурой текущих _quorum slices_, участники системы выбирают из относительно небольшой группы валидаторов, с которыми они связаны или которым доверяют, основываясь на их влиятельности. Из-за такой модели доверия формирование _quorum slices_ является необъективным процессом и неизбежно склоняется в сторону централизации. При этом во всех _quorum slices_ присутствует как минимум один валидатор, принадлежащий Stellar Development Foundation (SDF).

Такая структура приводит к риску выхода системы из строя. В случае, когда один узел становится недоступным, система продолжает функционировать. Однако, когда недоступными станут два любых узла SDF, произойдет полный каскадный сбой системы, т.е. никто из валидаторов не сможет достичь консенсуса. Если из строя выйдет валидатор _eno_ и один из валидаторов SDF, отказ произойдет для 90% узлов.

Одним из потенциальных решений будет приблизить структуру Stellar к той, которая используется в pBFT. Однако, в таком случае участникам придется постоянно мониторить сообщения от выбранных валидаторов и менять состав _quorum slices_ в зависимости от того, какие узлы ведут себя некорректно. Также участники могут снизить пороговое значение для достижения соглашения в _quorum slice_, что повысит liveness системы, но снизит ее безопасность.

На данный момент уязвимость, связанная с отказом всей системы по причине выхода из строя двух основных узлов, устранена – отказ ни одной пары узлов не приведет к тотальному сбою системы. Тем не менее, структура все еще достаточно централизована. Если из строя выйдут два любых узла, принадлежащих SDF, и два узла, которыми владеет социальная сеть Keybase, система также перестанет функционировать. Существуют и другие комбинации, способные вывести из строя всю систему.

Помимо прочего было обнаружено, что quorum slices большинства узлов IBM состоят только из SDF1, SDF2, SDF3 и имеют threshold, равный 2. Таким образом, полностью вывести из строя систему сейчас гораздо сложнее. Тем не менее, стоит учитывать риск того, что влиятельные узлы SDF попадут под контроль заинтересованной стороны или вступят в сговор. Хотя последнее утверждение маловероятно, ведь узлы, принадлежащие Stellar, заинтересованы в корректной работе системы.

В случае со Stellar угроза безопасности (в частности возможность провести double-spending) имеет гораздо большее значение, чем потеря liveness (в обычных банковских системах задержки по операциям все равно длятся гораздо дольше). Следовательно, участники должны выбирать и выбирают большие _quorum slices_, которые с гораздо большей долей вероятности будут находиться в соглашении, чем в рабочем состоянии.

### FBA в сравнении с другими алгоритмам достижения консенсуса

Мы рассмотрели основные понятия, принципы работы и ограничения, характерные для Federated Byzantine Agreement. Теперь давайте сравним его с другими распространенными алгоритмами достижения консенсуса, чтобы получить лучшее понимание того, в каких системах он применим.

По сравнению с Practical Byzantine Fault Tolerance, другим протоколом из BFT-семейства, Federated Byzantine Agreement обеспечивает явное преимущество в плане масштабируемости, поскольку не требует передачи большого количества сообщений между узлами, что позволяет построить сеть с большим количеством участников.

Однако, при сравнении FBA с proof-of-work, последний имеет преимущество в плане анонимности участников и обеспечивает большую децентрализованность, поскольку каждый, кто имеет подходящее оборудование, может участвовать в процессе генерации блоков. Как было описано ранее в этом разделе, Stellar, который является наиболее ярким примером использования протокола FBA на практике, имеет потенциальную склонность к централизованной структуре, поскольку валидаторы предпочитают включать в свои quorum slices узлы, в честности которых они точно уверены.

## 5.5 Hashgraph

Hashgraph – это одновременно и способ организации базы данных транзакций, и алгоритм достижения консенсуса. Первая версия этого алгоритма предполагает фиксированное количество участвующих в достижении консенсуса валидаторов, при этом для его достижения необходимо, чтобы более чем ⅔ из них были честными. Способ организации базы данных hashgraph сравним с постоянно ветвящейся цепочкой блоков, в которой каждый блок в каждой из цепочек связан не только с предыдущими блоками этой цепочки, но и с одним из блоков одной из других цепочек блоков.

_Граф хэшей (hashgraph)_ – структура данных, которая хранит историю распространения данных между узлами (рис. 5.33).

<img width="20%" alt="Рисунок 5.33 – Структура базы данных узла сети" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.34-Node's-database-structure.png"/> 

Этот алгоритм разработал Ли́мон Бэйрд (Dr. Leemon Baird), сооснователь и технический директор Swirlds, в 2016 году как альтернативу алгоритмам достижения консенсуса, предполагающим ограниченное количество известных валидаторов и наличие лидера. Недостаток алгоритмов, использующих лидеров, состоит в том, что на узлы-лидеры можно совершить DoS-атаку, вследствие чего вся система отказывает в обслуживании до момента смены лидера [49]. Одно из преимуществ этого алгоритма – достижение асинхронной византийской отказоустойчивости (asynchronous byzantine fault tolerance). Асинхронная византийская отказоустойчивость состоит в том, что функционирование алгоритма не зависит от времени, затраченного на доставку сообщений. Процесс валидации в текущей версии алгоритма permissioned, т. е. для того, чтобы стать валидатором, необходимо получить разрешение от остальных валидаторов.

### Принцип работы hashgraph

Вместо блоков в hashgraph каждый узел-валидатор создает события. Событие (event) – запись, которую создает и распространяет валидатор для подтверждения транзакций и факта обмена состоянием графа хэшей с другим валидатором.

Жизненный цикл события выглядит следующим образом:

> * _Создание_
> * _Распространение_
> * _Подтверждение_

### Создание события

Каждый узел-валидатор может создать подписанное им событие в любой момент времени. Он может включить в событие свои или полученные от других узлов транзакции, а может вообще не включать в транзакции в событие (табл. 5.3). Обычно в событие не нужно включать много транзакций, так как в hashgraph каждый узел-валидатор может создать новое событие в любой момент времени.

Таблица 5.3
<img width="50%" alt="Таблица 5.3" src="/resources/img/volume-2/5.5-Hashgraph/Table-5.3.png"/> 

Как мы видим из таблицы 5.3, каждое событие содержит ссылки на два предыдущих события, а каждое из этих двух предыдущих событий содержит ссылки на еще два предыдущих события и т. д. Таким образом, имея одно событие, возможно отследить все его события-предки (рис. 5.34).

<img width="42%" alt="Рисунок 5.34 – Формирование нового события на основе А и В" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.35-Forming-a-new-event-based-on-A-and-B.png"/> 

### Распространение события

Для распространения событий используется _Gossip protocol_ [50]. Каждый узел имеет соединение с остальными узлами. Согласно этому протоколу один узел получив сообщение от другого узла начинает сам передавать это сообщение другим узлам в случайном порядке и т. д. Таким образом, сначала сообщение передает один узел, потом два, потом четыре, потом восемь и т. д. Вследствие этого количество узлов, получивших сообщение, возрастает экспоненциально.

Допустим, Алиса хочет распространить свое новое событие в сети с помощью gossip protocol:

> Шаг 1: Алиса создала событие и собирается распространить его по остальным узлам (рис. 5.35).

<img width="36%" alt="Рисунок 5.35" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.36.png"/> 

> Шаг 2: Алиса отправляет событие случайно выбранному узлу сети, здесь это Кэрол (рис. 5.36).

<img width="36%" alt="Рисунок 5.36" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.37.png"/> 

> Шаг 3: Алиса и Кэрол отправляют это событие случайно выбранным каждой из них узлам сети, здесь это Боб и Ева (рис. 5.37).

<img width="36%" alt="Рисунок 5.37" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.38.png"/> 

> Шаг 4: Теперь Алиса, Боб, Кэрол и Ева распространяют это сообщение случайно выбранным каждым из них участникам сети. В результате, все узлы сети узнают об этом сообщении (рис. 5.38).

<img width="36%" alt="Рисунок 5.38" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.39.png"/> 

_Распространение о распространении (Gossip about gossip)_: узел-валидатор, получая событие от другого узла-валидатора, сверяет, какие события ему не известны, по ссылкам получаемого им события. Неизвестные события он запрашивает. Таким образом, обмениваясь событиями, узлы-валидаторы синхронизируют свои состояния графов хэшей. Также каждый узел-валидатор, получивший событие, верифицирует его в соответствии со своим графом хэшей. Если он согласен с этим событием, то также создает новое событие и включает в него значение _other-parent hash_ от получаемого события. Далее узел-валидатор, получивший сообщение, также распространяет свое последнее созданное событие, _other-parent hash_ которого ссылается на событие, полученное прежде. Общий принцип работы распространения о распространении можно рассмотреть на следующем примере (рис. 5.39), где показана история протокола распространения как граф хэшей: 

1. Алиса создала событие и сообщила Бобу о нем, а также о всех событиях, о которых знает она, но не знает Боб. Далее Боб создает свое событие, связанное с событием Алисы, как подтверждение того, что он получил данные от Алисы.
2. Боб сообщает Кэрол о своем событии, а также о всех событиях, о которых знает он, но не знает она. После этого Кэрол создает событие, связанное с событием Алисы через событие Боба, как подтверждение того, что она получила информацию от Боба. Практически в то же время Алиса и Дэйв проводят аналогичные действия.
3. Кэрол сообщает Дэйву о своем событии, а также о всех событиях, о которых знает она, но не знает он. Далее Дэйв создает событие, связанное с событием Алисы через события Кэрол и Боба, как факт того, что он получил информацию от Кэрол.
4. Дэйв сообщает Алисе о событиях, которые известны ему, но не известны Алисе. Алиса создает свое событие, связанное со своим событием и событиями Дэйва, Кэрол и Боба. Практически в то же время Кэрол и Боб проводят аналогичные действия.

<img width="42%" alt="Рисунок 5.39 – Наглядный пример работы Gossip about gossip" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.40-An-illustration-of-the-gossip-about-the-gossip-protocol.png"/> 

Каждый узел сети хранит структуру данных графа хэшей, полученную при обмене информацией о ней с остальными узлами. Таким образом, структура данных, хранимая у каждого узла, постоянно обновляется и синхронизируется с остальными. В итоге, у большинства узлов хранится одинаковая с большинством остальных узлов структура данных. Каждое событие хранится в памяти как подписанная автором последовательность байтов.

### Подтверждение события

Имея набор событий с транзакциями, важно знать, какое из них было раньше, а какое – позже. Поэтому события должны быть упорядочены по времени, причем этот порядок должен быть одинаков у каждого узла. Порядок устанавливается путем достижения консенсуса относительно упорядоченности событий через метки времени для каждого события. Как только событие обладает меткой времени, принятой большинством узлов, его можно считать подтвержденным.

Для достижения консенсуса относительно меток времени событий граф хэшей делится на раунды (рис 5.40).

<img width="20%" alt="Рисунок 5.40 – Наглядное представление деления графа на раунды через witness events и сильную связь" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.41-An-illustration-of-a-graph-being-divided.png"/> 

Раунд начинается и заканчивается как только одно из событий (вершина графа на рисунке 5.41) связано с ⅔ первых событий первого раунда (выделенные события на нижнем слое графа) через большинство событий разных создателей (выделенные по центру). Данная связь называется сильной связью (strongly seeing). Первые события каждого узла-валидатора в раунде называются witness events; относительно них и проводится виртуальное голосование.

<img width="65%" alt="Рисунок 5.41 – Пример сильной связи (strongly seeing)" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.42-An-example-of-strongly-seeing.png"/> 

Первые события в сети не имеют событий-предков, и каждый из них определяется к первому раунду как witness event. Раунд для каждого события определяется как функция от его событий-предков. Проще говоря, если последние witness events ниже событий по графу принадлежат к раунду _R_, то события до следующего witness event также принадлежат к раунду _R_. Следующее witness event принадлежит к раунду _R+1_.

Для достижения консенсуса относительно упорядоченности событий для каждого раунда каждый валидатор локально проводит виртуальное голосование, в котором выбирается медиана из меток времени соседних событий проверяемого события.

_Виртуальное голосование (virtual voting)_: каждый узел сети имеет копию графа хэшей, и каждый граф хэшей упорядоченный, т. е. если два разных графа хэшей _A_ и _B_ имеют одинаковое событие _Х_, тогда в каждом из них также находятся одинаковые предки этого события с одинаковыми связями между ними. Алиса способна вычислить голос Боба через граф хэшей, так как она видит, что если проверяемое событие является одним из событий-предков события созданных Бобом, то Боб согласен с этим событием и его голос считается «за». Значит, Бобу не обязательно принимать участие в голосовании лично. Таким образом, каждый узел может достичь согласия касательно любого количества решений, при этом, фактически, не отправляя ни одного сообщения с их голосами, а просто локально вычисляя результат голосования через имеющийся у него граф хэшей. При этом если Боб и Алиса честны, то Боб, не знающий о событии _Х_, может быстро о нем узнать благодаря протоколу распространения. Алгоритм достижения консенсуса предполагает, что это рано или поздно произойдет, но не выдвигает никаких предположений касательно необходимого на это количества времени.

Для определения порядка событий и включенных в них транзакций Алиса проводит виртуальное голосование по раундам. Боб и остальные узлы сети проводят такое же голосование. В каждом голосовании предполагается, что через некоторые witness events в графе хэшей Алисы будут отправляться голоса валидаторов, а некоторые из witness events в том же графе хэшей Алисы будут их получать.

Боб может мошенничать и создать два witness events _Х_ и _Y_ с одними теми же событиями-предками, причем _Х_ и _Y_ не будут событиями-предками друг друга. Тогда далее будет событие _W_, событиями-предками которого будет и _Х_, и _Y_. Событие _W_ будет видеть, что _Х_ и _Y_ созданы одним узлом валидатора, но ни один из них не является предком другого, а значит, это разделение истории на две альтернативные ветки событий будет распознано. В таком случае _W_ будет видеть либо ветку событий с _Х_, либо ветку событий с _Y_, либо ни одну из этих веток (рис. 5.42).

<img width="30%" alt="Рисунок 5.42 – Пример того как появляется событие W" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.43-An-example-of-event-W-creation.png"/> 

Событие _W_ сильно связано с событием _X_, если оно связано с ним минимум через ⅔ событий различных узлов. В итоге получается, что как Алиса, так и Боб, имея синхронизированные графы хэшей, могут вычислить виртуальный голос Кэрол касательно определенного решения и что оба получат одинаковый результат.

Для достижения консенсуса относительно очередности событий для каждого раунда каждый узел-валидатор локально проводит виртуальное голосование через unique famous witness events из famous witness events.

_Famous witness event_ – witness event, которое связано с большинством witness event в следующем раунде. Для определения таких событий достаточно выполнить byzantine agreement protocol только для каждого witness event, решая всего один вопрос – является ли это witness event популярным. Как только согласие относительно нескольких famous witness events достигнуто, легко воспроизвести из графа хэшей достоверный порядок всех событий.

Witness event считается famous, если выше по графу хэшей существует witness event, которое связано с проверяемым witness event минимум через ⅔ других witness events.

Имея граф хэшей, можно вычислить голоса всех валидаторов через виртуальное голосование. Каждый witness event раундом выше голосует «за» на вопрос, является ли определенное witness event популярным, если у него в событиях-предках присутствует проверяемое событие, иначе предполагается, что witness event голосует «нет». В виртуальном голосовании, когда witness event голосует «да»/«нет», голос вычисляется как функция от его событий-предков. Результат вычисляется через witness event (созданный раундом позже), у которого в событиях-предках присутствуют голосующие witness events. Например, определим, является ли famous witness event первое событие Алисы.

1. Каждый валидатор имеет граф хэшей, в котором через виртуальное голосование вычисляет, как проголосовал бы Дэйв касательно того, является ли первое событие Алисы famous witness event (рис. 5.43).

<img width="20%" alt="Рисунок 5.43 – Вычисление голоса Дэйва относительно определенного события" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.44-Calculation-of-Dave’s-vote-regarding-a-certain-event.png"/> 

2. Каждый валидатор через виртуальное голосование вычисляет, как проголосовала бы Кэрол касательно того, является ли первое событие Алисы famous witness event (рис. 5.44).

<img width="20%" alt="Рисунок 5.44 – Вычисление голоса Кэрол относительно определенного события" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.45-Calculation-of-Carol’s-vote-regarding-a-certain-event.png"/> 

3. Каждый валидатор через виртуальное голосование вычисляет, как проголосовал бы Боб касательно того, является ли первое событие Алисы famous witness event (рис. 5.45).

<img width="20%" alt="Рисунок 5.45 – Вычисление голоса Боба относительно определенного события" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.46-Calculation-of-Bob’s-vote-regarding-a-certain-event.png"/> 

4. Каждый валидатор через виртуальное голосование вычисляет, как проголосовала бы Алиса касательно того, является ли первое событие Алисы famous witness event (рис. 5.46).

<img width="20%" alt="Рисунок 5.46 – Вычисление голоса Алисы относительно определенного события" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.47-Calculation-of-Alice’s-vote-regarding-a-certain-event.png"/> 

То, является ли первое событие Боба famous witness event, вычисляется по такому же принципу; точно так же вычисляется famous witness event для всех witness events.

Как только определятся все famous witness events в раунде, убираются все famous witness events с одинаковым создателем, пока у каждого создателя famous witness event не останется по одному такому событию. Оставшиеся famous witness events называются unique famous witness events. При отсутствии разветвлений каждый famous witness event является unique famous witness event. Через данные unique famous witness events определяются согласованные метки времени для каждого их события-предка.

Согласованные метки времени вычисляются следующим образом. Представим, что проверяемое событие _Х_ находится в раунде _R_. В том же раунде Алиса создала unique famous witness event _A_. Алгоритм находит ближайшее к famous witness event Алисы событие _Y_, созданное Алисой в том же раунде, с которым связано событие _X_ как other-parent или как одно из ближайших событий-предков. Для создателя события _Х_ его cобытием _Y_ относительно его famous witness event будет событие _Х_. Метка времени события _Y_ считается моментом времени, когда об этом событии узнал узел, создавший событие _Y_. Принятой большинством меткой времени для события _Х_ будет медиана всех таких событий _Y_ для каждого создателя unique famous witness event. Рассмотрим следующий пример:

1. Для unique famous witness event Алисы (_А_) находим ближайшее self-parent событие  *Y<sub>А</sub>*, которое связано с _Х_, и сохраняем его метку времени  *t<sub>А</sub>* = 3 (рис. 5.47).

<img width="20%" alt="Рисунок 5.47 – Создание метки времени для unique famous witness event Алисы" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.48-Creating-the-timestamp-for-Alice’s-unique-famous-witness-event.png"/> 

2. Для unique famous witness event Боба (_В_) находим ближайшее self-parent событие *Y<sub>B</sub>*, которое связано с _Х_, и сохраняем его метку времени *t<sub>B</sub>* = 1 (рис. 5.48).

<img width="20%" alt="Рисунок 5.48 – Создание метки времени для unique famous witness event Боба" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.49-Creating-the-timestamp-for-Bob’s-unique-famous-witness-event.png"/> 

3. Для unique famous witness event Кэрол (_С_) находим ближайшее self-parent событие *Y<sub>C</sub>*, которое связано с _Х_, и сохраняем его метку времени *t<sub>C</sub>* = 2 (рис. 5.49).

<img width="20%" alt="Рисунок 5.49 – Создание метки времени для unique famous witness event Кэрол" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.50-Creating-the-timestamp-for-Carol’s-unique-famous-witness-event.png"/> 

4. Для unique famous witness event Дэйва (_D_) находим ближайшее self-parent событие *Y<sub>D</sub>*, которое связано с _Х_, и сохраняем его метку времени *t<sub>D</sub>* = 4 (рис. 5.50).

<img width="20%" alt="Рисунок 5.50 – Создание метки времени для unique famous witness event Дэйва" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.51-Creating-the-timestamp-for-Dave’s-unique-famous-witness-event.png"/> 

5. Согласованной меткой времени события Х является медиана от *t<sub>A</sub>* , *t<sub>B</sub>* , *t<sub>C</sub>* , *t<sub>D</sub>*  (рис. 5.51).

<img width="40%" alt="Рисунок 5.51 – Вычисление согласованной метки времени для события" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.52-Calculating-the-agreed-timestamp-for-an-event.png"/> 

Естественно, Алиса и Боб не будут иметь одинаковые графы хэшей в любой момент времени. Их графы будут согласованы в основном только относительно более ранних событий. Однако для самых поздних событий каждый из них может знать о событиях, о которых не знают другие. Как следствие, у валидаторов будет различаться подмножество подтвержденных транзакций, но заметно бо́льшая часть этого подмножества будет одинаковой. Более того, если Алиса не знает о некотором событии из более ранних событий, то в будущем оно дойдет до Алисы. В таком случае Алиса синхронизируется с большинством остальных узлов.

**Часто задаваемые вопросы**

*– Можно ли создать правила для замены валидатора?*

Основная проблема hashgraph заключается в том, что текущая версия не определяет правила изменения набора валидаторов. Одним из решений этого крайне важного вопроса может быть включение в сообщения валидаторов голосов за добавление или устранение участников. Таким образом, если большинство валидаторов поддержат это решение, будет добавлен новый узел или удален один из текущих. Также, если валидаторы определят, что один из них ведет себя нечестно, они смогут проголосовать за лишение его прав валидатора.

*– Для каких случаев лучше всего подходит hashgraph?*

Hashgraph хорошо подходит для случаев, в которых требуется наличие фиксированного количества равноправных валидаторов без какого-либо лидера. Например, несколько компаний сотрудничают, и им нужна система для учета данных о взаимодействиях между собой, в которой каждая компания имеет равные права и на работу которой не могут повлиять сторонние лица.

*– Может ли процесс валидации для алгоритма hashgraph быть permissionless?*

Без модификаций в алгоритме hashgraph это невозможно, так как каждый аудитор должен знать полное количество действующих валидаторов. Следовательно, список валидаторов должен быть общеизвестным и защищенным от модификации, т. е. любой желающий не должен иметь возможности его изменять.

[МЕТОДЫ ОБЕСПЕЧЕНИЯ ПРИВАТНОСТИ В СОВРЕМЕННЫХ УЧЕТНЫХ СИСТЕМАХ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-2/ru/6-methods-for-ensuring-privacy-in-modern-accounting-systems.md)
