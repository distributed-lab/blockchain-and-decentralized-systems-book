# 7 РАЗВИТИЕ ДЕЦЕНТРАЛИЗОВАННЫХ ТЕХНОЛОГИЙ

## 7.1 Устройство протокола Bitshares

Одноименная децентрализованная платформа реализует криптовалюту, смарт-контракты, торговую площадку и еще много интересной функциональности. Bitshares является учетной системой с хорошим компромиссом между децентрализацией и пропускной способностью [61]. Кроме того, протокол Bitshares был взят за основу в других децентрализованных системах (Steemit, EOS).

Идея протокола Bitshares состоит в создании инструмента, с помощью которого можно было бы торговать разными активами и валютами в децентрализованной среде без фактического депонирования их на торговую площадку.

### Назначение платформы Bitshares

Daniel Larimer, также известный под ником Bytemaster, является главным идеологом и разработчиком протокола. Платформа Bitshares позволяет кому угодно создавать user issued assets (UIA), или цифровые токены. Таким образом, на платформе учитывается базовая валюта, т. е. криптовалюта BTS, и множество пользовательских токенов.

Протокол реализует децентрализованную биржу, где этими цифровыми активами можно торговать. При проектировании учетной системы и механизма достижения консенсуса разработчики сделали большой упор на пропускную способность.

Bitshares позиционирует себя как платформа смарт-контрактов. Правда, смарт-контракты здесь предустановленные и их количество ограничено (реализованы наиболее популярные контракты). Впрочем, они более энергоэффективные и, соответственно, обходятся дешевле в контексте комиссий.

Еще одной особенностью платформы является поддержка платежей с повышенным уровнем конфиденциальности пользователей, которые можно использовать опционально. В Bitshares эта технология называется stealth transfers.

### Модель аккаунтов

Теперь рассмотрим, как устроены аккаунты в протоколе Bitshares. Здесь используется криптография на эллиптических кривых, причем сама кривая точно такая же, как в протоколе Биткоин. Формат адресов использует хэш-значение открытого ключа, систему счисления по основанию 58, префикс BTS и не содержит контрольную сумму. Но этот формат используется редко, поскольку общая база данных платформы оптимизирована таким образом, что каждый объект, в том числе и аккаунт пользователя, имеет собственный уникальный идентификатор, который является целым числом размером 8 байт (или 64 бит). В обычных операциях отправки платежа указывается именно такой идентификатор аккаунта.

Кроме того, протокол поддерживает регистрацию уникальных имен. Похожую функциональность впервые реализовали в протоколе Namecoin. Таким образом, в Bitshares можно зарегистрировать удобную для восприятия человека строку, которая будет уникальной в рамках соответствующей учетной системы, и привязать к своему аккаунту, чтобы использовать ее вместо account ID.

### Модель транзакций

Детальнее остановимся на модели транзакций в Bitshares (рис. 7.1).

<img width="55%" alt="Рисунок 7.1 – Структура транзакции в протоколе Bitshares" src="/resources/img/volume-2/7.1-Bitshares-protocol-design/Figure-7.1-Transaction-structure-in-Bitshares-protocol.png"/> 

На схеме видно, что тело транзакции состоит из пяти основных полей. Первые два поля транзакции необходимы для того, чтобы привязать ее к определенному блоку. Это нужно, чтобы определить цепочку блоков, в которую эта транзакция может быть добавлена, поскольку по правилам протокола транзакция не может быть подтверждена в той цепочке, к которой не привязана. Поле _expiration_time_ задает время, до которого транзакция может быть добавлена в блок. Если она не была подтверждена до наступления этого времени, то она считается невалидной и уже не может быть включена в блокчейн.

Поле _operations_veсtor_ является особенным. Эта особенность состоит в том, что в него можно поместить много разных операций. Операция – это еще один ключевой объект в протоколе Bitshares. Назовем несколько самых популярных типов операций: transfer (перевод), account_update (обновление аккаунта), asset_issue (эмиссия токена) и order (торговое предложение). Каждая операция имеет свой формат и необходимые параметры. Например, операция transfer требует указания аккаунта отправителя, типа актива, суммы перевода и аккаунта получателя. Сами операции независимы друг от друга, но могут быть выполнены только вместе, если транзакция будет принята.

Поле _extensions_ нужно, чтобы текущая версия ПО могла обрабатывать транзакции новой версии, где могут быть добавлены дополнительные поля. Конечно же, старое ПО не будет знать, как правильно верифицировать дополнительные поля новых транзакций, но хотя бы сможет корректно обрабатывать транзакции согласно старым правилам.

Это формат неподписанной транзакции. Чтобы транзакцию правильно подписать, нужно проанализировать все операции из поля operations_veсtor и составить список аккаунтов, которые должны подтвердить данную транзакцию. Тогда станет ясно, какими ключами нужно подписывать транзакцию. Все необходимые подписи помещаются в отдельное поле – _signatures_. Если не будет хватать хотя бы одной подписи, то вся транзакция будет считаться неправильной.

Отметим, что за счет оптимизации размера идентификаторов финальный размер транзакции, которая содержит одну операцию, будет равен приблизительно 100 байт. Это действительно очень компактная транзакция по сравнению с транзакциями в других протоколах.

Относительно комиссий в протоколе Bitshares реализован особый подход. Каждая операция требует определенной платы, которая снимается с баланса аккаунта-инициатора в момент подтверждения транзакции. Комиссия за осуществление операций может быть постоянной, а может меняться. Для грубого сравнения можно отметить, что комиссии за обычные переводы и торговлю значительно ниже, чем комиссии за эмиссию новых активов и регистрацию нового аккаунта.

### Децентрализованный обмен активами

Теперь разберемся, как работает торговля активами, которые эмитированы и учитываются на платформе Bitshares. Пользователь может составить транзакцию с такой операцией, где он заявляет, что готов обменять один актив на другой в определенном соотношении на определенную сумму.

Эта транзакция распространяется по сети и получает подтверждение, после чего другой пользователь может таким же образом заявить, что хочет обменять те же активы в том же соотношении. В момент подтверждения второй транзакции согласно протоколу обновляются балансы этих двух пользователей, т. е. совершается фактический обмен активами на основании того, что оба пользователя подписали заявления об обмене, которые соответствуют друг другу.

Поскольку такая торговля осуществляется на базе децентрализованной учетной системы, эта торговая площадка называется децентрализованной биржей. Однако на Bitshares не реализован механизм cross-exchange, которые позволяет пользователю обменять актив не напрямую, а через цепочку orders.

### Гибкость управления аккаунтами

Еще одной важной особенностью протокола Bitshares является возможность гибкого управления аккаунтами. Система динамических разрешений аккаунта (dynamic account permissions) позволяет задать управление аккаунтом по нескольким ключам, по принципу мультиподписи. Устроено это так, что каждый аккаунт может управляться взвешенной комбинацией других аккаунтов или ключей цифровой подписи.

Такой подход позволяет создать иерархическую структуру управления, организация которой подобна системе разрешений в реальной жизни. Получается, что можно организовать многопользовательское управление аккаунтом и его балансами, где каждый пользователь будет иметь определенный вес в принятии решения. При этом для проведения разных операций можно установить разные критерии. Такой механизм управления позволяет значительно снизить риски кражи активов и потери контроля над аккаунтом (рис. 7.2).

<img width="50%" alt="Рисунок 7.2 – Схема динамического управления аккаунтом" src="/resources/img/volume-2/7.1-Bitshares-protocol-design/Figure-7.2-Dynamic-account-management-scheme.png"/> 

Представим это схематично. На вершине иерархии есть аккаунт, от имени которого невозможно подтвердить транзакцию одним ключом. Это можно сделать только по подтверждению нескольких других аккаунтов и ключей. Участников нижних уровней иерархии обычно называют подписантами (signers). Каждый из них имеет свой вес в подтверждении операции. Например, на приведенной схеме подписанты имеют вес 25, 40, 35 и 40 единиц, а необходимый порог для подтверждения определенного типа операций может быть 50, 60 или 70 единиц. В то же время для других типов операций может иметь место другое распределение весов и другое пороговое значение.

Как это работает на уровне транзакций? Один из подписантов создает транзакцию с определенными операциями и подтверждает от имени своего аккаунта. Операции, которые входят в эту транзакцию, не выполняются, а находятся в режиме ожидания дальнейшего подтверждения. Тогда другие подписанты видят предложение и могут либо подтвердить, либо отклонить его от имени своего аккаунта с помощью транзакций, содержащих специальные операции.

### Эмиссия UIA

Детальнее разберем особенности эмиссии пользовательских активов на платформе Bitshares. Кто угодно может сформировать транзакцию с операцией создания нового актива, заплатить определенную комиссию, задать параметры этого актива и начать эмиссию соответствующих токенов. Эта функциональность протокола реализована в виде предустановленного смарт-контракта и имеет некоторые особенности.

По желанию эмитента можно удовлетворить требованиям KYC (Know Your Customer – знай своего клиента) с помощью механизма white list (список разрешенных аккаунтов) и дополнительного подтверждения (approve) эмитента. White list содержит аккаунты, которым эмитент актива дает разрешение получать и держать его токены. Механизм дополнительного подтверждения позволяет эмитенту контролировать каждую транзакцию по переводу или торговле токенами (он может отклонить или одобрить каждую транзакцию с его активом).

Кроме того, эмитент может ограничить торговлю токенами и разрешить только хранение и переводы или ограничить переводы, а разрешить только торговлю. Эмитент также может установить дополнительные комиссии на переводы и торговлю токенами.

Еще одна особенность состоит в том, что эмитент может активировать функцию изъятия и перераспределения токенов. Это работает для случаев, когда нужно поддерживать внешние механизмы осуждения сделок и откатывания платежей. Также отметим, что все настройки пользовательских активов задаются в виде параметров смарт-контракта и что эмитент задает, какие свойства он может менять, а какие будут постоянными. Например, он может ограничить себя в дополнительной эмиссии токенов, а может оставить возможность произвольного эмитирования. Эти параметры контракта будут видны всем пользователям.

Интересное свойство токенов, которые эмитированы на платформе Bitshares, состоит в том, что при совершении операций с ними пользователь может оплачивать комиссию либо базовой валютой либо этими самыми токенами. Конвертация выполняется на основании обменного курса, который задает эмитент.

### Механизм голосований

При изучении платформы Bitshares обязательно нужно упомянуть о механизме, который помогает принимать решения в децентрализованной среде, – о голосовании. При помощи голосования избираются члены комитета (committee members), валидаторы (witnesses) и разработчики (workers). Члены комитета нужны, чтобы голосовать за изменение некоторых параметров протокола, таких как комиссии, количество валидаторов и т. п. Валидаторы, или делегаты, нужны, чтобы верифицировать транзакции и формировать блоки. Разработчики же предлагают улучшения ПО; если они набирают достаточное количество голосов и укладываются в сроки по разработке, то получают вознаграждение.

При голосовании вес голоса каждого аккаунта пропорционален его балансу в базовой валюте. При этом поддерживается опция proxy voting, которая позволяет отдать свой голос другому избирателю. Это удобно тогда, когда пользователь сам не знает, за кого из кандидатов лучше голосовать, и отдает это право более компетентному пользователю. В целом, голосование очень важно для обеспечения высокой надежности платформы Bitshares.

### Механизм комиссий

Теперь посмотрим на механизм сбора комиссий за транзакции и вознаграждения активных участников сети. Существует такой баланс, который не принадлежит никому из пользователей платформы, а распоряжаться им можно исключительно по правилам протокола. Этот баланс называется _reserve pool_. Правила предполагают, что комиссии за все операции со всех аккаунтов попадают в reserve pool. На аккаунты валидаторов и разработчиков выплачивается вознаграждение из reserve pool как процент от его баланса. Кроме этого, на сбор и распространение комиссий могут накладываться правила реферальной программы, которую также поддерживает платформа (о ней вы можете прочитать отдельно) (рис. 7.3).

<img width="50%" alt="Рисунок 7.3 – Схема сбора и распространения комиссий" src="/resources/img/volume-2/7.1-Bitshares-protocol-design/Figure-7.3-Scheme-of-fees-payments-and-distribution.png"/> 

### SmartCoins

До этого мы говорили про смарт-контракт, который реализует обычные токены, а сейчас поговорим про другой смарт-контракт, который реализует market pegged assets – токены, привязанные по цене к какому-либо внешнему активу. Их также называют SmartCoins. Работает это по принципу контракта на разницу (contract for difference). Соответственно, эмитировать эти токены может кто угодно, просто замораживая определенную залоговую сумму, например, в базовой валюте. Коэффициент залога значительно выше единицы, а рекомендованное значение – 2 и более. Здесь все работает по принципам маржинальной торговли (margin trading), где используются margin positions и автоматические margin calls. Чтобы на платформе появились данные о цене актива на внешних рынках, используются доверенные стороны, которые размещают данные о цене актива в базе данных Bitshares с помощью операции специального типа. Здесь этими доверенными сторонами являются сами валидаторы.

### Формат заголовка блока

Заголовок блока в Bitshares имеет более простую структуру и меньший размер, чем заголовок блока в Биткоине (рис. 7.4).

<img width="55%" alt="Рисунок 7.4 – Заголовок блока в протоколе Bitshares" src="/resources/img/volume-2/7.1-Bitshares-protocol-design/Figure-7.4-Block-header-in-Bitshares-protocol.png"/>

Здесь имеются такие поля: идентификатор предыдущего блока, временная метка, идентификатор создателя, хэш-значение входящих транзакций и поле extensions для поддержания совместимости с новыми версиями заголовка блока.

Полный блок будет включать в себя заголовок блока, подпись валидатора, создавшего этот блок, и список транзакций, входящих в этот блок.

В рамках протокола Bitshares есть 4 понятия, которые играют ключевую роль в работе платформы: блоки, транзакции, операции и объекты. Объектами здесь называют аккаунт, актив, баланс, предложение и т. п.

### Множество операций и особенности их выполнения

Рассмотрим детальнее понятие операции в контексте этого протокола. В Bitshares на момент 2019 года – около 40 разных типов операций; с новыми обновлениями протокола можно добавлять новые типы. Операции позволяют инициировать некоторые простые изменения в учетной системе и использовать более сложные механизмы, такие как предустановленные смарт-контракты. Выше уже было сказано, что одна транзакция может содержать несколько операций, которые при успехе выполнятся одновременно.

Здесь приведен небольшой список наиболее популярных операций:

* *transfer_operation* переводит определенный актив с баланса одного аккаунта на другой;
* *limit_order_create_operation* создает объект заявки по обмену активов;
* *Limit_order_cancel_operation* отменяет такую заявку;
* *fill_order_operation* выполняется автоматически, когда две заявки соответствуют друг другу; она не требует создания транзакции, поэтому ее также называют виртуальной операцией;
* *account_create_operation* создает обычный аккаунт пользователя;
* *blind_transfer_operation* совершает конфиденциальный платеж;
* *asset_create_operation* создает объект нового актива;
* *asset_update_operation* изменяет параметры смарт-контракта существующего токена;
* *asset_issue_operation* эмитирует токены существующего актива;
* *witness_create_operation* создает аккаунт кандидата валидатора.

Касательно статистики можно сказать, что нагрузка на сеть Bitshares по количеству транзакций сравнима с нагрузкой на сеть Bitcoin или Ethereum. Более того, в некоторые моменты 2018 года платформа Bitshares обрабатывала больше транзакций, чем Bitcoin и Ethereum вместе взятые. А результаты нагрузочного тестирования показывают, что максимальная пропускная способность сети Bitshares в сотни раз превосходит максимальную пропускную способность сетей Bitcoin и Ethereum.

### Организация базы данных

Теперь рассмотрим одну важную архитектурную особенность протокола Bitshares, которая помогает достичь настолько высокой пропускной способности (рис. 7.5).

<img width="50%" alt="Рисунок 7.5 – Способы организации базы данных blockchain и ledger" src="/resources/img/volume-2/7.1-Bitshares-protocol-design/Figure-7.5-Blockchain-and-ledger-database-organization.png"/> 

Слева на схеме изображен способ организации базы данных под названием blockchain, с помощью которого обычно организовано хранение всей истории транзакций. Справа изображен другой способ организации базы данных – ledger. С его помощью обычно организовано хранение соответствий между идентификаторами и состояниями (например, аккаунт и его баланс).

Свойства blockchain позволяют легко проверить целостность базы данных и историю ее изменений, а также легко организовать синхронизацию и достичь консенсуса в децентрализованной среде.

Ledger удобен тем, что он компактным образом хранит последнее состояние базы данных и при этом обеспечивает быстрый поиск, чтение и обновление записей. Именно поэтому они принципиально имеют более высокую пропускную способность. Ledger обычно применяют в централизованных учетных системах.

Идея Bitshares состоит в том, чтобы использовать достоинства обоих способов организации базы данных одновременно. Таким образом, полный узел сети ведет учет одновременно с помощью двух баз данных, организованных по типу blockchain и ledger соответственно. При этом узлы синхронизируют данные друг с другом с помощью блоков и обновляют локальную копию blockchain, а верификацию и принятие транзакций они проводят, ориентируясь на последнее состояние базы данных, которое хранит ledger. Более того, размер всех данных, которые составляют ledger, оптимизированы таким образом, что узлы сети держат их в оперативной памяти. Это позволяет существенно ускорить процесс верификации и принятия новых транзакций.

### Оптимизация выполнения бизнес-логики

Многие учетные системы используют язык сценариев общего назначения для определения всех операций. Эти учетные системы, в конечном итоге, используют «бизнес-логический процессор» как виртуальную машину, и все транзакции определяются как скрипты, которые будут запускаться виртуальной машиной. Этот подход использует механизмы синхронизации потоков реального процессора и объединяет их, выполняя все инструкции через виртуальный процессор. Виртуальный процессор даже с компиляцией just-in-time всегда будет медленнее, чем реальный процессор, но итоговый темп вычислений – не единственная проблема подхода, когда все является скриптом.

Когда транзакции определены на таком низком уровне, это значит, что бо́льшая часть статических проверок и криптографических преобразований остаются в бизнес-логической обработке и общая пропускная способность падает. Для повышения производительности учетной системы и быстрого выполнения бизнес-логики нужно вынести все статические проверки, в том числе все криптографические преобразования, за рамки модуля бизнес-логики.

Еще одним шагом оптимизации является хранение данных конечного состояния учетной системы в оперативной памяти. Это значит, что «бизнес-логический процессор» может быстро следовать по указателям на области памяти и напрямую получать нужные ему данные, а не выполнять затратные по времени запросы к базе данных. Это также значит, что данные могут быть доступны без копирования и изменены прямо в месте их хранения. Эта оптимизация обеспечивает бо́льшую производительность по сравнению с использованием подхода, основанного на базе данных.

Таким образом, создание учетной системы с высокой производительностью не требует сложных технологий и разделения процессов среди узлов сети. Все, что необходимо для создания высокопроизводительного узла-валидатора, – отделение всех независимых вычислений от основной бизнес-логики, выполнение ее в одном потоке без прерываний на синхронизацию и хранение всех зависимостей верификации в оперативной памяти.

### Опции повышения конфиденциальности пользователей

Выше было отмечено, что учетная система Bitshares использует аккаунты и балансы, в отличие от Биткоина, где учет ведется на основании непотраченных выходов транзакций (UTXO). Повысить уровень конфиденциальности на платформе Bitshares – это нетривиальная задача, поскольку в контексте аккаунтов и балансов еще проще деанонимизировать пользователей, чем в Bitcoin.

Однако разработчики Bitshares решили эту задачу интересным образом. Они реализовали возможность задавать несколько входов и выходов в рамках одной операции. Теперь можно включать много входов и выходов в одну транзакцию, что усложняет анализ денежных потоков и повышает конфиденциальность пользователей.

Кроме того, эти операции по умолчанию используют методы confidential transactions и stealth addresses. Confidential transactions скрывают суммы на входах и выходах операции, но при этом используют доказательство того, что сумма выходов не превышает сумму входов. Stealth addresses же скрывает связь между открытым ключом, используемым как идентификатор получателя, и конкретным адресом, который указывается в выходе транзакции.

В Bitshares по умолчанию используются обычные (неконфиденциальные) платежи, но при желании пользователи могут использовать stealth transfers. Таким образом, учет монет на платформе ведется двумя разными способами.

Монеты могут быть переведены из одного способа учета в другой. Для этого реализованы отдельные операции:

* *transfer_to_blind_operation* используется для перевода монет из открытого оборота в скрытый;
* *blind_transfer_operation* для перевода монет скрытым образом;
* *transfer_from_blind_operation* для перевода монет из скрытого оборота в открытый.

Понятное дело, что эти операции по объему данных больше обычных и, соответственно, требуют большей комиссии.

Примечательно, что кто угодно может посчитать, сколько монет ушло в скрытый оборот, поэтому существует понятие stealth supply (количество монет в скрытом обороте). Но есть один практический недостаток опции конфиденциальности в Bitshares на данный момент (июль 2019). Дело в том, что до сих пор нет удобных графических интерфейсов для простой работы в режиме повышенной конфиденциальности.

**Часто задаваемые вопросы**

*– Поддерживает ли Bitshares возможность задания произвольных условий траты монет, например, с помощью Bitcoin Script?*

Нет, текущая версия протокола не поддерживает такую функциональность. Вряд ли она будет добавлена, потому что в Bitshares удобнее всего будет создавать новые типы операций и вводить их в последующих обновлениях протокола.

## 7.2 Платформа Ethereum и смарт-контракты

Ethereum – это децентрализованная платформа, предназначенная для выполнения произвольно программируемых смарт-контрактов [59]. Проект Ethereum имеет открытый исходный код и достаточно большое сообщество (разработчики, тестировщики, разработчики смарт-контрактов, пользователи). Ethereum реализует децентрализованную базу данных для хранения и синхронизации данных о состоянии аккаунтов пользователей и аккаунтов смарт-контрактов, а также базовую валюту платформы (криптовалюту) ether.

Платформа Ethereum позволяет разработчикам смарт-контрактов создавать произвольные децентрализованные приложения со встроенными экономическими функциями. Для программирования смарт-контрактов платформа реализует собственный язык – Solidity.

### Особенности работы платформы Ethereum

На платформе Ethereum есть только два типа аккаунтов: аккаунт пользователя и аккаунт контракта.

Аккаунт пользователя управляется только личным ключом цифровой подписи. Владелец аккаунта генерирует свою пару ключей для электронной подписи по алгоритму ECDSA. Изменять состояние этого аккаунта могут только подписанные этим ключом транзакции.

Для аккаунта смарт-контракта предусмотрена другая логика. Он может управляться только с помощью заранее заданного программного кода, который полностью определяет поведение смарт-контракта: как он будет распоряжаться своими монетами при определенных обстоятельствах, по инициативе какого пользователя и при каких дополнительных условиях эти монеты будут распространяться. Если некоторые моменты не предусмотрены разработчиками в программном коде, могут возникнуть проблемы. Например, смарт-контракт может перейти в какое-то определенное состояние, при котором он не принимает инициирование дальнейшего выполнения ни от одного из пользователей. В таком случае монеты, фактически, окажутся замороженными, потому что смарт-контракт не предусматривает выхода из этого состояния.

### Создание аккаунтов в Ethereum

Важно отметить, что Ethereum использует для цифровой подписи точно такой же алгоритм и точно такую же эллиптическую кривую, как и Bitcoin, но адрес вычисляется несколько другим образом. Здесь уже не применяется результат двойного хэширования, как в Bitcoin, а предусмотрено однократное хэширование открытого ключа функцией KECCAK на длине 256 бит. Используются только младшие биты полученного значения, а именно 160 младших битов выходного значения хэш-функции. В итоге мы получаем идентификатор аккаунта в Ethereum с размером 20 байт.

Отметим, что идентификатор аккаунта в Ethereum кодируется в шестнадцатеричной форме без применения контрольной суммы, в отличие от Bitcoin и многих других систем, где адрес кодируется в системе счисления по основанию 58 с добавлением контрольной суммы. Это значит, что работать с идентификаторами аккаунтов в Ethereum нужно осторожно: даже одна ошибка в идентификаторе гарантированно приведет к потере монет.

Еще одна важная особенность заключается в том, что аккаунт пользователя на уровне общей базы данных создается в тот момент, когда он принимает первый входящий платеж.

Относительно создания аккаунта смарт-контракта применяется совершенно другой подход. Вначале кто-то из пользователей пишет исходный код смарт-контракта, после чего код пропускается через специальный для платформы Ethereum компилятор и получается байт-код для виртуальной машины Ethereum. Полученный байт-код помещается в специальное поле транзакции. Эта транзакция заверяется от имени аккаунта инициатора; далее она распространяется по сети и размещает код смарт-контракта. Комиссия за проведение транзакции и, соответственно, за выполнение контракта снимается с баланса аккаунта инициатора.

Каждый смарт-контракт обязательно содержит свой конструктор. Он может быть пустым или содержать код по аналогии с конструкторами объектов в объектно-ориентированных языках программирования. После того, как конструктор выполняется, создается идентификатор аккаунта смарт-контракта, который может быть использован для отправки монет, вызова методов смарт-контракта и т. д.

Любой аккаунт содержит в себе четыре поля:

* *nonce* – счетчик, который отображает количество подтвержденных транзакций, инициированных этим аккаунтом;
* *balance* – количество wei, которые принадлежат адресу;
* *storageRoot* – 256-битное хэш-значение корневого узла дерева Merkle Patricia, которое покрывает содержимое аккаунта (в обычных аккаунтах поле пустое, в аккаунтах контракта оно хранит корневое хэш-значение от состояния аккаунта);
* *codeHash* – хэш-значение кода EVM, то есть значение кода, который выполнится при получении этим аккаунтом сообщения вызова. Это поле не может быть изменено после создания аккаунта.

Код EVM – бинарный код смарт-контракта, который выполняется на Ethereum virtual machine. Обычно смарт-контракт пишется на Solidity, но виртуальная машина, которая выполняет контракт, не понимает этот язык, поэтому предварительно необходимо скомпилировать код в машиночитаемый код EVM.

EVM является stack-based, то есть данные помещаются в стек, а операторы [60] работают непосредственно со значениями в стеке.

### Сообщение вызова в Ethereum

Контракты в Ethereum могут отправлять «сообщения» другим контрактам. Сообщения являются виртуальными объектами, которые не сериализуются и существуют только в сети Ethereum. Каждое сообщение содержит такую информацию:

* отправитель сообщения;
* получатель сообщения;
* количество монет, передаваемых вместе с сообщением;
* поле для опциональных данных;
* значение STARTGAS (количество максимальных шагов, которые разрешено выполнить для проведения транзакции).

Сообщение очень похоже на транзакцию, за исключением того, что оно инициируется контрактом, а не пользователем. Сообщения генерируются в момент когда исполняющийся контракт вызывает код CALL который создает и выполняет сообщение.

### Комиссионные сборы и gas 

В отличие от некоторых учетных систем, комиссия за транзакции в Ethereum оплачиваются в не зависимости от того, была ли транзакция успешно проведена (был ли содержащийся в ней код полностью выполнен). Даже если транзакция не была успешно подтверждена, валидаторы уже начали ее обработку (верифицировали и отправили ее код на выполнение виртуальной машиной); соответственно, эти вычисления должны быть оплачены.

Максимальная стоимость комиссии за транзакцию определяется как произведение _gasPrice_ и _gasLimit_. Параметр gasLimit определяется непосредственно отправителем транзакции и содержит в себе максимальное количество единиц _gas_, которые готов заплатить пользователь для проведения транзакции. Подобное ограничение необходимо из-за природы смарт-контрактов в Ethereum. Так как Ethereum поддерживает полные по Тьюрингу смарт-контракты, то не исключены ситуации, когда из-за ошибки в коде контракт может выполняться бесконечно (и тратить все монеты пользователя). Фактически, до обработки и подтверждения транзакции невозможно точно сказать, сколько gas она потребует для корректного завершения кода, потому что ветвления в коде смарт-контракта могут зависеть от последнего актуального состояния других аккаунтов. При этом важно понимать, что если пользователь задал недостаточное для выполнения контракта количество единиц gas, которые он готов заплатить, то смарт-контракт не будет до конца обработан валидаторами. Соответственно, транзакция не подтвердится, но пользователь все же потратит монеты на оплату комиссии. Отметим, что весь неиспользованный gas конвертируется обратно в ether и возвращается на баланс аккаунта отправителя после корректной обработки транзакции.

Если пользователь не хочет платить много за транзакцию (или же наоборот хочет заплатить побольше), то существует параметр gasPrice, в котором инициатор транзакции определяет количество wei, которые он готов заплатить за единицу gas. Чем выше это значение, тем более вероятно, что валидаторы возьмутся за обработку транзакции, так как ее добавление в блок гораздо выгоднее, чем добавление транзакции со сравнительно малым значением gasPrice. Фактическая комиссия за транзакцию вычисляется так:

**transactionFee = gas * gasPrice.**

### Структура транзакции в Ethereum

Чтобы было понятнее, мы приступим к рассмотрению структуры транзакции Ethereum и примера кода смарт-контракта. Транзакция Ethereum состоит из полей, изображенных на рис. 7.6.

<img width="50%" alt="Рисунок 7.6 – Структура транзакции Ethereum" src="/resources/img/volume-2/7.2-Ethereum-platform-and-smart-contracts/Figure-7.6-Ethereum-Transaction.png"/> 

Поле _nonce_ – это некоторый порядковый номер транзакции относительно самого аккаунта, который ее распространяет и является ее автором. Это нужно для того, чтобы отличать двойники транзакций, то есть исключить ситуацию, когда одна и та же транзакция принимается дважды. Благодаря наличию такого поля каждая транзакция имеет уникальное хэш-значение.

Далее следует поле _gas price_. Здесь указывается цена, по которой базовая валюта ether конвертируется в gas, которым оплачивается выполнение команд смарт-контракта и выделение ресурса виртуальной машины. Что это значит?

В Bitcoin комиссии оплачиваются непосредственно в базовой валюте – в биткоинах. Это возможно благодаря простому механизму расчета их размера: мы оплачиваем строго объем данных, который содержится в транзакции. В Ethereum ситуация сложнее, потому что только от объема данных транзакции отталкиваться уже не достаточно. Здесь транзакция еще может содержать программный код, который будет запускаться на виртуальной машине, а каждая операция виртуальной машины может иметь разную сложность и время выполнения. Существуют также операции, которые выделяют память для переменных и массивов данных. Они также будут иметь определенную сложность, от которой будет зависеть их оплата. Более того, на этапе формирования транзакции неизвестно, сколько будет операций и какие именно операции будут выполнены в момент принятия этой транзакции валидаторами.

Стоимость каждой операции в эквиваленте gas будет константной. Он и вводится специально для того, чтобы определить константную стоимость каждой операции. В зависимости от нагрузки на сеть будет устанавливаться параметр gas price, согласно значению которого базовая валюта будет конвертироваться в gas для оплаты комиссии.

Есть еще одна особенность транзакции в Ethereum: байт-код, который она содержит для выполнения в виртуальной машине, будет выполняться до тех пор, пока он не завершится с каким-то результатом (успешно/неуспешно) либо пока не закончится объем монет, выделенное на оплату комиссии. Именно во избежание ситуации, в которой с аккаунта отправителя из-за какой-то ошибки потратились бы все монеты на комиссию (например, в виртуальной машине стал выполняться какой-то бесконечный цикл), предусмотрено следующее поле – _start gas_ (его часто называют _gas limit_). Оно определяет максимальный объем монет, которые отправитель готов потратить на выполнение определенной транзакции.

Следующее поле называется _destination address_. Сюда вписывается адрес получателя монет либо адрес конкретного смарт-контракта, методы которого будут вызываться. После него следует поле _value_, куда вписывается сумма монет, которые отправляются на баланс destination address.

Далее располагается поле под названием _data_. Суда помещается не просто значение, а целая структура, в которой определяется код для виртуальной машины. Кроме того, в это поле можно помещать произвольные данные; для этого существуют специальные правила заполнения структуры.

И последнее поле транзакции называется _signature_. Оно одновременно содержит в себе и цифровую подпись инициатора этой транзакции, и открытый ключ, которым будет проверяться эта подпись. Из открытого ключа можно получить идентификатор аккаунта (адрес) отправителя этой транзакции, то есть уникально идентифицировать аккаунт отправителя в самой системе.

### Обработка транзакций

После отправки любой транзакции в сеть, она попадает в mempool каждого узла, и если владельцы большинства вычислительной мощности сети Ethereum принимают ее, то потом она включается в один из новых блоков. Отметим, что для подтверждения транзакции в Ethereum должно быть сформировано некоторое количество блоков на основе того, который включает данную транзакцию. На практике это количество составляет 6–20 блоков. Строго говоря, количество подтверждений транзакции определяет сторона, которая будет принимать изменения, вносимые транзакцией в состояние своего аккаунта. Например, некоторая транзакция добавляет на баланс аккаунта Алисы 1000 ether (сумма достаточно большая), тогда Алиса принимает решение, что будет дожидаться 35 блоков, следующих за тем, который подтверждает эту транзакцию.

В каждом блоке Ethereum существует как минимуму одна транзакция – награда за сформированный блок. Эта награда так же, как и комиссии, выдается узлу-валидатору, который решил ресурсоемкую задачу первым. Правда, награда выдается не сразу, а после появления (формирования) определенного количества блоков.

Также в Ethereum существует такое понятие как _uncle blocks_. Uncle blocks – блоки, которые были добыты и соответствуют правилам протоколу, но из-за задержек в сети (либо по другим причинам) были получены узлами сети позже альтернативных и не могут быть добавлены в основную цепочку блоков. В Bitcoin такие блоки отбрасываются, но в Ethereum они учитываются: проведенные транзакции, которые не конфликтуют, подтверждаются, но при этом вознаграждение за нахождение uncle блока меньше и вычисляется так: *(U<sub>n</sub> + 8 − B<sub>n</sub>) ∗ R / 8*, где _R_ – базовое вознаграждение за блок, _U<sub>n</sub>_ – высота uncle block, а _B<sub>n</sub>_ – высота последнего добытого блока.

### Структура блока Ethereum

Блок в Ethereum состоит из следующих полей (табл. 7.1).

Таблица 7.1
<img width="50%" alt="Таблица 7.1" src="/resources/img/volume-2/7.2-Ethereum-platform-and-smart-contracts/Table-7.1.png"/> 

### Ethereum virtual machine 

EVM является важным компонентом каждого узла сети Ethereum вне зависимости от того, является ли конкретный узел валидатором или нет, поскольку она отвечает за обработку состояния сети и выполнение всех необходимых вычислений. EVM отвечает за обработку такой информации:

* О балансах
* Об адресах
* О состоянии gas
* О смарт-контракте

Каждый узел Ethereum запускает EVM для поддержания сети Ethereum и достижения консенсуса. Виртуальная машина должна отслеживать состояние перечисленных компонентов для успешной обработки и подтверждения транзакции, которые, в свою очередь, влияют на состояние децентрализованной учетной системы в целом.

### Пример исходного кода смарт-контракта

Давайте сейчас детально рассмотрим самый простой смарт-контракт на примере. Это исходный код примитивного смарт-контракта, который может удерживать монеты пользователей и возвращать их по требованию.

Данный смарт-контракт называется Bank и он выполняет следующие функции: накапливает на своем балансе монеты (то есть при подтверждении транзакции и размещении такого смарт-контракта создается новый аккаунт, который может содержать на своем балансе монеты); он запоминает пользователей и распределение монет между ними; имеет метод пополнения, вывода, а также проверки баланса пользователя (рис. 7.7).

<img width="50%" alt="Рисунок 7.7 – Пример контракта в Ethereum" src="/resources/img/volume-2/7.2-Ethereum-platform-and-smart-contracts/Figure-7.7-Ethereum-contract-example.png"/> 

Рассмотрим этот код построчно. В этом контракте есть константные поля. Одно из них типа address называется owner. Здесь контракт запоминает адрес пользователя, создавшего этот смарт-контракт. Далее есть динамическая структура, которая сохраняет в себе соответствия между адресами пользователей и балансами. 

После этого следует метод Bank – конструктор этого контракта. Здесь происходит присвоение переменной owner адреса того, кто разместил этот смарт-контракт на платформе. Структура msg – это именно те данные, которые были переданы виртуальной машине вместе с транзакцией, содержащей весь код этого контракта. Соответственно, msg.sender – это адрес аккаунта-инициатора транзакции, которая размещает этот код. Он и будет владельцем смарт-контракта.

Метод deposit позволяет передать в транзакции определенное количество монет на аккаунт контракта. Смарт-контракт, получая эти монеты, оставляет их у себя на балансе, но в структуру balances записывает, кто именно был отправителем этих монет, чтобы запомнить, кому они принадлежат.

Метод withdraw принимает один параметр – ту сумму монет, которую инициатор хочет вывести из этого контракта. Здесь происходит проверка того, достаточно ли монет на балансе пользователя, который вызвал этот метод, для вывода средств. Если достаточно, тогда смарт-контракт отправляет на баланс пользователя это количество монет.

Метод getMyBalance проверяет текущий баланс пользователя. Целевой баланс считывается из структуры соответствий по адресу вызывающего аккаунта. Стоит отметить модификатор этого метода – view. Он обозначает, что метод никак не меняет переменные своего класса (контракта) и, фактически, является только методом чтения. Отдельная транзакция не создается для вызова этого метода, комиссия не платится, а все вычисления выполняются локально, после чего пользователь получает результат.

Также есть метод kill. Он нужен для того, чтобы деактивировать контракт и уничтожить соответствующее его состояние. Тут прописана дополнительная проверка того, является ли тот, кто вызывает этот метод, владельцем этого контракта. Если да, тогда контракт самоуничтожается, причем функция самоуничтожения принимает один параметр – идентификатор аккаунта, на который контракт отправит все монеты, оставшиеся на его балансе. При самоуничтожении контракта все оставшиеся монеты на его балансе автоматически уйдут на баланс владельца контракта.

### Выполнение контракта на платформе Ethereum

Рассмотрим схематично, как выполняются смарт-контракты на платформе Ethereum и как работает полный узел сети.

Полный узел сети Ethereum должен иметь как минимум четыре модуля (рис. 7.8).

<img width="50%" alt="Рисунок 7.8 – Модули полного узла Ethereum" src="/resources/img/volume-2/7.2-Ethereum-platform-and-smart-contracts/Figure-7.8-Ethereum-Full-Node-Modules.png"/> 

Первым является P2P networking module – модуль сетевого соединения и работы с другими узлами, где идет обмен блоками, транзакциями, информацией о других узлах. Это обязательный компонент для любой децентрализованной учетной системы.

Далее следует blockchain – модуль хранения цепочки блоков, обработки альтернативных цепочек, выбора приоритетной ветки, дополнения блоков, отсоединения блоков, верификации и т. п.

Следующий модуль называется Ethereum virtual machine. Это и есть виртуальная машина, которая принимает байт-код из транзакции в Ethereum. Этот модуль обрабатывает текущее состояние определенного аккаунта и выполняет изменения его состояния на базе полученного байт-кода. Версия виртуальной машины на каждом из узлов сети должна быть одинаковой для получения одного результата. Вычисления, происходящие на каждом узле Ethereum, абсолютно одинаковые, но в сети они происходят в асинхронном режиме: одни узлы раньше получают и проверяют некоторую транзакцию, то есть выполняют включенный в нее код, а другие – позже. Соответственно, после своего создания транзакция распространяется в сеть, узлы ее принимают и в момент верификации (по аналогии с выполнением Bitcoin Script для транзакций в Биткоине) здесь выполняется байт-код виртуальной машины.

Транзакция считается проверенной, если весь содержащийся в ней код был выполнен, было сгенерировано новое состояние определенного аккаунта и было сохранено новое состояние до тех пор, пока не будет понятно, применена ли эта транзакция. Если транзакция применена, тогда это состояние считается не только выполненным, но и актуальным. У каждого узла сети есть база данных, которая хранит состояние каждого аккаунта. Ввиду того, что все вычисления происходят одинаково и версия цепочки блоков одинакова, база данных, содержащая состояния всех аккаунтов, для каждого узла тоже будет одинаковой.

### Ограничения платформы Ethereum

Давайте рассмотрим ограничения, которые присущи Ethereum (и прочим похожим на него платформам смарт-контрактов), и, соответственно, развеем некоторые мифы. Часть ограничений обусловлена наличием виртуальной машины на каждом узле сети.

> * _Выполнение кода_
> * _Выделение памяти_
> * _Доступ к данным только из цепочки блоков_
> * _Отправка платежей_
> * _Создание нового контракта_
> * _Вызов других контрактов_

Действительно, здесь можно выполнять произвольные логические операции. Однако комиссия оплачивается отдельно за каждую операцию и за каждую дополнительно выделенную единицу объема памяти.

Виртуальная машина может читать данные из базы данных блокчейна, чтобы использовать эти данные в качестве триггера для выполнения той или иной логики смарт-контрактов. Виртуальная машина может создавать и отправлять транзакции, создавать новые контракты и вызывать методы других смарт-контрактов, которые уже опубликованы в сети, и т. д.

Наиболее распространенный миф заключается в том, что смарт-контракты Ethereum могут использовать информацию из любых интернет-ресурсов в своих условиях. Правда состоит в том, что виртуальная машина не может отправить сетевой запрос какому-то внешнему информационному ресурсу в Интернете, то есть нельзя написать такой смарт-контракт, который будет распределять ценность между пользователями в зависимости от того, допустим, какая погода на улице, либо того, кто выиграл какой-то чемпионат, либо любого другого происшествия во «внешнем мире», потому что данных об этих происшествиях просто нет в базе данных самой платформы. То есть если подобные данные не появятся в блокчейне, то и виртуальная машина не может использовать их в качестве триггеров.

### Недостатки платформы Ethereum

> * _Ошибки в коде (из-за сложностей при проектировании и тестировании)_
> * _Уязвимости виртуальной машины_
> * _Сложности задания цен на операции_

Первый недостаток состоит в том, что есть некоторые сложности при проектировании, разработке и тестировании смарт-контрактов в Ethereum. Практика показывает, что причиной очень большой процента ошибок становится человеческий фактор. Это актуально и для уже написанных смарт-контрактов Ethereum, которые имеют среднюю либо высокую сложность. Если для простых смарт-контрактов вероятность ошибки мала, то в сложных смарт-контрактах очень часто случаются ошибки, которые приводят к хищению средств, к их заморозке, к преждевременному уничтожению смарт-контрактов и т. п.

Второй недостаток заключается в том, что сама виртуальная машина создана людьми и не может быть идеальна во всех отношениях. Она может выполнять произвольные команды – и в этом кроется уязвимость: можно определенным образом сконфигурировать ряд команд, поместить их в транзакцию и отправить на выполнение, что приведет к заранее не предсказуемым последствиям. Это очень сложная сфера, но существует уже несколько исследований, которые показывают, что эти уязвимости есть в текущей версии сети Ethereum и они могут привести к отказу работы многих смарт-контрактов.

Еще одна большая сложность, которую можно считать недостатком, заключается в том, что можно практически либо технически определить некоторый специфический порядок операций, которые при выполнении в совокупности очень сильно нагрузят виртуальную машину и замедлят ее не пропорционально той комиссии, которая была уплачена за выполнение этих операций.

В прошлом уже был такой период развития Ethereum, когда разные исследователи, детально разбираясь в работе виртуальной машины, находили такие уязвимости. Фактически, они платили комиссии очень малого размера, но на практике сильно замедляли работу всей сети. Такой эффект достигался за счет подбора определенной последовательности команд виртуальной машины. Эти проблемы решаются очень сложно, так как нужно их, во-первых, обнаружить, во-вторых, скорректировать цену за выполнение этих операций и, в-третьих, провести hardfork (одновременное обновление всех узлов сети на новую версию ПО и одновременное вступление в действие этих всех изменений).

Что касается платформы Ethereum в целом, то было проведено очень много исследований и был получен очень большой практический опыт (как положительный, так и отрицательный). Он был использован при создании других децентрализованных платформ смарт-контрактов, таких как Bitshares, EOS. Тем не менее, остаются сложности и уязвимости, с которыми предстоит еще как-то бороться.

**Часто задаваемые вопросы**

*– Если все стороны действующего смарт-контракта хотят изменить условия, могут ли они отменить этот смарт-контракт с помощью мультиподписи, а потом создать новый смарт-контракт с уже обновленными условиями?*

Тут ответ будет двоякий. С одной стороны, смарт-контракт задается единожды, и он в дальнейшем не подразумевает никаких изменений; с другой стороны, он может иметь заранее прописанную логику, которая предусматривает полное или частичное изменение каких-то условий. То есть если вы хотите что-то поменять в своем смарт-контракте после его публикации, то вы заранее должны прописать условия и добавить функциональность замены, с помощью чего вы можете осуществлять обновление уже существующего контракта. Только таким образом можно организовать обновление контракта. Впрочем, и здесь можно допустить какую-то ошибку и получить соответствующую уязвимость, поэтому такие действия нужно очень тщательно проектировать и тестировать.

*– Можно ли добавить медиатора сделки в смарт-контракт? Что произойдет, если медиатор войдет в сговор с одним из участников смарт-контракта?*

Медиатор не обязателен в смарт-контракте, но можно предусмотреть одного или нескольких медиаторов сделки. Для этого нужно заранее включить идентификаторы медиаторов в контракт и прописать для них отдельные методы, которые они будут вызывать для влияния на ход выполнения сделки. Медиаторы и выбираются таким образом, что им доверяют одновременно все вовлеченные в процесс стороны. Соответственно, участники сделки просто не будут начинать взаимодействие, переводить монеты и вызывать методы контракта, если он предусматривает наличие медиатора, которому они не доверяют. А все риски относительно сговора решаются увеличением количества независимых медиаторов.

*– Можно ли одной транзакцией Ethereum перевести много разных токенов со своего адреса на разные целевые адреса, например, биржевые адреса, для торговли этими токенам?*

Это касается модели транзакций в Ethereum и ее отличия от модели в Bitcoin. Это отличие кардинально. При модели транзакций в Ethereum, если вы просто переводите монеты, конкретная их сумма, которую вы указали, переводится только с одного адреса на другой адрес без сдачи и без участия других адресов. То есть Ethereum работает не по модели непотраченных выходов (UTXO), а по модели аккаунтов и балансов. Следовательно, одной транзакцией провести несколько платежей нельзя – нужны отдельные транзакции. Если же платежи должны быть в разных токенах, то каждая из транзакций должна вызывать метод именно того контракта, который занимается учетом соответствующего токена.

*– В «Ограничениях платформы Ethereum» было указано, что невозможно описать такие условия, которые будут зависеть от данных внешнего интернет-ресурса. Возможно ли как-то обойти это ограничение?*

Решение состоит в том, что сам смарт-контракт может предусматривать одного или нескольких так называемых оракулов. Это доверенные стороны, которые собирают данные о состоянии «внешнего мира» и передают их в смарт-контракты через специальные методы. Сам контракт, в свою очередь, должен обработать все полученные наборы данных, принимая за правду те, которые получены от большинства оракулов. В контракте может быть задан такой алгоритм, который не учитывает данные от некоторых оракулов, которые противоречат большинству.

*– Можно ли создать свою платформу с реализацией своих собственных контрактов? Насколько это сложно и что для этого нужно?*

Теоретически это, конечно же, возможно, но для этого нужно решить ряд проблем, связанных со следующим: разработкой ПО узлов сети, созданием приложений пользователей, проектированием системы мотивации валидаторов, разработкой механизма достижения консенсуса и т. п. Также стоит определить, нужны ли произвольно программируемые смарт-контракты или достаточно будет реализовать несколько шаблонов; в противном случае каждый узел сети должен будет запускать свою виртуальную машину, которую нужно отдельно разрабатывать. Так или иначе, создание децентрализованной платформы смарт-контрактов «с нуля» – это очень сложная задача. В первую очередь, стоит отталкиваться от требований, которым должна удовлетворять система; может оказаться так, что проще сделать клон уже существующей системы и настроить параметры под конкретных валидаторов и пользователей.

[ЗАКЛЮЧЕНИЕ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-2/ru/8-conclusion.md)
