# 3 ТЕХНОЛОГИЧЕСКИЕ ДЕТАЛИ ФУНКЦИОНИРОВАНИЯ BITCOIN

## 3.1 Устройство и особенности Bitcoin Script

Существует три основных подхода к заданию условий относительно распределения и траты монет:

* полные по Тьорингу языки (Ethereum – Solidity);
* неполные по Тьюрингу языки (Bitcoin – Bitcoin Script);
* шаблонные смарт-контракты (Bitshares, Stellar и др.).

Для лучшего понимания отличий каждого из способов рассмотрим рисунок ниже (рис. 3.1):

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.1-Three-approaches-to-setting-conditions.png" alt="Рисунок 3.1 – Три подхода к заданию условий"/> 

Полные по Тьюрингу языки позволяют задавать произвольные условия траты монет и реализовывать сложнейшие смарт-контракты с циклами, вызовами функций и многим другим. Некоторым ограничением является необходимость строгого аудита кода, так как заранее непонятно, к чему могут привести ошибки в коде смарт-контракта.

Неполные по Тьюрингу языки, такие как Bitcoin Script, позволяют использовать набор заранее заданных операций и при этом использовать их в любой последовательности. Обычно набор таких операций ограничен несколькими десятками, но при этом операции реализованы безопасно и с их помощью можно без проблем задать наиболее востребованные (и наиболее часто используемые) условия.

Шаблонные смарт-контракты представляют собой набор готовых решений для использования. Этот набор сильно ограничен и пользователь не может добавить какую-либо дополнительную функциональность (по крайней мере, быстро – для этого нужно провести обновление протокола). Однако реализация этих функций наиболее оптимальна и безопасна.

В этом разделе мы подробно рассмотрим устройство Bitcoin Script, основные доступные операции и принципы их функционирования, особенности применения и реальные примеры использования Bitcoin Script как средства для задания условий выполнения транзакций. Несмотря на то, что _Bitcoin Script_ не позволяет написать произвольный смарт-контракт, он все равно активно используется разработчиками для реализации протоколов, которые работают поверх _Bitcoin_. Таким образом, возможно реализовать сценарий, по которому монеты можно потратить либо при наличии нескольких цифровых подписей и только по прошествию определенного времени, либо при каких-либо других условиях.

Как мы отмечали в первой части учебного пособия, верификация транзакций в Bitcoin подразумевает проверку _доказательств владения монетами_, которые должны удовлетворять _условиям траты монет_. Повторим, что доказательства владения монетами находятся во входе транзакции, а условия траты – в соответствующих выходах (рис. 3.2).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.2-Bitcoin-Transaction-Structure.png" alt="Рисунок 3.2 – Схема Bitcoin-транзакции"/> 

Эти условия и доказательства обычно формируются цифровыми кошельками автоматически. Для их описания в протоколе Bitcoin используется специальный язык – _Bitcoin Script_. Помимо платежей на обычные адреса, этот язык позволяет описывать достаточно сложные условия траты монет, в том числе те, которым можно удовлетворить только в определенный момент времени.

Как известно, в каждой транзакции имеются поля под названием scriptPubKey и scriptSig. Поле scriptPubKey содержит описание некоторых условий, которым пользователь должен удовлетворить, чтобы потратить монеты. В поле scriptSig содержатся данные, необходимые для удовлетворения таким условиям. Вместе оба поля представляют собой Script. Узлы сети выполняют этот скрипт и по результатам выполнения уже решают, является ли транзакция валидной. По сути, Bitcoin Script позволяет верифицировать транзакции, условия в которых могут быть описаны в произвольном порядке.

### Как выполняется Bitcoin Script?

Bitcoin Script – это неполный по Тьюрингу язык описания инструкций. В Bitcoin он используется для задания правил траты монет и удовлетворения этим правилам. Язык является стековым (stack-based) и использует «обратную польскую запись» («reverse-polish notation») для операндов.

Неполный по Тьюрингу означает, что язык имеет ограниченную функциональность и не поддерживает выполнение переходов и циклов. Следовательно, для скрипта исключена возможность вхождения в бесконечный цикл, что позволяет ограничить возможности злонамеренных сторон в отношении создания сложных транзакций и замедления работы всей системы.

«Reverse-polish notation» подразумевает, что оператор следует после операндов, а чтение выражения происходит слева направо. Такой тип записи выражений значительно проще обычного алгебраического, следовательно, влечет за собой меньшее количество вычислительных ошибок. В качестве примера рассмотрим выполнение нескольких арифметических операций над числами. В обычном алгебраическом представлении выражение выглядит так:

**(2 + 4) * 5 / 10**

Если же представить данный пример в виде набора стековых операций, то он будет иметь следующий вид:

**24 + 5 * 10 /**

Слегка непривычно, правда? Однако, на схеме ниже наглядно представлена последовательность всех вычислительных этапов (рис. 3.3).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.3-Example-of-processing-Stack-Elements.png" alt="Рисунок 3.3 – Пример обработки элементов стека"/> 

Пошагово все выполняется следующим образом:

1. В начале в стек помещается значение 2.
2. Затем в стек помещается значение 4. Теперь на вершине стека находится значение 4, а под ним значение 2.
3. Далее выполняется операция сложения. Для этого вынимаются два верхних стековых значения, складываются между собой и результат помещается обратно в вершину стека. Теперь на вершине стека находится значение 6.
4. Далее на вершину стека помещается значение 5.
5. Выполняется произведение верхних двух значений стека 5 и 6 и результат в виде 30 записывается в вершину стека.
6. В стек помещается значение 10.
7. Во время операции деления в качестве делителя выступает верхний операнд (10), и результат в виде 3 записывается в вершину стека.

Как видим, вычисления при помощи данной схемы достаточно просты и однозначны. Однако выше мы рассмотрели пример с простыми арифметическими операциями, где операндами были натуральные числа. В Bitcoin Script операции и операнды являются более сложными и разнообразными.

### Операции в Bitcoin Script

Для операций в Bitcoin Script существует специальная форма записи – OP_code (далее OP-код). Каждый OP-код можно рассматривать из двух частей: префикса «OP_» и непосредственно названия операции. Конкретный OP-код указывает компьютеру (виртуальному процессору), какая именно последовательность действий должна совершаться при его выполнении. Каждая операция представлена набором битов, который считывается виртуальным процессором и выполняется.

> **Операции в Bitcoin Script**
>> * _7 операций управления исполнением_
>> * _19 операций взаимодействия со стеком_
>> * _27 арифметических операций_
>> * _10 криптографических операций_

К операциям управления исполнением относятся такие OP-коды, как: OP_IF, OP_ELSE, OP_NOTIF, OP_ENDIF, OP_RETURN, позволяющие использовать в биткоин-скрипте операции ветвления (и тем самым предоставлять возможность создания нескольких независимых условий траты монет). Логика таких операций ничем не отличается от логики выполнения _if/else_ операторов в привычных языках программирования. Напомним, что Bitcoin Script является неполным по Тьюрингу, поэтому в нем отсутствуют операторы циклов, такие как _for_, _while_ и прочие. 

Операции взаимодействия со стеком представлены такими ОP-кодами, как OP_DROP, OP_DUP, OP_ROLL, OP_SWAP, OP_ROT и т. д. Они предназначены для работы со значениями из стека и позволяют как угодно управлять его элементами (удалять, перемещать, дублировать элементы и т. д.).

К операциям сравнения элементов стека относятся операции OP_EQUAL и OP_EQUALVERIFY. Отличие между этими операциями в том, что OP_EQUAL только возвращает значение true/false (результат сравнения операндов), а OP_EQUALVERIFY на основании этого прекращает либо продолжает выполнение следующих операций скрипта.

К арифметическим операциям относятся: сложение (OP_ADD), сравнение (OP_NUMEQUAL), операции нахождения минимального и максимального чисел (OP_MIN, OP_MAX) и множество других.

Криптографические операции. Операции OP_RIPEMD160, OP_SHA1, OP_SHA256 позволяют вычислить соответствующие хеш-значения. Операции OP_HASH160 и OP_HASH256 высчитывают двойной хэш (в первом случае это последовательное вычисление SHA-256 и RIPEMD, во втором – дважды взятый хэш SHA-256). Также включены операции проверки как одиночной подписи, так и мультиподписи (OP_CHECKSIG, OP_CHECKMULTISIG).

Стоит отметить, что все операции, кроме операций помещения значений в стек, являются безаргументными. Это означает, что данные операции работают только со значениями, которые находятся в стеке, и невозможно поместить на вход операции значение, которое находится вне стека. Поэтому в процессе задания условий нужно учитывать, что максимальная вместимость стека при использовании Bitcoin Script ограничена размером 520 байт.

Итак, изложенный выше материал позволяет сформировать представление об особенностях вычислений в Bitcoin Script и существующих операциях. Теперь рассмотрим, как он применяется в реальных bitcoin-транзакциях.

### Пример выполнения Bitcoin Script для P2PKH

Рассмотрим пример траты для ситуации, где монеты отправляются на обычный адрес, к которому привязан хэш одного открытого ключа (P2PKH, или pay-to-public-key-hash). Скрипт, который задает условия траты, объединенный со скриптом, который удовлетворяет этим условиям, приведен на рисунке 3.4.

С левой стороны схемы мы видим стек данных, а справа – сам скрипт. Первые два компонента строки Script  – значение подписи и открытого ключа – так называемый _unlocking script_, то есть скрипт, который указывается во входе транзакции, которая тратит монеты (находится в поле scriptSig). После этого следует набор данных, который указывается в выходе транзакции – это называется _locking script_ (поле scriptPubKey транзакции).

Иначе говоря, на схеме представлена конкатенация двух скриптов: скрипт, отпирающий монеты, и скрипт, запирающий монеты. Когда транзакция будет валидироваться уже узлом сети, эти два скрипта объединяются для выполнения проверки условий траты монет.

После конкатенации скриптов происходит последовательное выполнение полного набора операндов. Указатель выполнения идет последовательно по каждому операнду и каждому участку данных. Если указатель выполнения попадает на участок данных, то они помещаются в стек. Как мы видим на схеме, курсор выполнения скрипта в верхней части указывает на данные подписи, которые позже помещаются в стек. Далее, курсор выполнения указывает на открытый ключ – он также помещается в стек. Третьим шагом идет выполнение операции дубликации, что подразумевает копирование значения, которое находится на вершине стека, и помещение этих данных повторно в стек (в вершине находилось значение открытого ключа).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.4-The-first-step-of-script-execution.png" alt="Рисунок 3.4 – Первый шаг выполнения скрипта"/> 

После этого выполняется хэширование при помощи OP_HASH160 (рис. 3.5). Это значит, что верхнее значение стека хэшируется сначала алгоритмом SHA-2 на длине 256 бит, а потом функцией RIPEMD-160 на длине 160 бит. Операция точно такая, как при хэшировании открытого ключа при получении адреса. Фактически, полученное значение и является адресом.

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.5-The-second-step-of-script-execution.png" alt="Рисунок 3.5 – Второй шаг выполнения скрипта"/> 

Мы имеем в стеке подпись, открытый ключ и хэш-значение открытого ключа. Курсор выполнения скрипта указывает на адрес, который был задан в выходе транзакции. Эта часть данных тоже попадает в стек (рис. 3.6).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.6-The-third-step-of-script-execution.png" alt="Рисунок 3.6 – Третий шаг выполнения скрипта"/> 

Следующей выполняется операция сравнения OP_EQUALVERIFY. Два верхних элемента стека сравниваются. Если они равны, то эти данные удаляются из стека, возвращается значение true (это значение не попадает в стек, но от него зависит, продолжит ли скрипт свое выполнение) и считается, что проверка прошла успешно. После этого в стеке остаются значения подписи и открытого ключа. Соответственно, операция OP_CHECKSIG берет эти два операнда и проверяет подпись открытым ключом (рис. 3.7).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.7-The-fourth-step-of-script-execution.png" alt="Рисунок 3.7 – Четвертый шаг выполнения скрипта"/> 

Если подпись верна относительно транзакции (подпись покрывает поля транзакции), то результат проверки – true, и это значение помещается в стек. На этом выполнение скрипта заканчивается. Данные передаются в вызывающую функцию и там проверяются. Если в стеке находится значение true, значит верификация данного входа транзакции прошла корректно. Если все входы транзакции были корректно проверены, то и вся транзакция считается правильной.

### Пример с multisignature

Теперь рассмотрим, как при помощи Bitcoin Script задается мультиподпись. Условие, требующее несколько ключей, блокируется следующим скриптом (в качестве примера реализуем мультиподпись 2 из 3):

**scriptPubKey : OP_0 OP_2 \<pubKeyA> \<pubKeyB> \<pubKeyC>  OP_3 OP_CHECKMULTISIG**

Скрипт разблокировки будет выглядеть следующим образом:

**scriptSig : \<sig1> \<sig2>**

В данном случае OP_2 обозначает количество подписей, которые необходимо предоставить в scriptSig, а ОР_3 – количество предоставленных публичных ключей, которым должны соответствовать подписи.

Скрипт начинает выполняться с того, что в стек помещаются значения подписей, которые находятся в поле scriptSig (рис. 3.8).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.8-The-first-step-of-script-execution.png" alt="Рисунок 3.8 – Первый шаг выполнения скрипта"/> 

Далее в стек помещается значение 0 и 2 (по количеству подписей, которые необходимо проверить), как на рисунке 3.9. Значение 0 не несет никакой нагрузки, оно добавлено из-за особенности операции OP_CHECKMULTISIG, которая при выполнении удаляет одно дополнительное значение в стеке. 

<img width="60%" alt="Рисунок 3.9 – Второй шаг выполнения скрипта" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.9-The-second-step-of-script-execution.png"/> 

После этого в стек помещаются все значения открытых ключей (рис. 3.10) и значение 3 (по количеству значений открытых ключей).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.10-The-third-step-of-script-execution.png" alt="Рисунок 3.10 – Третий шаг выполнения скрипта"/> 

После чего выполняется операция OP_CHECKMULTISIG (рис. 3.11).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.11-The-fourth-step-of-script-execution.png" alt="Рисунок 3.11 – Четвертый шаг выполнения скрипта"/> 

OP_CHECKMULTISIG выполняется следующим образом. Сначала эта операция проверяет соответствие ключа, который находится вверху стека, и подписи, которая расположена ближе к вершине стека. После этого, в любом случае, ключ удаляется (поскольку каждый из ключей проверяется только один раз, поэтому их расположение должно соответствовать расположению предоставленных подписей). Процесс повторяется до тех пор, пока все подписи не будут проверены. Если все подписи действительны, то возвращается значение true, в противном случае – false.

Подобная схема редко используется, потому что в этом случае объем данных в поле scriptPubKey получается довольно большой и, соответственно, размер комиссии за транзакцию также возрастает. Вместо подобной схемы зачастую используется схема P2SH (pay-to-script-hash), где все условие передается в виде его хэш-значения и сторона, которой нужно будет разблокировать монеты, должна предоставить сам скрипт и данные для его выполнения.

### Использование механизма locktime

С помощью Bitcoin Script мы также можем задать условие, при котором монеты будут тратиться только через определенное время. Задание такого условия осуществляется с помощью следующего скрипта:

**\<time> OP_CHECKLOCKTIMEVERIFY OP_DROP OP_DUP OP_HASH160 \<address_В> OP_EQUALVERIFY OP_CHECKSIG**

Стоит отметить, что содержимое отличается от скрипта P2PKH присутствием части <time> OP_CHECKLOCKTIMEVERIFY OP_DROP. Рассмотрим, как выполняется именно эта часть, так как остальной скрипт выполняется идентично примеру выше.

Сначала на вершину стека помещается значение времени блокировки (рис. 3.12).

<img width="60%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.12-The-first-step-of-script-execution.png" alt="Рисунок 3.12 – Первый шаг выполнения скрипта"/> 

Далее операция OP_CHECKLOCKTIMEVERIFY сравнивает параметр <time> с полем lock_time, которое содержится в заголовке транзакции (рис. 3.13). Трата монет осуществляется, только если значение lock_time больше значения верхнего элемента стека (<time>).

<img width="30%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.13-The-second-step-of-script-execution.png" alt="Рисунок 3.13 – Второй шаг выполнения скрипта"/> 

После этого операция OP_DROP удаляет верхнее значение стека (рис. 3.14), которое будет в себе содержать значение времени для разблокировки, и которое нам более не понадобится, если OP_CHECKLOCKTIMEVERIFY вернет TRUE и тем самым продолжит выполнение скрипта.

<img width="30%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.14-The-third-step-of-script-execution.png" alt="Рисунок 3.14 – Третий шаг выполнения скрипта"/> 

### Нестандартные транзакции при помощи Bitcoin Script

13 декабря 2012 года в цепочку блоков Bitcoin была добавлена транзакция, которая платит 1 биткоин тому, кто предоставит данные, хэш-значение от которых будет соответствовать заданному. Транзакция содержала следующий скрипт:

**OP_HASH256
6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000 
OP_EQUAL**

Как вы поняли, транзакция, которая обрела название «Transaction puzzle», требовала от получателя таких данных, которые бы в результате хэширования давали значение, которое хранится в условиях траты монет. Схематически работу скрипта можно изобразить на рисунке 3.15.

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.15-Hash-function-preimage-validation-scheme.png" alt="Рисунок 3.15 – Схема проверки прообраза хэш-функции"/> 

На этом разнообразие транзакций не заканчивается. В сети встречаются транзакции, условие в которых требует определенного значения подписи, также транзакции, условия в которых содержат множество ветвлений, и др. Bitcoin Script – это мощный инструмент для задания условия траты монет. Его структура и организация не позволяют злоумышленным сторонам задать сложный сценарий, который может существенно нагрузить сеть. Но в то же время, правильно используя все его возможности, пользователи могут точно указать, каким именно образом могут быть потрачены монеты.

### Статистика транзакций в сети Bitcoin

Если проанализировать транзакции цепочки блоков Bitcoin за период с августа 2018 по август 2019 года, статистика использования разных видов Bitcoin Script и соответствующих типов транзакций имеет следующий вид (рис. 3.16) [23]:

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.16-Transactions-Outputs-Type-Statistics.png" alt="Рисунок 3.16 – Статистика типов выходов транзакций"/> 

Здесь важно обратить внимание на P2SH-транзакции. У многих уже, наверное, возникло недоумение, что за последний год не было отправлено ни одной P2SH_MULTISIG транзакции. Однако это не так. Дело в том, что до того момента, пока выходы P2SH-транзакции не потрачены, нельзя сказать, какой скрипт она содержала (там указано только хэш-значение скрипта) и, соответственно, какой тип операции проводила. Если же мы посмотрим на статистику входов транзакций за последний год, то мы уже сможем увидеть количество каждого типа P2SH-транзакций (рис. 3.17).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.17-Transaction-Output-Type-Statistics.png" alt="Рисунок 3.17 – Статистика входов транзакций"/> 

Однако отметим, что при этом количество отправленных транзакций не всегда говорит о количестве монет, которое передается таким образом. Поэтому, если мы проанализируем статистику транзакций относительно суммы передаваемых монет, то убедимся, что больший объем платежей приходится на P2SH транзакции (более 58%), хотя общее количество отправленных транзакций говорит о том, что около 50% являются P2PKH транзакциями (рис. 3.18).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.18-Transferred-Coins-Amount-by-Transaction-Type-Statistics.png" alt="Рисунок 3.18 – Статистика объема передаваемых монет от типа транзакции"/> 

**Часто задаваемые вопросы**

*— Какие еще «transaction puzzles» можно найти в транзакциях Bitcoin?*

В 2013 в сеть была добавлена транзакция, для получения средств из которой нужно было предоставить две разные строки текста, которые произвели бы одинаковый хэш по алгоритму SHA-1. Другими словами, чтобы разблокировать эти средства, нужно было обнаружить коллизию. В 2017 году коллизия все-таки была обнаружена и средства были переведены на адрес пользователя, которому удалось решить эту задачу.

## 3.2 Форматы ключей в Bitcoin

Прежде всего отметим, что мировая тенденция в оцифровке активов, скорее всего, рано или поздно поставит пользователя перед необходимостью управлять своими цифровыми активами напрямую. Как браузер позволяет просто работать с web-сайтами, осуществляя при этом сложные взаимодействия на программном уровне, так и цифровой кошелек является удобным средством для управления оцифрованными активами. Только в этом случае пользователю нужно уметь работать с ключами, поскольку доступ к активам осуществляется посредством ключей. Поэтому вопрос форматов ключей только кажется второстепенным, и достаточная осведомленность в этом случае окажется полезной даже рядовому пользователю.

Итак, чтобы управлять своими монетами, в учетной системе Bitcoin используются три объекта: личный ключ, открытый ключ и bitcoin-адрес. На данном этапе подойдут наиболее простые определения каждого компонента. Личный ключ – это случайно сгенерированное число длиной 256 бит; открытый ключ вычисляется из личного ключа (длина открытого ключа равна 512 бит), а bitcoin-адрес является хэш-значением открытого ключа (160 бит), полученным в результате применения двух разных алгоритмов хэширования.

Далее мы рассмотрим форматы кодирования личных и открытых ключей, которые чаще всего используются при работе с Bitcoin. Каждый из форматов имеет свои отличительные особенности, поэтому их следует изучить отдельно.

> **Основные форматы кодирования ключей для Bitcoin**
>> * _Hex (Base16 encoding)_
>> * _WIF (Wallet Import Format)_
>> * _BIP38 (зашифрованный личный ключ)_

Поскольку в Bitcoin используется криптография на эллиптических кривых, открытый ключ является точкой на кривой, которая имеет две координаты. Таким образом, мы можем записать любой открытый ключ в виде просто двух координат: _X_ и _Y_. Однако это не единственная возможная форма записи открытого ключа.

Рассмотрим, как выглядит открытый ключ в декартовой системе координат (рис. 3.19). На графике эллиптической кривой находится точка _P_ (_X_; _Y_), которая и является открытым ключом пользователя. Эта точка имеет две координаты: абсцисса – _X_, и ордината – _Y_. Соответственно, вполне возможно вычислить значение _Y_ по аргументу _X_, подставив в уравнение кривой значение координаты _X_ точки _P_.

<img width="30%" src="/resources/img/volume-2/3.2-Key-formats-in-Bitcoin/Figure-3.19-X-coordinate-point-calculation-scheme.png" alt="Рисунок 3.19 – Схема вычисления точки по координате Х"/> 

Но поскольку в уравнении эллиптической кривой (*Y<sup>2</sup> = X<sup>3</sup> + 7</nobr>*) присутствует *Y<sup>2</sup>*, то для каждого аргумента _X_ существует два значения _Y_: положительное и отрицательное. Для того чтобы строго задать и затем отличить нужную точку (_Р_) от симметричной (_-Р_), кроме аргумента _X_, нужно также знать знак значения функции _Y_. Исходя из этих правил, был построен формат сжатого открытого ключа.

### Понятие сжатого открытого ключа

Итак, сначала из личного ключа образуется обычный открытый ключ, у которого есть координаты _X_ и _Y_. После этого значения координат конкатенируются, а в начале сериализованного ключа добавляется специальный префикс, который позволяет строго отличить этот формат от других. В шестнадцатеричной системе счисления такой префикс имеет значение «04». В результате несжатый открытый ключ представляет собой последовательность из 65 байт.

Чтобы получить сжатый формат такого открытого ключа, достаточно координаты _X_ точки _P_ и специального префикса, который указывает на знак координаты _Y_ (а также на то, что это несжатый формат записи открытого ключа). Префикс «02» используется для положительного значения _Y_, а префикс «03» – для отрицательного (рис. 3.20). При этом меняется формат записи открытого ключа, который теперь представляет собой последовательность длиной 33 байта. А поскольку адрес является результатом двойного хэширования открытого ключа, он также меняется.

<img width="50%" src="/resources/img/volume-2/3.2-Key-formats-in-Bitcoin/Figure-3.20-Public-Key-Formats.png" alt="Рисунок 3.20 – Форматы записи открытого ключа"/> 

Соответственно, для одного и того же личного ключа может быть два адреса. Поэтому форматы ключей, которые будут рассмотрены далее, будут иметь два варианта: сжатый и обычный. Это нужно, чтобы мы могли четко понимать, какие открытые ключи нам нужно вычислять на основе этого формата: сжатые или обычные.

### Форматы личных ключей

Существует множество форматов представления личных ключей. Чуть ли не ежедневно появляются предложения по поводу различных усовершенствований или новых форматов личных ключей, поскольку существует много задач, для которых они могут быть применены. Тем не менее, в любом формате часто используются одни и те же данные, а отличается только способ их кодирования. Ниже будут рассмотрены три основных формата в их обычном и сжатом вариантах.

Hex, или Base16, – это формат, который предполагает запись числа в шестнадцатеричной системе счисления. Он используется преимущественно в программном обеспечении, например, при общении между узлами сети и мобильными кошельками; это упрощает поиск ошибок и отладку приложения за счет повышения читабельности данных.

Стоит отметить, что обычный hex – это просто личный ключ, но существует вариант hex для сжатого личного ключа. В этом варианте, кроме личного ключа, в конце добавляется один байт данных, который в шестнадцатеричной системе счисления имеет вид «01» (рис. 3.21). На первый взгляд здесь получается некоторое несоответствие, поскольку сжатый личный ключ длиннее, чем обычный личный ключ. Однако это сделано для того, чтобы пользователи могли определить, какие открытые ключи следует порождать из этого личного ключа.

<img width="50%" src="/resources/img/volume-2/3.2-Key-formats-in-Bitcoin/Figure-3.21-Private-key-presentation-in-hex-encoding.png" alt="Рисунок 3.21 – Представление личного ключа в кодировке hex"/> 

Другим важным форматом личных ключей является wallet import format (WIF). Он позволяет удобно создавать резервные копии личных ключей либо переносить их из одного кошелька в другой. Следовательно, одной из основных особенностей этого формата является его повышенная читаемость для человека. Для этого используется специальная система кодирования Base58Check, особенностью которой является наличие контрольной суммы и дополнительного байта, указывающего версию (помогает как пользователю визуально распознать формат и понять, что именно перед ним находится, так и программному обеспечению идентифицировать, что именно было получено на вход).

В случае обычного WIF версионный байт при кодировке Base58Check преобразуется в символ «5». Сжатый вариант WIF аналогичен обычному, но есть одно отличие: входные данные – это сжатый личный ключ, где присутствует комбинация символов «01» в конце. Несмотря на то, что версионный байт остается таким же, как и в обычном WIF, префикс в закодированном значении меняется с «5» на «K» или «L» (рис. 3.22). По сути, меняется длина входных данных. Из-за этого увеличивается разряд и меняется первый символ, несмотря на то что версионный байт остается прежним.

<img width="50%" src="/resources/img/volume-2/3.2-Key-formats-in-Bitcoin/Figure-3.21-Private-key-presentation-in-hex-encoding.png" alt="Рисунок 3.22 – Представление личного ключа в WIF"/> 

Последним из форматов личных ключей рассмотрим зашифрованный личный ключ. Общей и основной проблемой всех предыдущих форматов является хранение личных ключей в открытом виде. Соответственно, открытым остается очень важный вопрос о безопасности хранения личного ключа, который обеспечивает полный доступ к монетам пользователя. Поэтому разработчики BIP38 предложили ввести новый формат кодирования личных ключей – так называемый зашифрованный личный ключ [50]. Он позволяет сделать резервную копию личного ключа либо перенести его в другой кошелек или в другую систему, причем сделать это защищенным способом.

Здесь используется специальный алгоритм шифрования, который на вход принимает личный ключ и парольную фразу, известную только пользователю. Обычно в этом случае личный ключ представлен в формате WIF, но применяется и любой другой формат. При помощи парольной фразы личный ключ зашифровывается, и выходные данные кодируются при помощи Base58Check. При этом версионный байт подобран так, чтобы выходная строка начиналась с «6P» (рис. 3.23).

<img width="50%" src="/resources/img/volume-2/3.2-Key-formats-in-Bitcoin/Figure-3.23-Encrypted-private-key.png" alt="Рисунок 3.23 – Представление личного ключа в зашифрованном виде"/> 

Если пользователь увидит какие-либо данные, которые имеют отношение к Bitcoin и начинаются на «6P», вероятнее всего, это будет зашифрованный личный ключ. Чтобы его использовать, нужно знать парольную фразу, которой он зашифрован.

Расшифровать зашифрованный личный ключ можно в обратном порядке. Для этого пользователю достаточно ввести зашифрованные данные в свой кошелек (большинство кошельков поддерживает расшифрование ключа в этом формате), а после нужно ввести парольную фразу (passphrase). Кошелек расшифровывает личный ключ и выдаст его пользователю в открытом виде, доступном для применения.

Выше были рассмотрены форматы личных ключей. Теперь перейдем к форматам открытых ключей.

### Форматы открытых ключей

Открытые ключи используются преимущественно в программном обеспечении. Конечные пользователи обычно не оперируют открытым ключом, ибо если вы пользователь Биткоина, в зависимости от целей, вам будет удобно пользоваться либо личным ключом, либо bitcoin-адресом, а открытый ключ – это промежуточное звено.

Выделяют два формата открытых ключей: hex и hex-compressed (сжатый вариант hex). Аналогично личному ключу hex – это запись открытого ключа в шестнадцатеричной системе счисления. Единственное отличие состоит в том, что здесь используется немного другая схема, чтобы отличать сжатый открытый ключ от обычного, – добавляется специальный префикс. В случае обычного открытого ключа добавляется префикс «04», в случае сжатого добавляется один из префиксов: «02» или «03» (рис. 3.24).

<img width="50%" src="/resources/img/volume-2/3.2-Key-formats-in-Bitcoin/Figure-3.24-Public-key-in-compressed-and-uncompressed-forms.png" alt="Рисунок 3.24 – Открытый ключ в сжатом и несжатом виде"/> 

Почему этих префиксов два? Наличие двух префиксов для сжатого варианта открытого ключа обусловлено тем, что координата Y может быть положительной или отрицательной. Соответственно, префикс «02» указывает на положительную Y, а префикс «03» – на отрицательную.

**Часто задаваемые вопросы**

*– Какой алгоритм шифрования личного ключа используется в BIP38?*

Используется алгоритм AES в режиме Cipher Block Chaining (CBC), где применяется личный ключ длиной 256 бит. Подробнее об этом можно прочитать непосредственно в BIP38 [24].

*– В одном кошельке может быть много bitcoin-адресов и много личных ключей, значит ли это, что нужно экспортировать и импортировать все их по отдельности?*

Существует три варианта импорта/экспорта личных ключей: по отдельности, списком и импорт/экспорт основного секрета в случае иерархического порождения ключей. Если ключи не связаны между собой (каждый из них генерировался отдельно), то перенос их на другое устройство возможен только по отдельности либо набором. Однако если используется иерархическое порождение, то после переноса основного секрета все ключи могут быть локально порождены из него и восстановлены.

*– Какие еще существуют форматы личного ключа?*

Помимо перечисленных в данном разделе, существуют также мини-ключи и иерархические ключи. Первый формат генерируется определенным образом для того, чтобы получить ключ длиной в 30 символов. Главное его применение – QR-коды и физические монеты, как, например, Casascius. Принцип генерации иерархических ключей заключается в том, что используется определенное значение (основной секрет кошелька), из которого порождаются все используемые личные ключи. Преимущество этого метода в том, что достаточно сделать резервную копию основного секрета, из которого можно восстановить остальные ключи.

## 3.3 Форматы сериализации транзакций и блоков в Bitcoin

Bitcoin-транзакции передаются между узлами в сериализованном виде (_raw format_), а именно в виде байтовой последовательности данных. Эта последовательность также используется для хэширования и дальнейшего получения идентификатора транзакции. Поэтому, для корректной обработки транзакций и блоков узлами сети, существует строгий порядок для их сериализации.

Очень часто пользователь видит транзакцию уже в человекочитаемом виде (преобразованную обозревателем цепочки блоков или bitcoin-кошельком). В этом разделе мы научим вас читать сериализованные транзакции и блоки с одного взгляда, понимать, в каком виде они передаются по сети и каким образом обрабатываются узлами.

### Сериализация bitcoin-транзакции

Для лучшего восприятия предлагаем сразу начать с примера и рассмотреть сериализованную транзакцию, которая действительно была подтверждена в сети Bitcoin. Для начала давайте представим ее в JSON формате (рис. 3.25) [25].

<img width="40%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.25-JSON-Bitcoin-Transaction.png" alt="Рисунок 3.25 – Bitcoin-транзакция в формате JSON"/> 

В первой части учебного пособия мы уже рассматривали поля транзакции в таком виде. Теперь же рассмотрим как та же самая транзакция представлена в сериализованном виде (рис. 3.26) и где находится соответствующая информация [26].

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.26-Serialized-transaction.png" alt="Figure 3.26 – Serialized transaction"/> 

Первые четыре байта определяют версию протокола Bitcoin, согласно которой была составлена транзакция. 

Далее следует байт, в котором указывается количество входов транзакции. Следом за ним помещается хэш-значение предыдущей транзакции (откуда были получены монеты). Это значение занимает 32 байта (рис. 3.27).

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.27-Number-of-inputs-and-link-to-the-previous-transaction.png" alt="Рисунок 3.27 – Количество входов и ссылка на предыдущую транзакцию"/> 

Следующие 4 байта отвечают за индекс выхода предыдущей транзакции (рис. 3.28). В данном случае «00000000» означают, что индекс предыдущего выхода равен нулю.

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.28-The-output-index-of-the-previous-transaction.png" alt="Рисунок 3.28 – Индекс выхода предыдущей транзакции"/> 

Далее следует байт, который указывает на размер scriptSig, то есть доказательства владения монетами. В данном случае он равен «8с», то есть следующие 140 байт будут содержать в себе скрипт доказательства владения монетами (рис. 3.29 – А).

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.29-А-ScriptSig-value-of-the-transaction.png" alt="Рисунок 3.29 – А – Значение ScriptSig транзакции"/> 

Рассмотрим детальнее, что содержится в этих 140 байтах (рис. 3.29 – Б). Их можно разделить на 4 части. Первая часть состоит из одного байта «49» и обозначает операцию «OP_PUSHDATA(73)», которая помещает в стек 73 байта данных, которые будут следовать за этой операцией. Это будут данные цифровой подписи транзакции. После значения подписи следует байт «41» – операция «OP_PUSHDATA(65)», за которой следуют 65 байт значения открытого ключа.

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.29-B-The-detailed-script.png" alt="Рисунок 3.29 – Б – Детальное значение скрипта"/> 

Далее следуют 4 байта, в которых находится значение sequence (рис. 3.30). Напомним, что это значение используется для обозначения версии входа, который тратит один и тот же выход (это актуально для работы механизма _replace-by-fee_). По умолчанию это значение состоит из «ffffffff» и уменьшается с каждой следующей версией входа (соответственно с каждым следующим вариантом данной транзакции).

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.30-Sequence.png" alt="Рисунок 3.30 – Значение sequence"/> 

За этим значением следует байт, который обозначает количество выходов транзакции. В нашем случае это «01», что означает, что транзакция имеет ровно один выход. Затем указывается сумма перевода, под которую выделено 8 байт (рис. 3.31). Данная транзакция переводит 0.01 BTC (если точнее 999938 satoshi).

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.31-Number-of-Outputs-and-Transfer-Amount.png" alt="Рисунок 3.31 – Количество выходов и сумма перевода"/> 

Далее в теле транзакции находится байт, который указывает на размер scriptPubKey (условия траты монет). В нашем случае он равен «19» (рис. 3.32 – А), то есть размер условий равен 25 байтам.

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.32-А-ScriptPubKey-Size.png" alt="Рисунок 3.32 – А – Размер scriptPubKey"/> 

Рассмотрим, что находится в условиях траты монет. Данные можно разделить на 6 частей, как на рисунке 3.32 – Б. Байт «76» обозначает операцию «OP_DUP», то есть дублирование верхнего значения стека (открытый ключ пользователя). Далее байт «a9» указывает на операцию «OP_HASH», то есть вычисление адреса из открытого ключа. После этого байт «14» отвечает за операцию «OP_PUSHDATA(20)», которая помещает следующие 20 байт (адрес получателя) в стек. Далее выполняется операция «OP_EQUAL» (байт «88»), после чего выполняется проверка цифровой подписи – «OP_CHECKSIG», которой соответствует байт «ac».

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.32-B-Coins-Spending-Conditions.png" alt="Рисунок 3.32 – Б – Условия траты монет"/> 

Последние четыре байта транзакции «00000000» – это relative lockTime, равный нулю (рис. 3.33).

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.33-Relative-lockTime.png" alt="Рисунок 3.33 – Значение relative lockTime"/> 

### Сериализация блока в Bitcoin

Теперь перейдем к сериализации блока Bitcoin. Для этого возьмем блок, который содержит рассмотренную выше транзакцию. Сериализованный блок изображен на рисунке 3.34 [27].

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.34-Serialized-block.png" alt="Рисунок 3.34 – Блок в сериализованном виде"/> 

Выглядит сложно, однако стоит отметить, что этот блок содержит 4 транзакции, которые также включены в сериализованное значение. Эти транзакции изображены на рисунке 3.35.

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.35-Placement-of-Transactions-in-a-transaction-block-in-a-block.png" alt="Рисунок 3.35 – Размещение транзакций в блоке"/> 

Так как мы уже рассмотрели формат сериализации транзакции, то, фактически, остается рассмотреть, что скрывается за следующим фрагментом (рис. 3.36).

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.36-Serialized-Bitcoin-Block-Header.png" alt="Рисунок 3.36 – Заголовок блока Bitcoin в сериализованном виде"/> 

Первые 4 байта также являются значением версии протокола, по правилам которого был сформирован блок. В нашем случае это версия «1» (рис. 3.37), которая поддерживалась с момента genesis block до сентября 2012 года (Bitcoin Core 0.7.0). Последней на текущий момент версией протокола является версия 4, которая была введена с ноября 2015. Далее находится 256-битное хэш-значение предыдущего блока.

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.37-Hash-value-of-the-previous-block.png" alt="Рисунок 3.37 – Хэш-значение предыдущего блока"/> 

После этого находится 256 битное значение Merkle Root от всех идентификаторов транзакций (рис. 3.38). Отметим, что при формировании блока в качестве первой транзакции всегда используется coinbase транзакция, остальные могут располагаться в случайном порядке; единственное требование – то, чтобы входы были расположены ниже выходов, которые они тратят.

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.38-Merkle-root-value.png" alt="Figure 3.38 – Merkle root value"/> 

Следующее значение в блоке – это метка времени его формирования в Unix-формате (рис. 3.39), состоящее из четырех байтов.

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.39-Block-Formation-Unix-Timestamp.png" alt="Рисунок 3.39 – Unix timestamp формирования блока"/> 

Далее следуют два значения: первое из них – параметр difficulty, который определяет сложность решения текущей задачи proof-of-work; второе – nonce как доказательство решения этой задачи. Последнее значение определяет количество транзакций в блоке (рис. 3.40).

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.40-The-difficulty-parameter-nonce-value-and-the-number-of-transactions-in-the-block.png" alt="Рисунок 3.40 – Параметр difficulty, значение nonce и количество транзакций в блоке"/> 

## 3.4 Обмен сообщениями между узлами сети Bitcoin

Архитектура сети Bitcoin предусматривает одноранговую сеть, каждый узел которой равноправен и самодостаточен. На взаимодействие узлов сети Bitcoin так же, как и на другие процессы этой системы, не накладываются дополнительные ограничения. Консенсус достигается независимыми участниками, а обмен сообщениями между ними аналогично независим и децентрализован. Каждый участник сети сам решает, на основании какого блока строить дальнейшую историю, равно как сетевые узлы самостоятельно решают, с какими узлами общаться и как обрабатывать полученную информацию.

В первой части учебного пособия мы уже рассматривали важные моменты устройства Bitcoin-сети и роль узлов в ее функционировании. В этом подразделе мы рассмотрим технические детали взаимодействия узлов между собой, а именно: каким образом происходит обмен сообщениями между участниками сети Bitcoin. Также охарактеризуем состояние сети Bitcoin по данным на сентябрь 2019 года, рассмотрим протоколы распространения информации, требования к ним, проблемные вопросы таких протоколов и возможные пути решения.

### Роли узлов в сети Bitcoin

Ранее мы уже определяли, что узлы можно условно разделить на три группы:

> * _Полный узел сети (аудитор)_
> * _Validator node_
> * _SPV-node_

Теперь постараемся немного расширить классификацию, опираясь на функции, которые могут реализовать узлы сети. Каждый Bitcoin-узел может состоять из ряда модулей, различных по выполняемым функциям.

> * _Модуль, выполняющий хранение всей истории транзакций_
> * _Модуль, выполняющий верификацию транзакций_
> * _Модуль, ответственный за общение с другими узлами сети_
> * _Модуль, формирующий proof-of-work для майнинга_
> * _Модуль, который реализует пользовательский кошелек_

Примером узла, содержащего все модули, является ПК отдельного пользователя с реализацией Bitcoin Core или ему подобной. Такой узел можно представить схематически на рисунке 3.41.

<img width="40%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.41-Bitcoin-Full-Node.png" alt="Рисунок 3.41 – Полный узел сети Bitcoin"/> 

Каждый из таких узлов хранит всю историю транзакций, поэтому они могут автономно верифицировать последующие блоки в цепочке, без необходимости доверять третьей стороне как источнику данных. Такие узлы участвуют в достижении консенсуса, то есть наравне со всеми такими же узлами участвуют в принятии решений по подтверждению транзакций. Наличие модуля сетевого взаимодействия позволяет таким узлам общаться непосредственно с остальными участниками системы, а модуль кошелька использует локальную копию базы данных для обработки требуемых транзакций.

Второй тип – узлы, которые поддерживают сеть Bitcoin и участвуют в принятии решений, фактически являясь узлами-валидаторами, но у них может отсутствовать модуль кошелька (рис. 3.42).

<img width="40%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.42-Bitcoin-Validator-Node.png" alt="Рисунок 3.42 – Узел-валидатор в Bitcoin"/> 

Третьим типом является узел-аудитор. Такой узел обязательно содержит два модуля: модуль хранения всей истории транзакций и сетевой модуль, позволяющий ему полноценно обмениваться сообщениями с другими узлами для получения актуального состояния цепочки блоков. Такой тип узлов нашел применение у бирж и обозревателей учетных систем. Такой узел поддерживает сеть Bitcoin, так как хранит локальную версию цепочки блоков. Однако если у узла отсутствует модуль, позволяющий создавать блоки, такой узел не принимает участие в достижении консенсуса (рис. 3.43).

<img width="40%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.43-Auditor-Node.png" alt="Рисунок 3.43 – Узел-аудитор"/> 

Следующим типом узлов, имеющих тоже два модуля (но на этот раз модуль кошелька и сетевой модуль), является SPV-узел. Мы рассматривали принцип функционирования такого узла ранее (в подразделе 2.3 первой части учебного пособия). Такой узел не имеет собственной истории транзакций, а хранит только заголовки блоков (полученные от полных узлов либо других SPV-узлов). Но при этом он лично обращается к полным узлам, и исходя из полученных значений Merkle Branch, может определить: действительно ли конкретная транзакция была добавлена в цепочку блоков. Схематически место SPV-узла в сети Bitcoin можно изобразить на рисунке 3.44.

<img width="40%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.44-Bitcoin-SPV-node.png" alt="Рисунок 3.44 – SPV-узел в сети Bitcoin"/> 

Выделяют еще два элемента инфраструктуры Bitcoin, которые фактически не являются узлами, так как не поддерживают сеть и не принимают непосредственного участия в достижении консенсуса. Первый тип – кошелек, использующий доверенный узел. Из названия следует, что такой элемент сети имеет только модуль кошелька. Он связывается с конкретными полными узлами сети (очень часто только с одним) и получает от них все данные о транзакциях, связанных с адресами пользователя (рис. 3.45). Однако он не хранит историю всех транзакций и не выполняет верификацию.

<img width="50%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.45-Digital-Wallet-Connected-to-the-Network.png" alt="Рисунок 3.45 – Цифровой кошелек с подключением к сети"/> 

Второй тип представляют из себя узлы, которые содержат только модуль, который выполняет решение ресурсоемкой задачи, то есть занимается майнингом. Такие узлы получают задачу от полного узла (mining pool leader) и занимаются формированием proof-of-work, с дальнейшей его отправкой полному узлу в случае успеха. Такие узлы являются участниками mining pool (его клиентами), а владелец узла-валидатора является его оператором (рис. 3.46).

<img width="35%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.46-Mining-pool-structure.png" alt="Рисунок 3.46 – Структура mining pool"/> 

> **_Замечание._** *По оценкам, сделанным в апреле 2019 года, Bitcoin использует более 30 миллионов пользователей. Количество полных узлов, в то же время, – около 9,5 тысяч (более трех тысяч пользователей на один полный узел). Кстати, количество интернет-провайдеров в мире тоже близится к отметке 10 тысяч, при более чем 3,9 млрд активных пользователей.* 

В двух последних типах узлов отсутствовал модуль, отвечающий за обмен сообщениями в Bitcoin-сети. Далее мы рассмотрим функционирование именно этого модуля, а значит в контексте будут использоваться понятия полного узла и SPV-узла.

### Текущее состояние сети Bitcoin 

Условно в сети Bitcoin выделяют два вида узлов: публичные и приватные. Публичный узел (_public-IP node_) является общедоступным т. е. не требует разрешения на подключение к нему. ПО такого узла «слушает» порт в глобальной сети Интернет и принимает запросы на подключение. Публичные узлы помогают новым участникам найти к кому присоединиться. Если будет достаточно малое количество публичных узлов, то новым участникам будет сложно найти к кому присоединиться и в итоге сеть не сможет расти или вообще распадется на подсети.

Приватный узел (_private-IP node_) присоединяется к другим публичным узлам, но сам не принимает входящих соединений. Приватного узла достаточно для того чтобы проводить аудит учетной системы, отправлять свои транзакции и в общем поддерживать полную функциональность цифрового кошелька (рис. 3.47).

<img width="40%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.47-Bitcoin-network-structure.png" alt="Рисунок 3.47 – Структура Bitcoin-сети"/> 

На практике же видов узлов больше, ввиду особенностей организации подсетей. Например, существует подсеть соединенных между собой университетов, доступ к которой имеют только они. Такие университеты могут запускать публичные узлы, но только для своей частной подсети, а присоединяться к глобальной сети только через приватные узлы.

> **_Замечание._** *Далее мы будем использовать только понятия публичного и приватного узлов, так как. это самые распространенные виды.*

В ПО узла сети Bitcoin по умолчанию заложены ограничения на количество сетевых соединений с другими узлами:

* каждый узел стремится создать 8 исходящих (outbound) соединений, т. е. узел сети при запуске находит 8 узлов и соединяется с ними;
* публичные узлы допускают до 117 входящих (inbound) соединений.

Значения 8 и 117 Сатоши Накамото выбрал как компромисс между надежной связностью сети и оптимальной сетевой нагрузкой. Высокая связность позволяет сделать сеть более безопасной. Например, если бы узлы присоединялись к одному узлу вместо восьми, то была бы высокой вероятность ситуаций, когда злоумышленники создавали бы узлы, передающие ложные данные о состоянии системы, и проводили бы разного рода атаки. С другой стороны, если узлы присоединялись бы не к 8, а допустим к 1000 других узлов, то каждому приходилось бы хранить состояние этих подключений. А это, в свою очередь, влечет большие затраты памяти на хранение данных об активности узла, этапы передачи сообщений и т. д. Кроме того, если узел имеет 1000 сетевых соединений, то помимо хранения данных о состояниях этих соединений, ему также необходимо по каждому из них синхронизировать новые транзакции, блоки, а также отвечать на входящие запросы, что в результате создает большие потоки трафика.

По оценкам на апрель 2019 года, общее количество активных узлов в сети Bitcoin (приватные и публичные) варьируется от 60 до 100 тысяч узлов и при этом последняя версия Bitcoin 0.17 запущена только на трети узлов, на другой трети узлов запущена предыдущая версия Bitcoin 0.16, и оставшаяся часть – это еще более старые версии и альтернативные имплементации протокола (рис. 3.48) [28].

<img width="50%" alt="Рисунок 3.48 – Использования версий протокола по состоянию на сентябрь 2019 года" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.48-Using-protocol-version-(September-2019).png"/> 

Если проанализировать количество публичных узлов, то можно заметить, что из 60-100 тысяч узлов в сети на сегодняшний день только 10 тысяч являются публичными. Следовательно, соотношение публичных узлов к остальным равно примерно 1/8. Данное соотношение обусловлено упомянутыми выше двумя значениями 8 и 117 потому, что этим 10-ти тысячам публичных узлов нужно обслуживать около 80 тысяч приватных узлов. Поэтому и выбрано число 117, которое позволяет сохранить целостность сети в таких условиях. Карта на рисунке 3.49 показывает, что публичные узлы доступны в разных странах по всему миру [29].

<img width="50%" alt="Рисунок 3.49 – Карта концентрации доступных Bitcoin-узлов по всему миру" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.49-Concentration-map-of-available-Bitcoin-Nodes-around-the-world.png"/> 

### Структура сообщений в Bitcoin

Рассмотрим структуру сообщений, которыми участники сети Bitcoin обмениваются друг с другом. Все сообщения в Bitcoin имеют структуру, приведенную в таблице 3.1.

Таблица 3.1.
<img width="50%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Table-3.1.png" alt="Таблица 3.1."/> 

Одно из самых главных сообщений, без которых узлы сети не могут начать полноценное взаимодействие – это _version_ сообщение. Узлы обмениваются _version_ сообщением или handshake, когда в первый раз соединяются друг с другом. Сообщение имеет приведенную в таблице 3.2 структуру.

Таблица 3.2.
<img width="50%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Table-3.2..png" alt="Таблица 3.2."/> 

### Протокол распространения информации

Распространение информации является основной задачей сети Bitcoin, для выполнения которой нужны системные сообщения. Таким образом в сети Bitcoin используется 27 видов сообщений, основные из которых приведены на рисунке 3.50 [31].

<img width="20%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.50-The-main-Types-of-Messages-on-the-Bitcoin-Network.png" alt="Рисунок 3.50 – Основные виды сообщений в сети Bitcoin"/> 

В данном перечне можно заметить, что большинство сообщений, связанных с передачей транзакции (inv, tx, getdata), преимущественно используют трафик, а например сообщения, проверяющие в сети ли ваш узел (ping, pong), потребляют лишь малую часть всего трафика.

### Начало работы узла в сети Bitcoin

Узел сети, который запускается впервые и начинает взаимодействие с другими узлами сети, проходит следующие этапы:

> * _Отправка запроса DNS-серверу (поддерживаются членами сообщества), чтобы получить сетевые адреса активных узлов в сети_
> * _Подключение к узлам_
> * _Загрузка истории транзакций (initial blocks downloading)_
> * _Обмен блоками и транзакциями с узлами_

На первом шагу узлу необходимо послать запрос на один из DNS серверов, которые поддерживаются разработчиками ядра Bitcoin и членами сообщества и хранят базу данных о существующих активных узлах (сетевые адреса этих серверов вшиты в ПО узла). 

После запроса на DNS сервер узел узнает IP-адреса узлов, к которым он может подключиться. Далее он подключается к этим узлам и происходит протокол сверки версий. 

Затем новому узлу нужно запросить и скачать все блоки из уже существующей цепочки блоков. Для этого используется метод _Initial Block Download_, т. е. первоначальное скачивание блоков. После того как существующие блоки синхронизированы, новый узел начинает принимать полное участие в протоколе передачи данных по сети – обмениваться новыми блоками и транзакциями с другими узлами.

### Протокол распространения информации Flooding

Для передачи блоков и транзакций по сети Bitcoin используется модификация протокола Flooding [32]. Согласно этому протоколу узлы передают новые/полученные блоки и транзакции всем своим узлам, кроме тех, которые об этих блоках и транзакциях уже знают (рис. 3.51). 

<img width="30%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.51-General-Flooding-Protocol.png" alt="Рисунок 3.51 – Общая схема работы протокола Flooding"/> 

Для экономии трафика используют протокол состоящий из трех сообщений. Его суть состоит в том, что как только узел получает новую транзакцию или блок, он отправляет хэш этого объекта INV(hash(tx)) другим узлам, с которыми имеет соединение. Каждый узел обращается к своей локальной базе данных для проверки наличия в ней этого хэша; если не находит, то запрашивает у узла GETDATA(hash(tx)) нужный блок или транзакцию, соответствующую полученному хэшу. Узел, получив данный запрос, отправляет в ответ полный блок или полную транзакцию. Благодаря данной модификации с тремя сообщениями можно избежать повторного получения имеющейся транзакции или блока, а так как размер каждой транзакции обычно составляет 150–500 байт, то достигается существенная экономия сетевого трафика. Схематически рассмотрим пример распространения транзакции в сети Bitcoin на рисунке 3.52.

<img width="40%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.52-Network-Transaction-Distribution-Example.png" alt="Рисунок 3.52 – Пример распространения транзакции по сети"/> 

Допустим, узел А получил транзакцию tx с мобильного клиента и собирается ею поделиться с узлами B, C и D. У этих узлов нет этой транзакции, поэтому они они получат ее в момент времени t1. В момент времени t2 узел В попробует отправить эту транзакцию узлу С, но так как узел С уже располагает данной транзакцией, то он не запросит полную версию этой транзакции, и поэтому транзакция не будет передана по этому соединению. Узлы Е и G не знают об этой транзакции, и поэтому в ответ на сообщение о новой транзакции они ее запросят и получат в рамках момента времени t2. Данный процесс продолжается до тех пор, пока все узлы сети не будут иметь данную транзакцию.

### Diffusion – расширение Flooding

На самом деле Bitcoin использует протокол Diffusion [32] для передачи транзакций, который является расширением протокола Flooding. Согласно этому протоколу каждый узел в сети, получив новую транзакцию, не будет отправлять ее сразу, а будет ждать в течение случайного промежутка времени от 0 до 5 секунд. Таким образом, узел аккумулирует транзакции, прежде чем распространять их дальше. Это помогает экономить трафик, связанный с заголовками сообщений, усложнить шпионаж, связанный с прослеживанием времени, в момент которого получена транзакция, и избежать коллизий «на лету» (когда два узла одновременно отправляют друг-другу одну транзакцию).

Существует несколько сложностей, связанных с протоколами передачи данных в сети Bitcoin.

> * _Соблюдение анонимности пользователей_
> * _Устойчивость к атакам разного род_
> * _Требования к мощности оборудования и пропускной способности_
> * _Время распространения данных по сети_

Далее мы рассмотрим, каким образом решается каждая из перечисленных проблем.

### Примеры проблем в протоколах и их решения

Рассмотрим проблему анонимности. Ее можно сформулировать таким образом: как сделать невозможным (или очень дорогим) определение происхождения транзакций в сети, т. е. как сделать невозможным связывание определенной транзакции в сети Bitcoin и сетевого адреса узла, с которого она начала распространение по сети?

Ниже на схеме (рис. 3.53) можно заметить, что _supernode_ – это узел, который подсоединен ко всем узлам в сети. По моменту времени, в который этот узел впервые узнает о транзакции от других узлов, он может определить ее источник. Таким образом, _supernode_ может связать эту транзакцию с определенным IP-адресом.

<img width="30%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.53-Transaction-Source-Disclosure-Example.png" alt="Рисунок 3.53 – Пример раскрытия источника транзакции"/> 

Чтобы противодействовать таким атакам, был предложен протокол Dandelion [32], потом Dandelion++ [33]. Рассмотрим, как действует данный протокол.

Данный протокол распространяет транзакции по сети в двух фазах: 

> _Анонимная фаза (stem phase)_ – каждый узел отправляет транзакцию только одному из связанных с ним узлов.

> _Фаза распространения (fluff phase)_ – каждый узел транслирует транзакцию в сеть передавая ее всем связанным с ним узлам.

Каждый узел с вероятностью 0.9 распространяет транзакцию в анонимной фазе и с вероятностью 0.1 в фазе распространения(рис. 3.54). В итоге получается, что транзакция идет по одному пути до момента, когда она начинает распространяться. Таким образом, существует 10% вероятности, что транзакция начнет распространяться с нулевого узла, 10% – что с первого, 10% – что со второго, и т. д. Следовательно, определить настоящий источник транзакции становится очень сложно. В среднем через 10 таких скачков от одного узла к другому транзакция распространяется при помощи обычного протокола Flooding.

<img width="50%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.54-Dundelion++Protocol.png" alt="Рисунок 3.54 – Протокол Dundelion++"/> 

Теперь рассмотрим проблемы безопасности в сети Bitcoin. Одной из основных задач обеспечения безопасности состоит в том, чтобы повысить стоимость осуществления атаки до уровня, когда она становится экономически невыгодной. В качестве примера рассмотрим Eclipse attack.

Сценарий этой атаки подразумевает, что узлы, подконтрольные атакующему, изолируют честные узлы от общей сети Bitcoin и транслируют им ложное состояние базы данных.

Поскольку честные узлы присоединены только к узлам атакующего, то у них нет шансов узнать о блоках, которые являются частью настоящей цепи, если атакующий будет показывать им только блоки, которые он сформировал сам (рис. 3.55). Таким образом можно осуществлять двойную трату и некоторые другие атаки.

<img width="30%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.55-Eclipse-attack.png" alt="Рисунок 3.55 – Eclipse атака"/> 

В качестве противодействия этой атаке сами ее авторы предложили несколько способов модификации протокола, например, диверсификация соединений по IP (подключаться к разным регионам). Таким образом, если у каждого узла есть 8 исходящих соединений, то атакующему нужно будет владеть очень большим количеством узлов в сети, причем из разных частей мира, что делает атаку намного дороже для исполнения.

Теперь рассмотрим проблему потребления ресурсов. Как снизить требования к оборудованию и трафику полного узла Bitcoin? Один из основных принципов Bitcoin – это его доступность как для машин с большой вычислительной мощностью, так и для машин с низкой. Поэтому очень важно разрабатывать Bitcoin таким образом, чтобы он сохранял свою работоспособность, чрезмерно не нагружал глобальную сеть и не требовал дорогого оборудования для поддержания узлов. Примером проблемы в данном контексте являются ситуации в которых узлы, которые находятся ближе (по сети) к узлам-валидаторам, получают новые блоки раньше остальных. Как только блоки получены и верифицированы, узлы сразу же должны отправить данный блок всем своим соседним узлам. Так как большинство соседних узлов не слышало об этом блоке, они отправят запрос на его получение, и таким образом будут наблюдать скачок в потреблении трафика.

Скачок в потреблении трафика приводит к сложностям с интернет-соединением, так как в один момент времени требуется задействовать очень большую часть пропускной способности. В качестве решения этой проблемы был сформирован BIP 152: Compact Block Relay (Matt Corallo) [34]. Давайте рассмотрим, как работает это предложение.

Вместо одного протокола передачи блоков в сети, их будет три и они будут использоваться в зависимости от контекста.

Сначала рассмотрим Legacy Relaying (рис. 3.56 – A), т. е. старый способ распространения блоков. Узел А получает новый блок, валидирует его и отправляет заголовки (headers of inv) узлу В. Так как у узла В нет этого блока, он запросит его данные (getdata) и узел А ответит ему содержанием полного блока (block).

Далее появилось два новых вида запуска этого протокола, а именно High Bandwidth Relaying (с высоким потреблением трафика) и Low Bandwidth Relaying (с низким потреблением трафика).

<img width="45%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.56-Compact-Block-Relay.png" alt="Рисунок 3.56 – Compact Block Relay"/> 

Теперь рассмотрим новые виды протокола: High Bandwidth Relaying и Low Bandwidth Relaying. В каждом из данных видов протокола предполагается, что первым делом узел В должен сообщить узлу А, по какому типу этого протокола они будут работать. В случае с высоким потреблением трафика узел В сообщает узлу А (sendcmpct(1)), в случае же с низким узел В сообщает – (sendcmpct(0)).

Рассмотрим High Bandwidth Relaying (рис. 3.56 – В). Узел В сообщает узлу А, что они будут работать по типу протокола с высоким потреблением трафика (sendcmpct(1)). Работая по этому типу протокола узел А, получив блок, не выполняет его полную верификацию, а только проверку его заголовка. Далее узел А анонсирует этот блок узлу В и пробует предсказать на основе предыдущих передач данных, каких транзакций недостает узлу В (cmpctblock). После этого узел В, сверив этот блок с тем, что у него есть, запрашивает транзакции, которые ему необходимы (getblocktxn), и уже после полной верификации блока узел А отправляет оставшиеся транзакции узлу В.

Рассмотрим Low Bandwidth Relaying (рис. 3.56 – С). Узел В сообщает узлу А, что они будут работать по типу протокола с низким потреблением трафика (sendcmpct(0)). В этом же случае узел А анонсирует блок узлу В только после полной верификации этого блока.

Теперь рассмотрим проблемы быстрого распространения данных по сети. Как распространять по сети транзакции и блоки максимально быстро? Вопрос состоит в том, что быстрое распространение блоков и транзакций по сети действительно очень важно. Например, чем медленнее распространяются блоки, тем выше становится Orphan rate (число блоков, которые пришлось отбросить из основной цепочки потому, что они были созданы не на основе последнего известного блока). В результате таких задержек повышается объем бесполезно выполненной работы (proof-of-work), который снижает уровень безопасности учетной системы.

В качестве решения этой проблемы было предложено организовать дополнительную сеть – Bitcoin FIBRE [35]. В этой сети будут находиться только узлы-валидаторы и, в первую очередь, они обмениваются блоками в данной сети. Это позволяет обеспечить низкий Orphan rate.

**Часто задаваемые вопросы**

*– Какая выгода от запуска полного узла Bitcoin?*

В некоторых случаях использование доверенного узла или SPV-узла недостаточно и нужно запускать полный узел. Например, если вы хотите просто обеспечить максимальную защиту своих средств от атак, то вам нужен полный узел (достаточно приватного узла, который не принимает входящие соединения). Это нужно, чтобы самостоятельно проверять всю историю транзакций и PoW, следить за альтернативными ветвями цепочки блоков и своевременно переключаться на последнее актуальное состояние сети. Быть уверенным в достоверности выполнения этих процессов невозможно, если вы используете для этого сторонний источник. Если вы хотите помочь сети (сделать ее более связной и надежной), вы можете запустить публичный узел. Тогда другие узлы смогут присоединиться к вам (что увеличит общее количество соединений вашего узла), это поможет сети расти, а все описанные преимущества приватного узла также будут доступны.

*– Почему нельзя структурировать сеть Bitcoin (например, топология «звезда»)?*

Топология «звезда» предполагает наличие центрального компьютера, к которому присоединяются все остальные. Так как Bitcoin нацелен на децентрализацию учетной системы и минимизацию необходимого уровня доверия, то его топология должна быть распределенной (близкой к случайному графу). В топологии «звезда» потенциально уязвимым будет центральный узел, который при повреждении или атаке угрожает работоспособности всей системы. 

*– Почему нежелательно раскрывать топологию сети?*

Существует мнение среди разработчиков протокола Bitcoin, что известная топология сети делает ее более уязвимой к ряду сетевых атак. Например, если кто-то узнает, что в сети есть узкое горлышко (bottleneck), вариант, когда сеть разбита на два подмножества узлов, которые соединены только одним подключением, то атакующий, получив контроль над двумя целевыми узлами, может нарушить процесс достижения консенсуса и реализовать double-spending или подобные атаки.

*– Почему нельзя распространять только блоки (без отдельной передачи транзакций)?*

Несколько лет назад в Bitcoin был предложен опциональный режим работы _blocks-only_. Данный режим позволяет узлу не слушать новые транзакции, а слушать только уже созданные валидаторами блоки. Такая опция актуальна для узлов, которые намерены экономить свой трафик. Если же все узлы в сети будут использовать данную опцию, то мы будем наблюдать скачки в потреблении трафика публичных узлов, которые передают всем остальным новый блок целиком. Но наибольшая проблема этой ситуации состоит в том, что новые транзакции не смогут добраться до узлов-валидаторов, чтобы получить подтверждения. Тогда для передачи транзакции приходилось бы цифровой кошелек напрямую подключать к узлу-валидатору.

*– Шифруется ли трафик, который производят узлы?*

Нет, не шифруется. Данный вопрос был предметом дискуссий на протяжении последних нескольких лет. Был предложен протокол шифрования трафика, который помог бы, например, скрыть от провайдеров факт того, что вы пользуетесь Bitcoin. Сейчас ваш интернет-провайдер или администратор вашего роутера может увидеть, что вы пользуетесь Bitcoin и, возможно, даже определить какие из транзакций в сети ваши, а какие нет. Считается, что это раскрывает часть идентичности владельцев узлов, поэтому в данный момент активно ведутся разработки новых альтернативных протоколов шифрования каналов, которые будут работать в этой специфической среде.

*– Какой тип обновления нужен, чтобы изменить протокол обмена сообщениями?*

Ни hardfork, ни softfork не нужны, чтобы изменить эти протоколы, но нужно разрабатывать протоколы и соответствующие обновления ПО узла таким образом, чтобы они были обратно совместимы и чтобы необновленные узлы могли присоединяться к обновленным и нормально работать. Примером такого протокола является Compact Blocks Relay [34], рассмотренный выше. В нем предусмотрен обмен сообщениями со старыми узлами так же, как и с новыми.

## 3.5 Testnet и сложности обновления протокола

Testnet – это альтернативная по отношению к основной сеть узлов, которая работает по тому же протоколу, но поддерживается меньшим числом участников и выступает своеобразной «песочницей», к которой может присоединиться любой желающий для проведения тестов. Testnet имеет свой собственный genesis block, а монеты в нем отделены от монет в основной сети и не имеют никакой реальной стоимости.

Это позволяет разработчикам приложений или тестировщикам экспериментировать без необходимости проводить операции с реальными монетами и засорять основную цепочку транзакциями. Именно в testnet команда разработчиков протокола Bitcoin проводит тестирование обновлений и нового ПО, а также нагрузочные тесты сети перед введением этих обновлений в основной сети. Testnet разделяют на два вида: private testnet и public testnet.

### Testnet в Bitcoin и его предназначение

_Public testnet_ в Bitcoin работает точно так же, как и основная сеть (_mainnet_) с единственным отличием в том, что люди не придают ценности монетам этой системы. При этом пользователи могут как самостоятельно майнить тестовые монеты, так и обратиться к участникам, которые раздают небольшие доли монет желающим с целью тестирования программного обеспечения узлов, кошельков и т. п.

Помимо публичной тестовой сети, с которой могут работать все желающие, можно создать _private testnet_ (regtest, Regression Test Mode) – локальную (частную) версию Bitcoin. Этот вариант тестовой сети удобен тем, что можно быстро обновить ПО всех узлов сети и провести демонстрацию или тестирование изменений без необходимости одобрения со стороны остальных участников. У этого метода есть три основных преимущества.

> * _Отсутствие необходимости подключения к публичной сети_
> * _Полный контроль над сетью и проводимыми в ней транзакциями_
> * _Большинство параметров сети сохраняется, что позволяет самостоятельно менять тестируемые параметры или внедрять новые функции_

### Обновление протокола

В процессе обновления протокола децентрализованной системы разработчикам приходится сталкиваться с определенным сложностями. Особо сложной является ситуация, когда обновление нужно провести в permissionless системе и нельзя допустить остановки ее функционирования даже на короткий промежуток времени. Традиционные протоколы допускают наличие различных версий в сети, но, например, в Bitcoin и подобных учетных системах узлы должны обрабатывать блоки одинакового формата. Следовательно, некоторая группа участников не может свободно перейти на новую версию протокола, не учитывая версии ПО остальных узлов сети (именно в таких случаях и возникают форки).

Для внедрения любого изменения протокола нужно учесть следующие вопросы: как узлы придут к соглашению касательно новых правил, появятся ли в результате обновления уязвимости или баги и насколько безопасным будет обновленный протокол?

Причины для обновления могут быть разными, например, добавление новой функциональности, устранение известных уязвимостей или изменение ключевого правила в протоколе. На рисунке 3.57 приведена обобщенная схема обновления протокола децентрализованной системы.

<img width="60%" src="/resources/img/volume-2/3.5-Testnet-and-challenges-of-protocol-updating/Figure-3.57-Protocol-update-steps-diagram.png" alt="Рисунок 3.57 – Схема этапов обновления протокола"/> 

Процесс обновления начинается с того, что появляется новая версия протокола, которая анонсируется участникам сети. После анонса некоторая часть узлов начинает генерировать блоки уже нового формата, в то время как остальные могут оставаться на прошлой версии. При этом каждый узел принимает решение об обновлении самостоятельно. 

Спустя определенное время, все больше узлов-валидаторов начинают создавать блоки с отметкой о том, что они уже готовы перейти на новые правила. Далее узлы отслеживают, когда наберется критическая масса таких блоков и по общему правилу рассчитывают высоту блока или отметку времени в будущем, когда они переключатся на новые правила. Это должно произойти одновременно для всех узлов, тогда обновление считается активным. Напомним, что существует два вида обновления протокола – _softfork_, когда присутствует обратная совместимость, блоки более старых версий принимаются, если они не противоречат новым правилам, и _hardfork_ – более «жесткое» обновление, в котором нет обратной совместимости и все узлы должны перейти на новую версию, иначе их блоки будут отклоняться.

Для того, чтобы лучше разобраться с процессом обновления протокола, приведем пример, как это происходит в Bitcoin. Давайте определим ключевые характеристики каждого обновления и рассмотрим параметры, которые есть у каждого обновления в таблице 3.3.

Таблица 3.3
<img width="50%" src="/resources/img/volume-2/3.5-Testnet-and-challenges-of-protocol-updating/Table-3.3.png" alt="Таблица 3.3"/> 

Обновление может находиться в одном из пяти статусов (табл. 3.4).

Таблица 3.4
<img width="50%" src="/resources/img/volume-2/3.5-Testnet-and-challenges-of-protocol-updating/Table-3.4.png" alt="Таблица 3.4"/> 

Проиллюстрируем процесс детальнее при помощи схемы (рис. 3.58). Изначально обновлению присваивается статус _defined_, определяются значения _starttime_ и _timeout_. По окончании _starttime_, если прошедшее время не превышает _timeout_, обновление переходит в статус _started_. Если валидаторов, публикующих в сеть блоки с указанием новой версии, до окончания _timeout_ будет большинство, то обновление перейдет в состояние _locked-in_, после чего автоматически перейдет к _active_. В противном случае, оно будет считаться неудавшимся и перейдет в состояние _failed_.

<img width="40%" src="/resources/img/volume-2/3.5-Testnet-and-challenges-of-protocol-updating/Figure-3.58-The-life-cycle-of-updates.png" alt="Рисунок 3.58 – Жизненный цикл обновления"/> 

### Наиболее значительные обновления протокола Bitcoin

Со времени появления самой первой версии Bitcoin пережил много изменений. Давайте рассмотрим наиболее значительные из них.

_Первая версия протокола_. Версия 0.1, выпущена 8 января 2009 года. Этому событию предшествовала публикация whitepaper 1 ноября 2008 года, в котором Satoshi Nakamoto описал принципы функционирования будущей системы.

_Ограничение на размер блока в 1 МБ_. Строка кода, в которой появилось ограничение размера, была добавлена 15 июля 2010 года (версия 0.3.1 rc1). При этом неизвестно, когда было принято решение это сделать и кто участвовал в обсуждении. Главной мотивацией ограничения было снизить эффективность DDoS-атак. Однако такое строгое ограничение привело к несовместимости с предыдущими версиями, из-за чего многие владельцы узлов-валидаторов крайне негативно к нему отнеслись.

_Pay-to-Script Hash_. Добавление механизма Pay-to-Script Hash (BIP 16), который позволяет отправлять транзакции на защищенный адрес. Соответствующая первая попытка внедрения провалилась, вторая была предпринята 1 апреля 2012 года в версии 0.6.0rc2. В течение следующих нескольких месяцев 45% валидаторов, которые не обновились, продолжали производить некорректные блоки, из-за чего возникли проблемы с активацией.

_Segregated Witness_. Механизм Segregated Witness (SegWit), описанный в BIP 141, 143 и 147 [68–70], был призван оптимизировать транзакции и блоки путем вынесения подписей в отдельную структуру. Впервые SegWit был предложен в конце 2015 года, а выпуск состоялся в октябре 2016 (версия 0.13.1). Порог для активации был установлен на 95%. Однако, владельцы крупных майнинг-пулов, включая F2Pool, HaoBTC, AntPool, заявили, что поддержат обновление только в случае увеличения размера блока до 2 МБ.

### Адаптация новых версий Bitcoin среди узлов

Несмотря на то, что далеко не все обновления протокола Bitcoin были успешными, они играют крайне важную роль, внедряя новую функциональность и исправляя старые недочеты. Тем не менее, статистика показывает, что владельцы некоторых узлов крайне медленно реагируют на появление новых версий, продолжая использовать старые.

На рисунке 3.59 приведен график, который показывает историю распространения версий с апреля 2018 по апрель 2020. На графике видно, как после обновления количество узлов, поддерживающих новую версию, начинает постепенно расти [36]. 

Однако можно заметить, что даже после появления версии 0.19.1 обновились скорее узлы версии 0.18.1, в то время, как количество узлов, работающих на более старых версиях протокола, продолжает сокращаться так же постепенно, как и ранее.

<img width="50%" src="/resources/img/volume-2/3.5-Testnet-and-challenges-of-protocol-updating/Figure-3.59-Bitcoin-Version-Distribution-Timeline.png" alt="Рисунок 3.59 – График распространения версий Bitcoin по времени"/> 

Главная причина, по которой пользователи не переходят на новую версию протокола сразу же после выхода, кроется в опасениях по поводу ее безопасности и наличия уязвимостей. Владельцы узлов решают подождать в течение определенного времени, чтобы убедиться в том, что в новой версии нет критических уязвимостей.

Тем не менее, некоторые до сих пор пользуются крайне устаревшими версиями протокола, вплоть до 0.10.2 (рис. 3.60) [28].

<img width="50%" src="/resources/img/volume-2/3.5-Testnet-and-challenges-of-protocol-updating/Figure-3.60-Bitcoin-node-version-ratio.png" alt="Рисунок 3.60 – Соотношение версий узлов в Bitcoin"/> 

### Риск раскола сообщества

Любое изменение в децентрализованной учетной системе совершается только тогда, когда открытое сообщество наиболее активных пользователей достигает согласия относительно этого изменения. Проекты такого плана сложно напрямую монетизировать, поэтому очень важно наличие большого сообщества волонтеров, которые будут поддерживать работу учетной системы.

Когда в сообществе возникают споры, они обычно решаются мнением большинства. Но может случиться так, что члены сообщества не договорятся. Противоречие между сторонами увеличивается и может закончиться расколом сообщества (рис. 3.61). Примерами могут быть разделения следующих проектов:

> * _Ripple и Stellar_
> * _Ethereum и Ethereum Classic_
> * _Bitcoin и Bitcoin Cash_
> * _Monero и Monero Classic_

<img width="45%" src="/resources/img/volume-2/3.5-Testnet-and-challenges-of-protocol-updating/Figure-3.61-Accounting-system-community-split.png" alt="Рисунок 3.61 – Раскол сообщества учетной системы"/> 

Получается, что одно из самых больших преимуществ иногда может обернуться серьезным недостатком. Вместо того, чтобы работать над проблемой общими усилиями и искать пути оптимального обновления протокола, сообщество может погрязнуть в спорах и разделиться на мелкие группы, которые начинают продвигаться к своим целям.

**Часто задаваемые вопросы**

*— Могут ли злоумышленники использовать testnet, чтобы ввести пользователя в заблуждение и продать ему тестовые монеты, и как избежать этого?*

Зачастую злоумышленники пользуются невнимательностью пользователей или их желанием получить более выгодные условия покупки монет, переводя им монеты на тестовый кошелек. Чтобы не попасться на такую уловку, стоит обращать внимание на то, на какой кошелек вы собираетесь получить средства, и ни в коем случае не позволять постороннему человеку создавать кошелек за вас. Также злоумышленники могут создать multisig-кошелек и затем отправить средства на другой адрес, которым вы не владеете.

## 3.6 Основные классы атак на Bitcoin

Появление Bitcoin вызвало настоящий интерес специалистов по компьютерным наукам. Очень многие поначалу отнеслись к нему скептически, так как с одной стороны казалось, что это очередная попытка вовлечь людей в сомнительное финансовое предприятие, с другой – можно было подумать, что Биткоин просто сочетает хорошо известные стандарты криптографических схем – алгоритмы хэширования и подписи, – не предлагая ничего нового. Для криптографов это было слишком просто, а для исследователей интернет-безопасности – слишком абстрактно. Однако после 2014 года ситуация резко поменялась. Многие осознали, что Биткоин занял определенную нишу в цифровых платежах и продолжает привлекать все больше пользователей. В этот момент он стал полигоном для тестирования атак (что немаловажно – анонимным) и методов защиты децентрализованных систем. В этом подразделе мы рассмотрим основные классы атак на Биткоин и вновь обратим внимание на вопрос о том, _почему_ Bitcoin устроен именно таким, каким мы его видим.

Инженеры со всего мира на протяжении нескольких десятилетий искали способ достижения консенсуса относительно корректных транзакций в условиях полноценной децентрализации и анонимности участников. Как видим, эта задача действительно очень сложная, и именно создатель Биткоина впервые предложил эффективное решение. Собственно, за это достижение Satoshi Nakamoto был номинирован на получение Нобелевской премии [71].

Суть решения состоит в том, чтобы позволить любому желающему участвовать в формировании списка подтвержденных транзакций. Проще всего этого добиться, если участники будут обмениваться мнениями по поводу транзакций, которые они считают правильными. Однако при этом нужно надежно защититься от поддельных сообщений и перегрузки честных узлов сети поддельными данными злоумышленных узлов. Далее будут описаны детали проведения таких атак и принципы защиты от них.

### Flood-атака и механизм защиты

Сатоши Накамото предложил оригинальное решение: каждый потенциальный валидатор для получения права голоса должен предоставить доказательство выполненной работы. В этом и состоит суть алгоритма достижения консенсуса proof-of-work. Участник должен потратить некоторые ресурсы и предложить свой набор правильных транзакций, что является средством защиты от фальшивых мнений.

Применение proof-of-work для защиты от нежелательных рассылок предложил Адам Бэк (Adam Back) еще в 1997 году, тогда это было решением для защиты пользователей email-протоколов от спама. Позже такой подход лег в основу архитектуры HashCash – одной из ранних попыток А. Бэка создать независимую цифровую валюту. На момент 2019 года А. Бэк остается одним из ведущих криптографов и идеологов в Bitcoin-сообществе.

### Spam-атака и ее последствия

Под термином spam обычно подразумеваются навязчивые нежелательные сообщения в большом количестве. Цель spam-атаки – вывести из состояния нормального функционирования один или несколько узлов сети. Организовать такую атаку можно, но есть некоторые особенности. Можно взять программный кошелек внести в него некоторые изменения, так чтобы он создавал много транзакций, отправляя монеты со своих старых адресов на новые. Каждая транзакция при этом должна включать комиссию и в зависимости от этого предлагаем рассмотреть три разных сценария.

В первом случае злоумышленник включает очень низкую или нулевую комиссию. Тогда его транзакции не будут расходиться по сети вообще, т. к. каждый узел устанавливает значение минимально допустимой комиссии. Если фактическая комиссия за транзакцию ниже этого порогового значения, то узел сразу же отклоняет транзакцию. Таким образом, злоумышленник может отсылать такие транзакции только тем узлам, с которыми имеет прямое соединение, и то недолго. К тому же это будет малоэффективно, потому что его транзакции будут сразу отклоняться. А через некоторое время у этих узлов еще и сработает фильтр, который разорвет соединение с бесполезными или передающими некорректные сообщения узлами.

Во втором случае злоумышленник включает среднюю комиссию (выше порогового значения, но не достаточную для быстрого подтверждения). Его транзакции распространяются по всей сети, и эта атака будет немного эффективнее предыдущей. Все узлы сети будут верифицировать, хранить и транслировать транзакции злоумышленника. Таким образом можно занять значительную часть памяти внизу очереди неподтвержденных транзакций. Но узлы имеют ограничение на максимальный размер очереди, и через время такие транзакции удалятся, если не будут подтверждены. При этом транзакции остальных пользователей с достаточной комиссией будут подтверждаться должным образом.

В третьем случае злоумышленник включает достаточную комиссию. Тогда его транзакции практически могут заполнить всю пропускную способность валюты. Важно понимать, что при этом кошельки других пользователей также начнут завышать комиссию за транзакцию, чтобы получить обслуживание. Поэтому злоумышленнику нужно будет платить все больше и больше за каждую следующую транзакцию, чтобы остальные транзакции оставались внизу очереди. Затраты на такую flood-атаку будут весьма большими.

### Приостановка подтверждения новых транзакций (DoS)

Возможно ли создать атаку на Биткоин, которая остановит работу валидаторов, из-за чего не будут подтверждаться новые транзакции? Теоретически такая атака возможна. Может оказаться так, что кто-то, хорошо разбирающийся в программировании и безопасности ПО, обнаружит в исходном коде полных узлов критические уязвимости и захочет эксплуатировать их, нанося вред сети, вместо того чтобы предложить исправление. Предугадать такой сценарий или гарантированно защититься от него практически невозможно.

Но вероятность того, что такое произойдет в действительности, весьма мала. Поскольку Биткоин существует уже достаточно долго, попытки найти уязвимости уже много раз предпринимались и исследователи продолжают работать в этом направлении. К тому же, перед принятием очередных обновлений протокола, исходный код проходит строгий аудит и тестирование множеством независимых членов сообщества.

### Long-range атака

Принцип данной атаки проще понять, если вспомнить уже известную атаку 51%. В традиционном представлении это выглядело бы следующим образом. Атакующий отправляет 50 биткоинов на только что созданный адрес. После этого он отправляет монеты мерчанту, у которого обменивает их на другую валюту (например, лайткоины). Продавец ждет 6 подтверждений транзакции и отправляет другую валюту на кошелек пользователя.

Атакующий параллельно работает над новой цепочкой на базе блока, который находится перед блоком с транзакцией, в которой он отправляет 50 биткоинов мерчанту. Пользователь формирует новую транзакцию, в которой отправляет монеты себе на другой адрес. Имея больше половины вычислительной мощности сети, пользователь перенаправляет ее на новую цепочку. Вскоре его цепочка становится основной и все узлы по правилам работы протокола Bitcoin переключатся на нее. В результате успешной атаки пользователь сохранит свои биткоины и приобретет лайткоины. В случае long-range атаки пользователь начинает свою цепочку _не 6 блоками ранее, а от genesis block_.

Имея компьютер с вычислительной мощностью в 1 TH/s, вполне возможно всего за 5 минут построить новую цепочку от _genesis block_ до блока с порядковым номером 300 000. К слову, по состоянию на сентябрь 2019 года майнинговое оборудование для Биткоин с вычислительной мощностью в 14 TH/s можно было приобрести по цене 3000 USD. Минимальное значение параметра _mining difficulty_ равно числу, которое представлено ниже в системе счисления по основанию 16.

**00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff**

Когда пользователь строит свою цепочку, он может записать любое время, потраченное на создание блока (может подделать метку времени в заголовке блока), и при этом сложность майнинга остается минимальной. Если посмотреть на такую цепочку блоков в готовом виде, то она никак не будет отличаться от настоящего.

Когда новые узлы присоединяются к сети, могут ли они отличить настоящую историю блоков от поддельной? Даже на среднем по мощности оборудовании не понадобится много времени, чтобы создать такую цепочку. Устоит ли Биткоин перед атакой в тысячи таких цепочек?

Дело в том, что для протокола Биткоина это не уязвимость, поскольку разработчики учли возможность такой атаки. С этой целью правила прописывались таким образом, что они учитывают не только длину цепочки, но и параметр сложности, который определяет выполненную работу на построение основной цепочки. Поэтому узлы очень быстро могут отличить настоящую цепочку от поддельной.

С этой угрозой также помогает бороться механизм _checkpoints_ (детально рассматривался в первой части данного учебного пособия). Однако нужно помнить, что чекпоинты не являются trustless решением. Тот, кто их добавляет в ПО, может оказаться злоумышленником, поэтому здесь присутствует доверие и к разработчикам ПО, и к автору checkpoints.

### Routing-атаки

Несмотря на то, что узлом Биткоина можно управлять из любой точки Земли, на сегодняшний момент узлы по всему миру распространены неравномерно. По результатам исследований (рис. 3.62), большинство Биткоин-узлов размещаются в нескольких провайдерах интернет-услуг (ISP): 13 интернет-провайдеров (что составляет 0,026% всех интернет-провайдеров) вмещают 30% узлов всей сети Биткоина (изображено на левом графике). Более того, большая часть трафика, которым обмениваются узлы Биткоина, пересекает несколько интернет-провайдеров. Исследования показывают, что 60% всех возможных соединений Биткоина пересекают 3 интернет-провайдера. То есть, эти 3 интернет-провайдера могут видеть 60% всего трафика Биткоина (изображено на правом графике).

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.62-Ratio-between-the-total-number-of-nodes-and-connections-between-them.png" alt="Рисунок 3.62 – График соотношения общего количества узлов и соединений между ними"/> 

Существует уловка BGP – это routing-атака, в которой интренет-провайдер некорректно пересылает трафик на основе поддельных сообщений о маршрутизации в системе интернет-маршрутизации. Атаки такого типа встречаются достаточно часто (рис. 3.63), до сотни тысяч каждый месяц. Некоторые из них направлены на огромное количество сетевых адресов: до 30 000 IP-префиксов (изображено на левом графике).

Такие атаки уже сегодня влияют на сеть Биткоин. Каждый месяц по меньшей мере 100 Биткоин-узлов являются жертвами уловок BGP, а в ноябре 2015 года захваченными оказались 447 узлов, что составляет 8% узлов Биткоина (изображено на правом графике).

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.63-Statistics-of-BGP-tricks-performed.png" alt="Рисунок 3.63 – Статистика проведения уловок BGP"/> 

Атакующий с помощью routing-атаки может преследовать две цели. Первая состоит в том, чтобы разбить сеть Биткоин на части, не позволяя узлам каждой из них синхронизироваться между собой. Таким образом атакующий заставляет узлы создавать альтернативные ветки, вместо совместной цепочки блоков. После прекращения атаки все блоки, которые были сформированы меньшей группой, будут отброшены. Транзакции меньшей ветки окажутся неподтвержденными, а вознаграждение за формирование блоков недействительным. Такая атака выполняется по следующему сценарию (рис. 3.64).

> Шаг 0: узлы левой и правой части взаимодействуют через соединения Биткоина, обозначенные синими линиями.

> Шаг 1: злоумышленник хочет разбить сеть на две непересекающихся части: одна с левой стороны и одна с правой.

> Шаг 2: атакующий захватывает трафик, направляемый на левые узлы, выполняя уловку BGP.

> Шаг 3: вскоре после захвата весь трафик, отправленный справа налево, будет проходить через злоумышленника (красные линии).

> Шаг 4: атакующий разрывает эти соединения, эффективно разбивая сеть на две части.

> Шаг 5: во время атаки узлы в каждой части продолжают связь с узлами той же стороны.

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.64-Attack-routing-scheme.png" alt="Рисунок 3.64 – Схема routing-атаки"/> 

Вторая цель, которую может преследовать атакующий, – это задержка доставки блока узлу жертвы на 20 минут. При этом злоумышленник остается абсолютно незамеченным. В течение этого периода жертва не знает о самом последнем добытом блоке и соответствующих транзакциях. Последствия этой атаки зависит от типа жертвы. Если жертвой является мерчант, то он подвержен атаке двойной траты. Если жертва – валидатор, то он напрасно тратит вычислительную мощность своего оборудования. Наконец, если жертвой является обычный пользователь, то он не может внести свой вклад в сеть, распространяя последние актуальные блоки. Такая атака выполняется по следующему сценарию (рис. 3.65).

> Шаг 0: узлы А и В объявляют один и тот же блок жертве С.

> Шаг 1: узел С запрашивает блок с помощью GETDATA от узла А. Атакующий меняет содержимое GETDATA так, чтобы доставить старый блок из узла А.

> Шаг 2: старый блок доставлен.

> Шаг 3: незадолго до 20 минут после запроса узла С, злоумышленник запускает его доставку, изменяя другое сообщение GETDATA, созданное узлом С.

> Шаг 4: блок поставляется за 20 минут. Жертва не отключается от узла А.

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.65-Block-Delay-Attack-Scheme.png" alt="Рисунок 3.65 – Схема атаки задержки блока"/> 

### Другие технические и социальные атаки

_Анализ сетевого трафика (packet sniffing)_. Тот, кто может видеть весь ваш интернет-трафик, может определить, когда вы отправляете транзакцию, которую вы не получили от другого узла (что предполагает, что вы ее создали). Интернет-провайдеры или национальные фаерволы могут фильтровать трафик протокола Bitcoin, тем самым принося некоторые неудобства обычным пользователям. Но вопрос с фильтрацией сетевых пакетов может быть решен. Например, Bitcoin Core имеет хорошую интеграцию с Tor (децентрализованная сеть анонимизации трафика).

Атака _block withholding (selfish mining)_ подразумевает наличие временной задержки для только что сформированных блоков перед их отправкой другим узлам. Атакующим является валидатор с достаточно большой вычислительной мощностью, он создает новые блоки цепочки, но сразу не сообщает их другим узлам сети. Публикация этих блоков выполняется позже, по одному или группами, из-за чего блоки остальных валидаторов сеть отбрасывает как принадлежащие к другой, более короткой цепочке (_orphan blocks_). В этой атаке жертвами становятся другие валидаторы, где, в итоге, они либо принимают меньшее участие в достижении консенсуса, либо вообще не могут создать ни одного актуального блока.

Существуют и другие разноплановые атаки, такие как спланированные форки, всяческие запреты на использование валют определенных государств при обмене биткоинов, блокировка сетевого трафика полного узла сети со стороны интернет-провайдеров, а также запреты на производство специализированного оборудования или его использование.

К наиболее специфическим атакам можно отнести физическое похищение важных членов сообщества и внесение вредоносных элементов в аппаратное или программное обеспечение.

### Bitcoin alert system и отказ от нее

Сигнальная система (alert system) в Bitcoin позволяет транслировать клиентам сети сообщения о случаях обнаружения проблем и потенциальных угроз (рис. 3.66).

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.66-An-example-of-Bitcoin-alert-system-message.png" alt="Рисунок 3.66 – Пример сообщения сигнальной системы в Биткоин"/> 

Как заявил сам Сатоши на форуме bitcointalk.org еще на этапе разработки сигнальной системы, личный ключ, которым он подписывает сообщения, есть только у него (рис. 3.67).

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.67-Message-on-the-forum-about-the-alarm-system.png" alt="Рисунок 3.67 – Сообщение на форуме о сигнальной системе"/> 

Иначе говоря, данная надстройка централизованная. Однако Сатоши не видел в этом большой проблемы, поскольку она с лихвой перекрывалась социальным консенсусом. Любой пользователь мог проверить данные на форуме и других источниках, если он сомневался в достоверности проблемы (рис. 3.68).

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.68-Message-about-the-possibility-of-checking-data-by-each-user.png" alt="Рисунок 3.68 – Сообщение о возможности проверки данных каждым пользователем"/> 

Сатоши утверждал, что не может осуществлять никаких действий удаленно. А данное нововведение призвано обеспечить сохранность монет пользователей. Если во время работы протокола происходит что-то подозрительное, что может угрожать состоянию балансов пользователей, то каждый из них получит об этом сообщение. Игнорируя сообщения о потенциальной опасности, владелец монет может их потерять (рис. 3.69).

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.69-An-explanation-of-the-need-for-a-signal-system.png" alt="Рисунок 3.69 – Объяснение необходимости сигнальной системы"/> 

Позже Сатоши передал свой секретный ключ нескольким доверенным разработчикам Bitcoin Core. Участники сообщества начали высказывать опасения, что если ключом завладеет злоумышленник, то он сможет распространять сообщения, которые способны вызвать панику. Более того, случались инциденты, когда с помощью этих ключей совершались попытки влиять на правила сети, на комиссии и на параметр сложности.

Такое положение вещей противоречило модели безопасности Биткоина. И уже в обновлении Bitcoin Core 0.13.0, в 2016 году, сигнальная система была полностью устранена.

### Некоторые из обнаруженных и решенных проблем протокола

_BIP-0050_. В мае 2013 года был предложен BIP 50 для решения одной из таких проблем. В сети кто-то создавал и распространял блоки, которые имели большее количество суммарных транзакционных входов, чем предыдущий. 0.8-Bitcoin-узлы смогли справиться с этим, но некоторые из узлов до версии 0.8 – нет, вызвав неожиданное раздвоение цепочки блоков. В несовместимой цепочке pre-0.8 тогда было около 60% _hashrate_, чего не хватало для автоматического разрешения раскола.

Чтобы как можно скорее восстановить каноническую цепь, BTCGuild и Slush понизили свои 0.8-Биткоин-узлы до 0.7, за счет чего их пулы также отклоняли блок, содержащий большее число входов. За это время была проведена одна большая двойная трата. Но это было сделано ради эксперимента, а не из злоумышленных соображений.

Благодаря тому, что раскол сети был быстро замечен, тяжелых последствий удалось избежать. Как следствие, появилась обновленная версия протокола 0.8.1, которая содержала следующие правила:

* отклонять блоки, которые могут вызвать более 10 000 блокировок;
* ограничить максимальный размер создаваемого блока до 500 000 байт;
* создание обновления безопасности для более старых версий, которое реализует те же правила, но с ограничением числа максимальных блокировок до 120 000;
* создание веб-страницы на bitcoin.org, заставляющей пользователей обновиться до версии 0.8.1. На странице также указано, как установить DB_CONFIG на 120 000 блокировок.
* в течение последующих 2 месяцев отправлялись серии предупреждений пользователям более старых версий о необходимости обновления.

_CVE-2013-4165_. Еще одна уязвимость, которая была обнаружена в сети Биткоин, состоит в следующем. Злоумышленник может отправить ряд сообщений, которые приведут к целочисленной ошибке деления на ноль в коде обработки Bloom Filter, в результате чего в Bitcoin-Qt или в bitcoind происходит отказ в обслуживании. Bloom Filters были предложены в версии 0.8, следовательно, версии от 0.8.0 до 0.8.3 подвержены данной атаке отказа в обслуживании.

После обнаружения данной уязвимости начал использоваться алгоритм с постоянным временем для проверки попыток угадывания пароля RPC.

_CVE-2014-0160_. Эта уязвимость связана не напрямую с сетью Bitcoin, а с библиотекой OpenSSL. Она может позволить удаленному злоумышленнику получать конфиденциальные данные, включая учетные данные пользователя и секретные ключи, путем неправильной обработки памяти в этой библиотеке.

Для устранения этой уязвимости протокол OpenSSL был обновлен до версии 1.0.1g. Все ключи, которые генерируются в более старых версиях, считаются скомпрометированными, и они должны быть перегенерированы с использованием новой версии протокола.

_CVE-2016-10724_. Bitcoin Core до версии 0.13.0 был уязвим к DoS-атакам, вызванным системой удаленного сетевого оповещения, когда злоумышленник подписывает сообщение с определенным личным ключом, известным участникам-жертвам. Это влияет на клоны исходного кода, такие как Bitcoin Knots до версии 0.13.0.knots20160814 и некоторые альткоины.

**Распространенные мифы**

*Любой программист может убедиться в отсутствии уязвимостей в Bitcoin.*

Теоретически это возможно, но в действительности анализ такого количества исходного кода – работа для большой профессиональной команды, причем на достаточно длительное время.

**Часто задаваемые вопросы**

*– Если у пользователя много биткоинов в кошельке, и он готов их потратить, как ему технически заспамить транзакциями mempool Биткоина, чтобы повысить стоимость транзакции?*

Действительно, если у пользователя много биткоинов, он может потратить их на проведение стресс-теста. Для этого ему нужно модифицировать ПО своего полного узла. Достаточно простой вариант – это добавление цикла с генерацией нового адреса и отправкой на него случайного количества монет (например 0,5–2 BTC). Этот цикл лучше запустить в отдельном потоке и повторять 2–3 раза в секунду. При этом рассчитывать оптимальную комиссию, чтобы эти транзакции попадали в середину _mempool_, но не подтверждались в первом же блоке. Иначе говоря, это позволит не переплачивать комиссионные и эффективно нагружать все узлы в сети. Это оптимальный способ заполнить _mempool_ настолько, что пользователям, которые хотят осуществить срочные платежи, придется включать очень большую комиссию, чтобы их транзакции попали в начало очереди и с достаточной вероятностью были включены в следующий блок.

*– Говорят, что будущей угрозой Биткоину будут квантовые компьютеры. Что это означает?*

Под этим подразумевается атака на алгоритм цифровой подписи, который использует Биткоин сейчас. На текущий момент не существует квантовых компьютеров, способных реализовать такую атаку (и все еще неясно, будут ли они вообще созданы). Даже если они появятся, то криптография в Биткоине будет обновлена и она будет более стойкой к квантовым вычислениям. Уже есть алгоритмы постквантовой криптографии.

*– Может ли производитель майнинговых чипов, взять однажды контроль над мощностями через встроенную лазейку и провести атаку 51%?*

Потенциально возможно, хотя это достаточно сложно и, скорее всего, экономически необоснованно для производителя. Тем не менее, обнаружить закладку в майнинговых чипах достаточно сложно. Поэтому лучше, когда существует множество независимых производителей чипов и ни один из них не превосходит остальных, вместе взятых, по объемам производства. Кроме того, многие альткоины используют ASIC-resistant хэш-функции, для которых создание аппаратных майнеров крайне сложно, – майнинг выполняется на видеокартах или процессорах общего назначения.

*– Какие инструменты применяются для атак на Биткоин?*

Чаще всего это специализированное ПО, созданное на базе исходного кода полного узла сети.

*– Что будет с Биткоином, если интернет между континентами пропадет, а затем появится снова?*

На одном континенте будет одна история транзакций, а на втором другая. Когда соединение восстановится, то останется только одна цепочка – та, на которую было затрачено больше вычислительных мощностей. Для людей с континента с меньшей цепочкой транзакции, которые не конфликтуют с основной цепочкой, снова станут не подтвержденными, но они будут позже подтверждены в последующих блоках.

*– Где гарантия, что нет backdoor в коде Bitcoin?*

Специалисты придерживаются мнения, что специально встроенных закладок нет, так как исходный код изначально находится в открытом доступе и многократно проходил независимый анализ. Но могут быть непреднамеренные ошибки, из-за которых протокол может оказаться уязвимым. Вероятность этого мала, поскольку проводится тщательное тестирование и прорабатываются злонамеренные сценарии поведения внешних узлов. С другой стороны, дополнительно  убедиться в этом возможно после самостоятельного аудита исходного кода или обращения за помощью к доверенной стороне.

[BITCOIN КАК ПЛАТФОРМА](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-2/ru/4-bitcoin-as-a-platform.md)
