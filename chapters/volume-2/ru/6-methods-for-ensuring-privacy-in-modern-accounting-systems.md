# МЕТОДЫ ОБЕСПЕЧЕНИЯ ПРИВАТНОСТИ В СОВРЕМЕННЫХ УЧЕТНЫХ СИСТЕМАХ

## 6.1 Стандарты CryptoNote

Основное отличие современных учетных систем – использование криптографических операций, в частности цифровых подписей, для доказательства владения монетами и подтверждения всех изменений базы данных учетной системы. Однако очень часто использование стандартных криптографических алгоритмов в некотором смысле ограничивает приватность участников сети (простота распутывания цепочек транзакций). В этом случае приходится прибегать к методам, таким как confidential transactions, ring signatures, stealth addresses и т. д.

В 2013 году мир увидел серию стандартов CryptoNote, на основе которых построены анонимные криптовалюты, такие как Monero, Bytecoin, Karbo и многие другие.

Серия стандартов CryptoNote состоит из десяти стандартов, в которых описываются основные концепции построения анонимной криптовалюты. В стандартах описаны технологии построения общей истории транзакций, структура блока и транзакции, использование ключей для формирования адресов и подписания транзакций (использование механизма кольцевой подписи) [51].

В этом подразделе мы рассмотрим технологические особенности стандартов CryptoNote, а также рассмотрим, как эти концепции применяются, на примере криптовалюты Monero.

### Подписи в стандарте CryptoNote

Алгоритм подписания транзакций был описан в первом из серии стандартов, однако позднее был заменен на другой (улучшенная версия подписи). CryptoNote описывает алгоритм одноразовой кольцевой подписи. Такой подход позволяет пользователю подписать транзакцию и сохранить при этом анонимность, так как верификатор может убедится, что подпись была выработана одним из членов группы, не имея возможности узнать, кем именно (детальнее мы рассматривали особенности цифровой подписи в разделе 2.4). Для предотвращения атаки двойной траты было решено использовать механизм одноразовой подписи (использование изображения личного ключа).

Давайте повторим, что такое одноразовая кольцевая подпись и каким образом она вычисляется. Также как и для вычисления значения обычной подписи, пользователю необходимо иметь ключевую пару – личный и открытый ключи. Однако в случае кольцевой подписи также должны использоваться открытые ключи всех остальных участников группы. Для чего это нужно?

При использовании обычной подписи верификатор однозначно может связать значение подписи с соответствующим открытым ключом (идентификатором пользователя), поскольку публичный ключ используется для проверки подписи (рис. 6.1).

<img width="50%" alt="Рисунок 6.1 – Схема функционирования классической цифровой подписи" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.1-Classic-digital-signature-scheme.png"/> 

Для вычисления кольцевой подписи, кроме личного ключа пользователя, необходимо использовать его открытый ключ, а также открытые ключи всех участников группы. Кольцевая подпись позволяет верификатору убедится, что подпись сформировал один из участников группы, но, так как для верификации необходимы все открытые ключи, сказать точно, кто являлся подписантом, невозможно (рис. 6.2).

<img width="50%" alt="Рисунок 6.2 – Схема функционирования кольцевой подписи" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.2-Ring-signature-scheme.png"/> 

### Связь ключей и адресов

В отличие от большинства криптовалют, где пользователь владеет одной ключевой парой для управления одним адресом/аккаунтом, стандарты CryptoNote предполагают, что каждый пользователь имеет две ключевые пары. Фактически, пользователь генерирует два больших секретных значения, которые являются его личными ключами. Открытые ключи так же, как и в других учетных системах, являются произведениями этих секретов на значение базовой точки. Они называются public spend key и public view key (далее мы рассмотрим, почему).

Адрес формируется путем конкатенации префикса (18 для основной сети), двух открытых ключей, а также checksum от предыдущих полей (рис. 6.3). Checksum представляет собой хэш-значение KECCAK, усеченное до 4 байт. Полученный результат кодируется в Base58 [52].

<img width="42%" alt="Рисунок 6.3 – Схема формирования адреса" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.3-Address-formation-scheme.png"/> 

### Stealth addresses

Большинство криптовалют подразумевает наличие открытого адреса/аккаунта. Любая третья сторона может связать все транзакции, которые имеют отношение к этому адресу, а соответственно, и к его владельцу, если связь хотя бы одной транзакции и участвующей в ней стороны будет раскрыта. В таких условиях рекомендуется создавать новый адрес для каждого нового входящего платежа и сдачи. Однако такой подход является не самым удобным, так как он предполагает частую генерацию ключей и лишает пользователя удобства владения одним адресом/аккаунтом.

Стандарты Cryptonote подразумевают же использование так называемых stealth addresses. Доступ к ним имеет только владелец личных ключей, причем любой третьей стороне сложно раскрыть связь между обычным адресом и stealth address. Давайте рассмотрим, каким образом происходит формирование таких адресов и как пользователь получает доступ к монетам, которые на таком адресе заблокированы (рис. 6.4).

<img width="50%" alt="Рисунок 6.4 – Схема отправки платежа на stealth address" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.4-Sending-payment-to-the-stealth-address.png"/> 

Предварительно Алиса генерирует себе две ключевые пары и формирует адрес. Для получения платежа на первом этапе Алиса отправляет свой адрес Бобу. Боб получает адрес и вычленяет из него значения двух открытых ключей. После этого Боб генерирует одноразовое секретное значение _r_ и умножает его на базовую точку для получения _R_. Далее Боб использует полученные значения для формирования одноразового открытого ключа, к которому будут привязаны монеты; только владелец соответствующего секретного ключа сможет получить к ним доступ. В этом случае одноразовый открытый ключ вычисляется так:

**P = H(r * A<sub>1</sub> || n) * G + A<sub>2</sub> (n – индекс выхода).**

На втором шаге Боб формирует свою транзакцию. Он указывает непотраченные выходы во входах, сумму перевода и значение одноразового открытого ключа в выходах, а значение R в поле extra (рассмотрим далее). После этого, на третьем шаге, Боб отправляет транзакцию для подтверждения ее валидаторами.

Так как монеты отправлены на одноразовый открытый ключ, а не напрямую на адрес Алисы, то она сама вначале не знает, какие выходы ей принадлежат. Ввиду этого (четвертый шаг) она проверяет все выходы всех подтвержденных транзакций в поисках того, который адресован ей. Для каждого из выходов она вычисляет следующее значение:

**P' = H(a<sub>1</sub> * R || n) * G +  A<sub>2</sub>.**

Если это значение равно указанному в выходе транзакции _P_, то выход действительно принадлежит Алисе. Для его разблокировки ей необходимо вычислить соответствующий секретный ключ

**p = H(a<sub>1</sub> * R || n) + a<sub>2</sub>**

и подписать следующую транзакцию, которая тратит этот выход.

### Механизм защиты от двойной траты

Использование кольцевых подписей в чистом виде позволяет пользователю провести атаку двойной траты. Давайте рассмотрим пример, в котором в сети есть четыре пользователя, каждый из которых владеет одним непотраченным выходом (рис. 6.5).

<img width="50%" alt="Рисунок 6.5 – Непотраченные выходы участников кольца" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.5-Unspent-outputs-of-ring-participants.png"/> 

Каждый выход закреплен за конкретным открытым ключом. Для создания кольцевой подписи пользователь собирает открытые ключи из других непотраченных выходов, после чего формирует кольцевую подпись. К примеру, Алиса хочет отправить себе монеты на другой адрес и формирует транзакцию, которую подписывает, объединяя открытые ключи Алисы, Боба и Кэрол (рис. 6.6).

<img width="40%" alt="Рисунок 6.6 – Формирование транзакции Алисы" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.6-Alice’s-transaction-formation.png"/> 

Валидатор может проверить, закреплен ли за каждым ключом непотраченный выход и свидетельствует ли подпись о том, что этот выход тратится. Однако при этом валидатор не знает, какой именно из этих выходов тратится. Поэтому ничего не мешает Алисе создать альтернативную транзакцию, которая тратит те же монеты на другой адрес, после чего подписать ее, используя открытые ключи Боба и Дэйва (рис. 6.7).

<img width="40%" alt="Рисунок 6.7 – Попытка Алисы провести атаку двойной траты" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.7-Alice-tries-to-perform-a-double-spending-attack.png"/> 

Если не введен дополнительный механизм защиты, то для валидатора это значение подписи также будет корректным, а значит, средства будут переведены дважды. Поэтому стандарт CryptoNote предусматривает использование изображения личного ключа как средство обеспечения защиты от атаки двойной траты. Фактически, этот механизм позволяет обнаружить, были ли несколько подписей вычислены при помощи одного и того же личного ключа, без раскрытия самого ключа. Изображением секретного ключа является его хэш-значение, и оно используется для проверки подписи, что не позволяет подменить его. 

Если Алиса пытается провернуть то же самое, валидатор увидит, что подписи были вычислены при помощи одного и того же личного ключа, – и конфликтующая транзакция будет отклонена.

### Структура блоков в CryptoNote

Стандарты CryptoNote подразумевают организацию истории транзакций в цепочку блоков. Каждый блок связан с предыдущим посредством уникального идентификатора – хэш-значения блока. Давайте детально рассмотрим структуру блока в CryptoNote (рис. 6.8). 

<img width="36%" alt="Рисунок 6.8 – Структура блока согласно CryptoNote" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.8-Block-structure-according-to-CryptoNote.png"/> 

Как видим из рисунка, блок состоит из трех компонентов: заголовка блока (block header), тела coinbase транзакции и списка идентификаторов включенных транзакций. Отметим, что сам блок не содержит в себе никаких данных транзакций, кроме их идентификаторов. Это сделано для достижения небольшого размера блока, однако полным узлам все еще необходимо хранить все транзакции.

Ключевым отличием блоков в Monero и подобных криптовалют является их динамический размер [53]. Средний размер блока в Monero рассчитывается как среднее значение от размеров предыдущих 100 блоков. Максимальный размер блока не может превышать средний в более чем 2 раза. Также отметим, что в протоколе предусмотрен механизм штрафования майнеров за добычу блоков, размер которых превышает среднее значение. Размер штрафа рассчитывается так:

**P = R * ((B / M) – 1)<sup>2</sup>**, где
> *P* – размер штрафа;
> *R* – базовое вознаграждение за добычу блока;
> *B* – размер добытого блока;
> *M* – среднее значение размеров 100 последних блоков.

Таким образом, если сформированный блок имеет максимально допустимый размер, то вознаграждение за его создание равно штрафу. Также стоит отметить, что сумма штрафа платится валидатору следующего сформированного блока.

Давайте детальнее рассмотрим заголовок блока и все его поля (табл. 6.1).

Таблица 6.1
<img width="50%" alt="Таблица 6.1" src="/resources/img/volume-2/6.1-CryptoNote-standards/Table-6.1.png"/> 

В полях _minorVersion_ и _majorVersion_ указываются версии протокола: соответственно первая и та, которую поддерживает узел-валидатор. В поле _timestamp_ указывается время создания блока (в формате UNIX timestamp). Поле _prevID_ содержит в себе хэш-значение (идентификатор) предыдущего блока в цепочке, а поле _nonce_ – значение, необходимое для доказательства решения ресурсоемкой задачи.

Кроме заголовка и списка идентификаторов транзакций, блок содержит тело coinbase транзакции, которая платит вознаграждение валидатору. Coinbase транзакция (а именно то, соответствует ли сумма вознаграждения высоте блока и т. д.) также должна быть проверена остальными участниками. Структуру coinbase транзакции мы рассмотрим немного позже.

Рассмотрим, каким образом формируется идентификатор блока согласно стандарту CryptoЗамечание. Для вычисления хэш-значения блока используется хэш-функция CryptoNight. Особенность этой хэш-функции – требовательность к объемам необходимой памяти (около 2 MB), что делает использование специализированных интегральных схем (ASICs) неэффективным. На сегодня Monero использует CryptoNight v. 2 – алгоритм, который был спроектирован в 2017 году компанией Bitmain. Процедура получения идентификатора блока показана на рисунке 6.9.

<img width="42%" alt="Рисунок 6.9 – Схема формирования идентификатора блока" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.9-Block-identifier-generation.png"/> 

Отметим, что для получения значения Merkle Root используется функция KECCAK-256. В качестве примера давайте рассмотрим один из подтвержденных блоков в сети Monero (рис. 6.10).

<img width="50%" alt="Рисунок 6.10 – Пример блока, сформированного по протоколу Monero" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.10-An-example-of-the-block-generated-by-Monero-protocol.png"/> 

### Структура транзакций в CryptoNote

Структура транзакций определяется в четвертой части серии стандартов. Транзакции в анонимных валютах, построенных по этому протоколу, схожи по структуре с транзакциями в Bitcoin и строятся по модели UTXO (каждая транзакция содержит входы – ссылки на транзакции, с которых монеты были получены – и выходы, в которых содержатся условия траты монет).

Каждая транзакция состоит из двух компонентов: префикса транзакции и набора подписей. Префикс транзакции содержит основные данные транзакции (кто, кому и сколько переводит) и имеет следующую структуру (табл. 6.2).

Таблица 6.2
<img width="50%" alt="Таблица 6.2" src="/resources/img/volume-2/6.1-CryptoNote-standards/Table-6.2.png"/> 

Давайте на примере реальной транзакции в Monero рассмотрим ее поля (рис. 6.11).

<img width="50%" alt="Рисунок 6.11 – Транзакция в Monero" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.11-Monero-transaction.png"/> 

В заголовке транзакции есть 2 поля: _version_ и _unlock_time_. Первое поле отображает номер версии транзакции. В этом случае он равен 2, а значит, транзакция поддерживает механизм ring confidential transaction. В первой версии протокола была реализация только одноразовой кольцевой подписи для сокрытия истории происхождения монет. Внедрение ring confidential transaction позволило дополнительно скрывать суммы переводов. В поле unlock_time указывается значение времени, после которого транзакция может быть подтверждена.

Далее следуют входы транзакции. Вход транзакции содержит поля _amount_, _key_offsets_ и _k_image_. В поле _amount_ содержится количество монет на входе. В нашем случае значение amount равно 0, что значит, что сумма входа скрыта. Поле key_offsets содержит индексы смещения ключей (причем каждый следующий индекс обозначает смещение относительно предыдущего). Фактически, это индексы на непотраченные выходы в UTXO database. Наличие группы выходов необходимо для формирования кольцевой подписи. В нашем случае key_offsets содержит 11 значений. Это значит, что, кроме ключевой пары отправителя, используется еще 10 публичных ключей других пользователей для вычисления кольцевой цифровой подписи. Поле k_image содержит значение изображения секретного ключа и позволяет избежать атаки двойной траты.

За входами расположены выходы транзакции. В нашем случае количество выходов равно 2, каждый из которых содержит два поля: _amount_ и _key_. Поле amount содержит сумму выхода транзакции (в ослепленном виде), а key – открытый ключ получателя. Как мы отмечали ранее, ключ одноразовый и никакая третья сторона не может связать его с главным (master) открытым ключом получателя (метод stealth addresses).

Все остальные данные транзакции содержат в себе доказательства того, что транзакция верна и может быть подтверждена. Фактически, эти доказательства – цифровые подписи (включая данные range proofs и ring signatures). Отметим, что размер этих доказательств составляет более 70% размера транзакции и что средний размер транзакции в Monero более чем в 8 раз превышает размер обычной транзакции в Bitcoin.

## 6.2 MimbleWimble

19 июля 2016 года была опубликована работа под названием «MIMBLEWIMBLE» [54], которая фактически представляла собой протокол построения сети с высоким уровнем конфиденциальности пользователей и высокой масштабируемостью системы. Немного позже Эндрю Пулстра (Andrew Poelstra), один из наиболее известных в сообществе Bitcoin людей, опубликовал более развернутый документ, в котором описал детали и технические особенности протокола [55].

Какие же проблемы решает протокол MimbleWimble? Первая проблема состоит в том, что большинство цифровых активов требуют хранение полной истории транзакций, которая со временем может только увеличиваться. Соответственно, валидаторам необходимо выделять все больше физической памяти для хранения истории транзакций (иначе полноценная верификация транзакций будет невозможна).

Второй проблемой является сложность обеспечения конфиденциальности платежей в permissionless системе. Если мы возьмем ту же учетную систему Bitcoin, то в классическом варианте в деталях транзакции указываются открытый ключ, подпись отправителя монет, сумма перевода и адрес получателя. Таким образом, валидаторы могут проверить, что конкретный пользователь владеет монетами, которые собирается потратить, а также проверить то, что сумма выходов транзакции не превышает сумму ее входов. Открытость является важнейшей особенностью учетной системы Bitcoin, однако при этом не обеспечивается конфиденциальность переводов, а также достаточно просто деанонимизировать участников транзакции. Кроме того, можно потерять свойство взаимозаменяемости монет (монеты, над которыми совершали операции владельцы конкретных адресов, можно обнаружить среди прочих монет).

MimbleWimble сочетает несколько концепций: _confidential transactions_ для обеспечения конфиденциальности переводов, _range proofs_ для доказательства, что сумма конкретного входа и выхода не выходит за определенные границы, _CoinJoin_ для запутывания истории происхождения монет, а также _cut-through_ для оптимизации хранимых данных и уменьшения размеров транзакций и блоков.

> **Особенности MimbleWimble**
>> * _Конфиденциальность переводов_
>> * _Простота масштабируемости_
>> * _Отсутствие необходимости хранить историю транзакций в полном объеме_
>> * _Отсутствие в деталях транзакции адресов пользователей_

> **_Замечание._** *Прежде чем приступить к тому, как работает протокол MimbleWimble, стоит рассмотреть базовые свойства эллиптических кривых.*
> 1. _Необратимость. Операция умножения базовой точки на скаляр является достаточно простой операцией, однако получить скаляр при известных значениях результата и базовой точки является очень сложной задачей. Имея значения личного ключа х и базовой точки G, мы можем довольно просто вычислить значение открытого ключа X = x * G, однако получить значение личного ключа из известного открытого условно невозможно._
> 2. _Дистрибутивность. Сумма значений двух точек на эллиптической кривой равна сумме скаляров умноженных на значение базовой точки: x * G + y * G = (x + y) * G._
> 3. _Коммутативность. Изменение порядка множителей базовой точки не приводит к изменению результата: x * (y * G) = y * (x * G) = x * y * G._
	
### Модель транзакций MimbleWimble

Как и протокол Bitcoin, MimbleWimble поддерживает модель UTXO для проведения транзакций. Это значит, что транзакция содержит в себе набор входов (ссылки на предыдущие выходы и доказательства владения ними) и набор выходов, содержащих сумму переводов и информацию о новом владельце монет. Отметим, что выходы тратятся полностью (нельзя потратить только часть конкретного выхода), а сдача является отдельным выходом, доказать владение которым может сам отправитель.

Давайте рассмотрим пример, в котором постепенно перейдем от полностью открытых транзакций (схожих с транзакциями в Bitcoin) до транзакций с механизмами обеспечения конфиденциальности. Допустим, Гарри хочет отправить своей подруге Букле 8 монет. У него как раз есть два непотраченных выхода на 3 и 5 монет. Тогда транзакция будет выглядеть так, как изображено на рисунке 6.12.

<img width="40%" alt="Рисунок 6.12 – Неослепленные значения входов и выходов транзакции" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.12-Unblinded-transaction-inputs-and-outputs-values.png"/> 

Для подтверждения транзакции валидаторы проверяют, что Гарри действительно владеет выходами предыдущих транзакций, а также что сумма выходов подтверждаемой транзакции не превышает суммы ее входов. В этом примере это очень легко проверить, так как суммы открытые (все, что нужно сделать валидаторам, – просуммировать все входы и выходы и сравнить результат). Однако Гарри не хочет, чтобы кто-либо из валидаторов знал, сколько монет он передает (особенно Филч со своей странной кошкой). Для этого ему нужно ослепить (скрыть) значения входов и выходов транзакций.

Для этого протокол MimbleWimble предусматривает использование обязательств Педерсена для каждого значения входа и выхода транзакции. Обязательство Педерсена представляется следующим выражением:

**v ∗ H + x ∗ G**, где
*v* – сумма конкретного входа или выхода;
*H* – общеизвестная точка на эллиптической кривой;
*x* – ослепляющее значение (секрет сгенерированный пользователем);
*G* – еще одна общеизвестная точка на эллиптической кривой.

> **_Замечание._** *На этом этапе необходимо отметить, что необходимо использовать дополнительный ослепляющий секрет. Если мы будем скрывать передаваемую сумму только за счет умножения ее на базовую точку, свойство необратимости могло бы сработать, но так как сумма перевода ограничена небольшим значением, вторая сторона может подобрать его путем перебора и найти подходящую сумму перевода.*

Давайте рассмотрим, как после такой модификации изменятся значения входов и выходов транзакции. Например, Гарри, имея такие же входы, как в предыдущем примере, использует для ослепления секреты 19 и 37. Таким образом, применяя обязательства Педерсена, он формирует транзакцию так, как на рисунке 6.13.

<img width="40%" alt="Рисунок 6.13 – Ослепленные значения входов и выходов транзакции" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.13-Blinded-transaction-input-and-output-values.png"/> 

Теперь суммы переводов скрыты от валидаторов, однако все еще можно проверить, что сумма выходов не превышает сумму входов:

**(3H + 19G) + (5H + 37G) – (8H + 56G) = 0.**

Впрочем, такая структура транзакций имеет одну глобальную проблему: она требует, чтобы сумма ослепляющих факторов на входах транзакции равнялась сумме ослепляющих факторов на ее выходах. Соответственно, после отправления такой транзакции Гарри знает ослепляющий фактор (секрет) Букли, а значит, он может украсть у нее монеты (согласитесь, нельзя давать возможность поступать так с полярной совой) (рис. 6.14).

<img width="30%" alt="Рисунок 6.14 – Схема формирования удивленной совы" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.14-The-surprised-owl-formation-scheme.png"/> 

MimbleWimble решает и эту проблему. Что, если для получения транзакции Букля также определит свое секретное значение? Допустим, Букля сгенерировала свое секретное значение, равное 45. Тогда транзакция выглядит следующим образом (рис. 6.15):

<img width="40%" alt="Рисунок 6.15 – Ослепленные значения входов и выходов транзакции" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.15-Blinded-values-of-transaction-inputs-and-outputs.png"/> 

При этом сумма выходов и входов равно не 0 как ранее, а

**(3H + 19G) + (5H + 37G) – (8H + 45G) = 11G.**

Как в этом случае валидатору проверить, что транзакция не создает новых монет? На самом деле, все достаточно просто. Если сумма входов равна сумме выходов, полученный остаток будет являться открытым ключом, умноженным на G (это возможно, только если v_in * H – v_out * H = 0). Значение, полученное после вычисления (11G), называется ядром транзакции.

Для того, чтобы подтвердить транзакцию, валидаторы должны проверить, что это значение действительно является открытым ключом на кривой и что стороны совместно владеют общим секретным ключом от него. Самый простой способ доказать это – цифровая подпись, которую можно проверить при помощи результирующего открытым ключом (ядра транзакции). Механизм цифровой подписи в MimbleWimble позволяет вычислить такое общее значение сторонам, которые владеют частями общего секретного ключа.

### Доказательства диапазона

На этом этапе вроде бы все сходится. Однако есть еще один подводный камень: такая схема работает, только если значения входов и выходов положительные. Однако у пользователя остается возможность сформировать выходы, один или несколько из которых отрицательны (рис. 6.16).

<img width="40%" alt="Рисунок 6.16 – Ослепленные значения входов и выходов транзакции" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.16-Blinded-values-of-transaction-inputs-and-outputs.png"/> 

Как видим, в одном из выходов транзакции присутствует отрицательное значение суммы перевода, однако общая сумма сходится и для валидатора транзакция корректна:

**(3H + 19G) + (5H + 37G) – (–13H + 25G) – (21H + 7G) = 24G.**

Для доказательства того, что суммы выходов и входов положительные, а также не превышают максимальное допустимое значение, используются доказательства диапазона (range proofs), которые также являются криптографическими обязательствами. В 2019 году в MimbleWimble в качестве алгоритма формирования и проверки таких доказательств используются bulletproofs [56].

### Все этапы прохождения транзакции

После того, как мы рассмотрели основные особенности транзакций в MimbleWimble, давайте проанализируем, как такая транзакция формируется, передается и валидируется. Итак, Гарри имеет непотраченный выход на 100 монет и хочет передать Букле только 50. Из оставшихся монет он хочет заплатить 5 монет комиссии и 45 вернуть как сдачу. Поэтому он формирует транзакцию (рис. 6.17) следующего типа (V1 – секрет для разблокировки монет, V2 – секрет для получения сдачи, Х – сумма входов, выходов и комисии, m – дополнительные данные).

<img width="40%" alt="Рисунок 6.17 – Заготовка транзакции, передаваемая off-chain от отправителя получателю" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.17-Transaction-template-that-is-transferred-off-chain-from-sender-to-recipient.png"/> 

Также Гарри подготавливает доказательства диапазона для каждого из выходов транзакции. После этого он отправляет полученную транзакцию Букле.

Букля при получении транзакции выполняет проверку полей, после чего генерирует собственное секретное значение (ослепляющий фактор), формирует открытый ключ и вычисляет обязательство для выхода, который адресован ей. Вслед за этим Букля подписывает ядро транзакции, полученное на основе остаточного значения, комиссии и метаданных транзакции. Далее Букля возвращает Гарри набор следующих значений (рис. 6.18).

<img width="40%" alt="Рисунок 6.18 – Набор данных передаваемый от получателя отправителю" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.18-Dataset-that-recipient-transfers-to-sender.png"/> 

При получении этого набора данных Гарри может сформировать окончательную транзакцию и отправить ее в сеть для подтверждения. Транзакция состоит, фактически, из двух частей: тела и ядра. Тело транзакции хранит значения обязательств для всех входов и выходов транзакции, а также доказательства диапазона для каждого выхода (рис. 6.19). Ядро транзакции содержит остаточное значение (общий открытый ключ), значение подписи (Гарри может агрегировать свое значение подписи и значение, которое сформировала Букля), значение комиссии и дополнительные метаданные (если они есть).

<img width="35%" alt="Рисунок 6.19 – Структура транзакции" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.19-Transaction-structure.png"/> 

### Проверка и распространение транзакции

Когда Гарри закончил формирование транзакции, он отправляет ее одному из валидаторов. Узлу, получившему транзакцию, необходимо проверить, что она валидна, прежде чем передать ее остальным узлам сети. Проверка транзакции выполняется следующим образом:

1. Валидатор проверяет, что все входы транзакции непотраченные. Каждый полный узел на основании истории транзакций хранит конечное состояние в виде списка непотраченных выходов. Если выход транзакции Гарри есть в этом списке, то он может быть успешно потрачен.
2. Валидатор проверяет, находятся ли суммы в выходах транзакции в установленном диапазоне (проверяет доказательства диапазона).
3. Валидатор проверяет, равна ли сумма входов сумме выходов и комиссии. Для этого ему необходимо сложить все обязательства на входах и выходах транзакции и убедится, что полученная значение равно избыточному, а также что избыточное значение является точкой на эллиптической кривой (валидным открытым ключом).
4. Вслед за этим проверяется, соответствует ли подпись ядра транзакции полученному открытому ключу.
5. Последними выполняются системные проверки, которые уже не относятся к правилам протокола (например, проверяют, достаточен ли размер комиссии для того, чтобы транзакцию подтвердили валидаторы).

### Отсутствие адресов

В MimbleWimble не используются адреса. Каждая транзакция должна быть инициирована как отправителем монет, так и их получателем. Для формирования транзакции, стороны общаются off-chain непосредственно друг с другом. Отметим, что монеты не могут быть переданы без участия получателя (в отличии от того же Bitcoin, где можно отправлять монеты на любой адрес без каких-либо действий от их получателя).

В ходе взаимодействия отправитель указывает непотраченные выходы, а также их суммы. Получатель формирует выход, указывая вычисленное ослепленное значение. После этого они оба формируют доказательство того, что суммы выходов не превышают суммы входов, а также доказательства диапазона.

### Метод сut-through

MimbleWimble использует метод cut-through для удаления избыточных выходов, которые указаны в одном и том же блоке и как входы. Этот метод позволяет сократить место в блоке и уменьшить количество данных, которые должны содержаться в цепочке блоков. На рисунке 6.20 показано, каким образом происходит удаление избыточных выходов.

<img width="50%" alt="Рисунок 6.20 – Варианты истории до удаления избыточности и после" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.20-History-versions-before-and-after-the-redundancy-was-removed.png"/> 

Таким образом, валидаторы все еще могут убедится, что в блоке не было создано новых монет (за исключением награды за добычу блока), так как суммы на входах и выходах уравновешивают друг друга.

Более того, такое уничтожение выходов (сокращение истории передачи монет) может использоваться не только в границах одного блока, а также между несколькими блоками (так как входы одних транзакций в любом случае ссылаются на выходы предыдущих, за исключением coinbase транзакций). В результате, размер цепочки блоков может уменьшаться во время функционирования системы, если валидатор формирует блок с большим количеством входов (которые уничтожают предыдущие выходы) и малым количеством выходов. То есть валидаторы могут сокращать входы и выходы, но при этом они должны хранить историю всех ядер транзакции.

### Структура транзакции и блока

Блок MimbleWimble состоит из заголовка, набора входов, набора выходов и набора ядер транзакций.

Таблица 6.3
<img width="50%" alt="Таблица 6.3" src="/resources/img/volume-2/6.2-MimbleWimble/Table-6.3.png"/> 

Давайте детальнее рассмотрим структуру заголовка блока на примере подтвержденного блока в сети Grin (рис. 6.21).

<img width="50%" alt="Рисунок 6.21 – Пример заголовка блока в Grin" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.21-Block-header-example-in-Grin.png"/> 

Итак, каждый заголовок блока содержит версию протокола, согласно правилам которого он был сформирован. Также заголовок блока содержит хэш-значение предыдущего блока и значение Merkle root от полей заголовка предыдущего блока (а если точнее, то корень Merkle mountain ranges [57]). Следующим значением является метка времени формирования блока.

Далее идут три значения Merkle Root: для выходов блока, для доказательств диапазона, для ядер транзакций. За ними следует набор значений, связанных с решением ресурсоемкой задачи: сложность, используемый алгоритм и т. д. Последним элементом блока является агрегированное значение ядер всех подтвержденных транзакций.

## 6.3 Введение в zk-SNARKs

В первой части учебного пособия мы рассматривали, что такое доказательства с нулевым разглашением, для чего они используются и какие основные отличия между интерактивными (которые требуют взаимодействия двух сторон и в которых доказательства не могут быть верифицированы третьей) и неинтерактивными протоколами (которые предусматривают, что доказательство знания может быть проверено всеми валидаторами). В этом разделе же мы попытаемся объяснить принципы функционирования неинтерактивных доказательств и их реальное применение на примере zk-SNARKs.

Свое начало эти конструкции берут в 2013 году, когда вышла фундаментальная статья от нескольких математиков с описанием работы так называемой квадратичной арифметической программы (quadratic arithmetic program) [58], что, в свою очередь, стало основой для современных конструкций zk-SNARKs. Сегодня же SNARKs состоят из большого количества составных частей, разобраться в которых необходимо для понимания функционирования этих конструкций [74].

> * _Гомоморфное шифрование_
> * _Polynomial blind evaluation _ 
> * _Algebraic circuit_
> * _Rank-1 constraint system (R1CS)_
> * _Quadratic Arithmetic Programs (QAP)_

### Принципы гомоморфного шифрования

Гомоморфная криптосистема позволяет проводить некоторые операции над зашифрованными данными для получения результата. Такие системы используются, например, для схем слепой подписи, которые мы рассматривали в разделе 2.4. Чтобы понять, каким образом схемы гомоморфного шифрования используются для доказательств с нулевым разглашением, для начала необходимо рассмотреть базовые свойства таких схем.

> * _Сложность получения исходных данных из шифртекста_
> * _Изменение исходных данных приводит к изменению выходов функции_
> * _При нескольких известных значениях зашифрованных данных, между ними может быть проведена арифметическая операция_

Первое свойство характеризуется тем, что третья сторона, имея зашифрованное значение, не может получить исходное значение. То есть если мы обозначим функцию гомоморфного шифрования как _E(x)_, где _x_ – исходное значение, то сторона, получившая результат _E(x)_, не может восстановить _x_ (рис. 6.22).

<img width="40%" alt="Рисунок 6.22 – Необратимость функции гомоморфного шифрования" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.22-The-irreversibility-of-the-homomorphic-encryption-function.png"/> 

Второе свойство гарантирует, что, если исходные значения не равны, соответствующие зашифрованные значения также будут отличаться (за исключением очень малой вероятности). Формально это можно обозначить следующим образом:

если *x ≠ y*, then *E(x) ≠ E(y)*.

Последнее свойство является наиболее интересным: сторона, которая имеет два зашифрованных значения, может провести над ними арифметически правильную операцию, не раскрывая значения секретов. Таким образом, если пользователь знает значение _E(x)_ и _E(y)_, то он может, например, получить и проверить результат _E(x + y)_, не раскрывая ни значение _x_, ни значение _y_.

Рассмотрим пример, который иллюстрирует данный подход. Например, Алиса хочет доказать Бобу, что она знает два числа, сумма которых будет равна 15. Возьмем значения секретов _x = 13_ и _y = 2_. Стороны совместно определяют модуль _n = 17_ и значение базовой точки _g = 3_ (в качестве алгоритма шифрования будем использовать RSA). Чтобы доказать Бобу знание этих секретов, она ослепляет их и получает два значения, которые и передает Бобу: 

*E(x) = g<sup>x</sup> mod n = 3<sup>13</sup> mod 17= 12 mod 17*,
*E(y) = g<sup>y</sup> mod n = 3<sup>2</sup> mod 17 = 9 mod 17*.

Бобу же, в свою очередь, необходимо убедиться, что сумма секретов действительно равна 15. Для этого он “складывает” оба полученные от Алисы значения следующим образом:

*E(x + y) = g<sup>{x+y}</sup> mod n = g<sup>x</sup>g<sup>y</sup> mod n = 12・9 mod 17 = 6 mod 17*.

Вслед за этим он самостоятельно шифрует известный результат 15 и сравнивает полученные значения:

*E(15) = g<sup>15</sup> mod n = 3<sup>15</sup> mod 17 = 6 mod 17 ⇒ E(x + y) = E(15)*.

Так как результаты совпадают, Алиса может доказать Бобу, что она знает два числа, которые в сумме дают 15, при этом не разглашая этих чисел, а только передавая их в зашифрованном (ослепленном) виде. Поэтому свойства, которые мы отметили ранее, полностью обеспечиваются. 

Также стоит отметить, что гомоморфные системы также поддерживают линейные операции. То есть если нам необходимо умножить ослепленное значение на скаляр, то это выполняется следующим образом:

*E(ax) = (g<sup>x</sup>)<sup>a</sup> mod n = E(x)<sup>a</sup>*.

### Немного о полиномах и их blind evaluation

Для начала напомним, что такое полином. Полином представляют в таком виде:

*F(x) = a<sub>0</sub> + a<sub>1</sub>x + a<sub>2</sub>x<sup>2</sup> + ... + a<sub>n-1</sub>x<sup>n-1</sup>*, где
*x*  – переменная, а $а$ – фиксированные коэффициенты.

Итак, предположим, что Боб знает конкретный полином и хочет убедится, что его коэффициенты также известны Алисе (которая не хочет разглашать их). Для этого он хочет получить от Алисы ослепленное значение _E(F(x))_. Если бы не использовались доказательства с нулевым разглашением, то Боб мог бы передать Алисе значение _x_ и получить _F(x)_. Однако что, если Боб не хочет передавать секретное значение Алисе?

Для этого и может использоваться гомоморфное шифрование, которое мы рассмотрели ранее. Боб изначально формирует _E(F(x))_ и “запоминает” его для того, чтобы сравнить с полученным от Алисы значением. После этого он формирует набор ослепленных значений компонентов полинома и передает их Алисе:

*E(1), E(x), E(x<sup>2</sup>) ,..., E(x<sup>n-1</sup>)*.

Отметим, что если на этом этапе Алиса знает коэффициенты полинома, то она сможет предоставить корректное значение _E(F(x))_. Каким образом это происходит? Мы рассматривали ранее, каким образом ослепленное значение умножается на скаляр. Так же в этом случае Алиса может умножить на известные ей коэффициенты ослепленные значения, полученные от Боба. В результате, она получит следующее значение:

*E(F(x)) =E(1) <sup>a<sub>0</sub></sup> ･ E(x) <sup>a<sub>1</sub></sup> ･ E(x<sub>2</sub>) <sup>a<sub>2</sub></sup> ... E(x<sub>n-1</sub>) <sup>a<sub>n-1</sub></sup>*.

Полученное ослепленное значение передается Бобу и сравнивается с ранее рассчитанным. Если значения совпадают, то Боб гарантированно убеждается в том, что Алиса знает коэффициенты полинома (за исключением очень малой вероятности). При этом всем выполняются свойства доказательств с нулевым разглашением: Алиса не узнае́т секрет от Боба, не разглашает Бобу значения коэффициентов, но убеждает его в том, что знает эти значения.

### Algebraic circuit

Пока немного отойдем от концепции ослепления полиномов и рассмотрим, что такое _quadratic arithmetic programs_ (QAPs) и какое место они занимают в доказательствах с нулевым разглашением. Дело в том, что, чтобы SNARKs и многие другие протоколы могли функционировать, необходимо некоторым образом видоизменить исходную задачу. Для этого и используются QAPs [75].

Например, Алиса хочет доказать Бобу, что знает одно из значений x, которое удовлетворяет следующему уравнению, при этом не разглашая самого секретного значения: 

*x<sup>2</sup> - x - 6 = 0*.

Это же уравнение мы можем представить в виде следующей функции:

<img width="35%" alt="Function" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/function.png"/> 

Фактически, на вход функции Алисе необходимо подать секретное значение, и если выход функции будет равен 0, то она докажет, что знает нужный секрет. Однако в такой форме это не может работать, так как, чтобы Боб мог проверить знание Алисы, он должен самостоятельно выполнить эту функцию, вследствие чего ему станет доступно секретное значение.

Для создания QAP вначале необходимо упростить эту функцию, преобразовав ее в последовательность операторов, которые могут иметь только два типа [76]:

1. Оператор присвоения (=);
2. Арифметический оператор (+, −, /, ∗).

Таким образом, вы преобразовываете функцию в набор переходов состояния, которые можно изобразить как на схеме, так и в виде наборов операций функции (рис 6.23).

<img width="50%" alt="Рисунок 6.23 – Процесс упрощения исходной программы" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.23-The-process-of-initial-program-simplification.png"/> 

### Rank-1 constraint system (R1CS)

Теперь мы можем преобразовать полученные состояния (упрощенную версию кода) в R1CS. Для этого вначале нам необходимо сформировать вектор состояний (рис. 6.24), который содержит в себе все переменные упрощенной программы и значение 1 (для представления константных значений).

<img width="30%" alt="Рисунок 6.24 – Вектор состояний для исходной программы" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.24-The-vector-of-current-program-states.png"/> 

Фактически, R1CS представляет собой список триплетов векторов _(a, b, c)_, для которых выполняется следующее условие:

*< a̲<sup>i</sup> · s̲ > × < b̲<sup>i</sup> · s̲ > - < c̲<sup>i</sup> · s̲ > = 0* (6.1)

Это равенство должно выполняться для каждой строки упрощенного кода, то есть контролируется соответствие каждого логического перехода к новому состоянию. 

> **_Замечание._** *Операция · обозначает перемножение значений векторов с последующим сложением результатов. Таким образом, если есть два вектора a и b, то для них эта операция выполняется следующим образом:*
*a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> · (b<sub>1</sub>, b<sub>2</sub>, ..., bn) = a<sub>1</sub>b<sub>1</sub> + a<sub>2</sub>b<sub>2</sub> + ... + a<sub>n</sub>b<sub>n</sub> .*

Отметим, что в качестве решения уравнения (6.1) должен выступать вектор _s_. Фактически, вектор _s_ является свидетельством (witness), и все его значения могут быть рассчитаны при помощи начального секрета и операций упрощенной программы (рис. 6.25). Сторона, которой известен секрет, может лично рассчитать все значения _witness_.

<img width="56%" alt="Рисунок 6.25 – Вычисление вектора witness" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.25-Calculating-the-witness-vector.png"/> 

Исходя из этого примера, давайте сформируем для первого перехода триплет векторов (рис. 6.26), для которых выполняется условие (6.1).

<img width="30%" alt="Рисунок 6.26 – Триплет векторов для первого перехода" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.26-Vector-triplet-for-the-first-transition.png"/> 

Для проверки правильности формирования векторов давайте проверим выполнение условия. Фактически, нужно умножить каждый из векторов на вектор решения _s_, после чего проверить, что произведения _a · s_ и _b · s_ уравновешиваются значением _c · s_. Процесс проверки изображен на рисунке 6.27.

<img width="40%" alt="Рисунок 6.27 – Процесс проверки правильности выбора векторов для первого перехода" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.27-Checking-the-correctness-of-chosen-vectors-for-the-first-transition.png"/> 

Таким образом, мы можем заметить, что векторы сформированы правильно и что они действительно являются отображением первой строки упрощенной программы. Таким же образом нам нужно сформировать и векторы для двух следующих логических переходов (рис. 6.28).

<img width="50%" alt="Рисунок 6.28 – Наборы векторов для второго и третьего переходов" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.28-Vector-sets-for-second-and-third-transitions.png"/> 

На рисунках 6.29 и 6.30, как и в предыдущем случае, изображена проверка условия (6.1) для второго и третьего переходов.

<img width="40%" alt="Рисунок 6.29 – Процесс проверки правильности выбора векторов для второго перехода" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.29-Checking-the-correctness-of-chosen-vectors-for-the-second-transition.png"/> 

<img width="40%" alt="Рисунок 6.30 – Процесс проверки правильности выбора векторов для третьего перехода" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.30-Checking-the-correctness-of-chosen-vectors-for-the-third-transition.png"/> 

### Quadratic arithmetic programs

Следующим шагом является преобразование структуры R1CS в QAP. Напомним, что на этом этапе у нас есть триплет наборов векторов, которые отображают изменение состояния на каждом этапе выполнения программы (рис 6.31).

<img width="56%" alt="Рисунок 6.31 – Наборы векторов для всех логических переходов" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.31-Vector-sets-for-all-logical-transitions.png"/> 

Для выполнения перехода к QAP необходимо преобразовать набор векторов в набор полиномов _A_, _B_ и _С_ [77]. Из трех групп, каждая из которых содержит 3 вектора, мы должны получить 15 полиномов третьей степени. Для получения полинома нам необходимо определить точки, через который проходит график, описываемый этим полиномом. Далее, используя эти точки (рис. 6.32) и интерполяцию Лагранжа, мы получаем полиномы.

> **_Замечание._** *При использовании интерполяции Лагранжа полином вычисляется следующим образом:*
<img width="50%" alt="Формула" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/formula-1.png"/>

<img width="40%" alt="Рисунок 6.32 – Набор точек для получений значений полиномов" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.32-The-set-of-points-for-polynomial-values.png"/> 

Далее на основании полученных значений точек, мы преобразование векторы в следующий набор полиномов так, как на рисунке 6.33.

<img width="40%" alt="Рисунок 6.33 – Получение необходимых полиномов" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.33-Obtaining-the-necessary-polynomials.png"/> 

Полученный набор полиномов является параметрами экземпляра QAP. Отметим, что все описанные действия выполняются единожды и могут использоваться для той же функции повторно. Чтобы убедится, что полиномы сформированы правильно, мы можем провести их проверку. Для этого можно попробовать пересчитать выходные значения при различных (используемых) значениях _x_ (рис. 6.34).

<img width="40%" alt="Рисунок 6.34 – Проверка правильности вычисления полиномов, описывающих первый переход" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.34-Checking-the-correctness-of-first-transition-polynomials.png"/> 

На рисунке 6.34 мы видим, что состояние значений полиномов дает тот же вектор, который был использован для первого перехода упрощенной программы. Можно таким же образом проверить соответствие полиномов триплетам векторов _a_, _b_ и _c_ для всех остальных переходов.

Для чего мы сделали все эти преобразования? Дело в том, что трансформация в QAP позволяет преобразовать равенство (6.1) в равенство следующего типа:

*A(x) ∗ B(x) - C(x) = 0*, где (6.2)
*A(x) = ­­­­A̲ ･ s̲, B(x) = B̲ ･ s̲, C(x) = C̲ ･ s̲*.

Отметим, что, как и в предыдущем случае, это равенство будет выполняться для каждого перехода _(х = 1, 2, 3)_. Однако при этом мы можем проверить соответствие нашего _witness_ этой задаче. Если мы изменим значение _witness_, например, вместо [1, 3, 9, 6, 0] возьмем [1, 3, 10, 6, 0], то равенство для переходов не выполнится (рис. 6.35).

<img width="40%" alt="Рисунок 6.35 – Проверка соответствия witness первому переходу" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.35-Checking-the-correspondence-of-witness-to-the-first-transition.png"/> 

В этом случае мы можем убедится, что, если Алиса предоставляет решение задачи, Боб, зная исходную программу (то есть значения векторов полиномов A, B и С), может проверить его корректность. 

Таким образом, мы полностью меняем структуру нашей изначальной задачи, приводя ее к форме QAP, решением которой является вектор значений переходов. Однако в этом случае Алисе все еще нужно опубликовать свое секретное значение, чтобы убедить Боба в знании этого значения.

Настало время для еще одного математического трюка. Этот трюк состоит в том, что уравнение (6.2) будет удовлетворять одновременно всем значениям х, только если результирующий полином будет без остатка делиться на следующий полином:

<img width="25%" alt="Формула" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/formula-2.png"/> 

В нашем случае, так как мы имеем только 3 перехода программы, искомый полином _Z(x) = (x − 1)(x − 2)(x − 3)_. Таким образом, мы снова можем преобразовать уравнение (6.2) в уравнение следующего типа:

*A(x) ∗ B(x) - C(x) = Z(x) ∗ H(x)*.

В итоге, проверка того, знает ли Алиса секрет, упрощается: фактически, ей необходимо доказать, что она знает такое значение _H(x)_, которое удовлетворяет описанному выше уравнению.

### Упрощенный протокол проверки знания

На основании рассмотренных концепций давайте рассмотрим, каким образом Боб проверяет, обладает ли Алиса знанием секрета.

Алиса и Боб согласовывают программу, которая должна выполнится, и на ее основании формируют набор полиномов для ее проверки. После этого Боб выбирает случайную точку _x_ (номер перехода), формирует полином _Z(x)_ и ослепляет его (мы ранее рассматривали, как происходит этот процесс). Полученное значение _E(Z(x))_ он передает Алисе.

Алиса, используя сформированное доказательство _witness_, может сформировать полиномы _A(x)_, _B(x)_, _C(x)_ и _H(x)_, что позволяет доказать делимость результирующего полинома на значение, полученное от Боба. После этого Алиса может ослепить полученные полиномы и передать их Бобу.

Боб не может раскрыть полученные значения. Однако здесь ему на помощь приходят свойства гомоморфного шифрования. Боб может провести операции над ослепленными значениями и убедится в том, что следующее равенство выполняется (если Алиса действительно знает _witness_):

*E(A(x)B(x) - C(x)) = E(Z(x)･ H(x))*.

Отметим, что все рассмотренное еще не является zk-SNARKs, а больше схоже с интерактивной проверкой знания Алисы; однако при этом отображаются основные концепции, которые используются для неинтерактивных протоколов доказательства с нулевым разглашением. Для превращения этого протокола в неинтерактивные доказательства с нулевым разглашением необходимы дополнительные модификации, которые мы рассмотрим в следующей части учебного пособия.

[РАЗВИТИЕ ДЕЦЕНТРАЛИЗОВАННЫХ ТЕХНОЛОГИЙ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-2/ru/7-evolution-of-decentralized-technologies.md)
