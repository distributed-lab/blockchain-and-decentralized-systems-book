**6 现代会计系统中确保隐私的方法**


    **6.1 CryptoNote 标准**

现代会计系统与传统系统的主要区别在于，它们使用加密操作，如数字签名，来证明币的所有权并确认对会计系统数据库所做的所有更改。然而，标准的加密算法往往限制了网络参与者的隐私（即交易链的简单性可能被揭示）。在这种情况下，诸如机密交易、环形签名、隐匿地址等方法便派上用场。

2013 年，推出了一系列 CryptoNote 标准。基于这些标准构建了匿名加密货币，如 Monero、Bytecoin、Karbo 等。在本节中，我们将探讨这些标准的一些关键概念，看看它们所使用的技术，并且考察在这些协议中是如何实现匿名性和不可追踪性的。

CryptoNote 系列包括十个标准，描述了构建匿名加密货币的基本概念。这些标准详细阐述了构建共享交易历史、区块和交易结构的技术，以及如何使用密钥为生成地址和签署交易（使用环形签名机制）[51]。

在本节中，我们将探讨 CryptoNote 标准的技术特点，并看看这些概念是如何在 Monero 加密货币的例子中应用的。

***CryptoNote 标准中的签名***

交易签名算法在系列的第一个标准中有所描述，但后来被另一个算法取代（更改进的版本）。CryptoNote 描述了一种一次性环签名算法。这种方法允许用户在保持匿名的情况下签署交易。这是因为验证者可以检查签名是由某个群体的参与者生成的，而无需知道确切是谁做的（我们在第 2.4 节中详细描述了数字签名的特征）。为了防止双重花费攻击，决定使用一次性签名机制（使用私钥镜像）。

让我们来看看什么是一次性环形签名以及它是如何计算的。类似于计算普通签名的值，用户需要有一对由私钥和公钥组成的密钥。然而，当使用环形签名时，其他参与者的公钥也被使用。现在，为什么这很重要？

当使用普通签名时，验证者可以明确地将签名值与现有的公钥（用户的标识符）联系起来，因为公钥用于检查签名（图 6–1）。


![alt_text](images/image1.png "image_tooltip")


图 6–1

为了计算环形签名，除了用户的私钥外，还需要使用他的公钥和所有组成员的公钥。环形签名允许验证者检查这个签名是否由组成员之一形成。由于验证过程中需要所有公钥，因此无法准确地确定谁是签名者（图 6–2）。


![alt_text](images/image2.png "image_tooltip")


图 6–2

***密钥与地址的关系***

与大多数加密货币不同，其中用户拥有一对密钥来管理一个地址/账户，CryptoNote 标准假设每个用户有两对密钥。实际上，用户生成了两个大型秘密值作为他的私钥。就像其他系统一样，公钥是这些秘密值与基点值相乘的结果。公钥的命名如下：公共花费密钥（public spend key）和公共查看密钥（public view key；稍后我们会讨论原因）。

地址是通过连接前缀（主网络为 18）、两个公钥和前面字段的校验和组成的（图 6–3）。校验和是一个 KECCAK 哈希值，截取前 4 字节。结果用 Base58 编码 [52]。


![alt_text](images/image3.png "image_tooltip")


图 6–3

***隐身地址***

大多数加密货币需要公开地址/账户。如果至少有一笔交易和相关方的关联被披露，任何第三方都可以将所有与该地址相关的交易以及相应的所有者联系在一起。在这种情况下，建议为每个新的入账付款和找零创建一个新的地址。然而，这种方法并不是最方便的，因为它涉及频繁的密钥生成，用户无法享受拥有一个地址/账户的便利。

CryptoNote 标准中使用了所谓的隐身地址。只有私钥的所有者才能访问它们，第三方很难揭示常规地址和隐身地址之间的关系。让我们看看这些地址是如何生成的，以及用户如何获得锁定在这些地址中的硬币（图 6–4）。


![alt_text](images/image4.png "image_tooltip")


图 6–4

爱丽丝暂时为自己生成两个密钥对，并生成一个地址。为了在第一阶段接收付款，爱丽丝将她的地址发送给鲍勃。鲍勃接收到地址后，从中提取两个公钥的值。然后，鲍勃生成一个一次性秘密值 r，并将其与基点相乘以获得 *R*。鲍勃然后使用这个得到的值形成一个一次性公钥，硬币将与之关联；只有相应的私钥的所有者才能访问它们。在这种情况下，一次性公钥的计算方式如下：

**P = H(r * **** || n) * G + **** (n 是输出指数)。**

在接下来的步骤中，鲍勃创建交易并将其发送到网络。为此，他创建了交易，提交未使用的输出作为输入，添加转账金额和一次性公钥值到输出，并将 *R* 的值放入额外字段中（稍后将考虑）。然后，在第三步，鲍勃发送交易以供验证者确认。

由于硬币被发送到一次性公钥，而不是直接发送到爱丽丝的地址，甚至她一开始也不知道她拥有哪些输出。因此，在第四步，她检查所有已确认交易的所有输出，寻找发给她的那一个。

对于每个输出，她计算以下值：

**P' = H(**** * R || n) * G + **。

如果这个值与交易输出中的 P 相同，那么该输出合法地属于爱丽丝。为了解锁它，她需要计算相应的秘密密钥：

**p = H(**** * R || n) + **

并签署下一笔使用该输出的交易。

***双重花费保护机制***

直接使用环签名可能让用户执行双重花费攻击。让我们来看一个例子，在这个网络中有四个用户，每个用户都拥有一个未花费输出（图 6–5）。


![alt_text](images/image5.png "image_tooltip")


图 6–5

每个输出都分配给一个单独的公钥。为了创建环签名，用户从其他未花费输出中收集公钥，然后形成环签名。假设爱丽丝想将硬币转到她的另一个地址，于是她创建了一个交易。她通过组合爱丽丝、鲍勃和卡罗尔的公钥来签署该交易（图 6–6）。


![alt_text](images/image6.png "image_tooltip")


图 6–6

实际上，验证者可以检查每个密钥是否分配了一个未花费输出，以及签名是否表明该输出已被使用。然而，验证者并不知道这些输出中的哪一个被使用。因此，并不可能阻止爱丽丝创建一个替代交易，将同样的硬币发送到另一个地址，然后使用鲍勃和戴夫的公钥进行签名（图 6–7）。


![alt_text](images/image7.png "image_tooltip")


图 6–7

如果没有引入额外的保护机制，验证者会将这个签名视为正确的。在这种情况下，资金会被转移两次。因此，CryptoNote 标准涉及使用私钥镜像作为保护系统免受双花攻击的方法。该机制能够检测是否使用了同一个私钥计算了多个签名，而不揭示私钥本身。私钥镜像是其哈希值。它用于验证签名，因此无法被替换。

如果爱丽丝尝试这样做，验证者将看到签名是使用相同的私钥计算的，因此冲突的交易将被拒绝。

***CryptoNote 的块结构***

CryptoNote 标准组织成一个区块链交易历史。每个块通过唯一标识符（即块的哈希值）与前一个块关联。让我们仔细看看 CryptoNote 中的区块结构（图 6–8）。


![alt_text](images/image8.png "image_tooltip")


图 6–8

如图所示，区块由三个部分组成：区块头、交易的 coinbase 部分和包含的交易标识符列表。请注意，区块本身除了标识符不包含任何交易数据。这是为了实现较小的区块大小；然而，完整节点仍然需要存储所有交易。

Monero 的区块与其他类似加密货币的关键区别在于其动态区块大小[53]。Monero 的平均区块大小是过去 100 个区块大小的平均值。最大区块大小不能超过平均大小的 2 倍。此外，协议还提供了对挖掘比平均值大的区块的矿工进行惩罚的机制。惩罚的计算方式如下：

，其中

*P *– 惩罚大小；*R* – 区块挖矿的基础奖励；*B* – 挖出的区块大小；*M* – 最近 100 个区块的中位数。

因此，如果所形成的区块具有最大允许大小，则其创建奖励等于惩罚额。值得注意的是，惩罚金额将支付给下一个挖出区块的验证者。

让我们仔细看看区块头及其所有字段（表 6.1）。

表 6.1


![alt_text](images/image9.png "image_tooltip")


在 *minorVersion* 和 *majorVersion* 字段中，分别指定了协议版本：第一个版本和验证节点支持的版本。*Timestamp* 字段指示区块的创建时间（以 UNIX 时间戳格式）。prevID 字段包含链中前一个区块的哈希值（标识符），*nonce* 字段包含证明解决资源密集型任务所需的值。

除了头部和交易标识符列表外，区块还包含交易的 coinbase 正文，用于支付给验证者的奖励。其他参与者也应该检查 coinbase 交易（例如，奖励金额是否与区块高度相符等）。我们稍后会进一步研究 coinbase 交易的结构。

让我们看看按照 CryptoNote 标准如何生成区块标识符。CryptoNight 哈希函数用于计算区块的哈希值。这个哈希函数的一个显著特点是，它总是准确等于所需内存的大量（大约 2 MB），这使得专用集成电路（ASIC）效率低下。如今，Monero 使用 CryptoNight v. 2，该算法由 Bitmain 于 2017 年设计。图 6–9 显示生成区块标识符的过程。


![alt_text](images/image10.png "image_tooltip")


图 6–9

请注意，KECCAK-256 函数用于获得哈希根值。例如，让我们看看 Monero 网络中的一个已确认区块（图 6–10）。


![alt_text](images/image11.png "image_tooltip")


图 6–10

***CryptoNote 中的交易结构***

交易结构在标准系列的第四部分中进行了定义。基于该协议的匿名货币中的交易类似于比特币交易，并且也采用 UTXO 模型（每个交易包含输入——链接到接收到硬币的交易——和包含花费条件的输出）。

每个交易包括两个部分组成：交易前缀和一组签名。交易前缀包含基本数据（谁向谁转账以及金额多少），其结构如下（表 6.2）。

表 6.2


![alt_text](images/image12.png "image_tooltip")


让我们以真实的 Monero 交易为例，看看其字段（图 6–11）。


![alt_text](images/image13.png "image_tooltip")


图 6–11

交易头包含两个字段：*version* 和 *unlock_time*。第一个字段显示了交易的版本号。在这种情况下，它的值为 2，这意味着交易支持环形保密交易机制。第一个协议版本仅实现了一次性环形签名，以隐藏硬币来源的历史。当环形保密交易被引入时，它们还允许隐藏转账金额。unlock_time 字段指示交易可以被确认的时间。

然后是交易输入。交易输入包含字段 *amount、key_offsets* 和 *k_image*。amount 字段包含输入中的硬币数量。在我们的例子中，这个字段的值为 0，意味着输入金额是隐藏的。key_offsets 字段包含键偏移索引号（每个连续的索引表示相对于上一个的偏移）。实际上，这些是 UTXO 数据库中未花费输出的索引。输出组用于形成环形签名。在我们的例子中，key_offsets 包含 11 个值。这意味着，除了发送者的密钥对之外，还有其他 10 个用户的公钥用于环形签名的计算。k_image 字段包含私钥图像的值，以防止双花攻击。

在输入之后，还有交易输出。在我们的例子中，输出的数量是 2，每个输出包含两个字段：*amount* 和 *key*。amount 字段包含交易输出的总和（以盲化形式），而 key 字段包含收件人的公钥。如前所述，key 是一次性的，并且第三方无法将其与收件人的主公钥关联（隐匿地址方法）。

其他所有交易数据包含了证明交易正确且可以被确认的证据。实际上，这些证据是数字签名（包括范围证明和环形签名）。值得注意的是，这些证明占据了交易大小的 70% 以上，而 Monero 中的平均交易大小是标准比特币交易大小的 8 倍以上。


    **6.2 MimbleWimble**

2016 年 7 月 19 日，一篇题为“MIMBLEWIMBLE”的论文被发布[54]。实际上，这是一个具有高用户隐私性和高系统可扩展性的网络构建协议。稍后，比特币社区中最著名的人之一，安德鲁·普尔斯特拉（英语：Andrew Poelstra），发布了一份更详细的文件，描述了该协议的细节和技术特征 [55]。

MimbleWimble 协议解决了哪些问题？第一个问题是大多数数字资产需要存储完整的交易历史，这在随着时间推移会显著增加。因此，验证者需要分配越来越多的物理内存来存储交易历史（否则完整的交易验证将变得不可能）。

第二个问题是，在一个无需许可的系统中，确保支付的保密性非常困难。如果我们看看比特币的会计系统，在经典版本中，交易详情包括了公钥、硬币发送者的签名、转账金额以及接收者的地址。这使验证者能够检查特定用户是否拥有他要花费的硬币，并确保输出的总和不超过输入的总和。公开性是比特币会计系统最重要的特征，但这并不能确保转账的保密性，而且允许交易参与者被去匿名化。此外，你可能会失去硬币的可互换性（特定地址的硬币所有者与其他硬币可以被区分开）。

MimbleWimble 结合几个概念：保密交易以确保转账的保密性，范围证明以证明特定输入和输出的总和不超过某些界限，CoinJoin 用于更好地混淆硬币的历史，以及 cut-through 技术来优化存储数据的大小，并减少交易和区块的大小。


```
MimbleWimble 的特征
转账保密性
简单的可扩展性
无需存储完整的交易历史
用户地址不在交易详情中存储
```


在我们深入研究 MimbleWimble 如何工作之前，先考虑一些椭圆曲线的基本性质。



1. 
不可逆性：将基点乘以一个标量的操作相对简单，但很难从已知基点的结果值中获得标量的值。已知私钥值 *x* 和基点 *G*，我们可以很容易地计算出公钥值 *X = x ∗ G*，但实际上无法从已知公钥中得出私钥值。


2. 
分配律：椭圆曲线上两点的和等于将标量相加后再乘以基点：*x ∗ G + y ∗ G = (x + y) ∗ G*。


3. 
交换律：重新排列基点乘子的顺序不会改变结果：*x ∗ (y ∗ G) = y ∗ (x ∗ G) = x ∗ y ∗ G*。
***MimbleWimble 交易模型***

与比特币协议类似，MimbleWimble 支持 UTXO 交易模型。这意味着交易包含一组输入（指向先前输出的链接以及所有权证明）和一组输出，包含转账金额和关于新硬币所有者的信息。需要注意的是，输出是完全花费的（不能仅花费特定输出的一部分），找零是一个单独的输出，所有权可以由发送者自己证明。

让我们看一个例子，当我们从完全公开的交易（类似于比特币中的交易）逐步转向带有隐私机制的交易时。假设哈利想要给他的朋友海德薇转账 8 个硬币。他只有两个未花费的输出，分别是 3 个和 5 个硬币。因此，这笔交易将类似于图 6–12 中所示的交易。


![alt_text](images/image14.png "image_tooltip")


图 6–12

为了确认交易，验证者会检查哈利是否确实拥有先前交易的输出，并且确认交易的输出总和不超过输入总和。在这种情况下，这种验证非常简单，因为金额是公开的（验证者只需将所有输入和输出相加，然后比较结果）。然而，哈利不想验证者知道他转了多少硬币（特别是费尔奇和他那只奇怪的猫）。因此，他需要将交易的输入和输出值盲化（隐藏）。

为此，MimbleWimble 协议为每个交易的输入和输出值使用 Pedersen 承诺。Pedersen 承诺用以下表达式表示：

**v ∗ H + x ∗ G**，其中，*v* 是特定输入或输出的总和；*H* 是椭圆曲线上的一般已知点；*x* 是盲化值（用户生成的秘密）；*G* 是椭圆曲线上的另一个一般已知点。


```
注意：在这个阶段，应该注意到还需要一个额外的盲化秘密。如果我们只是通过将传输金额乘以基点来隐藏金额，虽然不可逆特性可能会起作用，但由于传输金额的值域相对较小，对方可以通过暴力破解来猜测，并找到合适的传输金额。
```


让我们看看在这种修改之后输入和输出的值。例如，哈利使用前例中相同的输入，并使用秘密数值 19 和 37 来进行盲化。通过应用 Pedersen 承诺，他形成了一笔如图 6–13 所示的交易。


![alt_text](images/image15.png "image_tooltip")


图 6–13

现在，验证者无法看到转账金额，但仍然可以验证输出的总和不超过输入的总和：

**(3H + 19G) + (5H + 37G) – (8H + 56G) = 0**。

然而，这种交易结构存在一个全球性问题：它要求交易输入的盲化因子的总和与其输出的盲化因子的总和相等。因此，在这笔交易被发送后，哈利知道了海德薇的盲化因子（秘密），这意味着他可以从她那里窃取硬币（不应允许你对极地猫头鹰这样做）（图 6–14）。


![alt_text](images/image16.png "image_tooltip")


图 6–14

MimbleWimble 也解决了这个问题。如果为了接收交易，海德薇也需要确定她的秘密值怎么办？假设海德薇生成了她的秘密值等于 45。那么交易将如下所示（图 6–15）：


![alt_text](images/image17.png "image_tooltip")


图 6–15

现在，输出和输入的总和不像之前那样等于 0，而是等于

**(3H + 19G) + (5H + 37G) – (8H + 45G) = 11G.**

在这种情况下，验证者如何确认交易没有创造新硬币？事实上，这相当简单。如果输入的总和等于输出的总和，结果余额将是 *G* 上的一个公钥（只有当 *v_in * H - v_out * H = 0* 时才可能）。在计算（11G）后得到的值称为交易内核。

为了确认交易，验证者必须检查这个值确实是曲线上的公钥，并且各方共同拥有其共享的秘密密钥。最简单的证明方式是使用数字签名，该签名可以使用得到的公钥（交易内核）来验证。MimbleWimble 中的数字签名机制允许拥有共享秘密的一部分的各方共同计算这个共享值。

***范围证明***

到目前为止，一切似乎都说得通。但还有一个陷阱——这种类型的方案仅在输入和输出的值为正时才有效。然而，即使其中一个或多个输出是负数，用户仍然可以花费几个输出（图 6–16）。


![alt_text](images/image18.png "image_tooltip")


图 6–16

正如我们所看到的，其中一个交易输出中有一个负值；然而总金额加起来，从验证者的角度来看，交易是正确的：

**(3H + 19G) + (5H + 37G) – (–13H + 25G) – (21H + 7G) = 24G。**

为了证明输出和输入的总和是正数且不超过最大可能值，使用范围证明。它们也是密码承诺。在 2019 年，MimbleWimble 使用 Bulletproofs 作为形成和验证这种承诺的算法[56]。

***所有交易阶段***

在我们考虑了 MimbleWimble 交易的主要特点后，接下来我们看看这些交易是如何形成、传输和验证的。假设哈利有 100 枚硬币的未花费输出，并且他只想转移 50 枚给海德薇。在剩下的硬币中，他想支付 5 枚作为手续费，并且将 45 枚作为找零返回。因此，他形成了一笔如下类型的交易（图 6–17）（V1 是解锁硬币的秘密，V2 是接收找零的秘密，X 是输入、输出和手续费的总和，m 是附加数据）。


![alt_text](images/image19.png "image_tooltip")


图 6–17

哈利还为每个交易输出准备了范围证明。然后他将这笔交易发送给海德薇。

当海德薇收到这笔交易时，她会检查字段并生成自己的秘密值（混淆因子），形成公钥并计算输出的承诺值。然后，海德薇签署了涵盖冗余值、费用和交易元数据的交易内核。随后，海德薇将以下一组值返回给哈利（图 6–18）。


![alt_text](images/image20.png "image_tooltip")


图 6–18

当哈利收到这个数据集后，他就可以组成最终的交易并将其发送到网络进行确认。事实上，交易由两个部分组成：主体和内核。交易主体存储了所有交易输入和输出的承诺值以及每个输出的范围证明（图 6–19）。交易内核存储了冗余值（共享公钥）、签名值（哈利可以将他的签名值与海德薇生成的值进行聚合）、费用值以及额外的元数据（如果有）。


![alt_text](images/image21.png "image_tooltip")


图 6–19

***交易验证和分发***

当哈利完全组成了交易后，他将其发送给其中一个验证节点。接收交易的节点在将其分发给网络中的其他节点之前必须检查其有效性。交易验证过程如下：



1. 
验证者检查所有交易输入未使用。每个完整节点根据交易历史记录以未使用输出列表的形式存储最终状态。如果哈利的交易输出在这个列表中，那么它可以被成功使用。


2. 
验证者检查交易输出的金额是否在指定范围内（验证范围证明）。


3. 
验证者检查输入的总和是否等于输出和费用的总和。为此，验证者需要将所有输入和输出的承诺相加，并确保得到的值等于冗余值，并且冗余值是椭圆曲线的一点（有效的公钥）。


4. 
之后，验证交易内核的签名是否与获得的公钥匹配。


5. 
最后，进行与协议规则无关的系统检查，例如，检查费用金额是否足够让交易被验证者确认。
***没有地址***

在 MimbleWimble 中没有地址。每个交易必须由硬币的发送者和接收者共同发起。为了形成交易，双方需要直接离线沟通。请注意，硬币不能在没有接收者参与的情况下进行转移（与比特币不同，比特币可以将硬币发送到任何地址，而不需要接收者采取任何行动）。

在互动过程中，发送者会指示未花费的输出及其金额。接收者生成一个输出，指示计算后的盲化值。然后双方共同形成证明，以确认输出的总和不超过输入的总和，并验证范围证明。

***Cut-through 方法***

MimbleWimble 采用 cut-through （穿过）方法来移除与输入在同一个区块中列出的冗余输出。该方法可以使区块摆脱不必要的数据，并减少存储在区块链中的数据量。图 6–20 展示了如何移除冗余输出。


![alt_text](images/image22.png "image_tooltip")


图 6–20

因此，验证者仍然可以确保没有创造新的币（除了挖矿区块的奖励），因为输入的金额与输出的金额相等。

此外，这种输出的销毁（减少币转移的历史）不仅可以在一个区块中使用，还可以在多个区块之间使用（因为一笔交易的输入在任何情况下都指向上一笔交易的输出，除了 coinbase 交易）。结果，区块链的大小在系统运行过程中可以减少，如果验证者形成一个包含大量输入（销毁以前输出）和少量输出的区块。这意味着，验证者可以减少输入和输出，但同时他们必须保留所有交易内核的历史记录。

***交易和区块结构***

一个 MimbleWimble 区块由一个头部、一组输入、一组输出和一组交易核心组成。

表 6.3


![alt_text](images/image23.png "image_tooltip")


让我们使用网络中的一个已确认区块作为例子来仔细研究区块头结构（图 6–21）。


![alt_text](images/image24.png "image_tooltip")


图 6–21

因此，每个区块头都包含其生成时所依据的协议版本。区块头还包含前一个区块的哈希值，以及前一个区块头字段中的哈希根值（更具体地说是哈希山脉根值[57]）。接下来是区块的时间戳。

然后有三个哈希根值：为了区块输出、范围证明和交易核心。接下来是与解决资源密集型任务相关的一组值：复杂度、使用的算法等。区块的最后一个元素是所有已验证交易的核心的聚合值。


    **6.3 zk-SNARKs 入门**

在第一册教材中，我们讨论了零知识证明、其用途以及交互式和非交互式协议的主要区别。双方互动是通常需要的，因为第三方无法验证证明。在非交互式协议中，需要确保所有验证者都可以验证证明的知识。在这一节中，我们将解释非交互式证明的工作原理，并以 zk-SNARKs 为例来了解其实际应用。

这些结构起源于 2013 年，当时几位数学家发表了一篇基础文章。该文章描述了所谓的二次算术程序 [58]，它成为现代 zk-SNARKs 结构的基础。如今，SNARKs 由大量需要理解的组件组成，因此我们才能弄清楚这些结构是如何工作的 [74]。


```
同态加密  
多项式盲评估  
代数电路  
一级约束系统 (R1CS)  
二次算术程序 (QAP)  
```


***同态加密原理***

同态加密系统允许在加密数据上执行某些操作，以获得结果。例如，这类系统用于盲签名方案，我们在 2.4 节中讨论过。为了理解同态加密方案如何用于零知识证明的证据，我们首先需要看看这类方案的基本属性。


```
从密文中获取源数据的难度
源数据的变化导致函数输出的变化
在已知多个加密数据值，可以在它们之间执行算术运算
```


第一个特性是，第三方不能从加密值中获得原始值。这意味着，如果我们将同态加密函数表示为 *E(x)*，其中 *x* 是初始值，那么接收到 *E(x)* 结果的一方无法恢复 *x*（图 6–22）。


![alt_text](images/image25.png "image_tooltip")


图 6–22

第二个属性确保如果原始值不相等，相应的加密值也会不同（除非出现非常小的概率）。从形式上讲，这可以表示为：

如果 *x ≠ y*, 就 *E(x) ≠ E(y)*。

最后一个属性是最有趣的：拥有两个加密值的一方可以对它们执行算术操作，而不透露秘密值。因此，如果用户知道 *E(x)* 和 *E(y)* 的值，他可以执行 *E(x + y) *的操作并检查结果，而不会透露 *x* 和 *y* 的值。

让我们看一个说明这种方法的例子。假设爱丽丝想要向鲍勃证明她知道两个数，它们的和等于 15。设定秘密值* x = 13* 和 *y = 2*。双方共同确定模 *n = 17* 和基点 *g = 3*（我们将使用 RSA 作为加密算法）。为了向鲍勃证明她知道这些秘密，爱丽丝对它们进行盲化，得到两个值，然后将它们发送给鲍勃：

*E(x) = ** mod n = ** mod 17= 12 mod 17, E(y) = ** mod n = ** mod 17 = 9 mod 17*。

鲍勃则需要确保这些秘密的和确实为 15。为此，他将从爱丽丝那里收到的两个值进行以下操作：

*E(x + y) = ** mod n = ** mod n = 12・9 mod 17 = 6 mod 17*。

然后他独立加密已知结果 15，并比较得到的值：

*E(15) = ** mod n = ** mod 17 = 6 mod 17 ⇒ E(x + y) = E(15)。*

由于结果相同，爱丽丝可以证明给鲍勃她知道两个数的和为 15，而无需公开它们，而是以加密（盲化）的形式传输。因此，我们之前提到的属性得到了充分保证。

值得注意的是，同态系统也支持线性运算。因此，如果我们需要将盲化值乘以标量，可以按如下方式进行：

E(ax) =  mod n = E。

***关于多项式及其盲评估的一点介绍***

首先，让我们回顾一下多项式是什么。多项式可以表示为以下形式：

，其中， 是变量， 是固定系数。

因此，假设鲍勃知道一个特定的多项式，并希望确保爱丽丝也知道它的系数（她不想公开它们）。为此，他想要从爱丽丝那里获得 *E(F(x))* 的盲化值。如果不使用零知识证明，那么鲍勃可以将 *x* 的值发送给爱丽丝，并接收 *F(x)*。但如果鲍勃不想要将秘密含义传递给爱丽丝怎么办？

为此，可以使用我们之前研究的同态加密。鲍勃最初生成 *E(F(x))* 并“记住”它，以便与从爱丽丝获得的值进行比较。在此之后，他生成一组多项式组件的盲化值，并将它们发送给爱丽丝：

*E(1), E(x), E(**) ,..., E(**)。*

注意，如果在这个阶段爱丽丝知道多项式的系数，她将能够提供 *E(F(x))* 的正确值。这是如何发生的？我们之前研究了盲化值如何与标量相乘。同样的情况也发生在这里。爱丽丝可以从鲍勃获得的盲化值乘以她知道的系数。结果，她将得到以下值：

。

所得的盲化值被传输给鲍勃，并与之前计算的值进行比较。如果值相同，那么鲍勃就确信爱丽丝知道多项式的系数（除了非常低的概率）。同时，零知识证明的属性得到了满足：爱丽丝不知道鲍勃的秘密，保留了系数值，但使鲍勃相信她知道这些值。

***代数电路***

现在，让我们暂时远离多项式盲化的概念，看看什么是*二次运算程序*（英语：*quadratic arithmetic programs；QAP*），以及它们在零知识证明中扮演的角色。关键在于，为了使 SNARKs 和许多其他协议正常运行，原始任务需要以某种方式进行修改。QAPs 正是为这个任务而使用的[75]。

例如，爱丽丝想向鲍勃证明她知道满足以下方程式的 x 的一个值，而不透露秘密值本身：

* - x - 6 = 0。*

我们可以将同样的方程表示为以下函数：


![alt_text](images/image26.png "image_tooltip")


实际上，爱丽丝必须将秘密值作为函数输入，如果输出等于 0，那么她就证明了她知道所需的秘密。然而，在当前形式下这是不可能的，因为为了让鲍勃检查爱丽丝的知识，他必须独立执行这个函数，而在这种情况下，他就会发现她的秘密值。

要创建 QAP，我们首先需要通过将其转换为只有两种类型的运算符的序列来简化该函数 [76]：



1. 
赋值运算符 (=)；


2. 
算术运算符 (+, −, /, ∗)。
因此，你可以将函数转换为一组状态转换，这可以在图表和函数操作集的形式中进行表示（图 6–23）。


![alt_text](images/image27.png "image_tooltip")


图 6–23

***一级约束系统 (R1CS)***

现在我们可以将接收到的状态（代码的简化版本）转换为 R1CS。要做到这一点，我们首先需要创建一个状态向量（图 6–24），其中包含简化程序的所有变量以及值 1（表示常数值）。


![alt_text](images/image28.png "image_tooltip")


图 6–24

实际上，R1CS 是一个向量三元组列表 (*a, b, c*)，对于它们，以下条件成立：

 （6.1）。

每一行简化代码都必须满足这一等式。这意味着每个逻辑转换与新状态的对应关系被控制。


```
注意：""操作表示向量值的乘积和后续的结果相加。因此，如果有两个向量 a 和 b，这个操作的执行方式如下：a1, a2, ..., an · (b1, b2, ..., bn) = a1b1 + a2b2 + ... + anbn。
```


需要注意的是，向量 *s* 必须作为等式 (6.1) 的解。实际上，向量 *s* 是一个见证，其所有值可以通过初始秘密和简化程序操作来计算（图 6–25）。知道秘密的一方可以独立计算所有*见证*值。


![alt_text](images/image29.png "image_tooltip")


图 6–25

基于这个例子，让我们形成一个向量三元组，以满足第一状态转换的条件 (6.1)（图 6–26）。


![alt_text](images/image30.png "image_tooltip")


图 6–26

为了验证向量是否正确形成，让我们检查是否满足条件。实际上，我们需要将每个向量与解向量 *s* 相乘，然后验证* a ･ s* 和 *b ･ s* 的乘积是否被 *c ･ s* 的值平衡。检查过程如图 6–27 所示。


![alt_text](images/image31.png "image_tooltip")


图 6–27

因此，我们可以看到这些向量是正确形成的，并且它们确实是简化程序的第一行的映射。同样，我们需要为接下来的两个逻辑转换形成向量（图 6–28）。


![alt_text](images/image32.png "image_tooltip")


图 6–28

与之前的情况一样，图 6–29 和 6–30 显示了对第二次和第三次转换的条件检查（6.1）。


![alt_text](images/image33.png "image_tooltip")


图 6–29


![alt_text](images/image34.png "image_tooltip")


图 6–30

***二次算术程序***

下一步是将 R1CS 结构转换为 QAP。请注意，在这个阶段，我们有一个向量的三元组，这些向量显示了程序执行每个阶段的状态变化（图 6–31）。


![alt_text](images/image35.png "image_tooltip")


图 6–31

为了转换到 QAP，必须将向量转化为多项式集 *A、B* 和 *C*[77]。在这三组（每组包含 3 个向量）中，我们需要获得 15 个三次多项式。要获得一个多项式，我们需要确定其通过的点。然后，使用这些点（图 6–32）和拉格朗日插值法，我们可以得到多项式。


```
注意：使用拉格朗日插值法时，多项式的计算方式如下：
```



![alt_text](images/image36.png "image_tooltip")



![alt_text](images/image37.png "image_tooltip")


图 6–32

接下来，根据获得的点值，我们将向量转化为下一组多项式，如图 6–33 所示。


![alt_text](images/image38.png "image_tooltip")


图 6–33

得到的多项式集作为 QAP 实例参数。请注意，所有描述的操作都是一次性的，并且可以针对同一个函数重复使用。为了确保多项式正确生成，我们可以对其进行检查。为此，我们重新计算不同（已使用的）*x* 值的输出值（图 6–34）。


![alt_text](images/image39.png "image_tooltip")


图 6–34

在图 6–34 中，我们看到多项式值的状态给出了与第一个简化程序的转换所使用的相同向量。同样，我们可以验证这些多项式是否为所有其他转换对应于 a、b 和 c 向量三元组。

我们为什么要进行这些转换？这个想法是 QAP 转换允许我们将方程 (6.1) 转换为以下类型的方程：

*A(x) ∗ B(x) - C(x) = 0, 其中 (6.2) A(x) = ­­­­A̲ ･ s̲, B(x) = B̲ ･ s̲, C(x) = C̲ ･ s̲。*

请注意，与之前的情况一样，这个方程在每个转换（*x = 1, 2, 3*）中都会成立。然而，我们可以验证我们的见证是否与这个任务相对应。如果我们改变见证值，例如，取 *[1, 3, 10, 6, 0]* 代替 *[1, 3, 9, 6, 0]*，那么转换的方程将不成立（图 6–35）。


![alt_text](images/image40.png "image_tooltip")


图 6–35

在这种情况下，我们可以确保如果爱丽丝为这个任务提供了一个解，鲍勃可以在知道原始程序的情况下验证其正确性（多项式向量 *A、B* 和 *C* 的值）。

因此，我们完全改变了原始任务的结构，将其转换为 QAP 形式，其解是转换值向量。然而，在这种情况下，为了让鲍勃相信她知道这个值，爱丽丝仍然需要公布她的秘密值。

是时候使用另一个数学技巧了。秘诀就是只有当结果多项式能够被以下多项式准确整除时，方程 (6.2) 才能同时满足所有 x 值：


![alt_text](images/image41.png "image_tooltip")


在我们的例子中，由于我们只有 3 个程序转换，所需的多项式是 *Z(x) = (x − 1)(x − 2)(x − 3)*。因此，我们可以再次将方程 (6.2) 转换为以下类型的方程：

*A(x) ∗ B(x) - C(x) = Z(x) ∗ H(x)。*

结果，检查爱丽丝是否知道秘密值变得更容易：实际上，她需要证明她知道满足上述方程的* H(x) *的值。

***简化的知识证明协议***

基于我们讨论的概念，让我们看看鲍勃如何检查爱丽丝是否有一个秘密。爱丽丝和鲍勃同意需要执行的程序，并基于此形成一组用于验证的多项式。

之后，鲍勃选择一个随机点 x（转换编号），形成一个多项式 *Z(x) *并对其进行盲化（我们之前讨论过这个过程是如何发生的）。他将获得的 *E(Z(x)) *传递给爱丽丝。

爱丽丝使用生成的见证证明来形成多项式 *A(x)、B(x)、C(x)* 和 *H(x)*。这使她能够证明所生成的多项式可以被她从鲍勃那里获得的值整除。然后爱丽丝可以对生成的多项式进行盲化并传递给鲍勃。

鲍勃不能公开他得到的值。然而，同态加密的属性可以帮助他。鲍勃可以对盲化值进行操作，并验证以下方程是否成立（如果爱丽丝确实知道*见证*）：

*E(A(x)B(x) - C(x)) = E(Z(x)･ H(x))*。

请注意，上面所讨论的仍然不是 zk-SNARKs。它更像是对爱丽丝知识的互动测试；然而，我们已经看到了一些在非交互式零知识证明协议中使用的基本概念。要将此协议转变为非交互式零知识证明，我们需要添加额外的修改，这将在本教材的下一卷中讨论。

