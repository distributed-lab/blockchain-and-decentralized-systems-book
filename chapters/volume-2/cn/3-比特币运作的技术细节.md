**3 比特币运作的技术细节**


    **3.1 比特币脚本的设计和特性**

设置硬币分配条件有三种主要方法：



* 图灵完备语言（以太坊 - Solidity）
* 非图灵完备语言（比特币 - 比特币脚本）
* 模板智能合约（比特股，恒星等）

为了更好地理解它们之间的区别，让我们来看一下以下图示（图 3–1）:


![alt_text](images/image1.png "image_tooltip")


图 3–1

*图灵完备语言*允许设置任意的硬币消费条件，并实现包含循环、函数调用等复杂智能合约。一个特定的限制是需要严格的代码审计，因为事先不清楚智能合约代码中的任何错误可能导致什么样的故障。

*非图灵完备语言*，如比特币脚本，允许使用一组预定义操作来组成任意顺序。通常，这些操作的集合限制在几十个，但同时这些操作是安全实现的，并且可以轻松地设置最常见（也是最频繁使用）的条件。

*模板智能合约*是一组预先制定的解决方案。这个集合非常有限，用户不能添加任何额外的功能（至少不能很快地添加，为此她需要更新协议）。然而，这些功能的实现是最优化和安全的。

在本节中，我们将详细讨论比特币脚本的结构。本节将分为两部分：首先是主要的可用操作和基本原理，其次是应用特点以及比特币脚本如何用于设置执行交易条件的现实示例。

尽管比特币脚本不允许编写任意智能合约，但开发人员积极利用它来实现在比特币之上运行的协议。因此，可以实现一种情景，即只有在满足几个数字签名或任何其他条件（仅在经过一定时间后）之后才能使用比特币。

正如本书第一册中所指出的，比特币交易验证涉及检查硬币所有权证明（证据），该证据必须满足花费硬币的条件。值得注意的是，这些证据在交易的输入中包含，而花费条件则包含在相应的输出中（图 3–2）。


![alt_text](images/image2.png "image_tooltip")


图 3–2

这些条件和证明通常由数字钱包自动生成。为了描述它们，比特币协议使用一种特殊语言，称为比特币脚本 （英语：Bitcoin Script）。除了向常规地址付款之外，这种语言还允许实现相当复杂的硬币花费条件，特别是那些只能在特定时刻满足的条件。

如你所知，每个交易都有称为 scriptPubKey 和 scriptSig 的字段。scriptPubKey 字段包含用户必须满足的一些条件的描述，以便使用硬币。scriptSig 字段包含满足这些条件所必需的数据。两个字段结合在一起就是脚本。网络的节点执行此脚本，并根据执行结果决定交易是否有效。实质上，比特币脚本允许验证条件可以以任意顺序描述的交易。

***比特币脚本是如何执行的？***

比特币脚本是一种非图灵完备的指令描述语言。在比特币中，它用于设置和满足花费硬币的规则。该语言是基于堆栈的，并使用"逆波兰表示法"来表示操作数。

非图灵完备意味着该语言的功能有限，而且不支持跳转和循环执行。因此，该脚本排除了进入无限循环的可能性，从而可以限制恶意方创建复杂交易并减慢整个系统的速度。

"逆波兰表示法"意味着操作符跟在操作数后面，表达式从左到右读取。这种类型比普通的代数表示法要简单得多，因此它导致的计算错误较少。举个例子，让我们考虑对数字执行几个算术操作。在正常的代数表示法中，表达式如下所示：

**(2 + 4) * 5 / 10**

如果我们将这个示例表示为堆栈操作集合，那么它将具有以下形式：

**24 + 5 * 10 /**

有点不寻常，对吧？然而，下面的图表清楚地显示了所有计算步骤的顺序（图3–3）。


![alt_text](images/image3.png "image_tooltip")


图3–3

逐步具体步骤如下：



1. 首先，将值 2 放入堆栈。
2. 接下来，将值 4 推入堆栈。现在在堆栈顶部是值 4，在其下是值 2。
3. 接着进行加法操作。为此，取出堆栈顶部的两个值，相加，然后将结果放回到堆栈顶部。现在堆栈顶部是值 6。
4. 接下来，将值 5 放在堆栈顶部。
5. 执行 5 和 6 堆栈顶部的两个值的乘积，得到结果（30），并将其放在堆栈顶部。
6. 将值 10 放入堆栈。
7. 对于除法操作，上方的操作数（10）作为除数，结果（3）放在堆栈顶部。

正如我们所看到，使用这种方案进行计算非常简单明了。然而，在上面的例子中，我们考虑了一个带有简单算术运算的示例，其中操作数是自然数。在比特币脚本中，操作和操作数更加复杂和多样。

***比特币脚本中的操作***

在比特币脚本中，操作有一种特殊的写法，是OP_code（以下简称 OP-code）。每个 OP-code 可以分为两部分：«OP_» 的前缀和直接操作名称。特定的 OP-code 告诉计算机（虚拟处理器）在执行期间应该执行哪些特定的操作序列。每个操作由一组比特表示，由虚拟处理器读取和执行。


```
比特币脚本中的操作
7 个执行控制操作
19 个堆栈交互操作
27 个算术操作
10 个加密操作
```


执行控制操作包括诸如 OP_IF、OP_ELSE、OP_NOTIF、OP_ENDIF、OP_RETURN 等 OP 码，它们使得比特币脚本支持分支操作（从而提供了创建多个独立的币花费条件的能力）。这些操作的逻辑与常见编程语言中执行 if / else 语句的逻辑没有区别。请记住，比特币脚本是一种非图灵完备语言，因此没有像 for、while 等循环操作符。

执行控制操作包括诸如 OP_IF、OP_ELSE、OP_NOTIF、OP_ENDIF、OP_RETURN 等 OP 码，它们使得比特币脚本支持分支操作（从而提供了创建多个独立的币花费条件的能力）。这些操作的逻辑与常见编程语言中执行 if / else 语句的逻辑没有区别。请记住，比特币脚本是一种非图灵完备语言，因此没有像 for、while 等循环操作符。

堆栈交互操作由诸如 OP_DROP、OP_DUP、OP_ROLL、OP_SWAP、OP_ROT 等 OP 码表示。它们旨在对堆栈中的值进行操作，允许你控制其元素（删除、移动、复制元素等）。

堆栈项比较操作包括操作 OP_EQUAL 和 OP_EQUALVERIFY。这些操作的区别在于 OP_EQUAL 仅返回一个 true/false 值（比较操作结果），基于此，OP_EQUALVERIFY 终止或继续执行下一个脚本操作。

算术操作包括加法（OP_ADD）、比较（OP_NUMEQUAL）、查找最小和最大数的操作（OP_MIN、OP_MAX）等等。

加密操作包括操作 OP_RIPEMD160、OP_SHA1、OP_SHA256，它们允许计算相应的哈希值。操作 OP_HASH160 和 OP_HASH256 计算双重哈希（在第一种情况下，这是 SHA-256 和 RIPEMD 的顺序计算，而在第二种情况下，是两次进行的 SHA-256 哈希）。还包括单个签名和多重签名验证（OP_CHECKSIG、OP_CHECKMULTISIG）。

值得注意的是，除了将值推送到堆栈的操作之外，所有操作都是无参数的。这意味着这些操作只能使用堆栈上的值，并且无法输入堆栈之外的值。因此，在使用比特币脚本并设置条件时，需要考虑最大堆栈容量限制为 520 字节。

总之，以上介绍的材料让你对比特币脚本的特点以及其中的计算与现有操作有了一个了解。现在让我们看看它在真实比特币交易中的应用。

***为 P2PKH 比特币脚本执行的示例***

让我们来看一个情况，当硬币发送到一个与特定公钥哈希相关联的常规地址（P2PKH，或支付到公钥哈希）。 设置支出条件的脚本，与满足这些条件的脚本结合在一起，如图 3–4 所示。

你在左侧看到一个数据堆栈，在右侧是脚本本身。脚本行的前两个组件是签名值和公钥值，所谓的解锁脚本，即在使用输入硬币的交易中指定的脚本（位于 scriptSig 字段中）。 然后是数据集是指示交易输出的锁定脚本（交易 scriptPubKey 字段）。

换句话说，图表显示了两个脚本的串联：解锁硬币的脚本和锁定硬币的脚本。当节点验证交易时，这两个脚本被合并以执行对硬币支出条件的检查。

在脚本连接之后，完整的操作数集按顺序执行。执行指针逐个遍历每个操作数和每个数据片段。如果执行指针指向一个数据片段，那么它将被推送到堆栈上。正如我们在图表中所见，脚本执行指针顶部指向的是签名数据，稍后将其推送到堆栈上。接下来，执行指针指向公钥 - 它也被推送到堆栈上。第三步是执行复制操作，这意味着将位于堆栈顶部的值复制并再次放置到堆栈上（堆栈顶部的值是公钥的值）。


![alt_text](images/image4.png "image_tooltip")


图 3–4

这意味着首先对堆栈顶部的值进行长度为 256 位的 SHA-2 算法哈希，然后再通过 RIPEMD-160 函数进行长度为 160 位的哈希。该操作与接收地址时对公钥进行哈希的操作完全相同。最终获得的值就是地址。


![alt_text](images/image5.png "image_tooltip")


图 3–5

我们在堆栈中有一个签名、一个公钥，以及公钥的哈希值。脚本执行指针指向了交易输出中指定的地址。这个数据也会放到堆栈上（图 3–6）。


![alt_text](images/image6.png "image_tooltip")


图 3–6

接下来是 OP_EQUALVERIFY 的比较操作。对比堆栈的前两个元素。如果它们相等（逐字节比较），则将这些数据从堆栈中删除，并返回 true（这个值不会放在堆栈上，但它决定了是否会继续执行脚本），认为检查成功。然后，签名和公钥值保留在堆栈上。因此，OP_CHECKSIG 操作使用这两个操作数并使用公钥验证签名（图 3–7）。


![alt_text](images/image7.png "image_tooltip")


图 3–7

如果交易签名有效（签名覆盖了交易的字段），则验证的结果为 true，并将此值推送到堆栈中。这完成脚本的执行。数据传递给调用函数并在那里进行检查。如果堆栈为 true，则表示此交易输入的验证是正确的。如果所有交易输入都已正确验证，则整个交易被认为是正确的。

***多重签名示例***

现在，让我们看看如何使用比特币脚本实现多重签名。一个需要多个密钥的条件由以下脚本锁定（作为示例，我们实现了 2 个 3 多重签名）：

**scriptPubKey : OP_0 OP_2 &lt;pubKeyA> &lt;pubKeyB> &lt;pubKeyC> OP_3 OP_CHECKMULTISIG**

解锁脚本如下所示：

**scriptSig : &lt;sig1> &lt;sig2>**

在这种情况下，OP_2 指示 scriptSig 中必须提供的签名数量，OP_3 指示签名必须匹配的提供公钥数量。

脚本的启动是基于将包含在 scriptSig 字段中的签名值推送到堆栈上（图 3–8）。


![alt_text](images/image8.png "image_tooltip")


图 3–8

值 0 和 2 被放置在堆栈上（根据应该验证的签名数量），如图 3–9 所示。值 0 没有任何意义；它是由于 OP_CHECKMULTISIG 操作的特性而添加的，当执行时，这种操作会删除一个额外的堆栈值。


![alt_text](images/image9.png "image_tooltip")


图 3–9

然后，所有公钥值（图 3–10）和一个值为 3（根据公钥值的数量）被推送到堆栈上。


![alt_text](images/image10.png "image_tooltip")


图 3–10

然后执行操作 OP_CHECKMULTISIG（图 3–11）。


![alt_text](images/image11.png "image_tooltip")


图 3–11

OP_CHECKMULTISIG 操作的执行方式如下：首先，该操作检查堆栈顶部的密钥是否与靠近堆栈顶部的签名匹配。然后，在任何情况下，密钥会被删除（因为每个密钥仅检查一次，所以它们的位置应与提供的签名的位置相对应）。该过程重复进行，直到所有签名都经过验证。如果所有签名都有效，则返回 true；否则返回 false。

这种方案很少被使用，因为在这种情况下，scriptPubKey 字段中的数据量相当大，因此交易费用也会增加。与这种方案相比，经常使用的是付款到脚本哈希（英语：pay-to-script-hash；P2SH）方案，该方案以哈希值的形式传递整个条件。需要解锁货币的一方必须提供脚本本身以及执行它所需的数据。

***使用锁定时间机制***

使用比特币脚本，我们还可以设置一种条件，即只有在一定时间之后才能使用货币。要设置这样的条件，使用以下脚本：

**&lt;time> OP_CHECKLOCKTIMEVERIFY OP_DROP OP_DUP OP_HASH160 &lt;address_В> OP_EQUALVERIFY OP_CHECKSIG**

值得注意的是，这个脚本与 P2PKH 脚本的内容不同，因为它包含以下部分：&lt;time> OP_CHECKLOCKTIMEVERIFY OP_DROP。让我们来看这个特定部分是如何执行的，因为除此之外，其余脚本的执行方式与上面的示例相同。

首先，锁定时间值被放置在堆栈的顶部（图 3–12）。


![alt_text](images/image12.png "image_tooltip")


图 3–12

接下来，OP_CHECKLOCKTIMEVERIFY 操作将 &lt;time> 参数与包含在交易头中的 lock_time 字段进行比较（图 3–13）。只有当 lock_time 的值大于堆栈顶部的值（&lt;time>）时，才能使用比特币。


![alt_text](images/image13.png "image_tooltip")


图 3–13

随后，OP_DROP 操作移除堆栈的顶部值（图 3–14），该值包含用于解锁的时间值，如果 OP_CHECKLOCKTIMEVERIFY 返回 TRUE 并继续执行脚本，则我们不再需要该值。


![alt_text](images/image14.png "image_tooltip")


图 3–14

***不寻常的比特币脚本交易***

2012 年 12 月 13 日，一笔交易被添加到比特币区块链中。一比特币被转移给提供与哈希值对应的数据的人。

该交易包含以下脚本：

**OP_HASH256 6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000 OP_EQUAL**

这笔被称为“Transaction puzzle”的交易要求接收方提供数据，当对其进行哈希处理时，得到的值与硬币支出条件中存储的值相匹配。该脚本可以用图 3–15 图解了。


![alt_text](images/image15.png "image_tooltip")


图 3–15

交易的多样性并不止于此。网络上存在一些要求满足特定条件的交易，而这些条件又需要特定的签名值。还有一些交易，其条件要求包含多个分支。比特币脚本是设置硬币支出条件的强大工具。其结构和组织方式不允许恶意方设置一个可能会显著过载网络的场景。同时，用户可以在正确使用所有功能时准确指定硬币的使用方式。

***比特币交易统计***

如果我们分析 2018 年 8 月至 2019 年 8 月期间比特币区块链上的交易情况，对于某些比特币脚本的类型和相关交易类型的使用统计如下（图 3–16）[23]：


![alt_text](images/image16.png "image_tooltip")


图 3–16

值得注意的是 P2SH 交易。许多人可能已经想到了，过去一年一笔 P2SH_MULTISIG 交易也没发送。然而，这并不是真的。事实是，直到 P2SH 交易的输出被花费，你无法确定它包含了哪种脚本（其中只有脚本的哈希值），因此，进行了什么类型的操作。如果我们看一下过去一年交易输入的统计数据，那么我们就可以看到每种类型的 P2SH 交易数量（图 3–17）。


![alt_text](images/image17.png "image_tooltip")


图 3–17

然而，在这种情况下，发送的交易数量并不总是与传输的硬币数量相匹配。因此，如果我们从传输的硬币数量的角度分析交易统计数据，我们发现 P2SH 交易占比较大（超过 58%）；尽管发送的总交易数量显示 P2PKH 交易仅约占 50％（图 3–18）。


![alt_text](images/image18.png "image_tooltip")


图 3–18

*****常见问题*****

*“在比特币交易中还可以找到什么其他“Transaction puzzles”？”*

2013 年，网络中添加了一笔交易以接收资金；但是，必须提供两行不同的文本，这两行文本使用 SHA-1 算法会产生相同的哈希值。换句话说，为了解锁这些资金，必须检测到一个冲突。然而，2017 年发现了这种冲突，并且这些资金被转移到成功解决这个“谜题”的用户的地址。


    **3.2 比特币中的密钥格式**

首先，值得注意的是，数字化资产的全球趋势很可能会导致用户迟早要求直接管理其数字资产的手段。就像浏览器允许在执行复杂的交互操作时简单地使用网站一样，数字钱包是管理数字化资产的便捷方式。然而，在这种情况下，用户需要能够操作密钥，因为通过密钥访问资产。因此，密钥格式的问题似乎只是次要的，即使是普通用户也需要有足够的了解。

因此，在管理比特币时，使用了三个对象：私钥、公钥和比特币地址。在这个阶段，对每个组件的最简单的定义就足够了。私钥是一个随机生成的 256 位数；公钥是从私钥计算出来的（公钥的长度为 512 位），而比特币地址则是使用两种不同的哈希算法得到的公钥的哈希值（160 位）。

稍后我们将考虑比特币中最常用的私钥和公钥编码格式。每种格式都有其独特的特点，因此它们应该分别进行研究。


```
比特币中的密钥编码格式
Hex（Base 16 编码）
WIF（钱包导入格式）
BIP38（加密私钥）
```


由于比特币使用椭圆曲线上的加密学，公钥是曲线上的一个点，具有两个坐标。因此，我们可以用两个坐标 *X* 和* Y* 来描述任何公钥。然而，这并不是表示公钥的唯一可能形式。

让我们来看在笛卡尔坐标系中公钥的样子（图 3–19）。在椭圆曲线图上，有一个点 *P（X；Y）*，这是用户的公钥。这个点有两个坐标：横坐标是 *X* 和纵坐标是 *Y*。因此，可以通过将点* P* 的横坐标* X *的值代入曲线方程中来计算 *Y* 的值。


![alt_text](images/image19.png "image_tooltip")


图 3–19

由于在椭圆曲线方程 *Y² = X³ + 7* 中包含了 *Y²*，因此对于每个参数 X，都存在两个值的* Y*：正值和负值。为了严格确定并区分所需点*（P）*与对称点*（-P）*，除了参数 *X* 外，还需要知道函数 *Y* 值的符号。基于这些规则，构建了一种压缩的公钥格式。

***压缩密钥格式***

首先，从私钥形成常规的公钥，该公钥具有 *X* 和 *Y* 坐标。然后，连接坐标值，并在序列化密钥的开头添加一个特殊的前缀，该前缀允许严格区分此格式与其他格式。在十六进制表示中，这样的前缀的值为“04”。因此，未压缩的公钥是一个包含 65 字节的序列。

要获得此类公钥的压缩格式，仅需要 *X* 坐标、*P* 点和指示 *Y* 坐标符号的特殊前缀（并且还表示这不仅仅是一个压缩的公钥格式）。对于 *Y* 的正值，使用前缀“02”，对于负值，则使用前缀“03”（图 3–20）。同时，公钥的格式发生变化，现在它的长度为 33 个字节的序列。由于地址是公钥的双哈希结果，它也会发生变化。


![alt_text](images/image20.png "image_tooltip")


图 3–20

因此，对于相同的私钥，可能会有两个地址。因此，稍后将讨论的密钥格式将有两个选项：压缩和常规。这是为了我们能够清楚地了解我们需要根据该格式计算哪些公钥：压缩或未压缩的。

***私钥格式***

有许多私钥表示格式。几乎每天都会提出各种改进或新的私钥格式的建议，因为它们可以应用于许多问题。然而，在任何格式中通常都使用相同的数据，只是它们的编码方式不同。下面我们将考虑它们的三种主要格式及其常规和简洁版本。

十六进制，或者 Base16，是一种将数字以十六进制表示的格式。它主要用于软件中，例如在网络节点和移动钱包之间的通信过程中。它通过增加数据的可读性来简化错误的查找和应用程序的调试。

值得注意的是，常规的十六进制只是一个私钥，但是还有一个压缩私钥的十六进制选项。在这个选项中，除了私钥外，还会在末尾添加一个字节的数据，这个数据在十六进制数系统中的形式为“01”（图 3–21）。乍一看，这里有些不一致，因为压缩私钥比常规私钥要长。然而，这是为了让用户确定应该从这个私钥生成哪些公钥。


![alt_text](images/image21.png "image_tooltip")


图 3–21

另一个重要的私钥格式是钱包导入格式（WIF）。它允许方便地创建私钥的备份副本或将其从一个钱包转移到另一个钱包。因此，该格式的一个主要特点是其增加了对人类的可读性。为此，使用了一种特殊的 Base58Check 编码系统。它涉及存在一个校验和和一个额外的字节来指示版本（这有助于用户在视觉上识别格式并理解他面前的内容，同时也有助于软件识别输入的确切内容）。

在普通的WIF中，以 Base58Check 编码的版本字节转换为字符“5”。压缩的 WIF 版本与普通版本类似，但有一个区别：输入是一个压缩的私钥，其中末尾有一个“01”字符的组合。尽管版本字节与普通 WIF 中的版本字节相同，但编码值中的前缀从“5”更改为“K”或“L”（图 3–22），实际上，输入数据的长度发生了变化。由于这个原因，溢出增加了，第一个字符发生了变化，尽管版本字节保持不变。


![alt_text](images/image22.png "image_tooltip")


图 3–22

私钥格式的最后一个是加密私钥。所有先前格式的共同基本问题是私钥的存储。因此私钥存储安全性的非常重要的问题仍然存在，因为私钥可以完全访问用户的货币。并且 BIP38 的开发人员提议引入一种新的私钥编码格式，即所谓的加密私钥[50]。它允许备份私钥或将其转移到另一个钱包或另一个系统，并且重要的是以安全的方式进行。

在这里使用了一种特殊的加密算法，该算法接收私钥和仅用户知道的密码短语作为输入。通常，在这种情况下，私钥以 WIF 格式呈现，但也可以使用任何其他格式。党使用密码短语时，私钥被加密，然后使用 Base58Check 进行编码。在这种情况下，版本字节被选择为使输出行以“6P”开头（图 3–23）。


![alt_text](images/image23.png "image_tooltip")


图 3–23

如果用户看到与比特币相关的任何以“6P”开头的数据，很可能这是一个加密的私钥。要使用它，你需要获取加密密钥。

可以按相反的顺序解密加密的私钥。为此，用户只需将加密数据输入到他的钱包中（大多数钱包支持解密此格式的密钥），然后需要输入密码短语。钱包会解密私钥，并以开放形式提供给用户，可供使用。

以上，我们考虑了私钥的格式。现在让我们继续看公钥的格式。

***公钥格式***

公钥主要用于软件中。终端用户通常不直接操作公钥，因为作为比特币用户，根据目标，使用私钥或比特币地址会更方便，而公钥则是中间环节。

公钥有两种格式：hex 进制和 hex 进制压缩（hex 进制的压缩版本）。与私钥类似，hex 进制是以 hex 进制表示的公钥记录。唯一的区别在于，这里使用了略有不同的方案来区分压缩公钥和常规公钥：添加了一个特殊的前缀。对于常规公钥，添加前缀“04”，而对于压缩公钥，则添加其中的一个前缀：“02”或“03”（图 3–24）。


![alt_text](images/image24.png "image_tooltip")


图 3–24

为什么会有这两个前缀呢？对于压缩版本的公钥有两个前缀的存在是因为 Y 坐标可以是正数或负数。因此，“02”前缀表示正数的 Y，而“03”前缀表示负数的 Y。

*****常见问题*****

*“BIP38 中使用的私钥加密算法是什么？”*

BIP38 中使用了 AES 算法以密码块链接（英语：Cipher Block Chaining；CBC）模式，使用了 256 位的私钥。可以直接在 BIP38 中了解更多相关信息。

*“在一个钱包中可以有许多比特币地址和许多私钥，这意味着你需要单独导出和导入它们吗？”*

私钥的导入/导出有三种选项：单独，按列表以及在分层生成密钥的情况下导入/导出主要密钥。如果这些密钥之间没有相互关联（每个密钥都是单独生成的），那么将它们转移到另一个设备上只能单独或作为一组进行。但是，如果使用了分层生成，则在传输主要密钥后，可以从该密钥本地生成并恢复所有密钥。

*“还有什么其他的密钥格式？”*

除了本节列出的格式之外，还有迷你密钥和分层密钥。第一种格式是以一定的方式生成的，以便获得一个长度为 30 个字符的密钥。它的主要应用是 QR 码和实体硬币，比如 Casascius。分层密钥的生成原理是使用特定的种子值，从中生成所有使用的私钥。这种方法的优点是只需备份主要秘钥，即可恢复其余的密钥。


    **3.3 比特币中的交易和区块的序列化格式**

比特币交易以序列化形式（原始格式）在节点之间传输，即以数据的字节序列形式。该序列还用于哈希并进一步获得交易标识符。因此，为了网络节点能够正确处理交易，需要序列化格式。

然后，用户可以通过区块链浏览器或比特币钱包以人类可读的形式查看交易。在本节中，我们将教如何一眼就能阅读序列化的交易和区块，了解它们以何种形式在网络上传输以及节点如何处理它们。

***比特币交易序列化***

为了更好地理解，我们建议从一个示例开始，查看一笔在比特币网络上确认的序列化交易。首先，让我们以 JSON 格式来审查它（图 3–25）[25]。


![alt_text](images/image25.png "image_tooltip")


图 3–25

在本书的第一部分，我们已经以这种形式查看了交易字段。现在让我们看看同一笔交易的序列化形式（图 3–26），以及相关信息的位置 [26]。


![alt_text](images/image26.png "image_tooltip")


图 3–26

接下来的四个字节确定了编译该交易的比特币协议的版本。

然后有一个字节，表示交易输入的数量。接下来是上一笔交易的哈希值（从中接收到硬币）。该值占据 32 字节（图 3–27）。


![alt_text](images/image27.png "image_tooltip")


图 3–27

接下来的 4 个字节负责上一笔交易的输出索引（图 3–28）。在这种情况下，“00000000”表示上一个输出的索引为 0。


![alt_text](images/image28.png "image_tooltip")


图 3–28

接下来的一个字节表示 scriptSig 的大小，即证明硬币所有权的脚本。在这种情况下，它等于"8c"，即接下来的 140 字节将包含用于证明硬币所有权的脚本（图 3–29–A）。


![alt_text](images/image29.png "image_tooltip")


图 3–29–A

让我们来看一下这 140 个字节中包含了什么（图 3–29）：这些字节可以分为 4 个部分。第一部分由单个字节“49”组成并表示操作“OP_PUSHDATA (73)”，它将在此操作之后推送 73 个字节的数据到堆栈上。这将是交易的数字签名数据。在签名值之后，接着是字节“41”：操作“OP_PUSHDATA (65)”，后面跟着 65 个字节的公钥值。


![alt_text](images/image30.png "image_tooltip")


图 3–29

接着是 4 个字节，用于定位序列值（图 3–30）。请记住，此值用于指示花费相同输出的输入的版本（这与替换式费用机制相关）。默认情况下，此值为“ffffffff”，并且随着每个输入版本的减少（因此，随着每个事务的后续版本）。


![alt_text](images/image31.png "image_tooltip")


图 3–30

接着是一个字节，表示交易输出的数量。在我们的案例中，这是“01”，这意味着交易有一个输出。然后指定转移金额，分配了 8 个字节（图 3–31）。这笔交易转移了到 0.01 比特币（更准确地说是 999938 satoshi）。


![alt_text](images/image32.png "image_tooltip")


图 3–31

接着，交易的主体中的一个字节指示了scriptPubKey（花费比特币的条件）的大小。在我们的案例中，它是“19”（图 3–32–A），即条件的大小为 25 字节。


![alt_text](images/image33.png "image_tooltip")


图 3–32–A

让我们更仔细地检查一下花费比特币的条件。数据可以分为 6 部分，如图 3–32–B 所示。字节“76”表示操作“OP_DUP”，即复制堆栈顶部的值（用户的公钥）。接下来，字节“a9”表示操作“OP_HASH”，即从公钥计算地址。然后，字节“14”负责操作“OP_PUSHDATA（20）”，将接下来的 20 字节（接收方地址）推送到堆栈上。之后，执行操作“OP_EQUAL”（字节“88”），之后检查数字签名：“OP_CHECKSIG”。这对应于字节“ac”。


![alt_text](images/image34.png "image_tooltip")


图 3–32–B

交易的最后四个字节“00000000”是相对 lockTime，等于零（图 3–33）。


![alt_text](images/image35.png "image_tooltip")


图 3–33

***比特币区块的序列化***

现在，让我们转向比特币区块的序列化。为此，我们采用上面讨论的包含交易的区块。序列化的区块如图 3–34 所示。


![alt_text](images/image36.png "image_tooltip")


图 3–34

看起来复杂，对吧？然而，值得一提的是，该区块包含了 4 个交易，这些交易也包含在序列化值中。这些交易如图 3–35 所示。


![alt_text](images/image37.png "image_tooltip")


图 3–35

因为我们已经考虑了交易序列化格式，现在我们还需要看看下一个片段（图 3–36）背后隐藏着什么。


![alt_text](images/image38.png "image_tooltip")


图 3–36

第一个 4 字节也是协议版本的值，指示了形成区块的规则。在我们的案例中，这是版本“1”（图 3–37），从创世区块形成开始一直到 2012 年 9 月（Bitcoin Core 0.7.0）都被支持。协议的最新版本是版本 4，于 2015 年 11 月引入。接下来是上一个区块的 256 位哈希值。


![alt_text](images/image39.png "image_tooltip")


图 3–37

在此之后，将放置所有交易标识符的 256 位哈希根值（图 3–38）。请注意，在形成区块时，始终使用 coinbase 交易作为第一笔交易，其余交易可以随机排列；唯一的要求是将输入放置在它们花费的输出下方。


![alt_text](images/image40.png "image_tooltip")


图 3–38

接下来是一个值，即 UNIX 格式的形成时间戳（图 3–39），由四个字节组成。


![alt_text](images/image41.png "image_tooltip")


图 3–39

然后是两个值：第一个是难度参数，它决定了解决当前工作量证明任务的复杂性；第二个是 nonce，被视为解决此问题的证据。最后的值确定区块中的交易数量（图 3–40）。


![alt_text](images/image42.png "image_tooltip")


图 3–40


    **3.4 比特币网络节点之间的消息传递**

比特币网络的架构提供了一个点对点网络，其中每个节点都是平等且自给自足的。对于比特币网络节点之间的交互，以及该系统的其他过程，没有额外的限制。共识是由独立的参与者达成的，它们之间的消息交换是独立的和分散的。每个网络参与者都独立决定使用哪个区块作为进一步历史记录的基础，同时网络节点则独立决定与哪些节点通信以及如何处理收到的信息。

在本书的第一部分中，我们已经审查了比特币网络结构的要点以及节点在其运行中的作用。在本节中，我们将考虑节点之间如何相互交互的技术细节，具体来说是比特币网络参与者之间的消息交换方式。我们还将根据 2019 年 9 月的数据描述比特币网络的状态，并考虑信息传播协议、它们的要求、这些协议的问题以及可能的解决方案。

***比特币中节点的角色***

之前，我们确定节点可以分为三组：


```
全节点（审计员）
验证节点
SPV 节点
```


现在我们尝试通过考虑网络节点可以实现的功能来扩展分类。每个比特币节点可以由许多模块组成，这些模块在执行的功能方面有所不同。


```
存储完整交易历史的模块
交易验证模块
负责与其他网络节点通信的模块
形成挖矿工作量证明的模块
实现用户钱包功能的模块
```


具有所有模块的节点示例是个人用户的 PC，其中安装了 Bitcoin Core 或类似的软件。此类节点可以用图 3–41 来形象表示。


![alt_text](images/image43.png "image_tooltip")


图 3–41

每个这样的节点都存储着完整的交易历史，因此它们可以独立验证链中的后续区块，而无需信任第三方作为数据来源。这些节点参与共识建设，意味着它们与所有其他节点一起参与确认交易的决策。网络交互模块的存在使得节点能够直接与系统中的其他参与者通信，而钱包模块则使用本地数据库的副本来处理所需的交易。

第二种类型是支持比特币网络并参与决策的节点，因此基本上属于验证节点。然而，这些节点可能没有钱包模块（图 3–42）。


![alt_text](images/image44.png "image_tooltip")


图 3–42

第三种类型是审计节点。这种类型包含两个必需的模块：一个用于存储完整交易历史的模块，以及一个允许与其他节点交换消息以获取区块链当前状态的网络模块。这种类型在交易所和会计系统观察员中找到了应用。这种类型的节点通过存储区块链的本地版本来支持比特币网络。然而，如果一个节点没有允许创建区块的模块，那么这个节点就不参与达成共识（图 3–43）。


![alt_text](images/image45.png "image_tooltip")


图 3–43

下一个类型的节点也有两个模块（一个钱包和一个网络模块）：SPV 节点。我们之前已经在书的第一部分的第 2.3 小节中考虑过这种节点的操作原理。这种类型的节点没有自己的交易历史，而只存储区块头（从完整节点或其他 SPV 节点接收）。同时，它自己地与完整节点通信，并根据获得的默克尔分支值确定特定交易是否实际添加到区块链中。SPV 节点在比特币网络中的位置如图 3–44 所示。


![alt_text](images/image46.png "image_tooltip")


图 3–44

还有两个网络元素，实际上它们不是节点，因为它们不支持网络，也不直接参与达成共识。第一个类型是使用受信任节点的钱包。顾名思义，这个网络元素只有一个钱包模块。它与特定的完整节点（通常只有一个）通信，并从它们那里接收与用户地址相关的所有交易数据（图 3–45）。然而，它不存储所有交易的历史记录，也不进行验证。


![alt_text](images/image47.png "image_tooltip")


图 3–45

第二种类型仅包含一个计算资源密集型任务解决方案的模块，这意味着它从事挖矿活动。这些节点从完整节点（挖矿池的领导者）那里接收任务，并参与形成工作量证明，成功后将其发送给完整节点。这些节点是挖矿池的参与者（其客户），而验证节点的所有者则是其运营者（图 3–46）。


![alt_text](images/image48.png "image_tooltip")


图 3–46


```
注意：根据 2019 年 4 月的估计，超过 3000 万用户使用比特币。同时，全节点的数量约为 9,500 个，这意味着每个全节点有超过 3000 个用户（顺便说一句，全球的互联网服务提供商数量也接近 1 万个，活跃用户超过 39 亿）。
```


在最后两种类型的节点中，没有负责在比特币网络上交换消息的模块。接下来，我们将研究这个特定模块的功能；因此，我们也将涵盖全节点和 SPV 节点等概念。

***比特币网络的现状***

比特币网络中有两种类型的节点：公共节点和私有节点。公共节点（公网 IP 节点）不需要许可即可连接到它。这样的节点的软件“监听”全球互联网上的一个端口，并接受连接请求。公共节点帮助新成员找到要加入的节点。如果公共节点数量足够少，那么新参与者将难找到要加入的节点，结果网络将无法增长，甚至可能会分裂成子网。

私有节点（私有 IP 节点）加入其他公共节点，但不接受传入连接。私有节点足以审核会计系统，发送您的交易，并通常支持数字钱包的全部功能（图 3–47）。


![alt_text](images/image49.png "image_tooltip")


图 3–47

在实践中，由于子网组织的特点，存在更多类型的节点。例如，有一个相互连接的大学子网，只有它们才能访问。这些大学可以运行公共节点，但只针对其私有子网，并且只能通过私有节点加入全球网络。


```
注意：接下来，我们将只使用公共节点和私有节点的概念，因为它们是最常见的类型。
```


默认情况下，在比特币网络节点软件中，与其他节点的网络连接数量有一些限制：



* 每个节点都试图创建 8 个出站连接，这意味着在启动后，它会找到 8 个并连接到它们；
* 公共节点允许最多 117 个入站连接。

中本聪选择 8 和 117 作为可靠的网络连接性和最佳网络负载之间的折衷值。高连通性使网络更安全。例如，如果节点连接到一个节点而不是 8 个节点，则存在攻击者创建节点传输关于系统状态的虚假数据并进行各种攻击的高概率情况。另一方面，如果节点连接到 1000 个节点而不是 8 个节点，则每个节点都必须存储这些连接的状态。这反过来会导致存储节点活动数据、消息传输阶段等方面的高内存成本。此外，如果节点有 1000 个网络连接，那么除了存储这些连接的状态外，它还需要与每个连接同步新的交易和区块，并响应传入请求，这实际上会产生极高的流量负载。

今天，比特币网络中活跃节点的总数从 60 到 100 万个不等，而比特币 0.17 的最新版本仅由三分之一的节点支持。比特币 0.16 的先前版本在另外三分之一的节点上启动，其余的是更旧的版本和替代协议实现（图 3–48）[28]。


![alt_text](images/image50.png "image_tooltip")


图 3–48

如果我们分析公共节点的数量，可以看到，今天网络中的 6 到 10 万个节点中，只有 1 万个是公共节点。因此，公共节点与其他节点的比例约为 1/8。这个比例是由上面提到的 8 和 117 这两个值决定的，因为这 1 万个公共节点需要为约 8 万个私有节点提供服务。因此，选择了 117 数字，它可以在这种情况下维护网络的完整性。图 3–49 中的地图显示了世界各地可用的公共站点 [29]。


![alt_text](images/image51.png "image_tooltip")


图 3–49

***比特币消息结构***

让我们看一下比特币网络成员之间交换的消息结构。比特币中的所有消息都具有表 3.1 中呈现的结构。


![alt_text](images/image52.png "image_tooltip")


其中一个最重要的消息是版本消息，没有它，节点无法开始全面交互。当节点首次连接到彼此时，它们会交换版本消息或握手。该消息的结构如表 3.2 所示。


![alt_text](images/image53.png "image_tooltip")


***信息分发协议***

信息分发是比特币网络的主要任务，实现它需要系统消息。因此，比特币网络中有 27 种类型的消息。其中主要的消息如图 3–50 所示 [31]。


![alt_text](images/image54.png "image_tooltip")


图 3–50

在这个列表中，你可以看到与交易传输相关的消息（inv、tx、getdata）使用的数据量最大。例如，检查网络连接的消息（ping、pong）只占所有流量的一小部分。

***比特币网络中启动节点***

在比特币网络中启动一个节点的过程如下：


```
向 DNS 服务器（由社区成员支持）发送请求，以获取网络中活动节点的网络地址
连接到节点
下载交易历史（初始区块下载）
与其他节点交换区块并交易
```


在第一步中，节点需要向由比特币核心开发人员和社区成员支持的 DNS 服务器之一发送请求。它还需要存储一个包含现有活动节点的数据库（这些服务器的网络地址已经在节点软件中嵌入了）。

发送请求到 DNS 服务器后，节点会获得可以连接的节点的 IP 地址。然后它连接到这些节点，并进行版本协商协议。

然后，新节点需要请求并下载现有区块链中的所有区块。为此，使用初始区块下载方法。在同步现有区块之后，新节点开始参与网络数据传输协议––与其他节点交换新的区块和交易。

***泛洪信息分发协议***

为了在比特币网络上传输区块和交易，使用了泛洪协议的修改版[32]。根据此协议，节点将新或者接收的区块与交易传输给它们的所有节点，除了那些已经知道这些区块和交易的节点（图 3–51）。


![alt_text](images/image55.png "image_tooltip")


图 3–51

为了节省数据，使用了由三个消息组成的协议。其核心思想是，一旦节点接收到新的交易或区块，它就会将该对象的哈希 INV(hash(tx)) 发送给连接的节点。每个节点都会查询本地数据库，检查是否有该哈希；如果没有找到，它会请求节点提供 GETDATA(hash(tx)) 以获取对应的区块或交易。收到此请求后，节点会回复完整的区块或完整的交易。通过这个三条消息的修改，可以避免现有交易或区块的重复传输，而且由于每个交易的大小通常为 150-500 字节，可以节省大量的网络数据。让我们看一个比特币网络中传播交易的示例（图 3–52）。


![alt_text](images/image56.png "image_tooltip")


图 3–52

假设节点 A 从移动客户端接收到交易 tx，并准备与节点 B、C 和 D 分享。这些节点都没有这个交易，因此它们将在时间 t1 接收到它。在时间 t2，节点 B 将尝试将此交易发送给节点 C，但由于节点 C 已经收到了此交易，它将不会请求完整版本的此交易，因此该交易将不会通过此连接传输。节点 E 和 G 不知道此交易，对于新交易的消息，它们将请求并在时间 t2 接收到它。这个过程会一直持续，直到网络中的所有节点都收到了该交易。

***Diffusion 一 Flooding 的扩展名***

Diffusion 协议 [32] 实际上是比特币使用的传输交易的方式，它是对 Flooding 协议的一种扩展。根据该协议，在收到新交易后，网络中的每个节点不会立即发送它，而是会等待一个 0 到 5 秒的随机时间段。因此，节点在将交易进一步分发之前会先积累交易。这有助于节省与消息头相关的流量，使与跟踪交易接收时间相关的监视变得更加复杂，并避免碰撞（当两个节点同时向对方发送一笔交易时）。

比特币网络中的数据传输协议存在一些困难。


```
尊重用户匿名性
抵抗各种攻击
硬件功率和容量需求
网络分发时间
```


接下来，我们将考虑如何解决列出的每个问题。

***协议中问题示例及其解决方案***

考虑匿名性的问题。可以这样表述：如何使得在网络中确定交易的起源变得不可能（或非常昂贵），即使不可能将比特币网络中的特定交易与开始在网络中传播节点的网络地址相关联？

在下图中（图 3–53），可以看到超级节点（英语：Supernode）是连接到网络中所有节点的节点。从这个节点首次从其他节点那里了解到交易的时间点开始，它就可以确定其来源。因此，超级节点可以将这个交易与特定的 IP 地址关联起来。


![alt_text](images/image57.png "image_tooltip")


图 3–53

为了防止这种攻击，提出了蒲公英协议 [32] 和后来的蒲公英++ [33]。让我们看一下这个协议是如何工作的。

该协议将交易在网络中分发为两个阶段：

*匿名阶段（stem 阶段）*：每个节点只将交易发送给与其关联的一个节点。

*分发阶段（fluff 阶段）*：每个节点将交易传输到网络，传递给所有连接的节点。

每个节点在匿名阶段以 0.9 的概率传播交易，在传播阶段以 0.1 的概率传播（图 3–54）。结果是，交易在开始传播之前沿着一条路径进行传播。因此，有 10% 的概率交易将从零节点分布，10% 从第一个节点，以此类推。此外，很难确定交易的真实来源。平均而言，经过 10 次这样的节点跳转后，交易将使用常规的泛洪协议进行分布。


![alt_text](images/image58.png "image_tooltip")


图 3–54

现在让我们考虑比特币网络中的安全问题。确保安全的主要任务之一是提高攻击的成本，使其在经济上变得不划算。以日蚀攻击为例。

这种攻击的情景意味着攻击者控制的节点将诚实节点与比特币网络的所有其他部分隔离开来，并向它们传输数据库的虚假状态。

由于诚实节点仅连接到攻击者的节点，如果攻击者只显示自己制作的区块，那么诚实节点就没有机会找出哪些区块是这个链的一部分（图 3–55）。因此，可以进行双重支付和其他一些攻击。


![alt_text](images/image59.png "image_tooltip")


图 3–55

作为对抗这种攻击的方法，作者自己提出了几种修改协议的方法，例如，多样化 IP 连接（连接到不同地区）。因此，如果每个节点都有 8 个出站连接，那么攻击者需要控制世界各地数量庞大的节点，使攻击的成本大大增加。

现在让我们考虑资源消耗的问题。如何减少完整比特币节点的硬件与流量要求？比特币的基本原则之一是它适用于高性能和低性能的计算机。因此，非常重要的是以这样的方式发展比特币，使其保持运行状态，不会过载全球网络，并且不需要昂贵的设备来维护节点。在这方面的一个问题示例是接近（网络上）验证节点的节点在其余节点之前接收到新区块。一旦接收到并验证了区块，节点应立即将此区块发送给所有相邻节点。由于大多数相邻节点尚未听说过此区块，因此它们将发送获取该区块的请求，从而导致数据消耗的激增。

这种激增会导致互联网连接出现困难，因为在某一时刻需要使用大部分带宽。作为解决此问题的方法，提出了 BIP 152：致密区块中继（Matt Corallo）[34]。让我们看看它是如何工作的。

与网络上的一个区块传输协议相比，现在将有三个区块传输协议，并根据情况使用它们。

首先让我们看一下遗产的区块中继（图 3–56–A），即分发区块的旧方法。节点 A 接收到一个新的区块，对其进行验证，并将 inv 的标头发送给节点 B。由于节点 B 没有此区块，它将请求其数据（getdata），节点 A 将以完整区块的内容作出回应。

然后出现了两种新类型的触发此协议的方式，即高带宽中继（高流量消耗）与低带宽中继（低流量消耗）。


![alt_text](images/image60.png "image_tooltip")


图 3–56–A

现在让我们看一下新的协议类型：高带宽中继和低带宽中继。在这两种协议类型中，假定节点 B 的第一步是告诉 A 他们将使用哪种协议类型。在高流量消耗的情况下，节点 B 向节点 A（sendcmpct(1)） 报告，在低流量的情况下，节点 B 报告（sendcmpct(0)）。

让我们考虑高带宽中继（图 3–56–B）。节点 B 告诉节点 A 他们将根据高流量消耗的协议进行操作（sendcmpct(1)）。按照这种协议类型，节点 A 在收到区块后不进行完整的区块验证，而只检查标头。然后，节点 A 向节点 B 宣布此区块，并根据以前的数据传输尝试预测节点 B 缺失的交易（cmpctblock）。然后，在验证了区块并与其拥有的数据相匹配后，节点 B 请求所需的交易（getblocktxn），在完全验证了区块后，节点 A 将剩余的交易发送给节点 B。

现在转向低带宽中继（图 3–56–C）。节点 B 告诉节点 A 他们将作为低流量消耗的协议进行操作（sendcmpct(0)）。在同样的情况下，节点 A 只在完全验证了该区块后才向节点 B 宣布一个区块。

现在让我们考虑如何快速在网络上分发数据的问题。如何尽快地在网络上分发交易和区块？在这种情况下，速度非常重要。例如，区块分发越慢，孤块率越高（指不在主链上的区块数量，因为它们不是基于最后一个已知区块创建的）。由于这种延迟，无用的工作量（工作证明）增加，导致会计系统的安全级别降低。

作为解决这个问题的方法，提出了比特币 FIBER [35]，这是一个额外的网络。在这个网络中只有验证节点存在，并交换区块。这确保了低孤块率。

*****常见问题*****

*“启动一个完整的比特币节点有哪些好处？”*

在某些情况下，使用受信任的节点或 SPV 节点并不足够，因此应该启动一个完整的节点。例如，如果想要提供对你的资金免受攻击的最大保护，则需要一个完整的节点（只需一个不接受传入连接的私有节点）。这是必要的，以便独立检查整个交易历史和 PoW，监视区块链的替代分支，并临时切换到网络的最新当前状态。如果使用第三方来源，你无法对这些过程的可靠性有信心。如果想要帮助网络（使其更加连接和可靠），你可以启动一个公共站点。然后，其他节点将能够加入你（这将增加你节点的总连接数），这将有助于网络增长，并且私有节点的所有描述的优点也将可用。

*“为什么无法将比特币网络构建（如为星型拓扑结构）？”*

星型拓扑结构假定存在一个中央计算机，所有其他计算机都连接到这个中央计算机。由于比特币旨在分散会计系统并最小化必要的信任级别，其拓扑结构必须是分布式的（接近随机图）。在星型拓扑结构中，中央节点可能会受到潜在的威胁，如果受到损坏或攻击，就会威胁到整个系统的可操作性。

*“为什么泄露网络拓扑结构是不好的？”*

在比特币协议的开发人员中，有一种观点认为，公开已知的网络拓扑结构会使其更容易受到一些网络攻击的威胁。例如，如果有人发现网络中存在“瓶颈”（即网络被划分为两个节点子集，它们只通过一条连接相连），那么一旦攻击者控制了两个目标节点，就可以破坏达成共识的过程，并实施双重支付或类似的攻击。

*“为什么只能分发区块（而不是单独的交易传输）？”*

几年前，比特币提出了一种可选的仅区块模式操作。该模式允许节点忽略新的交易，并假定节点只监听已由验证者创建的区块。这个选项适用于打算节省流量的节点。如果网络中的所有节点都使用此选项，那么公共节点的流量消耗将会剧增，完全向其他节点传输新区块。然而，这里最大的问题是新交易将无法到达验证节点以获得确认。因此，为了传输交易，你将不得不直接将数字钱包连接到验证节点。

*“流量生成的节点是否加密？”*

不，它没有被加密。过去几年来，这个问题一直是争论的焦点。曾经提出了流量加密协议的方案，例如，这将有助于对网络服务提供者隐藏使用比特币的事实。目前，你的互联网服务提供商或路由器管理员可以看到你使用比特币，并可能甚至确定网络上的哪些交易是你的，哪些不是。人们认为这暴露了节点所有者身份的一部分。因此，目前正在积极开发在这种特定环境中运行的新的替代加密通道协议。

*“更改消息传递协议需要哪种类型的更新？”*

更改这些协议既不需要硬分叉也不需要软分叉，但需要以一种方式开发协议和相应的节点软件更新，使它们向后兼容，并且未更新的节点能够加入更新后并正常工作。一个这样的协议示例是上面讨论的 Compact Blocks Relay[34]。它可以与旧节点和新节点进行消息传递。


    **3.5 测试网和协议更新的挑战**

测试网络是一个运行与比特币相同协议的备用网络，但由较少的参与者支持，充当一种“沙盒”，任何人都可以加入进行测试。测试网络有自己的创世区块，而其中的货币与主网络中的货币分开，没有真实价值。

这使得应用程序开发人员或测试人员可以进行实验，而无需使用真实货币进行操作，也不会用交易堵塞主链。测试网络是比特币协议开发团队测试更新和新软件以及在将更新引入主网络之前进行网络负载测试的地方。测试网络分为两种类型：私有测试网络和公共测试网络。

***比特币测试网及其目的***

比特币的公共测试网络与主网络的工作方式完全相同；唯一的区别在于人们不认为该系统中的货币具有价值。同时，用户既可以自行挖掘测试币，用于测试目的，并可以与分发小额币的参与者联系，以便希望测试节点、钱包等软件的人进行测试。

除了公共测试网络，在那里每个人都可以操作，你还可以创建一个私有测试网络（regtest，Regression Test Mode），这是比特币的本地（私有）版本。这个版本的测试网络很方便；你可以快速更新所有网络节点的软件，并演示或测试更改，而无需其他参与者的批准。这种方法有三个主要优势：


```
无需连接到公共网络
对网络及其交易拥有完全控制权
保存了大多数网络参数，使你可以独立更改被测试的参数或引入新功能
```


***协议更新***

在更新分散式系统的协议时，开发人员必须面对一些困难。特别困难的情况是在一个权限系统中进行更新，而其操作不能允许停止，即使只是短暂的时间。传统协议允许网络上存在不同版本，但是，在比特币和类似的记账系统中，节点必须处理相同格式的区块。因此，某一组参与者以前不考虑其他网络节点软件的版本（在这种情况下，通常会出现分叉）不能自由切换到新的协议版本。

为实施任何协议更改，必须考虑以下问题：节点将如何就新规则达成一致？更新是否会导致漏洞或错误？更新后的协议有多安全？

更新的原因可能有所不同，例如，添加新功能，消除已知漏洞，或更改协议中的关键规则。图 3–57 显示了更新分散式系统协议的概括方案。


![alt_text](images/image61.png "image_tooltip")


图 3–57

更新过程始于向网络参与者宣布协议的新版本。随后，一些节点开始生成新格式的区块，而其余节点可以保留在之前的版本上。此外，每个节点都独立决定是否升级。

一段时间后，越来越多的验证节点开始创建带有标记的区块，表明它们准备切换到新规则。然后节点跟踪何时积累了一定数量的这种区块，并且通常计算将在未来何时切换到新规则的区块高度或时间戳。这应该同时发生在所有节点上，然后更新被视为生效。总的来说，有两种类型的协议更新：软分叉，即保持向后兼容性，这意味着旧版本的区块会被接受，只要它们不违反新规则，和硬分叉，它是一种更“严格”的更新，不提供向后兼容性，因此所有节点必须切换到一个新版本；否则，它们的区块将被拒绝。

为了更好地理解协议更新的过程，我们要考虑这种过程在比特币如何运作。让我们先定义每个更新的关键特征，然后在表 3.3 中检查每个更新的参数。

表 3.3 


![alt_text](images/image62.png "image_tooltip")


更新可以处于 5 种状态之一（表 3.4）。

表 3.4 


![alt_text](images/image63.png "image_tooltip")


我们使用图 3–58 中显示的方案更详细地说明了这个过程。最初，更新被分配了定义好的状态，并确定了 starttime 和 timeout 的值。在 starttime 结束时，如果经过的时间不超过 timeout，则更新会切换到 started 状态。如果在 timeout 结束之前有大多数验证者发布了指示新版本给网络的区块，则更新将进入 locked-in 状态，之后将自动切换为 active 状态。否则，它将被视为失败，并进入 failed 状态。


![alt_text](images/image64.png "image_tooltip")


图 3–58

***最重要的比特币协议更新***

自第一个版本问世以来，比特币经历了许多变化。让我们看看其中最重要的几个。

协议的第一个版本，版本 0.1，发布于 2009 年 1 月 8 日。此事件之前于 2008 年 11 月 1 日发布了白皮书，在其中，中本聪描述了未来系统的原则。

*区块大小限制*为 1 MB。出现大小限制的代码行于 2010 年 7 月 15 日添加（版本 0.3.1 rc1）。但是，目前尚不清楚何时做出了这个决定以及谁参与了讨论。这一限制的主要动机是为了减少 DDoS 攻击的有效性。然而，如此严格的限制导致与之前版本的不兼容，这就是为什么许多验证节点的所有者对此反应消极的原因。

*付款到脚本哈希（英语：Pay-to-Script Hash）*。付款到脚本哈希（BIP 16）机制允许向安全地址发送交易被添加了。第一次尝试实施失败，第二次尝试于 2012 年 4 月 1 日在版本 0.6.0 rc2 中进行。在接下来的几个月里，45% 的未更新的验证节点继续产生错误的区块，导致了激活问题。

*隔离见证*。隔离见证（SegWit）机制，描述在 BIP 141、143 和 147 [68–70]，旨在通过在单独的结构中发出签名来优化交易和区块。隔离见证首次发布于 2015 年底，并于 2016 年 10 月发布（版本 0.13.1）。激活门槛被设定为 95%。然而，包括 F2Pool、HaoBTC、AntPool 在内的大型矿池的所有者表示说如果区块大小增加到 2 MB，就只会支持更新。

***比特币节点对新版本的适应***

尽管并非所有比特币协议更新都取得了成功，但它们在引入新功能和纠正旧缺陷方面发挥着极其重要的作用。然而，统计数据显示，一些节点的所有者对新版本的引入反应非常缓慢，他们继续使用旧版本。

图 3–59 显示了从 2017 年 8 月到 2019 年 8 月的版本分发历史。图表突出显示，更新后，支持新版本的节点数量开始逐渐增长 [36]。

不过可以注意到，即使在发布 0.18.0 版本之后，0.17.0 版本的节点更有可能被更新，而运行在旧协议版本上的节点数量继续逐渐下降，就像之前一样。

用户不立即在发布后切换到新协议版本的主要原因是担心其安全性和漏洞问题。节点所有者决定等待一段时间，以确保新版本没有关键性漏洞。


![alt_text](images/image65.png "image_tooltip")


图 3–59

然而，仍然有一些用户使用极其过时的协议版本，甚至到了 0.8.1 版本（图 3–60）[28]。


![alt_text](images/image66.png "image_tooltip")


图 3–60

***社区分裂的风险***

在分布式会计系统中，任何变更都只有在最活跃用户的开放社区该变更达成一致后才会实施。这类项目很难直接实现盈利，因此拥有一个支持会计系统运作的志愿者大社区非常重要。

当社区出现争议时，通常会通过多数意见来解决。但有时社区成员无法达成一致。各方之间的矛盾加剧，就可能导致社区分裂（图 3–61）。以下是几个项目的分裂示例。


```
瑞波（Ripple）和恒星（Stellar）
以太坊（Ethereum）和以太坊经典（Ethereum Classic）
比特币（Bitcoin）和 Bcash
门罗币（Monero）和门罗经典（Monero Classic）
```



![alt_text](images/image67.png "image_tooltip")


图 3–61

这意味着最大的优势有时可能变成关键的劣势。社区没有共同解决问题和寻找最佳更新协议的方法，而是陷入了争论之中，分裂成小团体，并开始朝着各自的目标前进。

*****常见问题*****

*“攻击者是否可以利用测试网络来误导用户并向他们出售测试币？如何避免这种情况发生？”*

通常，攻击者会利用用户的粗心大意或他们想要以更优惠的条件购买硬币的愿望，通过将它们转移到一个测试钱包中来进行欺骗。为了不上这种当，你应该注意使用哪个钱包来接收资金，并绝不允许外部人士为你创建钱包。攻击者还可以创建一个多重签名钱包，然后将资金发送到你不拥有的另一个地址。


    **3.6 比特币的基本攻击类型**

通常，攻击者会利用用户的粗心大意或他们想要以更优惠的条件购买硬币的愿望，通过将它们转移到一个测试钱包中来进行欺骗。为了不上这种当，你应该注意使用哪个钱包来接收资金，并绝不允许外部人士为你创建钱包。攻击者还可以创建一个多重签名钱包，然后将资金发送到你不拥有的另一个地址。

比特币的出现引起了计算机科学家们的真正关注。他们大部分最初对此持怀疑态度。一方面，似乎这是另一次吸引人们参与可疑金融企业的尝试；另一方面，人们会注意到比特币将广为人知的加密方案标准，哈希和签名算法，巧妙地结合起来，而没有引入任何新的东西。对于密码学家来说，这太简单了；对于互联网安全研究人员来说，这又太抽象了。然而，2014 年后情况根本的改变了。

人们意识到，比特币在互联网支付领域占据了一定的市场份额，并且不断扩大其用户群。在某个时刻，比特币成为了攻击和保护分布式系统方法的实验场所（尤其是匿名攻击测试方面）。本章将探讨对比特币的主要攻击类别，并深入探讨为什么比特币被设计成我们今天看到的这种设置。

几十年来，来自世界各地的工程师一直在寻找一种在完全去中心化和参与者匿名性的情况下就正确交易达成共识的方法。这是有史以来最困难的任务之一，最终，正是比特币的创造者首先提出了一个有效的解决方案。事实上，中本聪因其成就而被提名诺贝尔奖 [71]。

解决方案的核心是允许任何人参与确认交易的列表的形成。最简单的方法是让参与者交换他们认为正确的交易的确认。然而，每个人也必须可靠地保护自己免受恶意节点伪造消息并向诚实网络节点发送虚假数据的攻击。如何进行此类攻击以及如何防范它们的详细信息将在后续描述。

***泛洪攻击与保护机制***

中本聪提出了一个非常原创的解决方案：每个潜在的验证者必须提供工作量证明才能获得投票权。事实上，这就是工作量证明共识算法的本质。参与者必须投入一些资源并提供自己的一组正确交易，这作为一种防范错误意见的手段。

1997 年，亚当·贝克（Adam Back）提出了使用工作量证明来防止不必要的邮件发送；那时这是一种保护电子邮件协议用户免受垃圾邮件的解决方案。后来，这种方法成为 HashCash 架构的基础之一 —— 亚当早期尝试创建独立数字货币的一种方法。截至 2019 年，亚当·贝克仍然是比特币社区中领先的密码学家和理论家之一。

***垃圾邮件攻击及其后果***

垃圾邮件通常指大量的侵入性垃圾邮件消息。垃圾邮件攻击的目标是使一个或多个网络节点无法正常运行。在组织此类攻击时，必须满足一些先决条件。可以使用软件钱包并对其进行更改，使其创建大量交易，将硬币从其旧地址发送到新地址。每笔交易应包含一笔费用，最终导致三种情况。

在第一种情况下，攻击者包含一个非常低或零的手续费。然后其交易根本不会在网络中传播，因为每个节点都设置了最低所需费用的值。如果实际交易费用低于此阈值，则节点立即拒绝交易。因此，攻击者只能将这些交易发送给与其直接连接的节点，而且持续时间不长。此外，这种方式是不起作用的，因为其交易将被立即拒绝。而且，经过一段时间，这些节点也会触发一个过滤器，与无用节点或传输错误消息的节点断开连接。

在第二种情况下，攻击者包含一个平均手续费（高于阈值但不足以获得快速确认）。他的交易将传播到整个网络中，这种攻击将比前一种略微有效。网络中的所有节点都将验证、存储和广播攻击者的交易。这样一来，你可以在未确认交易队列的底部消耗大量内存。但是，节点对队列的最大大小有限制，如果这些交易未获确认，它们将在一段时间后被删除。在这种情况下，具有足够手续费的其他用户的交易将得到适当的确认。

在第三种情况下，攻击者包含足够的佣金。然后，他的交易几乎可以填满整个货币的带宽。重要的是要了解，其他用户的钱包也将开始增加交易费用以获得服务。因此，攻击者将需要为每笔后续交易支付更多的费用，以便其余的交易保持在队列底部。这种泛洪攻击的成本非常高。

***新交易确认的暂停（DoS）***

是否可能发动一次攻击，使验证节点停止工作，导致新交易不再得到确认？从理论上讲，这样的攻击是可能的。有人可能精通编程和软件安全，就这个人会发现全节点源代码中的关键漏洞。他可能想要利用这些漏洞，而不是提供修复方案来损害网络。然而，几乎不可能预测这种情况或保证对其进行保护。

然而，这种情况发生的可能性非常小。由于比特币已经存在了相当长的时间，人们已经多次尝试找到漏洞，研究人员仍在继续朝着这个方向努力。此外，在采用协议更新之前，源代码经过了许多独立社区成员的严格审计和测试。

***长程攻击***

这种攻击的基本原理很容易理解，当把它与众所周知的 51% 攻击相联系时更是如此。

在传统的情况下，攻击过程如下。攻击者向一个新建的地址发送 50 比特币。之后，他将这些比特币发送给一个商家，与商家交换成另一种货币（例如莱特币）。卖家等待 6 次交易确认后，将另一种货币发送到用户的钱包。

与此同时，攻击者在基于比特币区块链上一个早于他向商家发送 50 比特币交易的区块上工作。用户形成一个新的交易，将比特币发送到另一个地址。拥有网络超过一半的处理能力，用户将其用于新的链。很快，用户的链可能成为主链，所有节点都会根据比特币协议的规则切换到它。通过这次成功的攻击，用户将保留他的比特币并获得莱特币。在长程攻击的情况下，用户不会从 6 个区块前开始他的链，而是从创世块开始。

拥有 1 TH/s 处理能力的计算机，可以在 5 分钟内从创世块建立一个新的链，一直延伸到序列号为 300,000 的区块。顺便提一下，截至 2019 年 9 月，售价 3000 美元的比特币挖矿设备的处理能力达到 14 TH/s。挖矿难度参数的最小值等于以下基数 16 表示的数字。

**00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff**

当用户构建自己的链时，他可以记录任何花费在写入区块上的时间，而挖矿复杂度保持最低水平。如果以成品形式查看这样的区块链，那么它在任何方面都不会与真实的比特币区块链有所区别。

当新节点加入网络时，它们能够区分真实的区块历史和虚假的区块历史吗？即使是中等功率的设备，也不需要很长时间来创建这样的链。那么，比特币是否能够抵御来自这些链的数千次攻击呢？

实际上，这对比特币协议并不构成漏洞，因为开发人员从一开始就考虑到了这种攻击的可能性。由于规则的制定不仅考虑到链的长度，还考虑到了复杂度参数（确定构建主链所需的工作量），节点可以非常快速地区分真实链和虚假链。

检查点机制（在本教程的第一部分中详细讨论）也有助于应对这种威胁。但是，请记住，检查点不是一个无需信任的解决方案。将它们添加到软件中的任何人都可能是攻击者，因此必须对软件开发人员和检查点的作者有一定程度的信任。

***路由攻击***

尽管比特币节点可以从世界任何地方进行控制，但目前全球节点的分布是不均匀的。根据研究（图 3–62），大多数比特币节点位于少数几个互联网服务提供商（ISP）那里：13 个互联网提供商（占所有互联网提供商的 0.026%）承载了整个比特币网络 30% 的节点（在左图中显示）。此外，大部分比特币节点之间交换的流量经过了几个互联网提供商。研究表明，所有可能的比特币连接中有 60% 经过了 3 个不同的互联网提供商。这意味着这 3 个互联网提供商可以看到 60% 的比特币流量（如右图所示）。


![alt_text](images/image68.png "image_tooltip")


图 3–62

有一种 BGP 技巧——这指的是一种路由攻击，即互联网提供商根据互联网路由系统中的虚假路由消息错误地转发流量。这种类型的攻击相当常见（图 3–63）：每个月多达数十万次发生。其中一些攻击针对大量网络地址，最多达到3万个IP前缀（左图所示）。

这些攻击对比特币网络产生影响。每个月至少有 100 个比特币节点成为 BGP 技巧的受害者，2015 年 11 月有 447 个节点被攻击，占比特币节点总数的 8%（右图所示）。


![alt_text](images/image69.png "image_tooltip")


图 3–63

利用路由攻击的攻击者可能有两个目标。第一个目标是将比特币网络分裂成多个部分，同时不允许节点彼此同步。因此，攻击者迫使节点创建替代的区块链分支，而不是共同的区块链。在此类攻击结束后，由较小节点群体形成的所有区块将被丢弃。较小分支的交易将未确认，并且形成区块的奖励将无效。在执行此类攻击时，通常会发生类似以下情景的情况（图 3–64）。

步骤0：左侧与右侧的节点通过蓝色线表示的比特币连接进行交互。

步骤1：攻击者想将网络分成两个不相交的部分：一个在左侧，一个在右侧。

步骤2：攻击者通过执行 BGP 技巧捕获发送到左侧节点的流量。

步骤3：捕获后不久，从右到左发送的所有流量都将经过攻击者（红色线）。

步骤4：攻击者中断这些连接，有效地将网络分成两部分。

步骤5：在攻击期间，每个部分的节点继续与同一侧的节点进行通信。


![alt_text](images/image70.png "image_tooltip")


图 3–64

攻击者可能追求的第二个目标是使区块交付给受害节点延迟 20 分钟。在这种情况下，攻击者完全不被注意到。在此期间，受害者不知道最新挖掘的区块和相关交易。此攻击的后果取决于受害者的类型。如果受害者是商家，那么他将受到双重支付攻击。如果受害者是验证者，那么他将白白浪费他的设备的计算能力。最后，如果受害者是普通用户，那么他将无法通过分发最新的相关区块来为网络做出贡献。此类攻击将按照以下方式进行（图 3–65）。

步骤0：节点 A 和节点 B 向受害者 C 宣布相同的区块。

步骤1：节点 C 使用 GETDATA 从节点 A 请求区块。攻击者更改 GETDATA 的内容以传递节点 A 的旧区块。

步骤2：传递旧区块。

步骤3：在节点 C 请求后的 20 分钟之前，攻击者通过修改节点 C 创建的另一个 GETDATA 消息开始传递。

步骤4：单元在 20 分钟内被转交了。受害者不与节点 A 断开连接。


![alt_text](images/image71.png "image_tooltip")


图 3–65

***其他技术和社会的攻击***

网络流量分析（包嗅探）。任何能够看到你所有互联网流量的人都可以确定你什么时候提交了一个你没有从另一个节点收到的交易（这意味着你创建了它）。互联网服务提供商或国家防火墙可以过滤比特币协议流量，从而给普通用户带来一些不便。但是网络数据包过滤的问题可以解决。例如，比特币核心与 Tor（一个分布式流量匿名化网络）很好地集成。

区块隐藏（自私挖矿）攻击意味着新形成的区块在发送到其他节点之前存在一段时间延迟。攻击者是一个具有足够大计算能力的验证者，他创建了新的区块链区块，但不立即将它们重定向到其他网络节点。这些区块稍后一个接一个或成组地发布；因此，其余验证者的区块被网络拒绝，因为它们属于另一个较短的链（孤立块）。在这种攻击中，其他验证者成为受害者；然而，最终他们要么在达成共识中扮演较小的角色，要么根本无法创建任何相关的区块。

其他各种攻击包括计划的分叉、在交换比特币时对某些国家货币使用的各种限制、互联网服务提供商阻止全节点的网络流量，以及禁止生产专门设备或其使用。

最具体的攻击包括绑架重要社区成员以及在硬件或软件中引入恶意元素。

***比特币警报系统及其关闭方式***

比特币中的警报系统允许向网络客户端广播有关检测到问题和潜在威胁的消息（图 3–66）。


![alt_text](images/image72.png "image_tooltip")


图 3–66

正如中本聪在 bitcointalk.org 论坛上所述，即使在开发信号系统的阶段，只有他拥有用于签署消息的私钥（图 3–67）。


![alt_text](images/image73.png "image_tooltip")


图 3–67

换句话说，这个附加组件是集中式的。然而，中本聪并不认为这是一个大问题，因为它与社的会共超过了重叠。如果用户对问题的可靠性感到怀疑，他可以在论坛和其他来源上检查数据（图 3–68）。


![alt_text](images/image74.png "image_tooltip")


图 3–68

中本聪声称他无法远程执行任何操作。而这一创新旨在确保用户硬币的安全。如果在协议运行过程中出现任何可威胁用户余额状态的可疑情况，每个用户都会收到相应的通知。忽略关于潜在危险的消息，硬币所有者可能会丢失它们（图 3–69）。


![alt_text](images/image75.png "image_tooltip")


图 3–69

中本聪后来将他的私钥与几位信任的比特币核心开发者分享。社区成员开始对此表示担忧，因为如果攻击者取得了这个密钥，他就能够传播可能引起恐慌的消息。此外，还发生过利用这些密钥试图影响网络规则、费用和复杂性参数的事件。

这种情况与比特币的安全模型相矛盾。在 2016 年的比特币核心 0.13.0 更新中，警报系统被完全取消了。

***一些被发现并解决的协议问题***

BIP-0050。2013 年 5 月，BIP 50 被提出来解决其中一个问题。在网络中，有人创建并分发了区块，其总交易输入数量大于先前的区块。0.8 版比特币节点能够处理这个问题，但是一些 0.8 版本之前的节点无法处理，导致了区块链意外分裂。在那个时候，不兼容的 0.8 版本之前的链上大约有 60% 的算力，这并不足以自动解决分裂。

为了尽快恢复规范的区块链，BTCGuild 和 Slush 将它们的 0.8 版比特币节点降级至 0.7 版，因此它们的矿池也拒绝了包含更多交易输入的区块。在此期间，发生了一次重大的双重支付。然而，这是为了进行实验而不是出于恶意目的。

由于网络分裂被迅速注意到，严重后果得以避免。结果，出现了更新的 0.8.1 版本的协议，其中包括以下规则：



* 拒绝可能导致超过 1 万个锁定的区块；
* 限制创建的区块的最大大小为 50 万字节；
* 为旧版本创建一个安全更新，实施相同的规则，但将最大锁定数限制为 12 万个；
* 在 bitcoin.org 上创建一个网页，强制用户升级到 0.8.1 版本。该页面还显示如何将 DB_CONFIG 设置为 12 万个锁定。
* 在接下来的两个月里，向旧版本用户发送了一系列关于更新需求的警报。

CVE-2013-4165。在比特币网络上发现的另一个漏洞是，攻击者可以发送一系列消息，导致在 Bloom Filter 处理代码中发生整数除零错误，从而导致比特币-Qt 或 bitcoind 的拒绝服务。Bloom Filter 在 0.8 版本中引入；因此，版本 0.8.0 到 0.8.3 容易受到这种拒绝服务攻击的影响。

在发现这个漏洞后，开始使用恒定时间算法来验证对 RPC 密码的猜测尝试。

CVE-2014-0160。这个漏洞与比特币网络没有直接关联，而是与 OpenSSL 库相关。它可以允许远程攻击者通过不正确处理该库中的内存来获取机密数据，包括用户凭据和私钥。

为了消除这个漏洞，OpenSSL 协议被更新到了 1.0.1g 版本。在旧版本中生成的所有密钥都被视为受到损害，并必须使用新版本的协议重新生成。

CVE-2016-10724。在 0.13.0 版本之前，比特币核心容易受到 DoS 攻击的影响，这是由于一个远程网络通知系统当攻击者使用已知于受害者的特定私钥签署消息时造成的。这影响到了像 Bitcoin Knots 这样的源代码克隆，直到 0.13.0.knots20160814 版本以及一些替代货币。

*****常见误区*****

*任何程序员都可以验证比特币中是否存在漏洞。*

理论上是可能的，但实际上，分析如此庞大的源代码量是一个需要庞大且专业的团队进行的工作，而这需要相当长的时间。

*****常见问题*****

*“用户如果在他的钱包中拥有大量的比特币，并准备花费它，他如何在技术上用交易垃圾邮件攻击比特币内存池，以增加交易成本？”*

确实，如果用户拥有大量比特币，他可以用于进行压力测试。为此，他需要修改他的全节点软件。一个相当简单的选项是添加一个循环，用于生成一个新的地址并向其发送随机数量的比特币（例如 0.5–2 BTC）。最好在单独的线程中启动这个循环，并每秒重复 2 到 3 次。同时，计算出最佳费用，使得这些交易落入内存池的中部，但不会在第一个区块中被确认。换句话说，这样可以避免支付过多的费用，并有效地使网络中的所有节点负载。这是填充内存池的最佳方法，以便那些想要进行紧急支付的用户必须支付非常高的费用，以使他们的交易位于队列的顶部，并有可能被包含在下一个区块中。

*“据说量子计算机将是比特币未来的威胁。这是什么意思？”*

这意味着量子计算可能对比特币现在使用的数字签名算法构成攻击。目前还没有能够实施这种攻击的量子计算机（甚至还不清楚它们是否会被创造出来）。即使它们出现了，比特币的密码学也将被更新，更加抵御量子计算的攻击。已经有了后量子密码学算法。

*“制造矿机芯片的厂商是否可以通过内置后门控制算力并进行 51% 攻击？”*

这理论上是可能的，尽管这很困难，而且很可能在经济上是不合理的对于一个制造商来说。然而，在矿机芯片中找到后门是相当困难的。因此，最好是有许多独立的芯片制造商，而且没有一个在生产方面超过其他所有制造商的总和。此外，许多山寨币使用抗 ASIC 的哈希函数，对于这些函数创建硬件矿工是极其困难的，因此挖矿是在 GPU 或通用处理器上进行的。

*“攻击比特币所使用的工具有哪些？”*

最常见的是专门的软件，这种软件是基于完整网络节点源代码创建的。

*“如果洲际间的互联网连接消失然后再次出现，比特币会发生什么？”*

在一大陆上会有一条交易历史，而在另一大陆上会有另一条。当连接恢复时，只会存在一条链，即花费更多计算能力的那一条。对于来自交易历史较小链的大陆的人们，如果他们的交易不与主链冲突，它们将再次变为未确认状态，但随后会在后续的区块中得到确认。

*“比特币代码中没有后门的保证吗？”*

专家们的观点是由于源代码是公开的，意味着每个人都可以看到并进行渗透测试，因此不存在有意构建的后门。但是，可能会存在无意的错误，可能使协议易受攻击。这种可能性很小，因为会进行严格的测试，并且会对外部节点行为的恶意场景进行研究。另一方面，你可以通过自我审计源代码或联系可信方进行额外的验证。

