**5 共识达成方法**


    **5.1 权益证明共识算法**

权益证明（英语：Proof-of-Stake，PoS）描述在特定数字账本系统中的代币所有权证明。基于 PoS 的共识算法被创建为对工作量证明的一种资源消耗较少的替代方案。在这种共识算法构建方法中，节点获得创建新区块的权限的概率取决于其代币余额。在本节中，我们将探讨 PoS 共识算法背后的基本原理以及在账本系统中使用这种方法的特点。

***权益证明的运行原理和区块结构***

当使用权益证明共识算法时，验证节点是基于一系列因素的伪随机选择的，包括特定代币的年龄、某些随机值和节点状态。值得注意的是，在权益证明系统中，生成区块的过程被称为*锻造*或*铸造*。

在一般形式下，PoS 中新区块形成的顺序如下。区块头、当前时间、验证者的余额（他的股份）以及其他特定数据，比如计算的货币年龄（见下文描述）或某种随机变量被输入到一个函数中，该函数确保验证者以公平的方式被选择。该函数在一定的时间间隔内被调用，并且每次验证者尝试执行它时，它都会返回一个确定的结果（请求是否成功）。

使用权益证明共识算法的数字货币包括以下几种。


```
Peercoin
Nxt
NEM
Novacoin
Cardano
```


在权益证明系统启动时，硬币尚未分发。创建者通常会开始进行货币的预发行，或者从工作量证明转换为纯权益证明。但是，为什么验证者会获得奖励呢？在第一种情况下，当货币预发行时，验证者从交易费中获得奖励。当工作量证明和权益证明结合在一起时，验证者可以通过生成新货币和接受交易来获得奖励。

要参与新区块的创建，参与者的余额必须存在一些货币 —— 这称为权益。权益大小影响节点被选为下一个锻造区块的概率（图 5–1）。因此，权益越大，被选中锻造下一个区块的几率就越大。


![alt_text](images/image1.png "image_tooltip")


图 5–1

让我们以 Peercoin 为例，观察权益证明和工作量证明系统中区块结构的差异（图 5–2）。稍后我们将详细讨论 Peercoin 系统本身。


![alt_text](images/image2.png "image_tooltip")


图 5–2

在左侧，是一个工作量证明（PoW）区块的示意图。其头部类似于比特币中的头部。Coinbase 交易是一个退化交易，它只有一个空输入，不包含任何链接，但包含无限数量的输出。输出值的总和不得超过为创建此区块而提供的奖励金额。Coinbase 交易后面是其他用户的交易。根据原始比特币规则，这些交易需要支付一笔费用，这笔费用将会加入到创建该区块的奖励中。

在右侧，是一个权益证明（PoS）区块。在其头部已经有两个退化交易：第一个是 coinbase，根据协议规则是强制性的，第二个是 coinstake，在按照 PoS 规则生成区块时需要。Coinstake 交易有自己的形成规则。这里的 coinbase 交易包含一个输入和一个输出，两者都为空，而 coinstake 交易至少包含一个输入，在其中指定了一笔交易的未使用输出链接（为这些币计算了 coinage 参数），以及两个或更多的输出，第一个输出为空，而其他输出用于消费和重新分配币。创建 PoS 区块的奖励将与作者在输出中指向自己的币相加。

此外，该区块包含区块作者的签名，必须由 coinstake 交易的第一个输入中指定的公钥进行验证。签名证明确实是该参与者创建了该区块。Coinstake 交易后跟着用户的交易，这些交易也是已签名的，也就是说，整个区块都是已签名的。

这样做是为了防止外部人士盗用新的 PoS 区块并用它来确认和分发他的交易。如果用户没有特定的密钥，就无法生成必要的签名。

***Peercoin***

Peercoin [38] 是第一个引入权益证明算法的加密货币。然而，值得注意的是，在 Peercoin 中使用了 PoS 和 PoW 算法的组合。这意味着链中的一些区块是使用 PoW 创建的，而另一些则是使用 PoS 创建的。这两种选择都确认交易并以费用和新（发行的）硬币的形式提供奖励。然而，当使用 PoW 创建区块时，新货币的数量要大得多，因为在这种情况下，成功生成的概率不取决于验证者的余额。值得注意的是，PoW 和 PoS 的难度参数是相互独立计算和更改的。与工作证明类似，权益证明的难度负责在第一次尝试时生成证明的概率，并用于控制区块的生成频率，以便在长时间内保持一致。例如，如果最近生成了更多或更少的区块，难度将相应地增加或减少。

正如前面提到的，节点在权益证明中打造区块的机会取决于其余额中的硬币数量。然而，这并不是唯一的度量标准，因为这将使得决定将更多硬币保存在钱包中的最富有的验证者获得优先权。为了避免这种情况，使用了额外的方法来选择验证者。

为了避免，Peercoin 实现 *coinage* 机制。Coinage 是通过将在权益中的硬币数量乘以它们停留的天数来确定的。然而，硬币必须在参与打造之前在钱包中停留 30 天。将大量具有高时代的硬币保存在权益中的用户更有可能获得下一个区块的打造权。

在节点验证了下一个区块之后，coinage 会重置，需要再次等待 30 天。同时，在 90 天后找到下一个区块的概率最大化。这样可以防止拥有高权益和硬币年龄的用户主导。


```
注意：在孤区块上消耗的 coinage 会被更新。这会降低攻击成本，并意味着攻击者可以尝试生成区块，直到成功为止。为了防止风险，Peercoin 实施了一个集中式的检查点转换机制，记录区块链的状态并提醒有关替代历史版本的危险。
```


如果钱包所有者想他的硬币停止参与验证过程并返回到主余额中，他将需要等待一段时间。这样做是为了确保使用这些硬币添加的区块不会出现无效。

***Nxt***

Nxt [39] 是一种基于纯权益证明算法的数字货币，这意味着没有挖掘新硬币的方式，整个供应量（10 亿）从系统开始就可用。Nxt 的主要区别在于它如何防御“无所谓”的攻击和其他类型的攻击。

区块是基于前一个区块的唯一信息生成的，这种信息容易验证，并且几乎不可能预测。节点生成新区块的机会取决于其有效余额（对每个帐户都不同），上一个区块添加后的时间以及某个基准值。系统中的所有节点都知道最后两个参数。根据这些数据，很容易预测谁将获得生成下一个区块的权利。

如果硬币在生成 1440 个区块所需的时间内未参与交易，则将其添加到帐户的有效余额中。只有有效余额上的硬币才参与锻造过程。为防止远程攻击，参与者只能重新组织 720 个之前的区块。如果交易包含在距离当前区块 10 个区块的区块中，则该交易被视为最终有效。

值得注意的是，Nxt 使用的是帐户和余额模型，而不是像比特币和 Peercoin 那样使用 UTXO 机制，这与 Stellar 和以太坊类似。

***NEM***

最初，NEM [40] 是作为 Nxt 的克隆而设计的，但后来经过重大改进并发展来成为独立系统。NEM 不使用权益证明（PoS），而是使用一种称为重要性证明（PoI）的修改版。

PoI 与 PoS 比较相似，但使用了额外的因素来确定下一个验证者。节点的重要性由以下三个特征确定：硬币数量、交易数量和帐户的年龄。这样，NEM 的创建者鼓励用户不仅要积累硬币，还要使用它们。

与 Nxt 一样，在 NEM 中也没有硬币挖掘。验证者仅从已确认交易的费用中获得奖励。

在 NEM 术语中，为生成区块而获得奖励被称为*收获*（英语：harvesting）。为了能够参与区块生成过程，用户必须在其账户余额中至少拥有 1 万个硬币。此外，硬币并不会在它们被转移到余额后立即参与到该过程中。每天只有当前余额的 10% 的硬币会变得“胜任”。

你可以看到，收获与其他 PoS 加密货币中实施的锻造（forging）非常相似。然而，它有一些不同之处，其中最重要的是设备不必始终处于打开状态以参与交易验证过程。

NEM 具有*委派收获*机制。其思想是参与者可以将其账户连接到现有的超级节点，并利用其计算能力共同生成区块。这意味着你可以让其他节点使用你的 POI 评级，从而增加生成新区块的机会，而无需增加计算能力。

一旦 NEM 网络上出现新交易，第一个检测到它的节点会验证并通知其他节点。通过这种方式，它在网络中进行信息级联。

为了在节点之间维护一个“声誉系统”，NEM 使用了 Eigentrust$++$ 算法。它可以在系统中分配负载，并淘汰未参与验证过程的节点。

***Ouroboros***

Ouroboros 协议于 2016 年开发 [41]。它旨在消除第一代系统的缺陷。Ouroboros 是第一个经过验证强大的 PoS 协议。生成下一个区块的权利是随机确定的，但这个过程是可验证的和经过验证的公平的。当大多数参与者是诚实的时候，攻击者将无法影响算法的随机性。

Ouroboros 引入了 epoch 的概念（Cardano 基于此协议，使用持续 5 天的 epoch）。每个 epoch 又分为持续 30 秒的时隙（图 5–3）。每个时隙都收到一位获得选择将一个区块添加到当前时隙的权利一个领导者。领导者将获得奖励，无论他们是否发布了一个区块。安全模型假设攻击者可以扩展任意数量的链到他的时隙。


![alt_text](images/image3.png "image_tooltip")


图 5–3

时隙领导者的选择基于 Follow the Satoshi (FTS)算法 [42]。其思想是在所有持有股份的硬币中随机选择一枚硬币，其所有者成为领导者，并拥有所有由此产生的特权和义务。因此，参与份额的某个节点持有的硬币越多，它成为领导者的机会就越大。

由于领导者具有重要的权限，必须有一种方法来确保他的选择是真正随机的。为了确保随机性，使用了一种特殊的分布式加密协议，该协议确保了随机输出值。所谓的选民（持有一定份额的用户，例如，总硬币数的 2%）进行一次虚拟的“抛硬币”，并与其他选民共享结果。其思想是每个参与者生成一个输入值，最终参与者们得到一个共享的随机输出值，只要系统中至少有一个诚实的参与者，攻击者就无法影响这个输出值。

选择分为三个阶段：



1. 
承诺阶段。每个参与者生成一个密钥，然后形成一个中包含其他参与者的加密份额的“承诺”，并使用自己的私钥对其进行签名，指定 epoch 编号并附上他的公钥，以便每个参与者都可以验证他的消息的所有数据是否正确。


2. 
揭示阶段。参与者揭示了他们在前一阶段形成的承诺。选民将此值添加到区块链中。


3. 
恢复阶段。如果由于某种原因，某些承诺仍然未被揭示（某些参与者有网络问题等），则剩余的参与者增加他们在第一阶段获得的份额，并打开所有剩余的承诺。最终，每个参与者必须拥有一套完整的承诺和揭示值，以及其正确性的证明。所有选民接收相同的种子值，该值用于 FTS 算法。

```
注意：Ouroboros 协议的基本假设是应该有大多数诚实的节点，具体来说是 50% + 1。在这种情况下，协议保证攻击者无法违反系统的持久性和活性。
```


***Ouroboros Praos***

Ouroboros Praos [43] 是第一个旨在广泛使用的权益证明协议。Praos 的主要区别在于它适用于具有未知上限消息传递延迟的网络。在攻击者选择遵循其规则并为攻击者有利地生成区块的参与者的情况下，它提供了有保障的安全性。然而，这仅在超过 50% 的参与者是诚实的情况下才可能发生。

Ouroboros Praos 使用可验证随机函数来确保随机性。该函数接收秘钥和输入数据，并输出一个伪随机数和证明。任何拥有公钥和证明的人都可以检查该数字是否实际上是从给定输入中获得的，但无法预先获取它。

对于 Praos 中的每个 epoch，都有预先约定的随机数值，所有参与者都必须将其用作其可验证随机函数的输入数据。在每个时隙中，每个参与者使用他们的可验证随机函数和随机数来生成一个随机数。如果生成的数字小于参与者权益的阈值，他将成为给定时隙的领导者。由于随机值是由每个参与者独立生成的，可能会出现几个或没有领导者的情况。下一个纪元的随机数从上一个 epoch 的区块头中内置的可验证随机函数的值计算得出。

如果选择了多个领导者，则会发生分叉，即使它们都是诚实的。在出现分叉的情况下，诚实的参与者应选择他们首先收到的链。这意味着传输区块速度更快的领导者更有可能在最长的链中。

***Ouroboros Genesis***

Ouroboros Genesis [44] 的开发目标是创建一个类似比特币的 PoS 协议。为此，引入了“动态可用性”的概念。这涉及对具有以下特征的环境中的区块链协议进行分析：



* 各方可自由连接和断开
* 在线和离线参与者的数量是动态变化的
* 在任何给定时刻，事先不知道任何信息

Ouroboros Genesis 协议旨在保护系统免受长期攻击，即当攻击者获得了很久以前花费他们的硬币的用户的私钥，并使用这些硬币来创建一条更深入区块链的替代历史时所实施的攻击。

Ouroboros Genesis 带来的主要改进是新的链选择原则。领导者选择最长的链，但不能超过预先指定的长度，或者选择在分叉之后的区块间隔内具有更多区块的链（图 5–4）。


![alt_text](images/image4.png "image_tooltip")


图 5–4

***Proof-of-stake 的主要优势和劣势***

既然我们已经考虑了 proof-of-stake 的基本原理以及基于该协议的会计系统的具体实现，让我们突出其优势，与 proof-of-work 协议相比，这些优势更为显著。


```
无需大量计算能力
生成区块的权利不取决于计算能力，而取决于特定余额上的硬币数量（在某些情况下还取决于这些硬币的特性）
不需要专用硬件来生成区块
```


PoS 系统的主要优势在于，无需大量计算能力就可以参与交易验证：任何具备适当软件和足够硬币余额的个人电脑都可以参与铸造。此外，正如我们之前提到的，在诸如 NEM 之类的系统中，硬币可以委托给超级节点；在这种情况下，参与者甚至不需要一直保持计算机开启状态。

下一个优势显著提高了对手进行 51% 攻击的成本。然而，只有在合理选择考虑下一个验证器时的硬币特性以及引入一些随机性以防止预先计算攻击的情况下，这才是真实的。我们稍后会更详细地讨论这个和其他攻击。

最后一个重要优势直接与前两个相关。为了成为 PoS 系统中的验证者，无需购买 ASIC、大量 GPU 或大量 CPU。

然而，PoS 系统有以下缺点：


```
一次性发行比起在一段时间内延长的无许可币挖掘更加集中。
基于 PoS 协议的系统更容易受到攻击，这些攻击比如 PoW 特定攻击更容易实施。
```


***proof-of-stake系统的基本攻击类型***

现在让我们看一些针对 PoS 系统的特定攻击：


```
无利害关系
预先计算
Fake stake
币龄加和攻击
短程攻击
长程攻击
```


***无利害关系攻击***

无利害关系攻击的理念基于一个假设，是攻击者可以轻松地构建替代的区块链，而其他验证者将支持这一链，因为他们可以同时在两个链上工作，这在计算能力方面对他们来说没有任何成本。因此，可能出现所有验证者同时在多条链上工作的情况（图 5–5 和 5–6）。


![alt_text](images/image5.jpg "image_tooltip")


图 5–5


![alt_text](images/image6.jpg "image_tooltip")


图 5–6

这种情况发生的第二个原因是验证者有财务动机同时在多条链上工作，因为他们将生成更多的区块并获得更多的奖励。

然而，需要注意的是，为了实施无利害关系攻击，以下假设必须为真：



1. 
验证者在任何可能的情况下都会寻求利润，即使这会危及网络安全和质量。


2. 
一个验证者都会按照系统规则行事。


3. 
验证者修改他们的软件或使用第三方软件，该软件被故意修改以进行不正确的行为。
无利害关系攻击的主要风险是，只要所有节点都支持分叉，攻击者即可执行双重支付，即使他在系统中仅拥有总股权的 1%。让我们更仔细地看一下这种情况（图 5–7）。


![alt_text](images/image7.png "image_tooltip")


图 5–7



1. 
爱丽丝创建了链的一个分叉，并将一定数量的硬币发送到交易所。


2. 
爱丽丝在主链上添加了一笔交易，将资金转移到她的替代账户。


3. 
爱丽丝兑换了她的硬币；交易所交易记录被记录在替代链上，这也看起来是有效的，因为它得到了所有参与者的支持。


4. 
如果交易成功，爱丽丝将所收到的硬币提取到另一个系统中的钱包中。


5. 
爱丽丝停止验证替代链的区块，导致该链被废除。
在实际情况下，这种情况极不可能发生，因为它假设绝对所有的验证者都会支持每个新的区块。在现有系统中，总会有诚实的节点不会支持替代链。因此，爱丽丝将不得不让一些验证者参与她的链或增加她的股权。

***预先计算攻击***

如果验证节点拥有大量处理能力，它可以影响当前区块的哈希，以增加生成下一个区块的机会。如果计算显示下一个区块将属于另一个用户，攻击者会更改交易参数并再次尝试。此攻击的有效性取决于攻击者的股权以及系统中的验证者总数。

为防止此类攻击，应向区块生成过程添加一定程度的随机性。

***Fake stake 攻击***

这种攻击依赖于一些基于权益证明的共识算法实现在将区块放入 RAM 或硬盘之前不验证 coinstake 交易的事实。Coinstake 交易是当节点生成一个区块时，节点发送给自己的一种特殊交易。结果，攻击者可以通过使用非常少量的硬币（或根本没有硬币）向受害节点的硬盘或 RAM 填充虚假数据来导致受害节点失败。

问题在于，在许多 PoS 系统中（例如 HTMLCoin、Emercoin、Qtum 等），当区块通过网络分发时，它们被分成两个独立的消息：区块（Block）和头部（Header）。节点在验证头部并将其包含在最长链中后，才会请求区块。由于 coinstake 交易包含在区块中，节点在没有区块的情况下无法验证头部。因此，它必须将头部直接存储在 RAM 中，这给了攻击者填充受害者 RAM 的假交易的可能性。

***币龄加和攻击***

这种攻击在早期使用币龄机制的系统中是可能的。持有一定股权的攻击者可以等待很长时间，并几乎完全控制网络。

目前，在 Peercoin、Novacoin 和 Blackcoin 等系统中，存在着最大币龄限制，为 90 天。

***短程攻击***

进行短程攻击时，恶意者从最近的一个区块开始创建一条替代链，并试图超越主链，说服参与者转向他的版本。验证者同时在多条链上工作更有利，因为这会增加他们的收入，并提高他们所工作的版本正确的机会。

然而，正如你从前面的章节中所记得的，一些 PoS 系统，如 Nxt，使用基于特定特征的机制，可以预测谁将会在下一个新区块上工作。

另一种保护免受短程攻击的方法是，强制验证者在获得参与生成区块的权利之前抵押一定数量的硬币。签署冲突区块的验证者将失去他们的抵押。

***长程攻击***

长程攻击基于尝试重写区块链历史的方法，从创世区块开始，因为与基于PoW的系统不同，它不需要大量的计算资源。此外，攻击者还可以尝试获取早期系统参与者的私钥，以便使用相应的硬币来构建替代链。

可以通过限制验证者可以创建替代区块链的深度来防止这种攻击。目前许多 PoS 系统都使用了这种方法。

*****常见问题*****

*“拥有大量系统中硬币的钱包所有者为什么不能利用它们进行作弊？”*

如果拥有大量硬币的钱包所有者试图作弊，这些硬币的价格将下跌，因此对他来说是不利的。

*“如果有 100 个权益证明网络节点每秒生成并发送他们的区块提案，只会有一个被选中的区块保留下来。谁会选择哪个区块是正确的，并排除其他 99 个呢？”*

共识算法将基于区块选择规则。为了让每个人都遵循这个规则并选择一个区块，提供了一些特定的参数。例如，在 Peercoin 中，这是币龄。在 PoW 的情况下，如果有人生成了一个正确的区块，但另一个被接受了，区块的创建者将浪费计算能力。在经典的 PoS 中，区块创建者不会使用他的硬币。在 Peercoin 中，它们将保持未花费状态，并且可以在下一次尝试生成区块时使用。

*“一个 PoS 系统能否防止恶意节点修改区块规则？”*

在不修改已经运行节点的源代码的情况下，规则是无法修改的。分散系统假设存在某些会计规则，并且总会有一些节点遵循这些规则。当然，一些恶意节点可能会修改他们的软件，但他们将无法与诚实的节点进行交互，任何修改协议或其规则的尝试都将失败。


    **5.2 委托权益证明作为共识算法**

DPoS（委托权益证明）是一种去中心化环境下的共识算法，作为比特币工作量证明（PoW）和权益证明（PoS）的替代方案而创建。DPoS 是在 2014 年在 Graphene 项目的背景下开发的。它首次被用于 Bitshares，后来也用于 Steemit 和 EOS。DPoS 解决了 PoW 的主要问题——大量能源消耗。为了解决这个问题，DPoS 只将生成区块的权利授予了在选举过程中被选择的验证节点，并且这些节点需要满足特定的计算能力要求。

DPoS 还解决了 PoS 的主要问题，即用户需要启动一个完整节点以便他的代币参与共识过程。在 DPoS 中，通过完整节点验证器来处理交易，解决了这个问题。为了让他的代币参与共识过程，用户只需发送一个带有投票的特殊交易。

与权益证明相比，在 DPoS 系统中，用户的代币可以参与投票过程，同时也可以用于转账。由于余额变化，投票中的权重也会相应改变。

这种共识算法最适合设计用于既有普通用户（移动客户端），又有各种公司（充当验证者的全节点）的会计系统。DPoS 旨在保持高频率生成新区块，并且与在分布式、无信任环境中运行的其他共识算法相比，具有较高的交易容量。DPoS 非常适用于无需用户身份验证的开放式访问系统。

***DPoS 算法***

该共识算法的工作条件与 PoW 和 PoS 不同。验证者需要披露其身份，并声明他们愿意持续支持全节点，及时验证交易，并形成新的区块。

这种基于改进的权益证明的共识算法允许每个用户被选为验证者。投票由所有用户进行，投票权重由投票者的资产数量确定。由于用户可以看到谁有权生成新的区块，他们可以形成严格的验证者序列并优化区块生成和验证过程。这使得平台能够减少区块生成时间并增加容量。通过实践测试，发现几十个验证者可以实现 1-2 赫兹的区块生成频率。

根据 DPoS 的实现方式，用户还可以确定投注的权重，但无论如何，投注都不能超过用户拥有的资产数量。根据 DPoS 的实现方式，还可能存在另一个特性，即代理投票。其思想是，如果用户无法决定投票给谁，他可以将他的投票权重转移给另一个他认为在这种特定情况下更有能力的普通用户。

根据投票结果，由社区决定的自然数 N（通常在 20 到 50 之间）个获得形成新交易块的权利的候选者被选中。有趣的是，委员会成员（如果有的话）和验证者都不是匿名的。在数字货币系统中，他们有与其身份相关联的账户。他们拥有一定的声誉，参与项目的发展，出现在论坛上，提出改进等。他们的活动是可见的。协议规则保证了如果参与投票资产的大多数是由诚实的用户控制的，那么就会做出正确的决策。根据投票结果，成为验证者的代表们开始逐个发布区块。在投票过程中被选中的验证者们被以伪随机的方式洗牌形成一个队列。洗牌是通过一种特殊的算法来执行的，因此无法提前预测队列。然而，这对于所有诚实的网络参与者都是相同的。在队列中的最后一个验证者发布了一个区块后，该组循环结束，还一个新的循环在相同的顺序中开始。验证者列表在验证者工作周期的 epoch 期间是有效的。在每个 epoch 后（图 5–8），验证者的列表根据投票结果和在验证者工作期间投票的用户的投票而更新。之后，这些操作会重复进行。


![alt_text](images/image8.png "image_tooltip")


图 5–8

验证者参与以下工作：


```
维持全节点处于稳定运行状态
从所有用户收集和验证交易
区块生成
签名和发布区块
数据集的丢失恢复困难
```


验证者发布带有他们同意的上一个区块的哈希值的区块。如果所有验证者都诚实并且彼此同意，则区块链如下所示（图 5–9 (1)）。如果存在分歧，例如，验证者 C 不同意验证者 B 的区块，则链将分叉（图 5–9 (2)）。主链将根据其他验证者的决定确定。


![alt_text](images/image9.png "image_tooltip")


图 5–9

那些已经启动了全节点并且准备提供服务但尚未成为验证者的代表们将继续等待成为验证者。代表节点实际上是一个审计节点，但如果它在候选人队列中上升，随时可以成为验证者节点。

根据 DPoS 的实现方式，例如在 BitShares 中，用户还可以选择将他们的投票权转移到某些代理人身上，这些代理人的唯一目的是监视系统并进行投票。这个选项称为代理投票。

值得注意的是，例如 BitShares 用户除了选择验证者外，还可以选择委员会成员和工作者。委员会成员是可以投票更改协议特性的用户，例如区块大小、区块之间的间隔，以及确定交易费用。工作者是提供实际工作以更新协议的用户。如果工作者的提案获得足够多委员会成员的投票支持，那么他就开始开发并在每个实现阶段获得奖励。

在这个算法中，每个代表的权重直接取决于用户。通过投票，用户可以通过重新分配或删除投票权重来剥夺一个代表的权重，如果代表开始恶意行为或停止执行他们的工作。值得注意的是，投票的变化会在 epoch 结束后生效。随着时间的推移，验证者组的结构可以通过投票而改变，因此不活跃的参与者会失去他们的权利，而工作中的参与者则会受到奖励。

***DPoS 系统是如何启动的？***

在 DPoS 系统刚开始时，当没有用户彼此信任时，他们之间也没有验证者来生成区块。因此，系统缺乏用户成为验证者的能力，从而无法启动系统。这就是为什么在使用这种共识算法启动系统之前，社区通常会在不同的平台上进行投票。这次投票允许选择将作为验证者工作并扮演其他系统角色的用户。社区成员还可以公布第一个包含他们信任用户的验证者和其他参与者的列表。

***DPoS 是如何工作的？***

希望成为验证者的用户运行一个完整节点，并声明他们愿意生成区块。为此，他们创建一个新的代表来形成交易。在代表被提名后，希望投票的用户形成一个相应操作的交易。

例如，爱丽丝和鲍勃想成为验证者（图 5–10）。为此，他们形成了包含新代表创建操作的交易。这些交易将与区块 n 的发布一起添加到分类账中。伊娃和卡罗尔分别在他们的余额中拥有 115 和 564 个代币，并且他们都想投票。为此，他们形成了包含投票操作的交易，这些交易将在随后的区块中发布，例如 n + 1。


![alt_text](images/image10.png "image_tooltip")


图 5–10

让我们以一个包括三个验证者和三个工作周期的一般示例来看一下 DPoS 是如何工作的：

用户：爱丽丝、鲍勃、卡罗尔、伊娃、威尔、乔和玛丽。余额：爱丽丝 - 1；鲍勃 - 2；卡罗尔 - 3；伊娃 - 4；威尔 - 5；乔 - 6；玛丽 - 7。

你可以看到，在所有用户中，在投票阶段最有影响力的是玛丽。然后投票开始（图 5–11）：

对卡罗尔的投票：伊娃（4）、爱丽丝（1）、威尔（5）、乔（6）。对伊娃的投票：卡罗尔（3）、鲍勃（2）、玛丽（7）。对爱丽丝的投票：卡罗尔（3）、伊娃（4）、鲍勃（2）、乔（6）。对鲍勃的投票：威尔（5）。


![alt_text](images/image11.png "image_tooltip")


图 5–11

最后，卡罗尔、伊娃和爱丽丝被视为平等的验证者，因为他们拥有最多的选票，而鲍勃则保持为代表。在这种情况下，通过轮流发布块的验证者组实现了共识。假设某个用户想要执行两笔冲突的交易，TxA 和 TxB。验证者爱丽丝、卡罗尔和伊娃验证它们并仅发布他们同意的交易。在这种情况下，有两个选项：

**选项 1**

验证者们同意 TxB（图 5–12）。伊娃同意 TxB；爱丽丝同意 TxB，这意味着她同意伊娃；卡罗尔同意 TxB，因此同意爱丽丝。链没有分叉。


![alt_text](images/image12.png "image_tooltip")


图 5–12

**选项 2**

卡罗尔同意 TxA，而伊娃和爱丽丝同意 TxB。伊娃形成了一个包含她的交易的区块，然后爱丽丝，如果她同意伊娃的决定，将基于伊娃的区块形成自己的区块。否则，爱丽丝将形成一个她认为正确的单独的区块。然后，卡罗尔根据她同意的伊娃或爱丽丝的区块之一形成一个区块。在这种情况下，链分叉了。现在，对于所有网络节点来说，有两条可供选择的替代链。如果它们都符合协议规则，那么诚实的节点将有兴趣做出相同的选择。这就是为什么协议有一个规则，规定如果一条链得到更多验证者的支持，那么它将被视为优先链。在这个例子中（图 5–13），爱丽丝和伊娃选择了交易 TxB，因为它是大多数验证者的选择，所以带有 TxB 的链被认为是相关的，而带有 TxA 的链被认为是分叉链。


![alt_text](images/image13.png "image_tooltip")


图 5–13

假设选项 2 发生了，卡罗尔通过发布包含 TxA 而不是 TxB 的区块贬低了自己；因此用户决定重新分配他们的选票（图 5–14）：

投票给卡罗尔：鲍勃（2）。投票给伊娃：卡罗尔（3）、爱丽丝（1）、威尔（5）、乔（6）。投票给爱丽丝：伊娃（4）、威尔（5）、乔（6）。投票给鲍勃：威尔（5）、乔（6）、玛丽（7）。


![alt_text](images/image14.png "image_tooltip")


图 5–14

因此，鲍勃、伊娃和爱丽丝被视为相等的验证者，因为他们拥有最多的选票，而卡罗尔不再是验证者。验证者列表被更新，整个过程重复进行。

*****常见问题*****

*“你应该为我的记账系统选择哪种共识算法？”*

有几个主要的标准。用户是否信任验证者？验证者是否匿名？他们的数量是恒定的还是随时间变化？验证者是如何连接的？只有通过使用这些指标，你才能区分具有不同共识算法的各种类型的记账系统。


    **5.3 BFT 类算法**

并非所有的记账系统都需要像比特币那样的相同的去中心化水平，但与此同时，它们需要更高的容量和更低的交易确认时间。此外，通常有意义的是创建一个具有手动分配验证者功能的权限记账系统。BFT 共识协议就是在这些特定条件下运行的。

在本节中，我们将了解这类协议中最广泛的协议的运作原理。我们还将对这些协议进行比较，并解释是什么确保了 BFT 类型系统的容错性。

***实用型 BFT 算法***

实用拜占庭容错（英语：Byzantine Fault Tolerance；pBFT）[45] 是一种设计用于在异步分散系统中工作的共识算法。系统中的所有节点都相互连接，并且在任何时刻，其中一个节点是领导者。该协议的目的是在失败节点的数量不超过 *(n − 1) / 3 *的情况下，实现所有诚实节点之间的一致性，其中 n 是系统中验证节点的总数。在 BFT 术语中，失败节点不仅是那些无法活动或不可预测的节点，还包括那些故意勾结以破坏诚实节点工作的节点。

该算法包括从提议添加交易到最终更新记账系统状态的 5 个主要阶段。


```
请求
预准备
准备
提交
回复
```


接下来，我们将研究 pBFT 中这些阶段的特点，然后我们将研究诚实节点数量如何影响系统达成对更新会计系统状态的协议。

在*请求*阶段，领导节点接收待确认的交易（图 5–15）。一旦领导节点接收到交易，它会验证交易并将其组合成一个区块。完成后，该区块将被签名，并可以分发给其他验证节点。


![alt_text](images/image15.png "image_tooltip")


图 5–15

接下来是*预准备*阶段，在此阶段，领导节点将形成的区块发送给所有其他验证节点（图 5–16）。该区块由领导节点签名，并与预准备消息一起发送，这有助于其他节点验证发送者并理解该区块与共识过程的哪个阶段相关。请注意，在此阶段传输的消息总数为 *n - 1*，其中 *n* 是验证节点的总数。


![alt_text](images/image16.png "image_tooltip")


图 5–16

在接下来的步骤（准备阶段）中，其余的验证节点相互交换收到的区块（每个验证节点将区块发送给所有其他验证节点）。该区块以前的准备消息和发送者的签名一起发送（图 5–17）。因此，每个验证节点都声明已经验证了该区块并准备确认它。在此阶段的最大消息数为 *(n − 1)  ** (n − 1)*，其中 f 是验证节点的总数。如果某些节点失败并且没有响应，则网络中的最小消息数为 *(n − 1 − f) ** (n − 1)*，其中 f 是失败节点的数量（*fmax = (n − 1) / 3*）。


![alt_text](images/image17.png "image_tooltip")


图 5–17

现在，重要的是要注意网络是异步的，这意味着在验证节点之间传输消息时会存在延迟。在这种情况下，根据来自其他验证节点的 *2f + 1* 个确认，每个节点独立地做出进入下一阶段的决定。换句话说，只要其中一个节点从 *2f + 1 *个不同的验证节点接收到关于相同区块的准备消息，它就可以进入下一步。

当收到所需数量的确认时，节点将进入提交阶段，在该阶段它确认了特定的区块。在这个阶段，它生成一个提交消息，对其进行签名，并将其转发给所有其他验证节点（图 5–18）。一旦该节点从 *2f + 1 *个验证节点收到提交消息，它将根据已确认的交易更新其本地数据库状态。在此阶段的最大消息数为 *n  ** (n − 1)*，最小消息数为 *(n − f)  ** n*。


![alt_text](images/image18.png "image_tooltip")


图 5–18

在验证节点的本地数据库副本更新之后，用户可以查询它们以获取当前状态，并确保大多数验证节点已确认下一个区块（图 5–19）。请注意，pBFT 共识算法确保如果验证节点将另一个区块添加到链上，则无法更改或替换该区块。


![alt_text](images/image19.png "image_tooltip")


图 5–19

实际 BFT 协议的一个限制是验证节点之间交换的大量消息。请注意，允许节点达成共识的此类消息的最大和最小可能数量是：





其中 *n *是所有验证节点的数量，*f *是最大失败节点数（表 5.1）。

表 5.1


![alt_text](images/image20.png "image_tooltip")


让我们更仔细地看一下节点是如何达成共识的，以及如果多个验证节点失败或表现恶意会发生什么。

***共识达成过程***

想象一种情况，5 个验证节点参与使用 pBFT 协议达成一致，其中一个是领导者。在这种情况下，失败节点的最大数量是 1（如果有 2 个或更多节点失败，则无法达成共识）。

首先，让我们看一个例子，当所有节点都是诚实的，而且没有一个失败的时候（图 5–20）。达成共识的过程可以分解为以下步骤。



1. 
*请求*。在第一阶段，领导者从系统用户那里接收交易，根据协议规则对其进行验证，并形成一个区块。


2. 
*预准备*。接下来，领导节点将此区块分发给其他验证者。由于领导者行为诚实，所有其他验证者都收到相同的区块。


3. 
*准备*。节点相互交换接收到的区块。由于所有节点都是诚实的且未失败，在此阶段结束时，每个验证者从所有其他节点那里收到相同的确认。因此，他们可以转向提交步骤。


4. 
*提交*。验证者交换他们准备确认的区块值。在此阶段结束时，每个验证者收到绝大多数对单个区块的确认，并更新其注册状态。


5. 
*回复*。系统用户查询验证者以获取当前状态。由于所有验证者都基于相同的区块更新了其注册状态，其他参与者（审计员和普通用户）可以更新其本地状态。

![alt_text](images/image21.png "image_tooltip")


图 5–20

现在，让我们看一下（图 5–21）当五个验证者中的一个试图干扰共识过程时的情况。实际上，此节点可能会简单地失败；然而，我们研究当它有恶意行为时：在共识层面上，这两种情况都是相同的。



1. 
*请求*。领导者接收交易并将它们形成一个区块。


2. 
*预准备*。在这个例子中，领导节点是诚实的，因此它向所有其他节点发送相同的区块值。


3. 
*准备*。节点相互交换消息，大家都在等待特定区块的 *2f + 1* 个确认（来自 *2f + 1* 个诚实验证者）。请注意，尽管其中一个验证者的恶意行为以及它向所有其他节点发送一个与原始值不同的区块值，诚实验证者仍然可以收集到必要数量的确认并进入下一阶段。


4. 
*提交*。验证者再次相互交换包含当前区块的消息。即使恶意验证者向每个人发送一个无效的区块值，剩余的验证者仍然会收到所需数量的确认并更新其本地注册状态。


5. 
*回复*。当查询验证者时，用户会选择被大多数人确认的区块，因此攻击者的无效区块不会影响用户何时更新注册状态。

![alt_text](images/image22.png "image_tooltip")


图 5–21

在这个例子中，当有多个恶意节点存在时问题就开始了（图 5–22）。在这种情况下，剩余的节点将无法达成共识（即使诚实节点的数量多于入侵者）。因此，我们考虑当存在两个恶意验证者时系统如何运作。



1. 
*请求*。领导者接收交易并将其形成区块。


2. 
*预准备*。领导节点仍然是诚实的，因此它向所有其他节点发送相同的区块值。


3. 
*准备*。节点相互交换消息，每个人都在等待 *2f + 1* 个确认。然而，恶意节点的数量超过了* f* 个节点，因此诚实节点将无法获得足够的确认，也无法进入共识的下一阶段（提交和回复阶段被跳过，不会创建新的区块，节点会再次尝试）。
需要注意的是，如果可以确保领导者是诚实的，那么网络可以达成共识（因为其他每一个诚实的节点都会有五次确认中的三次）。但由于节点无法确定领导者是否表现诚实（实际上，领导者可能会改变主意），在这种情况下无法达成共识。


![alt_text](images/image23.png "image_tooltip")


图 5–22

作为最后一个例子，让我们看一下领导者是恶意的情况（图 5–23）。在这种情况下，它可以向所有其他节点传输不同的块数值，因此不会达成一致意见。



1. 
*请求*。领导者接收交易并形成 4 个不同的块。


2. 
*预准备*。领导者向其他节点发送不同的块数值。目前，节点不知道它们已经收到了不同的块数值，因此它们继续进行下一阶段。


3. 
*准备*。节点互相交换消息（每个节点向对方发送消息）并等待 *2f + 1* 次确认。由于它们都收到了不同的块数值，它们交换不同的值，最终导致它们中没有一个可以获得所需数量的确认，也无法继续进行共识的下一阶段。

![alt_text](images/image24.png "image_tooltip")


图 5–23

***HotStuff 共识算法***

HotStuff [46] 是另一种类似 BFT 的共识算法，也涉及到一个领导者。然而，在这个方案中，达成共识的每一步都取决于领导者。每个节点不直接与其他节点交换消息，而是将其传输给领导者，后者稍后再进行分发。在每个阶段，领导者提出了共识状态的变化（转向新阶段），节点们确认或拒绝这一变化。

这种方法可以通过减少节点传输的消息数量，显著减少整个网络的负载。

该算法涉及 4 个阶段，节点通过这些阶段达成对注册表状态更改的共识（图 5–24）。


```
准备
预提交
提交
决定
```


在这些阶段中，领导节点形成所谓的法定证书，其中包含验证者的签名。这里使用了阈值签名机制：当证书获得的签名数量超过所需阈值 *2f + 1* 时，节点们将进入下一个阶段。在每个下一个阶段开始之前，领导者向验证者发送上一个阶段的证书。节点们验证证书中是否达到了所需的阈值，并对共识的下一个阶段进行投票。


![alt_text](images/image25.png "image_tooltip")


图 5–24

*准备*阶段意味着领导节点从网络接收一组交易，形成一个确认区块，并将该区块与准备好的消息一起分发给其他验证者节点。

在*预提交*阶段，节点验证他们在前一阶段接收到的区块是否符合协议规则，然后向领导者发送确认，表示他们准备验证该区块。领导者从验证者那里收到准备好的投票，并将它们组合成一个预提交法定证书，与预提交消息一起分发给验证者以接受。

在*提交*阶段，验证者检查预提交证书，如果他们同意，则签署预提交消息并将其返回给领导者。要使该预提交证书被视为有效，必须由阈值数量的验证者签署。验证者的签名覆盖了所有交易，因此当领导者收集验证者对整个区块的投票时，他不能更改它，因为这将导致签名的有效性违反。

在领导者收到足够数量的确认后，他再次形成法定证书，但这次是为了提交阶段，并将其发送给其他验证者，之后节点进入下一个投票阶段。

在决定阶段，发生类似的过程。验证者从领导者那里收到提交法定证书，验证其是否有效，以及是否包含由必要数量的验证者签署的上一个阶段的证书，然后签署它。领导者收到足够数量的提交法定证书确认后，他形成一个决定证书并将其传递给所有验证者节点。

当验证者收到这样的证书时，他们认为所有共识阶段已经完成，并根据交易更新注册表状态。

现在让我们看一下在这种情况下验证者之间传输的消息数量（表 5.2）。

表 5.2


![alt_text](images/image26.png "image_tooltip")


正如你在图表上看到的，HotStuff 协议使得传输的消息数量相比 pBFT 大大减少。为了比较，下面的图表显示了传输消息数量与验证者数量的比率（图 5–25）。


![alt_text](images/image27.png "image_tooltip")


图 5–25

这就是说，重要的是要理解，如果领导者在其中一个阶段失败，接下来会发生以下情况：



* 
pBFT 协议意味着如果有足够多的诚实节点（并且如果领导者在第一个阶段没有失败），仍然会达成共识；


* 
HotStuff 意味着无法达成共识，因为每个下一个阶段的转变只由领导者发起。
*****常见问题*****

*“如果节点长时间失败会发生什么？”*

很多时候，共识协议规定，在新区块形成的每个阶段，领导角色会转移到新的节点。因此，如果领导者失败，并且在其中一个区块上没有达成共识，下一个区块将由下一个节点发起。

*“BFT 类共识算法的最大验证者数量是多少？”*

理论上没有严格的限制。然而，对于基于 BFT 的共识算法来说，最有效的验证者数量是几十个至几百个。对于类似 pBFT 的算法，验证者数量最多可达数十个，而对于 HotStuff 等协议，则可达数百个。从账户系统安全的角度来看，这些值是最优的。同时，这些值需要传输的消息量较少，因此可以快速达成共识。

*“如何成为基于 BFT 类共识算法的系统中的验证者？”*

要添加或删除验证者，必须获得其他 *2f + 1* 个验证者的同意。因此，要成为验证者，你需要获得当前验证者的批准并与他们建立联系。


    **5.4 FBA 作为共识算法**

联邦拜占庭共识（英语：FBA；Federated Byzantine Agreement）是基于 BFT 的共识算法。FBA 的主要区别在于系统中节点的交互由参与者自身动态确定。在这里，节点成为那些信任它的人的验证者。在金融技术领域，FBA 算法首次成功实施是在 Stellar 平台上。

在 FBA 中，节点所有者必须独立选择一组他信任的节点（期望它们不会违反规则）。因此，信任可以是单向的，因此节点 A 可以信任节点 B 的决策，但 B 不一定会信任 A。

FBA 允许在不知道彼此的无限数量的验证者之间达成共识；此外，验证者的总数量可能是未知的。

***"quorum"、"quorum slice"和"quorum intersection"的术语***

包括节点本身和它所信任的节点的集合被称为 *quorum slice*。一个节点可以有多个 *slice*。

节点 A 的 quorum 是其 slice 中的所有节点以及这些节点 slice 中的节点，换句话说，是 A 信任的人和信任 A 的人。此外， quorum 还可以更深，包括那些被 A 信任的节点所信任的人。Quorum 是一个封闭的节点集合，足以在分布式系统中达成一致。

Quorum intersection 是同时属于多个 slice 的一个节点或多个节点。Quorum 和 quorum slice 是相对集合，对于每个节点独立定义。因此，所有可能的 quorum（或 slice）的数量可能大于整个网络中的节点数量。

图 5–26 显示一个具有 quorum slice 和节点F的 quorum 的网络示例。箭头表示信任的方向。如果节点之间有两个相反的箭头，它们互相信任。如果只有一个箭头，第二个节点不信任第一个节点。


![alt_text](images/image28.png "image_tooltip")


图 5–26

图 5–27 显示了 quorum intersection，其中节点 B 是{A，B，C}和{G，D，E，F}的 intersection，节点 G 是{H，I}和{G，D，E，F}的 intersection。


![alt_text](images/image29.png "image_tooltip")


图 5–27

事实上，一个节点可以属于多个 slice，而 slice 本身可以包含另一个切片。当节点试图达成共识时，它们彼此交换消息，并仅在同意的节点数超过预定阈值时达成一致。阈值应不少于 quorum slice 中节点数的 ⅔。

***阻碍集***

FBA 还引入了*阻碍集*的概念。对于节点 N 而言，*阻碍集*（英语：blocking set）是一个包含 N 的每个 slice 至少一个节点的集合（图 5–28）。阻碍集可以说服参与者做出某个决定。


![alt_text](images/image30.png "image_tooltip")


图 5–28

***Disjoint quorum 和 divergent state***

*Disjoint quorums*：两个没有直接或间接交叉的 quorum slice 形成独立的 quorum，因此，它们做出不同的决定，导致 *divergent state*。*Divergent state* 是系统被分为几个独立的 quorum 后的状态；每个法定人数都保留着自己的交易历史，不影响其他法定人数。

在 PBFT 系统中，只要故障节点的数量不超过系统总节点数的 ⅓，就可以保证容错性。在 FBA 的情况下，这个数字根据 quorum slice 的结构而变化，从 0 到 ⅓ 不等。如果一定数量的节点创建具有相同节点数量的 quorum slice，FBA 的容错性将接近于零。如果这些节点发生故障，系统将停止运行。

图 5–29 展示了这种情况的一个例子。在这种情况下，两个 quorum slice 只有一个共同的节点。如果攻击者控制了这个节点，或者它因某种原因失败，其他节点将无法达成共识。


![alt_text](images/image31.png "image_tooltip")


图 5–29

***联邦投票***

为了在 FBA 系统中达成共识，使用了联邦投票机制（图 5–30）。它包括三个阶段：投票、接受和确认 [46；47]。首先，每个节点可以就特定的声明进行投票，例如，添加一个新的交易块。通过对该声明进行投票，节点（如果它不是恶意的）将永远不会投票支持相矛盾的声明。


![alt_text](images/image32.png "image_tooltip")


图 5–30

在投票阶段之后，节点进入*接受*阶段。如果一个节点之前没有接受过相矛盾的声明，并且存在一个包括每个参与者都投票或接受了该声明的 quorum，那么该节点可以接受该声明。不论 quorum 的决定如何，节点都接受与其 blocking set 相同的声明。由此看来节点可以对一个声明进行投票，但接受另一个声明。

然而，blocking set 并不是一个 quorum，因为一个利益相关方可以通过控制其 blocking set 中的节点来强加其决定于该节点。因此，还有另一个称为*确认*的步骤。其思想是，节点必须检测到一个所有节点都接受该声明的 *quorum*。如果节点的所有 quorum 也确认该声明，那么该节点确认该声明。

***在 Stellar 中使用 FBA***

SCP（Stellar Consensus Protocol）[47] 是基于 FBA 的共识协议。Stellar 共识协议利用联邦式投票机制确保一致的结果和系统的可操作性。在此过程中，进行了大量轮次的联邦式投票，针对各种声明，直到其中一个通过了所有阶段。

联邦式投票的第一轮是*提名*阶段，节点在此轮投票以接受特定的交易区块。在第一阶段，节点通过联邦式投票生成候选值。如果节点*确认了*其提名，则该值被视为候选值。没有候选值的节点可以提名任何值。之后，它只能根据联邦式投票程序接受和确认来自其他节点的提名声明。

为了减少候选者数量，使用了临时优先级机制。初始时，节点确定从其所属中选择的拥有优先级最高的节点的 quorum slices，并一个节点，即将提名该节点的值。只有当节点找不到更高优先级的邻居时，它才能提名自己的值。为了计算优先级，使用了哈希函数。块编号和给定节点的公钥被用作输入。节点在邻居的拓扑结构片中出现的次数越多，其优先级就越高。

在受到 blocking set 的影响下，节点可以对不同的候选者进行投票和接受提名，但最终只会确认一个。让我们看一个例子，在图 5–31 中。


![alt_text](images/image33.png "image_tooltip")


图 5–31

在提名过程中，可能会有几个已确认的候选者。后来它们被合并成一个*复合*。这种方法取决于它所实施的个别系统。例如，在 Stellar 中，交易集合被合并，生成的组合体具有集合中所有交易的最大时间戳。

当提名阶段结束并形成一个复合时，节点会进入投票阶段（图 5–32），它有三个阶段：*准备、提交、外化*。在最后一个阶段，节点实际执行他们投票的命令，例如在交易块中的操作。首先，节点必须*投票*、*接受*并*确认*投票的*准备*状态，然后这三个阶段为*实施*状态重复执行（即，为投票执行联合投票）。

投票本身是一个数据结构，由两个字段组成：一个正整数计数器和 Vote 类的对象，其中包含上个阶段的候选值。

如果由于某种原因，投票被卡在未定义状态，就会执行中止操作，从而递增计数器并使节点移至下一个投票（具有较高计数器的投票）。当节点交换有关投票状态的信息时，它们可以将一系列投票附加到消息中，而不是一个特定的状态。

当节点确信其他验证者不会投票*实施*具有不同值的投票时，投票就会获得*准备*状态。同时，对所有计数器较低的投票执行*中止*操作。当确认了投票的准备声明后，节点会继续对*实施*状态进行投票。这可以确保每个人都同意该投票，并最终执行其命令。

经过所有联邦投票轮次并确认*实施*声明后，节点执行投票中指定的命令。


![alt_text](images/image34.png "image_tooltip")


图 5–32

***中心化问题***

FBA 系统能够达成共识的恶意节点数量取决于拥有不同结构的 quorum slice，从 0 到总参与者的 ⅓ 不等。当大量节点创建与相同几个节点的 quorum slice 时，容错性将趋于零。如果这几个节点失败，系统将无法运行。图 5–33 展示了这种情况的一个例子。在这种情况下，几个 quorum slice 仅有一个共同的节点，如果该节点受到感兴趣方的控制或因某种原因停止工作，则其他节点也将无法工作。


![alt_text](images/image35.png "image_tooltip")


图 5–33

***恒星网络的分散级别***

在对 2019 年 Stellar 节点之间的交互进行分析时，明显看到大约有 35 个活跃验证者，其月正常运行时间超过 90%。此外，超过一半的 quorum slice 由 10 个或更少的验证者组成。验证者数量较少的第一个原因是缺乏在这一角色中参与系统的动机。

目前活跃的大部分验证者节点要么由恒星发展基金会本身拥有，要么由合作伙伴公司拥有。例如，IBM 在基于区块链的支付系统中使用恒星，而 Satoshi Pay 和 tempo.eu.com 正在开发基于恒星平台的应用程序。他们有动机使系统保持运行，因为他们的服务依赖于恒星。然而，他们并没有像 PoW 或 PoS 系统中那样获得实际的奖励。

第二个原因是验证者数量如此之少是因为系统对验证者的信任依赖性。根据当前 quorum slice 的结构，系统参与者从一个相对较小的验证者组中选择他们信任的验证者，这些选择可能基于他们的影响力或直接合作。由于这种信任模式，forum slice 的形成是一个有偏向的过程，它不可避免地倾向于中心化。值得注意的是，所有的拥权切片中都至少包含一个恒星发展基金会（SDF）的验证者。

这种结构导致系统故障的风险更高：如果一个节点不可用，系统会继续正常工作；然而，当任何两个 SDF 节点不可用时，将发生完全的级联系统故障，即任何验证者都无法达成共识。如果 eno 节点和其中一个 SDF 节点停止运行，将会有 90% 的节点发生故障。

一种潜在的解决方案是使 Stellar 结构更接近于 pBFT 中使用的结构。然而，在这种情况下，参与者将不得不不断监控来自所选验证者的消息，并根据节点的错误行为改变 quorum slice 的结构。此外，参与者可以降低他们 quorum slice 中的协议阈值，这本身将增加系统的活跃性，但会降低其安全性。

目前，由于两个主要节点的故障而导致整个系统崩溃的漏洞已被消除。现在，任何节点对的故障都不会导致整个系统的崩溃。然而，结构仍然相当集中。如果任何两个 SDF 节点和两个 Keybase 社交网络拥有的节点失败，系统也将停止运行。还有其他组合可以使整个系统失效。

除此之外，发现大多数 IBM 节点的 quorum slice 仅包括 SDF1、SDF2 和 SDF3，并且具有 2 的阈值。因此，现在更难完全禁用系统。尽管如此，仍值得考虑的风险是有影响力的 SDF 节点可能会受到任何感兴趣的方或串通的控制。最后一种情况不太可能发生，因为 Stellar 有兴趣保持网络及其节点的健康。

在 Stellar 的情况下，安全性故障（例如双花的可能性）比活跃性丢失更为关键（在传统银行系统中，交易延迟仍然更长）。因此，参与者选择（并必须选择）较大的拥权切片，这些拥权切片更有可能处于协议状态而不是工作状态。

***FBA 与其他共识算法的比较***

我们已经回顾了联邦拜占庭协议的基本概念、运作原理和局限性。现在让我们将其与其它常见的共识算法进行比较，以更好地了解它适用于哪些类型的系统。

与另一个来自 BFT 家族的协议——实用 BFT 协议相比，FBA 协议在可扩展性方面具有明显优势，因为它不需要节点之间大量交换消息。这使得可以构建一个拥有大量参与者的网络。

然而，与工作量证明相比，FBA 在参与者的匿名性方面具有劣势，并且它提供了更大的分散化，因为只要具有适当硬件的人都可以参与区块生成过程。正如本节前面描述的那样，Stellar 是 FBA 协议使用最突出的例子，但由于验证者更倾向于将他们绝对信任的节点包含在其拥权切片中，因此它倾向于具有集中化的结构。


    **5.5 Hashgraph**

Hashgraph 既是组织交易数据库的一种方式，也是一种共识算法。该算法的第一个版本假设存在固定数量的验证者，并且超过 ⅔ 的验证者是诚实的。Hashgraph 中的数据库组织方法类似于不断分叉的区块链，其中每个链的每个区块不仅与前一个区块相连，而且还与其他链的区块相连。

*Hashgraph *是一种数据结构，用于存储节点之间数据分发的历史记录（图 5–34）。


![alt_text](images/image36.png "image_tooltip")


图 5–34

这个算法是由 Swirlds 的联合创始人和技术总监 Leemon Baird 博士于 2016 年开发的，作为一种替代仅涉及有限数量已知验证者和领导者的共识算法。基于领导者的算法的缺点是，领导者容易受到拒绝服务攻击，结果整个系统会停止工作，直到更换领导者 [49]。该算法的一个优点是，它提供了异步拜占庭容错，这意味着其操作不依赖于消息传递的时间。在当前版本的算法中，验证过程是有权限的，这意味着要成为验证者，节点需要得到其他验证者的许可。

***Hashgraph 的工作原则***

Hashgraph 的工作原则是每个验证节点生成事件而不是区块。事件是验证者创建并分发以确认交易的条目。然后，哈希图状态与另一个验证者交换。

事件的生命周期如下：


```
创建
分发
确认
```


***事件创建***

每个验证节点可以在任何时刻创建一个签名事件。它可以包括自己的交易，从其他节点接收的交易，或者根本不包括任何交易（表 5.3）。通常，一个事件不需要包含太多的交易，因为在 hashgraph 中，每个验证者可以在任何给定的时间创建一个新的事件。

表 5.3


![alt_text](images/image37.png "image_tooltip")


表 5.3 显示每个事件包含链接到两个先前事件，而这两个先前事件又包含链接到另外两个先前相关事件，依此类推。因此，当有一个事件时，就可以跟踪其所有祖先事件（图 5–35）。


![alt_text](images/image38.png "image_tooltip")


图 5–35

***事件分发***

事件分发使用*八卦协议 *[50]。每个节点都连接到其他节点。根据该协议，当一个节点收到来自另一个节点的消息时，它开始以随机顺序将此消息传输给其他节点。因此，首先，一个节点发送一条消息，然后是两个节点、四个节点、八个节点，依此类推。结果，接收消息的节点数量呈指数增长。

假设爱丽丝希望使用八卦协议将她的新事件分发到网络上：

步骤 1：爱丽丝创建事件并计划将其分发给其他节点（图 5–36）。


![alt_text](images/image39.png "image_tooltip")


图 5–36

步骤 3：爱丽丝和卡罗尔将此事件发送给其他随机选择的节点，即鲍勃和伊娃（图 5–38）。


![alt_text](images/image40.png "image_tooltip")


图 5–38

步骤 4：现在，爱丽丝、鲍勃、卡罗尔和伊娃将此消息分发给网络中的随机选择成员。结果，所有节点都将了解此消息（图 5–39）。


![alt_text](images/image41.png "image_tooltip")


图 5–39

*八卦关于八卦*：当验证节点从另一个验证节点接收到事件时，它使用所接收的事件的链接检查它不知道的事件。然后，它请求它不知道的事件。因此，通过交换事件，验证节点同步它们的哈希图状态。此外，每个接收到事件的验证节点都根据其哈希图对其进行验证。此外，每个接收到事件的验证都根据其哈希图对其进行验证。如果它同意此事件，它还会创建一个新事件，并包含所接收事件的 *other-parent 哈希*值。然后，接收到消息的验证节点还会传播其最后创建的事件，其中 *other-parent 哈希*指向先前接收的事件。让我们看一下以下示例中的一般原则（图 5–40），该示例显示了哈希图作为哈希图的八卦协议的历史：



1. 
爱丽丝创建了事件，并向鲍勃通报了此事件以及她所知道但鲍勃不知道的所有事件。然后，鲍勃创建了与爱丽丝事件相关的自己事件，以确认他从爱丽丝那里收到了数据。


2. 
鲍勃告诉卡罗尔关于他的事件以及他所知道但她不知道的所有事件。之后，卡罗尔通过鲍勃的事件创建了与爱丽丝事件相关的另一个事件。这作为她从鲍勃那里收到信息的确认。几乎同时，爱丽丝和戴夫进行了类似的操作。


3. 
卡罗尔向戴夫通报了她的事件以及她所知道但戴夫不知道的所有事件。接下来，戴夫通过卡罗尔和鲍勃的事件创建了与爱丽丝事件相关的事件，以证明他从卡罗尔那里收到了信息。


4. 
戴夫告诉爱丽丝关于他所知道但爱丽丝不知道的事件。爱丽丝创建了与她的事件以及戴夫、卡罗尔和鲍勃的事件相关的事件。几乎同时，卡罗尔和鲍勃也在做类似的事情。

![alt_text](images/image42.png "image_tooltip")


图 5–40

每个节点存储一个通过与其他节点交换有关它的信息获得的哈希图数据结构。因此，存储在每个节点中的数据结构不断更新，并与其他节点同步。结果，大多数节点具有相同的数据结构。每个事件都以作者签名的字节序列的形式存储在内存中。

***事件确认***

拥有一组包含交易的事件，了解哪个事件较早，哪个事件较晚非常重要。因此，事件应该按时间顺序排序，并且每个节点的排序应该相同。通过为每个事件分配时间戳来达成共识来建立顺序。一旦一个事件的时间戳被大多数节点接受，就可以认为它已经确认。

为了就事件时间戳达成共识，哈希图被划分为一系列轮次(图 5–41)。


![alt_text](images/image43.png "image_tooltip")


图 5–41

一轮只有当事件中的某一个（如图 5–42 中的图顶部）通过不同创建者的大多数事件（中心高亮显示的事件）被连接到首轮的 ⅔ 才（图表底层的选定事件）开始和结束。 这种连接称为强视图。 每一轮中每个验证器节点的第一个事件称为见证事件；也针对此进行虚拟投票。


![alt_text](images/image44.png "image_tooltip")


图 5–42

在网络中，第一个事件没有祖先事件，并且每个事件由第一轮确定为见证事件。 对于每个事件，每轮都是其祖先事件的函数。 简单来说，如果最后的见证事件在图中的事件下方属于第 R 轮，则下一个见证事件之前的事件也属于第 R 轮。 下一个见证事件属于第 R + 1 轮。

为了就每一轮事件的排序达成共识，每个验证器在本地进行虚拟投票，投票中选择特定事件被检查的相邻的事件时间戳中的中位数。

*虚拟投票*：每个节点都有一个哈希图的副本，每个哈希图都是有序的，这意味着如果两个不同的哈希图 A 和 B 具有相同的事件 X，则它们的每个哈希图也具有与此事件相同的祖先，以及相同的连接。爱丽丝能够通过哈希图计算鲍勃的投票，因为她看到如果事件是鲍勃事件的祖先事件之一，那么鲍勃对此事件表示同意，他的投票被视为“赞成”。 鲍勃不必亲自投票。 因此，每个节点都可以就任意数量的决定达成一致，实际上并不发送任何投票消息，而只是通过其哈希图本地计算投票结果。 此外，如果鲍勃和爱丽丝是诚实的，那么鲍勃即使不知道事件 X，也可以通过分发协议迅速了解。 共识算法暗示这迟早会发生，但对所需时间并不做任何假设。

为了确定事件和其中包含的事务的顺序，爱丽丝进行基于轮次的虚拟投票。鲍勃和其他节点也以相同的方式进行投票。在每次投票中，假设验证器的投票将通过爱丽丝哈希列中的某些见证事件发送，并且相同哈希列中的一些见证事件将接收到它们。

鲍勃可以欺骗并创建两个见证事件 *X* 和 *Y*，这两个事件具有相同的祖先事件，而* X* 和 *Y* 不会成为彼此的祖先事件。然后会有一个事件 *W*，其祖先事件将是 *X* 和 *Y*。事件 *W* 将看到 *X* 和* Y* 是由一个节点创建的，但它们一个也不是祖先给对方，这意味着历史被分叉为两个替代事件分支的情况将被识别。在这种情况下，*W* 将看到一个具有 *X* 的事件分支，一个具有 *Y* 的事件分支或者这些分支中的任何一个都没有（图 5–43）。


![alt_text](images/image45.png "image_tooltip")


图 5–43

如果事件 *W* 至少通过 ⅔ 个不同节点的事件与事件 *X* 强关联，那么它们之间就存在强关联。因此，爱丽丝和鲍勃都具有同步的哈希图，可以计算关于特定决策的卡罗尔的虚拟投票，而且两者将得到相同的结果。

为了在每一轮事件中达成事件顺序的共识，每个验证器节点通过下一轮中唯一的知名见证事件进行本地虚拟投票。

*知名见证事件*是与下一轮中大多数著名见证事件相关联的见证事件。要识别这样的事件，只需对每个见证事件执行拜占庭协议，解决一个问题即可——这个见证事件是否受欢迎。一旦协议达到几个受欢迎的见证事件，就可以轻松地从哈希图中重现所有事件的可靠顺序。

如果在这个哈希列中有一个位于上方的见证事件，通过至少 ⅔ 的其他见证事件与已验证的见证事件相关联，那么该见证事件被认为是受欢迎的。

拥有哈希图，你可以通过虚拟投票计算所有验证器的投票。位于“*是*”的每个见证事件上方的见证事件如果它的祖先事件中有一个经过验证的事件，就对问题“特定的见证事件是否受欢迎”进行投票；否则，假定该见证事件投票“*否*”。在虚拟投票中，当见证事件投票“*是*”或“*否*”时，投票结果是通过其祖先事件的函数计算的。结果是通过拥有投票见证事件的祖先事件（在后来的轮次中创建）计算的。例如，让我们确定爱丽丝的第一个事件是否是著名的见证事件。



1. 
每个验证器都有一个哈希图，其中通过虚拟投票计算戴夫是否会爱丽丝的第一个事件是否是受欢迎的见证事件进行投票（图 5–44）。

![alt_text](images/image46.png "image_tooltip")



    图 5–44



2. 
每个验证器通过虚拟投票计算卡罗尔会就爱丽丝的第一个事件是否是受欢迎的见证事件如何进行投票（图 5–45）。

![alt_text](images/image47.png "image_tooltip")



    图 5–45



3. 
每个验证器通过虚拟投票计算鲍勃会就爱丽丝的第一个事件是否是受欢迎的见证事件如何进行投票（图 5–46）。

![alt_text](images/image48.png "image_tooltip")



    图 5–46



4. 
每个验证器通过虚拟投票计算爱丽丝会就爱丽丝的第一个事件是否是受欢迎的见证事件如何进行投票（图 5–47）。

![alt_text](images/image49.png "image_tooltip")



    图 5–47

鲍勃的第一个事件是否是受欢迎的见证事件，是根据相同的原则计算的；类似地，所有见证事件的著名见证事件都是这样计算的。

一旦确定了这一轮中的所有著名见证事件，则会删除所有具有相同创建者的著名见证事件，直到每个著名见证事件的创建者只保留一个。剩余的著名见证事件称为唯一的著名见证事件。在没有分叉的情况下，每个著名见证事件都是一个唯一的著名见证事件。通过唯一的著名见证事件的数据，可以为它们的每个祖先事件定义一致的时间戳。

一致时间戳的计算方法如下。假设被测试的事件 *X* 在第 *R* 轮。同一轮中，爱丽丝创建了一个独特的著名见证事件 *A*。算法找到事件 *Y*，该事件是爱丽丝的著名见证事件最接近的一个，她在同一轮中创建，且事件 *X* 与其关联（作为 other-parent 事件或作为最邻近的祖先事件之一）。对于事件 *X* 的创建者，他的事件 *Y* 相对于他的著名见证事件将是事件 *X*。事件 *Y* 的时间戳被认为是生成事件 *Y *的节点知道该事件的时间。事件 *X* 的最常见时间戳将是每个独特著名见证事件的创建者的所有 *Y* 事件的中位数。考虑以下示例：



1. 
让我们找到爱丽丝的独特著名见证事件（*A*）与事件 *X* 相关的最近 self-parent 事件 *YА*，并记录其时间戳* tА = 3*（图 5–48）。

![alt_text](images/image50.png "image_tooltip")



    图 5–48



2. 
让我们找到鲍勃的独特著名见证事件（*B*）与事件 *X* 相关的最近 self-parent 事件 *YB*，并记录其时间戳* tB = 1*（图5.49）。

![alt_text](images/image51.png "image_tooltip")



    图 5–49



3. 
让我们找到卡罗尔的独特著名见证事件（*C*）与事件 *X* 相关的最近self-parent 事件 *YC*，并记录其时间戳 *tC = 2*（图 5–50）。

![alt_text](images/image52.png "image_tooltip")



    图 5–50



4. 
让我们找到戴夫的独特著名见证事件（*D*）与事件 *X* 相关的最近 self-parent 事件 *YD*，并记录其时间戳* tD = 4*（图 5–51）。

![alt_text](images/image53.png "image_tooltip")



    图 5–51



5. 
事件 *X *的商定时间戳是 *tА、tB、tC、tD *的中位数（图 5–52）。

![alt_text](images/image54.png "image_tooltip")


图 5–52

当然，爱丽丝和鲍勃在任何时候都不可能拥有相同的哈希图。它们的哈希图主要根据较早的事件达成一致。然而，对于最近的事件，他们每个人可能会知道其他人不知道的事件。因此，即使绝大多数确认的交易子集是相同的，但验证者们可能拥有不同的确认交易子集。此外，如果爱丽丝不知道某个较早事件中的某个事件，未来它仍然会到达爱丽丝。这种情况下，爱丽丝会与大多数其他节点保持同步。

*****常见问题*****

*“是否可以创建规则来更改验证者？”*

Hashgraph 的主要问题是，当前版本没有定义更改验证者集合的规则。解决这个极其重要问题的一个办法可能是将增加或删除参与者的投票包含在验证者的消息中。因此，如果大多数验证者支持这个解决方案，将添加一个新节点或删除当前的一个。此外，如果验证者确定其中一个行为不诚实，他们可以投票剥夺其验证者权利。

*“Hashgraph 最适用于哪些情况？”*

Hashgraph 适用于固定数量的验证者且不需要领导者的情况。例如，几家公司合作，它们需要一个系统来记录它们之间的交互数据，这样每家公司都可以享有平等的权利，第三方无法干扰其运作。

*“哈希图算法中的验证过程是否可以是无许可的？”*

这是不可能的，除非对算法进行修改。问题在于每个审计者必须知道验证者的总数。因此，验证者的名单必须是众所周知并且受到保护的，即不能被任何人更改。

