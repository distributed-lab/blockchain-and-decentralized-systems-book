**7 分散化技术的演变**


    **7.1 比特股协议设计**

分散化平台比特股（英语：Bitshares）实现加密货币、智能合约、交易平台以及许多其他有趣的功能。Bitshares 是一个在分散化和容量之间移动的会计系统 [61]。此外，Bitshares 协议还被用作其他分散系统的基础，如 Steemit 和 EOS。

Bitshares 协议的理念如下：创建一个工具，能够在分散化环境中交易各种资产和货币，而无需实际将其存放在交易所。

***Bitshares 平台的目的***

Daniel Larimer（也被称为 Bytemaster）是该协议的主要理念提出者和开发者。Bitshares 平台允许任何人创建用户发行资产（英语：user issued assets；UIAs）或数字代币。因此，该平台记账基础货币（BTS 加密货币）和许多用户发行的代币化资产。

该协议实现了一个分散化的交易所，这些数字资产可以在这里交易。在设计会计系统和共识机制时，开发者强调了系统的容量。

Bitshares 将自己定位为智能合约平台。值得注意的是，这里的智能合约是预定义的，并且数量有限（最受欢迎的合约被实现了）。这些智能合约更加节能，因此在费用方面也更便宜。

该平台的另一个特点是支持具有高度用户隐私性的支付，用户可以把这种职能选择是否使用。在 Bitshares 中，这项技术被称为隐匿转账。

***账户模型***

现在让我们看看 Bitshares 协议中的账户是如何组织的。它使用椭圆曲线密码学，曲线本身与比特币协议中的完全相同。地址格式使用公钥的哈希值、基于 58 的数字系统、BTS 前缀，并且不包含检验和。然而，这种格式很少使用，因为一般平台数据库经过优化，每个对象，包括用户账户，都有自己的唯一标识符，这是一个 8 字节（或 64 位）的整数。通常，在发送付款时，使用这样的账户标识符。

此外，该协议支持唯一名称的注册。这种功能最早在 Namecoin 协议中实现。因此，在 Bitshares 中，你可以注册一个方便人类识别的字符串，这将在相应的区块链系统内是唯一的，并将其链接到你的账户，以便代替账户 ID 使用。

***交易模型***

让我们更详细地研究一下 Bitshares 的交易模型（图 7–1）。


![alt_text](images/image1.png "image_tooltip")


图 7–1

图中显示，交易主体包括五个主要字段。交易的前两个字段是特别重要为了将其绑定到特定的区块。这是必要的，以确定可以将该交易添加到哪个区块链中，因为根据协议规则，交易不能在未绑定的链中被确认。*expiration_time* 字段设置了交易可以被添加到区块的截止时间。如果交易在此时间之前未被确认，则被视为无效，并且无法在区块链中再包含。

*operations_vector* 字段是不同。其主要特点是可以将各种不同的操作放入其中。操作（*Operation*）是 Bitshares 协议中的另一个关键对象。以下是一些最流行的操作类型：*transfer*（转移），*account_update*（更新账户），*asset_issue*（发行代币化资产）和 *order*（交易订单）。每个操作都有自己的格式和所需参数。例如，*transfer* 操作需要发送者的账户、资产类型、转移金额和接收者的账户。操作本身是相互独立的，但只有当交易被接受时才能一起执行。

*extensions* 字段是必要的，这样当前版本的软件就可以处理新版本的交易，其中添加了额外的字段。当然，旧版本的软件不会知道如何正确验证新交易的额外字段，但它能够根据旧规则正确处理交易。

这是一个未签名的交易格式。为了正确签署交易，需要分析 *operations_vector* 字段中的所有操作，并列出必须确认交易的账户列表。然后可以确定需要用哪些密钥来签署交易。所有必要的签名都放在一个单独 *signatures* 的字段。如果至少一个签名没有提供，那么整个交易就会被视为不正确。

请注意，通过优化标识符的大小，包含一个操作的交易的最终大小大约是 100 字节。与其他协议中的交易相比，这确实是非常紧凑的交易。

关于费用，Bitshares 协议实施了一种特殊的方法：每个操作都需要一定的费用，这些费用在交易确认时从发起账户的余额中扣除。操作的费用通常是固定的，但可能会有所变化。大致比较一下，普通转账和交易的费用远低于发行新资产和注册新账户的费用。

***分散资产交易所***

现在让我们看看在 Bitshares 平台上发行和记录的资产是如何交易的。用户可以进行这样的操作，在其中声明他准备以特定的比例和金额交换一种资产与另一种资产。

这个交易在网络上传播并得到确认，之后另一个用户可以以同样的方式声明他想要以相同的比例交换相同的资产。在第二个交易得到确认的那一刻，这两位用户的余额将按照协议得到更新。例如，资产的实际交换是基于两位用户都签署了相应的交换声明。

由于这样的交易发生在一个分散的会计系统中，这个平台被称为分散交易所。然而，Bitshares 不实现交叉交易机制，它允许用户不直接而是通过订单链交换资产。

***账户管理的灵活性***

Bitshares 协议的另一个重要特征是其灵活的账户管理。动态账户权限系统使用户可以基于多重签名原则指定多个密钥来管理账户。这样实现的目的是使每个账户可以由其他账户或数字密钥的平衡组合来控制。

这种方法允许你创建一个类似于现实生活中的许可系统的层次化管理结构。结果是，你可以组织多用户管理一个账户及其余额，这里每个用户在决策中具有一定的权重。此外，对于各种的操作，你可以设置不同的标准。这种管理机制可以显著降低资产盗窃风险和失去对账户控制的风险（图 7–2）。


![alt_text](images/image2.png "image_tooltip")


图 7–2

从示意图上看，它是这样的：在层次结构的顶部，有一个主要账户，该账户需要几个账户和密钥的确认才能确认交易。层次结构较低的账户通常被称为签名者。每个签名者在相应操作的确认中具有自己的权重。例如，在上图中，签名者的权重分别为 25、40、35 和 40 单位，而确认某种类型操作的必要阈值可能是 50、60 或 70 单位。同时，对于其他类型的操作，可能需要不同的权重分布和不同的阈值。

在交易级别上它是如何工作的？其中一个签名者创建一笔包含某些操作的交易，并代表他的账户进行确认。这笔交易中包含的操作不会被执行，而是等待进一步的确认。然后，其他签名者看到这个提议，就可以通过包含特定操作的交易来代表他们的账户批准或拒绝它。

***UIA 发行***

让我们更详细地看看 Bitshares 平台上的用户资产是如何发行的。任何人都可以通过创建新资产来形成一笔交易。用户需要支付一定的费用，设置资产参数，然后发行相应的代币化资产。该协议的功能实现为一个预装的智能合约，带有一些标准功能。

根据发行人的要求，可以使用白名单机制（一个预先批准的账户列表）和发行人额外的确认来实现 KYC（了解你的客户）程序。白名单包含由发行人预先批准接收和持有相应资产代币的账户。额外的确认机制允许发行人控制每笔代币的转移或交易，这意味着发行人可以拒绝或批准他的每笔资产交易。

另外，发行人可以限制代币化资产的交易，只允许存储和转移。或者，转移可以被限制，只允许交易。发行人还可以为转移和交易这些资产设定额外的费用。

此外，发行人可以激活撤销和重新分配代币的功能。这适用于需要外部机制来撤销交易和收回支付的情况。请注意，所有资产属性和限制都是通过相应设置智能合约参数来确定的。此外，发行人决定哪些属性可以更改，哪些是永久的。例如，发行额外代币可能会受到限制，或可能允许随意发行新代币。这些合约参数对所有用户都是可见的。

对于在 Bitshares 平台上代币化的资产，还有一个有趣的方面：在执行交易时，用户可以用基础货币或直接用该代币支付交易费用。转换基于发行人设定的汇率。

***投票机制***

Bitshares 平台采用投票机制来帮助在分散环境中做出决策。委员会成员、验证者（见证人）和开发者（工作者）都是通过这种投票过程选举出来的。委员会成员需要投票以改变协议参数，例如费用、验证者数量等。验证，者或代表，由交易验证和区块生成负责。开发者提供软件改进；如果他们获得足够数量的票数并遵守开发期限，他们会获得奖励。

在投票过程中，每个账户的投票权重与其在基础货币中的余额成正比。同时，支持代理投票选项，允许你将你的投票转给另一位投票者。在用户不知道要投给哪位候选人时是很方便的，可以将这个权利交给更有经验的用户。总体而言，投票是确保平台可靠性的关键。

***费用机制***

现在让我们看看支付交易费用和奖励活跃网络参与者的机制。存在一个*外汇储备库*，这是一个不属于任何平台用户的余额，并且只能根据协议规则进行管理。规则规定，所有账户的交易费用都归入储备池。验证者和开发者的账户将获得储备池余额的一定百分比。此外，还有一个可以叠加在费用收取和分配上的推荐计划（图 7–3）。


![alt_text](images/image3.png "image_tooltip")


图 7–3

***SmartCoins***

之前我们探讨了一个实现普通代币的智能合约，现在我们讨论另一个实现*市场挂钩资产*的智能合约，是挂钩外部资产的代币。它们也被称为智能币 （英语：SmartCoins）。这基于*差价合约*进行运作。因此，任何人都可以通过冻结一定数量的基础货币作为保证金来发行这些代币。担保比例显著高于平常，建议的值为 2 或更高。在智能币系统中，一切都按照保证金交易的原则运行，使用保证金头寸和自动保证金追缴。为了在外部市场上出现资产价格数据，使用了可信任方，他们通过特殊类型的交易将数据注入 Bitshares 区块链。在这里，这些可信任方就是验证者本身。

***区块头格式***

Bitshares 的区块头结构更简单，尺寸也比比特币的区块头小（图 7–4）。


![alt_text](images/image4.png "image_tooltip")


图 7–4

包括以下字段：前一个区块的标识符 (*previous_block_id*)、时间戳、创建者的标识符 (*witness_id*)、传入交易的哈希值 (*merkle_root*) 和扩展字段，以保持与区块头新版本的兼容性。

完整的区块将包括区块的头部，创建此区块的验证者的签名，以及包含在此区块中的交易列表。

在 Bitshares 协议中，有四个概念在平台的运行中起关键作用：区块、交易、操作和对象。对象包括*账户、资产、余额、报价等*。

***操作子集及其实现特征***

让我们更详细地考虑这个协议中操作的概念。截至 2019 年，在 Bitshares 协议中大约有 40 种不同类型的操作（在每次新的协议更新期间可以添加新的操作类型）。操作允许在会计系统中发起一些简单的更改，并启用更复杂的机制，如预定义的智能合约。如上所述，一次交易可以包含多个操作，如果成功，这些操作将同时执行。

以下是一些最受欢迎的操作的简短列表：



* *transfer_operation* 将特定资产从一个账户的余额转移到另一个账户；
* *limit_order_create_operation* 创建资产交换请求对象；
* *limit_order_cancel_operation* 取消上述请求；
* *fill_order_operation *在两个申请相互对应时自动执行；它不需要创建交易，因此也被称为虚拟操作；
* *account_create_operation* 创建一个普通用户账户；
* *blind_transfer_operation* 进行保密支付；
* *asset_create_operation* 创建一个新资产对象；
* *asset_update_operation *更改现有代币的智能合约设置；
* *asset_issue_operation* 发出现有资产的代币；
* *witness_create_operation* 创建验证者候选账户。

关于统计数据，Bitshares 网络在交易数量方面的负载与比特币或以太坊网络的负载相当。此外，在 2018 年的一些时刻，Bitshares 平台处理的交易量超过了比特币和以太坊的总和。负载测试的结果表明，Bitshares 网络的最大容量是比特币和以太坊网络的数百倍。

***数据库组织***

现在，让我们看看 Bitshares 协议的一个重要架构特征，它有助于实现如此高的容量（图 7–5）。


![alt_text](images/image5.png "image_tooltip")


图 7–5

左边的图展示了一种称为区块链的数据库组织方式，它组织整个交易历史的存储。右边是另一种组织数据库的方式——账本。它组织了标识符和状态之间的对应关系的存储（例如，账户及其余额）。

区块链的特性使得检查数据库的完整性和其变化的历史变得容易。除此之外，它还可以在分散环境中轻松地组织同步并达成共识。

账本的好处在于，它紧凑地存储了数据库的最新状态，同时提供了快速搜索、读取和更新记录的功能。这就是它具有更高容量的原因。账本通常用于集中式会计系统。

Bitshares 的理念是同时利用这两种数据库组织方式。因此，完整的网络节点同时使用区块链和账本类型的两个数据库记录交易。同时，节点使用区块与彼此同步数据，并更新区块链的本地副本。他们还进行交易的验证和接受，并关注账本存储的数据库的最新状态。此外，组成账本的所有数据的大小都进行了优化，使得网络节点可以将其保存在 RAM 中。这重大加快了交易验证和接受新交易的过程。

***业务逻辑执行的优化***

许多会计系统使用通用脚本语言来定义所有操作。这些会计系统最终将“业务逻辑处理器”用作虚拟机，并且所有交易都定义为将由虚拟机运行的脚本。这种方法使用真实处理器的线程同步机制并将它们组合在一起，通过虚拟处理器执行所有指令。即使是及时编译，虚拟处理器也总是比真实处理器慢，但当所有东西都是脚本时，这种方法的最终计算速度并不是唯一的问题。

当交易在如此低的层次上定义时，这意味着大部分静态检查和加密转换仍然留在业务逻辑处理中，整体吞吐量下降。为了提高会计系统的性能并快速执行业务逻辑，所有静态检查，包括所有加密转换，必须从业务逻辑模块的范围内移除。

另一个优化步骤是在 RAM 中存储会计系统的最终状态数据。这意味着“业务逻辑处理器”可以快速跟随指向内存区域的指针，直接接收所需的数据，而无需执行耗时的数据库查询。这也意味着可以在不复制数据的情况下访问数据，并且可以在位置上进行重新安排。这个优化在基于数据库的方法中提供了性能提升。

因此，创建高性能的会计系统不需要复杂的技术，也不需要在网络节点之间划分进程。创建高性能验证节点所需的一切是将所有独立的计算与主要业务逻辑分离，在线程中不间断地执行，并将所有验证依赖项存储在 RAM 中。

***用户隐私选项***

根据上文提到，Bitshares 会计系统使用账户和余额，而不是比特币中的未花费交易输出（UTXO）为基础的会计方式。在 Bitshares 平台上增加隐私并不是一个简单的任务，因为在账户和余额的背景下，去匿名化用户甚至比在比特币中更容易。

尽管如此，Bitshares 的开发者通过一种有趣的方式解决了这个问题。他们实现了在单个操作中指定多个输入和输出的功能。现在，你可以在一个交易中包含许多输入和输出，这使得现金流的分析更加复杂，增加了用户的隐私。

此外，这些操作默认使用保密交易和隐匿地址。保密交易隐藏输入和输出的金额，但使用证明来显示输出的总和不超过输入的总和。隐匿地址则隐藏用作接收者标识的公钥与交易输出中指定的特定地址之间的关联。

Bitshares 默认情况下进行常规（非保密）支付，但用户可以根据需要使用隐匿转账。因此，该平台上的硬币记账以两种不同的方式进行。

代币可以从一种会计方法转移到另一种。为此，已实施了单独的操作：



* *transfer_to_blind_operation* 用于将硬币从公开转移到隐藏；
* *blind_transfer_operation* 以隐藏的方式转移硬币；
* *transfer_from_blind_operation* 将硬币从隐藏转移到公开。

显然，这些操作在数据量方面比通常的要大，因此需要更高的费用。

值得注意的是，任何人都可以计算有多少硬币进入了隐藏流通，因此存在隐匿供应的概念（隐藏流通中的硬币数量）。不过，Bitshares 目前（2019 年 7 月）在隐私选项方面有一个实际缺陷。事实是，高隐私模式下工作的图形界面对于普通用户来说仍然不明显且不方便。

*****常见问题*****

*“Bitshares 是否支持设置使用硬币的任意条件，例如使用比特币脚本？”*

不，目前的协议版本不支持此功能。未来不太可能添加，因为在 Bitshares 中，创建新的操作类型并在后续的协议更新中引入它们是最方便的。


    **7.2 以太坊平台和智能合约**

以太坊是一个旨在执行任意可编程智能合约的分散平台 [59]。以太坊项目有开源代码和相当大的社区（开发人员、测试人员、智能合约开发人员、用户）。以太坊实现了一个分布式数据库，这种数据库用于存储和同步用户账户和智能合约账户的状态，以及为太坊平台的基础货币（加密货币）。

以太坊平台允许智能合约开发者创建具有内置经济特征的定制分散应用程序。对于智能合约，平台实现了自己的 Solidity 这个编程语言。

***以太坊平台运行的特点***

让我们考虑以太坊平台上存在的账户类型。只有两种类型：用户账户与合约账户。让我们看看它们的区别。

用户账户只由私有数字签名密钥管理。账户持有人使用 ECDSA 算法生成他的电子签名密钥对。只有用这个密钥签名的交易才能改变这个账户的状态。

而智能合约账户的逻辑则有所不同。它只能通过预设的程序代码进行控制，该代码完全决定了智能合约的行为：在某些情况下，它将如何管理其代币，也就是说，在什么条件下这些代币会被分配，以及由哪个用户发起这个分配。如果程序代码中没有开发人员提供某些点，可能会出现问题。例如，智能合约可能会进入某个特定状态，在这种状态下，它不会接受任何用户发起的进一步执行。在这种情况下，事实上，代币将被冻结，因为智能合约没有提供解决此状态的方法。

***以太坊中创建账户***

值得注意的是，以太坊使用与比特币完全相同的算法和椭圆曲线进行数字签名，但地址的计算方式略有不同。

在这种情况下，不再像比特币那样应用双重哈希，而是通过 KECCAK 函数提供了一次哈希，长度为 256 位。接收到的值中较不重要的位被截取，即哈希函数输出值的 160 个较不重要的位。最终，我们得到一个大小为 20 字节的以太坊地址。

请注意，与比特币和许多其他系统不同，以太坊中的账户标识符以十六进制编码，而且没有校验和，而比特币中的地址以基数 58 编码，并加上校验和。因此，在以太坊中处理账户标识符时需要小心：即使是标识符中的一个错误也会导致代币丢失。

另一个重要特征是，在一般数据库层面，用户账户是在用户接受第一笔传入付款时创建的。

创建智能合约账户有完全不同的方法。首先，其中一个用户编写智能合约的源代码，完成后，代码通过以太坊平台的专用编译器，并获得以太坊虚拟机的字节码。接收到的字节码被放入特殊交易字段中。该交易代表发起者的账户进行验证，然后传播到网络上，并承载智能合约代码。交易费用以及合约执行的费用将从发起者账户的余额中扣除。

每个智能合约都包含自己的构造函数；它可以是空的，也可以有内容。在构造函数执行后，智能合约账户标识符被创建，可以用于发送代币、调用智能合约方法等。

任何账户包含四个字段：



* *nonce*：显示此账户发起的已确认交易数量的计数器；
* *balance*：属于该地址的 wei 的数量；
* *storageRoot*：Merkle Patricia 树的根节点的 256 位哈希值，该树涵盖了账户的内容（在普通账户中，该字段为空；但在合约账户中，它存储了账户状态的根哈希值）；
* *codeHash*：EVM 代码的哈希值，也就是当该账户收到调用消息时将执行的代码的值。该字段在创建账户后不能更改。

EVM 代码是以太坊虚拟机上运行的智能合约的二进制代码。通常，智能合约是用 Solidity 编写的，但执行合约的虚拟机不理解这种语言，因此首先必须将代码编译为机器可读的 EVM 代码。

EVM 是基于堆栈的，这意味着数据被压入堆栈，操作符直接与堆栈中的值进行操作 [60]。

***以太坊中的调用消息***

以太坊中的合约可以向其他合约发送“消息”。消息是虚拟对象，未序列化，仅存在于以太坊网络上。每个消息包含以下信息：



* 消息发送者；
* 消息接收者；
* 随消息传输的代币数量；
* 可选数据字段；
* STARTGAS 值（允许执行的交易最大步骤数）。

消息特别类似于交易，唯一不同的是它是由合约触发的，而不是由用户触发。当执行的合约调用生成并执行消息的 CALL 代码时，消息就会被生成。

***费用和 gas***

与许多其他会计系统不同，以太坊中的交易费用无论交易是否成功完成（即，交易中包含的代码是否完全执行）都需要支付。即使交易未成功确认，验证者也已经开始处理它（验证并将其代码发送给虚拟机执行）；因此，这些计算必须付费。

交易的最大费用由 *gasPrice* 和 *gasLimit* 的乘积定义。*gasLimit *参数由交易的发送者直接确定，并包含用户愿意为一笔交易支付的最大 gas 单位数。由于以太坊中的智能合约的性质，这种限制是必要的。由于以太坊支持图灵完备的智能合约，可能由于代码中的错误，合约可以无限期地执行（并花费所有用户的代币）。更重要的是，在交易事实上被处理和确认之前，无法准确确定交易将花费多少 gas（即，代码的正确完成）。这是因为智能合约代码中的分支可能依赖于其他账户的最新当前状态。同时，重要的是要理解，如果用户没有足够的 gas 单位来支付合约的执行，智能合约将不会被验证者完全处理。因此，交易不会被确认，但用户仍需支付费用。请注意，所有未使用的 gas 都会在交易正确处理后转换回以太币，并返回到发送者的账户余额。

如果用户不想为交易支付太多费用（或者相反，想支付更多），则可以使用 gasPrice 参数，交易发起者可以在其中确定他愿意为每个 gas 单位支付的 wei 数。这个值越高，验证者越愿意开始处理交易，因为将其添加到区块中比添加一个相对较小 gasPrice 值的交易要有利得多。实际的交易费用计算如下：

**transactionFee = gas * gasPrice.**

***以太坊交易结构***

为了更清晰，我们将开始审查以太坊交易的结构和示例智能合约代码。以太坊交易由图 7–6 中显示的字段组成。


![alt_text](images/image6.png "image_tooltip")


图 7–6

*nonce* 字段是交易相对于账户的序列号，该账户分发交易，基本上是其作者。这是为了区分重复交易，以确保同一交易不会被接受两次。因此，每个交易都有唯一的哈希值。

接下来是 *gas price* 字段。在这里你可以看到以太币基础货币转换为 gas 的价格，gas 用于支付智能合约命令的执行以及虚拟机资源的分配。这意味着什么？

在 Bitcoin，费用是用基础货币——比特币。这是由于一种简单的机制来计算其大小：我们严格按照交易中包含的数据量支付。在以太坊中，情况要复杂得多，因为仅仅指定交易数据的数量是不够的。在这里，交易可能仍然包含将在虚拟机上运行的程序代码，并且虚拟机的每个操作可能具有不同的复杂性和执行时间。还有一些操作为变量和数据数组分配内存。它们也将具有一定的复杂性，费用取决于此。此外，在交易生成阶段，还不确定将执行多少操作以及在验证者接受此交易时将执行哪些具体操作。

每个操作的成本以 gas 等值计算，并且将是固定的。引入 gas 是为了确定每个操作的固定成本。gas price 参数根据网络负载而定。基础货币的相应价值将转换为 gas 以支付费用。

以太坊交易的另一个特点是：它在虚拟机中包含的字节码将一直执行，直到它以某种结果（成功/不成功）结束，或者直到一定数量的硬币被分配用于支付费用。*start gas* 字段（通常称为 *gas limit*）是为了避免某种错误导致发送者账户中的所有硬币都被用来支付费用（例如，在虚拟机中开始运行无限循环）。它确定了发送者愿意为特定交易支付的最大硬币数量。

下一个字段称为 *destination address*。它包括硬币的接收者的地址或特定智能合约的地址，其方法将被调用。接下来是 value 字段，其中包含发送到目的地址余额的硬币数量。

接下来是一个叫 *data* 的字段。该字段不仅包含值，还包含定义虚拟机代码的整个结构。此外，你可以将任意数据放入该字段；为此，有专门的规则来填充结构。

最后一个交易字段称为 *signature*。它包含了这笔交易的发起者的数字签名，同时用于验证该签名的公钥。通过公钥，你可以得到该交易的发送者的账户标识符（地址），也就是说，在系统中唯一识别发送者账户。

***交易处理***

将交易发送到网络后，它会进入每个节点的内存池，如果以太坊网络的大部分计算能力的所有者接受它，那么它将被包含在其中一个新的区块中。请注意，为了在以太坊中确认一笔交易，必须在包含该交易的区块的基础上形成一定数量的区块。在实践中，这个数字是 6–20 个区块。严格来说，交易确认的数量由将接受交易对其账户状态的更改的一方确定。例如，一笔交易可能会将 1000 个以太币添加到爱丽丝的账户余额中（这个数额相当大），那么爱丽丝决定她将等待再有 35 个区块在确认该交易的区块之后。

每个以太坊区块至少有一笔交易，是对已形成区块的奖励。这个奖励与费用一样，被授予最先解决资源密集型任务的验证节点。实际上，奖励不会立即发放，而是在出现（形成）一定数量的区块后发放。

在以太坊中，还有一种叫 uncle block 的东西。Uncle block 是已开采且符合协议规则的区块，但由于网络延迟（或其他原因），它们比其他替代块更晚被网络节点接收，无法添加到主链中。在比特币中，这样的区块会被丢弃，但在以太坊中，它们被纳入考虑：不冲突的交易会被确认，但找到 uncle block 的奖励较少。计算公式如下： (* + 8 − **) ∗ R / 8*，其中 *R* 是基础区块奖励， 是 uncle block 的高度， 是最后一个已开采区块的高度。

***以太坊区块结构***

以太坊中的区块包含以下字段（表 7.1）。

表 7.1


![alt_text](images/image7.png "image_tooltip")


   

***以太坊虚拟机***

EVM 是以太坊网络中每个节点的重要组成部分，无论某个节点是否是验证者，因为它负责处理网络状态并执行所有必要的计算。EVM 负责处理以下信息：



* 余额；
* 地址；
* gas 状态；
* 智能合约。

每个以太坊节点都启动一个 EVM 来维护以太坊网络并达成共识。虚拟机必须监控所列组件的状态，以确保成功处理和交易确认，这反过来又影响整个分散会计系统的状态

***智能合约源代码的示例***

现在让我们仔细看看最简单的智能合约。下图显示了一个简单智能合约的源代码，它可以持有用户代币并在需要时将其返还。

这个智能合约叫做 Bank，它执行以下功能：在其资产负债表上累积代币（也就是说，当一笔交易被确认并且这样的智能合约被放置时，会创建一个新的账户，它可以在其资产负债表上包含代币）；它记住用户和他们之间的代币分配。它有补充、提取以及检查用户余额的方法（图 7–7）。


![alt_text](images/image8.png "image_tooltip")


图 7–7

让我们一行一行地查看这个代码。在这个合约中有常量字段。地址类型之一被称为 *owner*。在这里，合约记住了创建这个智能合约的用户的地址。接下来是一个动态结构，它保存了用户地址和余额之间的对应关系。

之后是 *Bank* 方法——这个合约的构造函数。在这里，owner 变量被赋予了在平台上发布这个智能合约的人的地址。*msg* 结构正是与包含此合约代码的交易一起传输到虚拟机的数据。

因此，msg.sender 是发起交易的账户地址，该账户托管了此代码。它将是智能合约的拥有者。

*deposit* 方法允许在交易中将一定数量的代币转移到合约账户。接收这些代币的智能合约将它们留在自己的资产负债表上，但在资产负债结构中添加了这些代币的发送者，以存储代币属于谁的信息。

*withdraw* 方法接受一个参数——发起者想从该合约中提取的代币数量。在这里，会检查调用该方法的用户的余额是否有足够的代币来提取资金。如果账户有足够的资金，那么智能合约会将这个数量的代币发送到用户的余额中。

*getMyBalance* 方法检查用户的当前余额。目标余额从关联结构中读取在调用账户的地址。此方法的修饰符被称为 view。这意味着该方法不会以任何方式更改其类（合约）的变量，也实际上，它只是一个读取方法。调用此方法不需要创建单独的交易，也无需支付手续费，所有计算都是在本地执行的，之后用户会收到结果。

还有 *kill* 方法。它用于停用合约并销毁其相应的状态。这里编写了额外的检查，查看调用此方法的人是否拥有此合约。如果是，则合约会自毁，self-destruct 函数接受一个参数 是合约将所有剩余代币发送到的账户的标识符。如果合约自毁，所有剩余的代币会自动进入合约拥有者的余额。

***以太坊平台上的合约执行***

让我们从示意图上来看看以太坊平台上的智能合约是如何执行的，以及完整的网络节点是如何工作的。

完整的以太坊网络节点必须至少有四个模块（图 7–8）。


![alt_text](images/image9.png "image_tooltip")


图 7–8

第一个是 P2P 网络模块——一个网络连接模块，与其他节点进行工作，交换区块、交易和其他节点信息。这是任何分散会计系统所必需的组件。

然后是 blockchain 模块——它存储区块链，处理替代链，选择优先分支，补充区块，断开区块，进行验证等。

下一个模块称为以太坊虚拟机。这个虚拟机接受来自以太坊交易的字节码。该模块处理特定账户的当前状态，并根据收到的字节码对其状态进行更改。每个网络节点上的虚拟机版本必须相同以获得相同的结果。在每个以太坊节点上发生的计算完全相同，但在网络上，它们以异步模式发生：某些节点较早接收和验证某些交易；这意味着它们执行包含其中的代码，其他节点则稍后执行该代码。因此，交易创建后，它会在整个网络上传播；节点接受它，并且在验证时（类似于在比特币中执行比特币脚本以验证交易），虚拟机的字节码会被执行。

交易被认为已验证，如果其中包含的所有代码都已执行，并且为某个特定账户生成了新的状态，直到明确是否应用了这笔交易的状态都已保存。如果交易被应用，那么这个状态不仅被认为是完成的，而且是相关的。每个节点都有一个数据库，用于存储每个账户的状态。由于所有计算都相同并且区块链版本相同，因此每个节点的所有账户状态的数据库也将相同。

***以太坊平台的局限性***

让我们看看以太坊平台（以及其他类似的智能合约平台）固有的局限性，同时也澄清一些误解。由于每个网络节点都有虚拟机，某些限制是存在的。


```
代码执行
内存分配
只能从区块链访问数据
发送付款
创建新合约
调用其他合约
```


确实，这里可以执行任意逻辑操作。然而，每个操作和每个额外分配的内存单元都需要单独付费。

虚拟机可以从区块链数据库中读取数据，以便将这些数据用作执行智能合约某种逻辑的触发器。虚拟机可以创建和发送交易，创建新合约，并调用已经在网络上发布的其他智能合约的方法等。

最常见的误解是以太坊智能合约可以使用来自任何互联网资源的信息作为其自身条件。事实是，虚拟机无法向互联网上的一些外部信息资源发送网络请求，也就是说，你不能编写一个根据街上的天气、谁赢得了冠军或其他发生在外部世界的事件来分配价值给用户的智能合约。这是因为这些事件的数据根本不在平台本身的数据库中。这意味着，如果这些数据没有在区块链上出现，那么虚拟机就无法将其用作触发器。

***以太坊平台的缺点***


```
代码中的错误（由于开发和测试的难度）
虚拟机的漏洞
为操作设定价格的难度
```


第一个缺点是，在以太坊中开发和测试智能合约存在一些困难。实践表明，人的因素成为很大比例错误的原因。这在已经编写的以太坊智能合约中是真实存在的，这些合约的复杂性中等或较高。虽然简单智能合约的错误概率较小，但复杂智能合约的错误往往会导致资金被盗、资金冻结以及过早销毁。

第二个缺点是虚拟机本身是由人创建的，在每个方面都不能完美。它可以执行任意命令——这就是漏洞所在：你可以以某种方式配置一系列命令，将它们放在一个交易中并发送执行，这将导致不可预测的后果。这是一个非常复杂的领域，但已经有几项研究表明，当前版本的以太坊网络中存在这些漏洞，它们可能导致许多智能合约的失败。

另一个可以被认为是缺点的巨大难点在于，可以在实践上或技术上确定一些特定的操作顺序，当一起执行时，这些操作会非常重地加载虚拟机并使其速度减慢，甚至不成比例地低于执行这些操作所支付的费用。

在过去，已经有研究人员在详细研究以太坊虚拟机时发现了漏洞。他们只支付了非常小的费用，但实际上他们大大减慢了整个网络的速度。这种效果是通过选择一系列特定的虚拟机命令实现的。这些问题非常难以解决，因为首先需要找到它们；第二，你需要调整执行这些操作的价格，就第三，需要进行硬分叉（同时更新所有网络节点到新版本的软件，并同时使所有这些变化生效）。

至于以太坊平台整体，已经进行了大量的研究并获得了丰富的实践经验（包括正面和负面）。这些经验用于创建其他分散智能合约平台，如 Bitshares 和 EOS。然而，仍然存在一些困难和漏洞，这些问题仍需解决。

*****常见问题*****

*“如果与智能合约相关的所有方都想更改条款，他们可以使用多重签名取消此智能合约，然后创建一个带有更新条件的新智能合约吗？”*

答案是两方面的。一方面，智能合约一旦设定，以后就不再改变；另一方面，它可能具有预定义的逻辑，允许对某些条件进行完全或部分更改。也就是说，如果你想在发布智能合约后更改其中的内容，那么你必须规定这些条件，并添加替换功能，以便可以更新现有的合约。只有这种方式才能组织合约更新。然而，这里的任何行动都必须仔细设计和测试，以避免错误并避免引入相应的漏洞。

*“我可以在智能合约中添加交易中间人吗？如果调解人和智能合约中的某个参与者串谋会发生什么？”*

智能合约中不需要调解人，但可以预见到一个或多个交易调解人。为此，你需要提前在合约中包含的标识符，并为其指定用于影响交易进展的个别方法。调解人的选择方式是他们同时得到参与过程的所有方的信任。因此，如果参与交易的各方不信任中间人，他们就不会开始互动、转移资金和调用合约方法。所有关于串谋的风险都可以通过增加独立调解人的数量来缓解。

*“是否可以在一次以太坊交易中将不同种类的代币从一个地址转移到不同的目标地址，例如交易所地址，以便在这些地址中交易这些代币？”*

这涉及到以太坊的交易模型及其与比特币模型的区别。这种区别是根本性的。在以太坊的交易模型中，如果你只转移代币，指定的金额仅从一个地址转移到另一个地址，没有找零和其他地址的参与。也就是说，以太坊并不采用未使用输出（UTXO）模型，而是采用账户和余额模型。因此，不可能在一次交易中进行多次付款——因此，需要单独的交易。如果付款必须使用不同的代币，那么每个交易都应调用处理相应代币记账的合约方法。

*“在“以太坊平台的限制”中提到无法描述取决于外部互联网资源数据的条件。是否有可能规避这一限制？”*

解决方案是智能合约本身可以包含一个或多个所谓的“预言机”。这些是收集“外部世界”状态数据的受信任方，并通过特定的方法将其传输给智能合约。合约本身反过来必须处理所有收到的数据集，认为从大多数预言机接收到的数据是真相。可以在合约中指定一个算法，这种算法不考虑与大多数预言机数据相矛盾的部分预言机的数据。

*“是否可以创建带有自定义合约的自有平台？这有多困难，需要哪些准备？”*

理论上当然可以，但为此必须解决一些问题，涉及以下内容：开发网络节点的软件，创建用户应用程序，设计验证者的激励机制，开发共识机制等。还要确定是否需要编程的智能合约，或者只需要实现几个模板；否则，每个节点都必须运行自己的虚拟机，而这需要单独开发。不管怎样，从零开始创建分散智能合约平台是一项非常困难的任务。首先，有必要根据系统需要满足的需求开始；可能会发现克隆现有系统并为特定的验证者和用户配置设置要容易得多。

