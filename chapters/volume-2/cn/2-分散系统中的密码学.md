**2 分散系统中的密码学**


    **2.1 密钥数据的生成与处理**

密码学是当今最流行的数据保护机制。它仅依赖于数学规则，不需要传输通道或存储服务器的物理安全性。密码学的有效性基于两个组成部分：加密算法的强度和密钥数据（密钥）的安全性[16]。

在本小节中，我们将讨论与密钥数据生成和处理相关的基本面。

***密钥的基本功能***

在我们了解密钥的基本功能之前，让我们首先了解一下加密密钥是什么。加密密钥是一系列控制着加密数据转换（加密算法）的执行的比特[17]。


```
数据加密
数据解密
数字签名计算（生成）
数字签名验证
消息认证码（MAC）计算
MAC 验证
共享机密计算
附加密钥数据生成
```


让我们考虑密钥的安全性如何影响这些密码算法的使用。首先，加密确保数据的机密性（内容对第三方隐藏）。如果一个密码算法被认为足够强大，那么只有使用适当的解密密钥才能看到原始消息（明文）。

在数字签名的背景下，密码密钥也扮演着重要角色。用户使用他们的私钥对初始消息进行签名，第二方使用用户的公钥验证签名。在这种情况下，如果攻击者获得了用户的私钥，他也将能够代表用户发送消息。让我们定义一下 *MAC*（消息认证码）是什么以及密钥的可靠性对于这类密码算法的重要性。除了 MAC 是使用一个秘密密钥计算和验证之外（图 2–1），MAC 值与数字签名值密切相关。


![alt_text](images/image1.png "image_tooltip")


图 2–1

从上面的解释（和图示）中，可以看到秘密密钥参与了计算和验证消息认证码的过程。这意味着如果攻击者获取了密钥，他也可以代表你发送消息。

密钥还用于在使用多个用户的密钥生成共享加密密钥时创建共享秘密。

使用密钥的另一种选择是生成子密钥，这些子密钥反过来用于上述的密码操作。例如，在 HD 钱包中就使用了这种方法。

***密钥生命周期***

一个加密密钥经历一系列状态，这些状态确定了它的生命周期（图 2–2）。主要的状态包括：



* 待处理：密钥已生成但尚未激活以供使用
* 激活：密钥用于加密数据的密码转换
* 激活后：密钥仅应用于解密或验证


![alt_text](images/image2.png "image_tooltip")


图 2–2

现在，让我们看一下与加密密钥使用相关的过程：



* 生成
* 激活：密钥可用于密码转换并分发到网络
* 暂停：限制的密钥使用（原因可能是密钥已过期或已撤销）
* 更新：以前停用的密钥可以再次用于密码转换销毁：密钥生命周期的结束（逻辑密钥销毁）；

首先生成密钥数据，然后进入待处理状态，这意味着它不用于密码操作。如果密钥长时间未使用，可以将其销毁。

当密钥用于（如加密、签名等）数据的密码转换时，它们变为激活状态。

当密钥处于激活后状态时，它只能用于解密消息和验证数字签名（或 MAC 值）。密钥可以转移到激活状态（用于密码转换数据）或被销毁。

***密钥生成原则***

密码密钥可以通过以下几种方式获得：


```
使用随机/伪随机数生成器
从另一个密钥（或密码）派生
设置共享密钥
```


***随机序列生成器***

从结构上看，随机序列生成器和伪随机序列生成器的主要区别在于，在第一种情况下，熵的来源必须具有物理噪声传感器。

随机机械运动的示例包括抛硬币、骰子、布朗运动跟踪的光电系统。

由于这种差异，随机序列生成器主要是以硬件形式实现的。在现代随机序列生成器中，最常使用具有广泛频率范围的电子噪声传感器。在开尔文绝对零度以上的温度下，所有电子元件的参数都会发生随机变化（热噪声）。因此，任何电子元件，如电阻器、硅二极管、电子管等，都可以用作物理噪声传感器。在实践中，构建一个具有无偏和非相关序列的优秀硬件生成器是一个复杂的过程。

***伪随机序列生成器***

正如我们之前提到的，伪随机序列是具有接近随机序列特性的序列，但在特定条件下这种序列可以重复。

图 2–3 显示了确定性（伪随机）序列生成器的模型。默认情况下，生成器中必须包含下面显示的每个元素。


![alt_text](images/image3.png "image_tooltip")


图 2–3

考虑到这一点，让我们描述一下伪随机序列生成器的工作原理：



1. 
初始值由只能被授权实体访问的专用函数（种子）放入内部状态。


2. 
内部状态通过内部状态修改函数进行修改，该函数将当前内部状态、用户提供的任何附加数据以及熵源的输出数据作为输入。


3. 
输出数据由将修改后的内部状态作为输入的输出数据生成函数计算。


4. 
内部状态修改函数（重新种植）在给定新的初始值时更新内部状态，并且根据此函数，当前内部状态可能取决于先前的内部状态，也可能不取决于先前的内部状态。
伪随机序列生成器的主要要求包括不可预测性、可恢复性、时间复杂性、不可逆性、统计属性不可区分于随机序列，以及重复周期必须大于或等于指定周期。

***测试随机和伪随机序列生成器***

值得注意的是，对于随机和伪随机序列生成器，有必要验证输出的随机性。

作为例子，我们使用 NIST STS，这是在用于密码信息保护工具的开发者中最广泛使用的统计测试之一。它用于评估随机和伪随机序列生成器的随机性。NIST STS 套件包含 15 个统计测试，根据这些测试生成概率向量 *P = {P1, P2, …, Pn}*；对 *Pi *组件的分析允许指示在测试序列中的具体随机性缺陷。测试及其一般描述的列表见表 2.1 [67]。

表 2.1 测试列表及其一般描述


<table>
  <tr>
   <td><strong>#</strong>
   </td>
   <td><strong>测试名称</strong>
   </td>
   <td><strong>测试描述</strong>
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td><em>位频率</em>
   </td>
   <td>这个测试的核心是确定整个二进制序列中 0 和 1 的比例。目标是查明序列中 0 的数量和 1 的数量是否几乎相同。
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td><em>块内频率</em>
   </td>
   <td>该测试的核心是确定具有长度为 m 位的块内部 1 的比例。目标是查明在长度为 m 位的块中单位的重复频率是否大致等于 m/2。
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td><em>相同比特序列</em>
   </td>
   <td>该测试的核心是计算原始序列中的总行数，其中一行表示相同比特的连续子序列。此测试的目的是得出这样的结论：由不同长度的 1 和 0 组成行的数量是否实际上与随机序列中的数量相对应。
   </td>
  </tr>
  <tr>
   <td>4
   </td>
   <td><em>1 的最长连续</em>
   </td>
   <td>此测试确定了在长度为 m 位的块内的最长连续的 1。目的是找出这样一个运行的长度是否实际上符合绝对随机序列中最长连续1 的长度的期望。
   </td>
  </tr>
  <tr>
   <td>5
   </td>
   <td><em>二进制矩阵秩</em>
   </td>
   <td>这里，从原始二进制序列构建的不相交子矩阵的秩被计算了。此测试的目标是检查构成原始序列的固定长度的子字符串之间的线性依赖。
   </td>
  </tr>
  <tr>
   <td>6
   </td>
   <td><em>频谱</em>
   </td>
   <td>该测试的本质是估计原始序列离散傅里叶变换峰值的高度。其目标是识别输入序列的周期性属性，例如，紧密相邻的重复部分。
   </td>
  </tr>
  <tr>
   <td>7
   </td>
   <td><em>不重叠模板</em>
   </td>
   <td>该测试计算在原始序列中找到的预定模板的数量。其目标是识别产生频繁设置的非周期性模板的随机或伪随机数生成器。
   </td>
  </tr>
  <tr>
   <td>8
   </td>
   <td><em>重叠模板</em>
   </td>
   <td>该测试的核心是计算在原始序列中找到的预定模板的数量。与第 7 个测试的不同之处在于，如果找到一个模板，框架只向前移动一个比特，之后搜索继续。
   </td>
  </tr>
  <tr>
   <td>9
   </td>
   <td><em>Maurer's universal</em>
   </td>
   <td>该测试确定了原始序列中相同模板之间的比特数（直接与压缩序列的长度相关）。该测试的目的是查明是否可以在不损失信息的情况下显著压缩给定序列。
   </td>
  </tr>
  <tr>
   <td>10
   </td>
   <td><em>线性复杂度</em>
   </td>
   <td>该测试基于线性反馈移位寄存器（英语：linear feedback shift register；LFSR）的工作原理。其目标是确定输入序列是否足够复杂，因此可以被视为绝对随机。
   </td>
  </tr>
  <tr>
   <td>11
   </td>
   <td><em>串行</em>
   </td>
   <td>该测试涉及计算整个比特初始序列中所有可能的 m 比特长度的重叠模板的频率。其目标是确定 m 比特长度的 2m 重叠模板的出现次数是否与完全随机的输入比特序列大致相同。
   </td>
  </tr>
  <tr>
   <td>12
   </td>
   <td><em>近似熵</em>
   </td>
   <td>与串行测试类似，该测试重点关注计算整个比特初始序列中所有可能的 m 比特长度的重叠模板的频率。测试的目的是将原始序列中长度为 m 和 m+1 的两个相邻块的重叠频率与绝对随机序列中类似块的重叠频率进行比较。
   </td>
  </tr>
  <tr>
   <td>13
   </td>
   <td><em>累积和</em>
   </td>
   <td>该测试涉及在序列中给定的（-1, +1）数字的累积和确定的任意回合中的最大偏差（离零的）。测试的目的是确定输入序列中发生的部分序列的累积和是否与绝对随机输入序列的预期和相比太大或太小。
   </td>
  </tr>
  <tr>
   <td>14
   </td>
   <td><em>随机漫步</em>
   </td>
   <td>该测试的核心是计算在累积和的任意回合中具有严格 k 次命中的循环数量。测试的目的是确定某个状态在循环内的命中次数是否与绝对随机输入序列的相应数量不同。
   </td>
  </tr>
  <tr>
   <td>15
   </td>
   <td><em>随机漫步变体</em>
   </td>
   <td>在这个测试中计算了累积和的任意回合中某个状态的总命中次数。测试的目的是确定在任意回合中对各种状态的命中次数是否偏离了预期值。
   </td>
  </tr>
</table>


***密钥派生函数（KDF）***

密钥派生函数是一种基于特定秘密值，利用伪随机函数生成一个或多个秘密密钥的函数。这类函数的操作原理与哈希函数的原理非常相似，这意味着密钥派生是一个单向函数（通常使用内存硬散列函数作为伪随机函数）。密钥派生函数只能单向运行的事实不允许我们找出原始秘密值或任何其他派生密钥。

基于密码的 KDF 通常用于哈希密码并稍后进行验证。在这种情况下，盐值与秘密密码一起用作参数。

*****常见问题*****

*“使用密码派生密钥有多安全？”*

为了从密码中派生密钥数据，建议使用一个随机的、较长的密码。因此，如果你使用一个长度为 20 个字符的随机密码（同时使用大小写字母和数字），那么要想找出这个密码并获取密钥信息，攻击者将需要大约 2120 次尝试，这是相当可接受的（尤其是在使用内存硬哈希函数时）。然而，在实践中，这种类型的密码很难记住，用户通常会选择一个要小得多的值，而且这个值不是随机的，而是与出生日期、宠物名等有关。

*“除了NIST STS之外，还有哪些用于随机序列的测试？”*

除了 NIST STS 之外，还有许多不同的用于随机序列生成器的测试。其中最流行的包括：



* 
Diehard：由乔治·马萨格利亚（George Marsaglia）开发的一组“经典”统计测试，首次于 1995 年发布。


* 
TestU01：类似于 Diehard 的一组统计测试。它包括了文献中提出的“经典”和一些第三方统计测试的实现。


* 
Dieharder：一组统计测试，包括 Diehard、NIST STS 中的所有测试以及 RGB 开发的一些额外测试。
*“时间与内存折中攻击是什么？”*

时间与内存折中是一种方法，它允许通过减少或相应地增加所使用的内存量来增加或减少计算时间。在密码学中，基于时间与内存的折中的攻击被用于加速穷举攻击。例如，考虑用于查找哈希函数前图的查找表。如果最初执行广泛的穷举攻击，可以将获得的值在内存中存储，然后在后续的查找穷举中瞬间完成。


    **2.2 密钥交换协议**

在交换密钥或其他信息时的主要任务之一是以不让任何未经授权的方访问通道中的数据内容的方式进行交换过程。通常，这需要有一个受信任的第三方或任何其他安全通道的存在。

密钥交换协议用于在用户之间创建一个安全的通信通道。它们包括密钥分发协议和密钥协商协议。

*密钥协商协议*是一系列通过生成共享的秘密密钥来创建安全通信通道的用户操作。其主要特点是每个参与方对创建共享秘密密钥作出了相等的贡献。

*密钥分发协议*是一系列用户操作的既定顺序，用于创建安全通信通道，其中包括生成和交换会话密钥以及认证消息。

*密钥分发协议*的主要目标是由参与方（爱丽丝和鲍勃）派生一个共享密钥。与此同时，鲍勃和爱丽丝必须确保通信仅在彼此之间进行，而不与攻击者或虚假方进行。大多数此类协议基于存在受信任的权威（Trent），并假定 Trent 为每个用户派生一个秘密密钥。因此，在协议开始运行之前，所有密钥已经由用户拥有。

所有密钥分发协议可分为以下（重叠的）类别：


```
基于对称加密的协议
基于非对称加密的协议
使用认证机构（受信任的权威）的协议
```


还有以下密钥分发模型：


```
面对面交换密钥
使用先前的密钥
使用受信任的第三方
```


然而，这些方法最终都归结为主体的物理存在。

使用对称加密时，想交换机密信息的两个参与方必须拥有相同的密钥。为了防止攻击者通过完整的暴力破解找到密钥，密钥必须经常更改。因此，任何加密系统的强度主要取决于密钥分发技术。这个术语意味着以一种其他人无法捕获或修改这个密钥的方式将密钥传输给想要交换数据的各方。对于两个参与者，爱丽丝和鲍勃，密钥分发可以通过以下一种方式完成：


```
密钥可以由爱丽丝创建并物理传输给鲍勃（或反之亦然）
第三方可以创建一个密钥并将其物理传输给爱丽丝和鲍勃
爱丽丝和鲍勃拥有事先创建的密钥
如果爱丽丝和鲍勃都与第三方参与者（卡罗尔）建立了安全连接，那么她可以通过这个安全通道从爱丽丝传递密钥到鲍勃
```


第一和第二种方法称为*手动密钥分发*。它们是分发密钥最可靠的方式，但在许多情况下，它们是不方便甚至不可能使用的。在分布式系统中，任何节点或服务器必须能够与许多经过身份验证的节点和服务器交换机密信息。因此，每个节点必须具有动态支持的密钥集。这个问题在大型分布式系统中尤为相关。

所需的密钥数量取决于需要进行交互的参与者数量。如果加密是在网络或传输层执行的，则对于每对网络节点都需要一个密钥。因此，如果有 N 个节点，那么所需的密钥数量为 。如果加密是在应用程序级别执行的，那么对于每一对应用程序进程都需要密钥，而进程的数量明显多于节点。

第三种密钥分发方法可以在协议栈的任何级别应用，但如果攻击者获得其中一个密钥，整个密钥序列将被揭示。此外，仍然必须进行大量密钥的初始分发。

因此，在大型自动化系统中，通常使用第四种方法的各种选项。这些选项假设存在所谓的密钥分发机构（英语：Key distribution authority；KDA），负责为节点、进程和应用程序进行密钥分发。每个参与者都必须与 KDA 共享一个唯一的密钥。

使用 KDA 依赖于使用密钥层次结构。至少使用两种类型的密钥：主密钥和会话密钥。

为了确保终端系统之间的机密通信，使用了一个临时密钥，即会话密钥。通常，会话密钥用于在传输层加密连接；之后，它会被销毁。每个会话密钥必须通过网络从密钥分发机构获得。会话密钥以加密形式传输，使用的是密钥分发机构和终端用户之间共享的主密钥。

这些主密钥也必须以某种安全的方式分发。同时，需要手动分发的密钥数量显著减少。如果有* N *个参与者想要建立连接，那么每个时刻都需要 个会话密钥，但只需要* N* 个主密钥（每个参与者一个）。

会话密钥的生命周期通常等于会话的生命周期。会话密钥越频繁更改，它们越更安全，因为对手有更少的时间来破解当前会话的密钥。另一方面，会话密钥的分发会延迟任何交换的开始并拥堵网络。需要一项安全策略来平衡这些条件并确定特定会话密钥的最佳生命周期。

如果连接的寿命很长，那么必须有定期更改会话密钥的可能性。

对于非连接协议，如面向事务的协议，没有显式的连接初始化或中断。因此，不清楚会话密钥必须多久更改一次。大多数方法依赖于对每个新交换使用新的会话密钥。最常用的策略是仅在固定时间段内或仅对一定数量的消息进行签名时使用会话密钥。

***迪菲-赫尔曼协议***

迪菲-赫尔曼协议（英语：Diffie–Hellman Protocol；DH）是一种密码学密钥协商协议，允许两个或多个参与方使用不受窃听保护的通信渠道获得共享的密钥。获得的密钥用于使用对称加密算法加密后续密钥交换。

由惠特菲尔德·迪菲（Bailey Whitfield Diffie）与马丁·赫尔曼（Martin Edward Hellman）提出的开放密钥分发方案在加密领域具有革命性意义，因为它解决了传统密码学的主要问题 –– 密钥分发问题。

在其纯粹形式中，迪菲-赫尔曼协议对通信渠道中的数据修改（包括中间人攻击）是脆弱的，因此使用它的方案会应用额外的单向或双向身份验证方法。

在用于生成长期密钥的迪菲-赫尔曼协议中，存在两个大素数作为公共参数 *p* 和 *q*（*p *是模值，*q *是群生成器）。

想象一下，在三个主体之间有一个传输通道：爱丽丝、鲍勃和卡罗尔。爱丽丝和鲍勃需要创建一个卡罗尔不知道的共享密钥；同时，卡罗尔可以看到他们通过通信渠道传输的一切。以下是创建共享密钥的步骤：



1. 
爱丽丝和鲍勃随机生成私钥 *1 &lt; a &lt; p* 和 *1 &lt; b &lt; p*，分别。


2. 
使用私钥，每个用户创建自己的公钥 A =  *mod p*（爱丽丝），*B = ** mod p*（鲍勃）。


3. 
公钥通过数据通道传输。


4. 
交换了公钥后，爱丽丝和鲍勃可以形成一个共享密钥 *S = * mod *S = ** mod p = ** mod p = ** mod p*（图 2–4）。

![alt_text](images/image4.png "image_tooltip")


图 2–4

利用共享密钥 *S* 和一个密钥派生函数（我们在这里称其为 *fk*），各方可以生成一致的密钥 *K*，例如，*K =* fk* (S，par)*，其中 par 是协商密钥的参数。通过在每个通信会话中按照相同原则单独生成会话密钥，可以实现更高的密码强度。

请注意，该算法容易受到中间人攻击。如果对手能够进行主动攻击，这意味着他不仅可以捕获消息，还可以替代它们，他可以捕获参与者 *A* 和 *B* 的公钥，创建自己的一对公钥和私钥，并将自己的公钥发送给每个参与者。之后，每个参与者将计算一个与对手而不是与另一个参与者共享的密钥。如果没有完整性控制，参与者将无法检测到这种替代。实施这种攻击需要大量资源，而在现实世界中很少发生这种攻击。

***椭圆曲线迪菲-赫尔曼协议（ECDH）***

椭圆曲线迪菲-赫尔曼协议（ECDH）也可以使用椭圆曲线进行运算。在这种情况下，爱丽丝与鲍勃分别拥有私钥 *a、b *和公钥 , 。每个公钥是通过对点 *G* 进行 *n* 次相加得到的。



1. 
爱丽丝和鲍勃生成公钥 * = а ∗ G*, * = b ∗ G*。


2. 
爱丽丝和鲍勃交换公钥。


3. 
在收到对方的公钥后，他们各自计算(, ) = *a ∗ ** = b ∗ ** = a ∗ b ∗ G*，其中* * 是共享的秘密。基于 ECDH 的大多数标准协议使用密钥派生函数从  的值获取对称密钥（图 2–5）。

![alt_text](images/image5.png "image_tooltip")


图 2–5

***加密密钥交换协议***

*加密密钥交换（EKE）协议是一种密钥分发协议*，它通过对称和非对称加密，提供了网络用户之间安全交换数据的能力。该协议假定爱丽丝和鲍勃共享一个秘密 *S*（甚至可以是熵较低的秘密，例如密码），并且通过使用该协议，他们可以相互进行身份验证并生成会话密钥*** K***（图 2–6）。


![alt_text](images/image6.png "image_tooltip")


图 2–6

让我们描述协议操作的每个步骤：



1. 
爱丽丝生成一对密钥，并用共享的加密密钥 *S* 加密来自该对的公钥 *A*。之后，爱丽丝向鲍勃发送了一条加密消息。值得提及，公钥 *A* 以加密形式传输，以便只有鲍勃能够生成用该密钥加密的消息。


2. 
收到爱丽丝的消息后，鲍勃对其进行解密，得到 *A*；然后，他生成对称密钥 *K*，该密钥将与爱丽丝共享。鲍勃使用从爱丽丝那里收到的密钥 *A* 和共享的秘密密钥* S* 分别对 *K *进行加密。


3. 
收到鲍勃的响应后，爱丽丝解密该消息并获得会话密钥* K*。在设置了会话密钥后，启动相互身份验证过程。爱丽丝生成一个随机值 *Ra*，用着 *K* 加密它，并将其发送给鲍勃。


4. 
鲍勃解密此消息，获得 ，并生成他的随机值 。然后，鲍勃将 * *与 * *连接起来，并用密钥 *K* 对结果进行加密。接下来，他将最终值传输给爱丽丝。


5. 
爱丽丝解密鲍勃的消息，确保 * *与她在步骤 3 中发送给鲍勃的相同，并用 *K* 加密的消息回答鲍勃，其中包含他的 。


6. 
鲍勃解密爱丽丝的答复，并确保 * *与他在步骤 4 中发送给爱丽丝的相同。


7. 
一旦协议完成，双方将进一步使用会话密钥 *K* 来交换信息。
*****常见问题*****

*“如何进行中间人攻击？”*

如我们前面所提到的，每个参与方都向另一方传输其公钥。实际上，如果没有确保传输消息真实性的机制，那么一方无法确保其接收到的密钥确实属于第二方。结果，攻击者可以向两方发送他的公钥值并与每个人生成一个共享密钥。之后，他可以充当转发器：接收一方的消息，阅读它，然后将其传输给另一方。此外，攻击者还可以修改这些消息。

*“我能够在两个以上的参与方之间使用 DH 协议吗？”*

是的，该协议允许在任意数量的参与方之间生成共享密钥。然而，对于更多的参与方，交互协议更为复杂，而且需要执行更多的后续步骤。

*“将公钥基础设施与 DH 协议一起使用有什么好处？”*

使用 DH 协议时，如果没有身份验证机制，中间人可能会冒充与其协商密钥的目标方。因此，爱丽丝交换公钥并生成共享密钥，实际上是与攻击者而不是鲍勃协商的。因此，DH 协议通常与公钥基础设施一起使用，后者是有关公钥及其所有者的信息来源。


    **2.3 哈希树的概念与应用**

建立数据树的概念由拉尔夫·默克尔（Ralph Merkle）在 1979 年发布。此后，这个概念被广泛应用于检查大量数据的完整性，以及在版本控制系统和密码数字签名算法中使用。

在教材的第一部分我们已经提到了哈希树。在本节中，我们将详细描述使用哈希树验证数据的过程，深入探讨这种结构可以提供的属性，并考虑该概念的主要应用领域。

***哈希树的结构***

哈希（或默克尔）树是处理大量数据的基本方法之一。总体而言，哈希树结构包括图 2–7 中描述的以下组件：


```
哈希树结构的组件
哈希根
哈希节点
哈希叶子
```



![alt_text](images/image7.png "image_tooltip")


图 2–7

*哈希叶子*是一些数据的哈希值。树的每个叶子和节点在大小上是相等的，这个大小取决于所使用的哈希函数。哈希树中叶子的数量由等于 2h 的值确定，其中 h 是哈希树的高度（在图 2–7 中，哈希树的高度为 2）。

*哈希节点*是两个子叶子（或节点）连接后的哈希值。每个节点的大小与叶子的大小相同，也由所使用的哈希函数的参数确定。

*哈希根*是放置在树顶部的一个节点。哈希根的特点是与所有子节点和叶子的关联（更改树的一个节点或叶子将更改根的值）。

构建哈希树的基本思想可以用以下方程描述：

  = ( || )

简而言之，为了获得下一级的节点，当前级别的节点（或叶子）被成对连接并进行哈希运算。

哈希树的结构具有许多有用的特性：


```
改变任何数据块中的一个位都将显着（且不可预测地）改变哈希根的值
当其中一个数据块的完整性受到破坏时，可以准确迅速地确定哪个块已被修改
认证是简单的，只需要很小的证明尺寸来证明某个块存在于哈希树结构中。
```


***构建哈希树***

让我们看一个哈希树是如何构建的例子。假设我们有 4 个包含数字的数据块："1"、"2"、"3"和"4"。要构建哈希树，我们需要为每个数据块计算哈希值，如图 2–8 所示（这里使用了 SHA-256 哈希函数）。


![alt_text](images/image8.png "image_tooltip")


图 2–8

得到的哈希值是哈希叶子节点。接下来，它们需要链接成节点。为此，将值对连接在一起，然后对得到的值进行哈希（图 2–9）。


![alt_text](images/image9.png "image_tooltip")


图 2–9

结果是我们得到了两个节点，它们现在需要以相同的方式链接成一个哈希根值。获得哈希根值与获得特定的哈希节点相同（图 2–10）。


![alt_text](images/image10.png "image_tooltip")


图 2–10

现在我们得到了一个根值，它连接了源数据的所有块。使用这个例子足以解释如何检查哈希树所有组件的完整性。

假设攻击者想要将最后一个数据块修改为“5”。在这种情况下，攻击者的动机并不清楚；然而，这并不重要。重要的是攻击者不能让每个人相信数据没有被修改。通过哈希树中使用哈希函数来实现这个特性。

当攻击者更改目标数据时，哈希值会发生变化，变得可见。由于这个叶子与相邻的叶子连接，并且将得到的值进行哈希，节点值也会改变。因此，哈希树根值完全改变（图 2–11）。


![alt_text](images/image11.png "image_tooltip")


图 2–11

你可以自己测试此示例，并确保根值确实已完全更改。攻击者只有在找到碰撞时（即经过哈希后的数据集产生与目标哈希值相同的值），实际上只有在密码哈希函数被破解时才能成功修改数据。

***哈希树中的认证***

哈希树的另一个特点是，它具有快速且简单的验证功能，即使对于大量的数据，验证也能迅速知道某个特定数据集是否存在于树结构中。为此，验证者只需要一个哈希根值和一组称为哈希分支的值。

什么是哈希（默克尔）分支？例如，验证者想要确保某个数据集存在于默克尔树结构中。他拥有数据（因此也有其哈希值），以及目标哈希根值。

其中一种选择是从节点请求所有数据块，重新计算值并将其与自己的哈希根进行比较。这种方法是可靠的，但需要传输大量数据。

因此，还有另一种在具有小数据集的情况下检查数据块是否存在于梅克尔树结构中的方法，即使用梅克尔分支。梅克尔分支包含一组哈希值（叶和节点），足以验证特定数据块。如何获取这组值？包含所需数据块的节点为它们重新计算梅克尔树，并仅选择验证器需要获取特定叶的梅克尔根值所需的值（成对连接和哈希）；然后传输所选的值。接收到一组值并拥有自己的数据块后，验证器计算梅克尔根值并将其与自己存储的值进行比较（图 2–12）。


![alt_text](images/image12.png "image_tooltip")


图 2–12

上面的图示显示了验证第三个数据集（在我们的例子中，该值为“3”）是否存在于哈希树结构中。验证器存储此数据块的哈希值（4E0740…），并获取哈希分支，包括相邻数据块的哈希值（4B2277…）和一个默克尔节点（在本例中为 F5FC2A…）。验证器将存储的值与第一个哈希分支值连接起来，并对结果进行哈希。然后将结果与第二个梅克尔分支值连接，并再次进行哈希。最终的值与现有的哈希根进行比较，如果值相等，那么这样的数据块实际上存在于哈希树结构中。


```
注意：有多种身份验证方案可以同时检查不止一个而是多个数据块的存在（从而提高算法性能）。例如，这些方案包括章鱼认证方案。
```


***哈希树的应用领域***

让我们看一下哈希树概念已应用于以下领域。


```
数字签名算法
分散文件共享系统（BitTorrent、IPFS）
区块链和 SPV 节点
版本控制系统（Git）
```


基于哈希函数的*数字签名*潜在地可用于替代当今常见的数字签名，因为传统数字签名容易受到量子计算机攻击的影响。这种类型的签名的特点是它们不需要昂贵的计算，仅基于所使用的哈希函数的强度。

哈希树的另一个应用领域是*分散文件共享协议*，比如 BitTorrent 和 IPFS。BitTorrent 协议通过为每个数据块分配数字指纹（使用 SHA-1 哈希函数的结果）来检查下载的文件片段的完整性。相关的问题是，某些相关数据的量非常大，因此这些数据的“指纹”也很大。

为了保持种子文件的大小较小，采用了哈希树方案。我们可以使用它将来自不同片段的哈希连接成一个单一的哈希根。因此，我们得到一个哈希值，允许检查整个数据块的完整性。同样，根据层次结构方案，特定的哈希节点使得能够对特定块进行完整性检查。

在 IPFS 中，所有数据都表示为一个默克尔有向无环图（英语：merkelized directed acyclic graph；MDAG），这允许用户检索与单一唯一标识符相关联的整个数据集（直至目录的内容）。

自 2009 年 1 月 3 日比特币出现以来，哈希树构建方案引起了最多的关注。在"比特币：点对点的电子现金系统" [18]中，提供了以下方案（图 2–13）。


![alt_text](images/image13.png "image_tooltip")


图 2–13

这个图表描述了比特币中的区块结构。在其头部，有一个名为*"Root Hash"*的字段。这是什么意思呢？

比特币中的每个区块包含多达数千个交易。这些交易被散列并形成未来哈希树的叶子。然后，这些叶子被两两连接并散列，直到获得一个单一的根值。这正是放置在区块头部的值，在名为"Root Hash"的字段中。这个方案允许检查一个交易在一个区块中是否包含。

根据这个原则，*简单支付验证（英语：simplified payment verification；SPV）*方法运作。每个 SPV 节点都存储所有区块头（每个区块头的大小为 80 字节）。区块头包含了已添加到相应区块的所有交易的哈希根值。如果 SPV 节点想要确保交易已被确认，它会联系完整节点并请求特定交易的哈希分支（图 2–14）。一旦收到哈希分支，验证者将构建到哈希根值的认证路径（该值由它存储，因为它与其他网络节点同步）。


![alt_text](images/image14.png "image_tooltip")


图 2–14

*****常见问题*****

*“为什么要使用哈希树，而不是对整个数据序列进行哈希？”*

如果我们对整个数据集进行哈希，我们也可以确保其完整性。然而，在这种情况下，披露部分数据是不灵活的。如果我们对整个数据集进行哈希，验证者只能检查数据是否与整个集合的哈希值匹配。使用哈希树可以证明一个数据片段包含在整个结构中。这种方法对证明的总量要求较少，而且还可以通过仅证明其片段的完整性来确保整个数据集的机密性。

*“任何节点是否可以有超过两个子节点？”*

实际上，有这样一种情况，我们可以构建一个中每个节点将具有多于两个的子节点树。然而，这将显著降低此方法的效率并增加用于验证特定数据集的证明的大小。


    **2.4 数字签名的类型**

数字签名是一种机制，允许确保已签名消息的完整性和作者身份。然而，其应用的某些领域需要确保数字签名通常无法提供的其他属性。因此，提出了一些新的方法，在本小节中我们将对其进行考察。


```
一次性签名
多重签名
门限签名
群签名
环签名
盲签名
```


***一次性签名方案***

一次性签名方案最早由莱斯利·兰伯特（Leslie Lamport）于 1979 年提出。这类方案的基础是使用单向函数（哈希函数）。一次性签名意味着只使用一对密钥签署一条消息。在签署过程中，该方案暗示了私钥片段的公开。如果同一密钥对被多次使用，那么私钥的更多部分将被披露，然后攻击者可以利用这些部分恢复他人的私钥并代表目标用户为其他消息生成签名。

为了理解一次性签名的基本原理，我们将考虑两种基本的一次性签名算法（LOTS（兰伯特一次性签名）[19]和 WOTS（温特尼茨一次签名）[20]），以及两种算法中签名的计算和验证的特点，它们的基本特性以及攻击者可以利用什么来伪造特定用户的签名。

***兰伯特一次性签名***

首先，用户需要生成一对密钥，用于生成和验证签名。兰伯特签名方案[21]假设用户的私钥由一组成对的随机生成的秘密值组成。它们的数量由签名消息的大小确定（即哈希值的长度）。如果所使用的哈希函数输出值长度为 n 位，那么必须生成 *2n* 个秘密值来签署相应的消息。私钥如图 2–15 所示。


![alt_text](images/image15.png "image_tooltip")


图 2–15

例如，如果我们生成每个 256 位长度的秘密值并使用 256 位长度的哈希函数，那么我们的私钥长度应约为 8 千字节，与传统方案中使用的 256-512 位长的密钥相比，这是相当大的数据量。

公钥是由生成的秘密的哈希值组成的串联值。其长度取决于用于生成它的哈希函数（如果哈希函数的输出等于秘密的大小，那么在这种情况下，公钥和私钥的大小将相同）。从私钥生成公钥的过程如图 2–16 所示。


![alt_text](images/image16.png "image_tooltip")


图 2–16

在计算公钥后，它可以被发布、传输给验证者、在网络上传播等。在这种情况下，如何计算签名值？生成签名消息后，会从中计算一个哈希值。要签署一条消息，我们必须发布取决于哈希值的特定位（它是否等于“0”或“1”）配对中的一个秘密值之一（图 2–17）。


![alt_text](images/image17.png "image_tooltip")


图 2–17

结果，初始生成的秘密值中确切有一半被发布。现在如何验证签名是否有效？验证者可以计算消息哈希并得到相同的位序列。根据这个序列，验证者根据得到的哈希值的特定位的值选择一组公钥（图 2–18）。


![alt_text](images/image18.png "image_tooltip")


图 2–18

在验证者生成了所需的公钥集之后，他从数字签名的各个部分计算哈希值，如果这些值的哈希值与前一步生成的公钥匹配（图 2–19），则签名就有效。


![alt_text](images/image19.png "image_tooltip")


图 2–19

***为什么签名是“一次”的？***

为了理解兰伯特一次性签名的工作原理以及为什么不能使用一个密钥签署多个消息，让我们看一个简单的例子。我们将使用一个返回四位值的哈希函数（我们省略计算算法：我们只知道相同输入数据的哈希函数输出相同）。

首先，我们生成一个私钥。由于哈希长度为四位，我们需要生成八个秘密值（图 2–20）。


![alt_text](images/image20.png "image_tooltip")


图 2–20

之后，需要通过哈希秘密值（图 2–21）计算公钥的值，并将其发送给验证者。


![alt_text](images/image21.png "image_tooltip")


图 2–21

当用户形成一条消息时，他计算其哈希值。接下来，生成数字签名。例如，得到的哈希值为"0110"。在这种情况下，签名值由私钥的部分组成，具体取决于哈希值的位（图 2–22）。


![alt_text](images/image22.png "image_tooltip")


图 2–22

在发布这个数字签名值以及消息之后，几乎每个人都会认出生成的秘密值的一半：*X0*、*Y1*、*Y2*、*X3*。攻击者可以保存这些值；之后，他更容易猜测受害者私钥的剩余部分。

如果同一用户再次使用相同的密钥序列签署另一条消息，那么这条消息的哈希值也将不同。因此，所需发布的秘密位置也会发生变化。这意味着在发布数字签名的新值之后，将披露私钥组件的另一部分。例如，如果用户第二次使用相同的私钥签署哈希值为"1001"的消息（图 2–23），他需要披露以下位置的秘密值：*X0*、*Y1*、*Y2*、*X3*。


![alt_text](images/image23.png "image_tooltip")


图 2–23

如果攻击者已经获取了两条消息及其签名值，那么他拥有了最初生成秘密值的完整集合。这意味着他可以代表目标用户签署任何消息。由于私钥的所有者不希望将其披露，因此他可以使用一个密钥生成不超过一个签名。

***温特尼茨一次签名***

另一个一次性签名的例子是温特尼茨一次签名（英语：Winternitz OTS）[20]。这种方法与兰伯特签名非常相似，但它为每个消息块而不是每个签名消息位假定一个单独的秘密值。因此，温特尼茨参数（宽度）被初步确定了，这个参数反映了消息块的大小。例如，如果我们将温特尼茨宽度设置为 16（4 位），并使用 SHA-256 哈希函数，那么原始哈希值将被分成 64 个 4 位长度的块。

然后，我们生成私钥值。在这种情况下，密钥的数量与块的数量匹配（图 2–24），也等于 64。


![alt_text](images/image24.png "image_tooltip")


图 2–24

*公钥*是通过连接私钥部分的哈希值计算的。此外，所需的哈希函数计算次数等于温特尼茨宽度的值。基于这一点，公钥片段等于用于计算哈希值的私钥片段的 16 倍（图 2–25）。


![alt_text](images/image25.png "image_tooltip")


图 2–25

*公钥*生成后可以传递给验证者。当签署消息时，其哈希值会预先计算并分成 4 位块。之后，每个块都转换为十进制值（图 2–26）。


![alt_text](images/image26.png "image_tooltip")


*数字签名*是每个块的私钥值，该值被散列了次数等于转换表明后的十进制值获得所示的次数（图 2–27）。


![alt_text](images/image27.png "image_tooltip")


图 2–27

当验证者接收到签名值时，它会预先计算接收到的消息的哈希值并将其分成块。之后，它将每个块的值转换为十进制形式，从温特尼茨宽度值中减去十进制值，并得到自己的自然数集。此后，验证者根据所得到的自然数集对签名片段的值进行哈希（次数等于从温特尼茨宽度中减去块十进制值的结果）。如果每个得到的哈希值等于公钥的相应部分，则验证的签名是正确的（图 2–28）。


![alt_text](images/image28.png "image_tooltip")


图 2–28

***多重签名***

*多重签名*是一种数字签名方案，它要求多个方参与（同时应用他们的私钥）来计算签名。有两种主要类型的多重签名。第一种假设签名根据公钥集进行验证。在这种情况下，参与方确定公钥和验证签名所需的密钥数量。签名本身由一组值组成，每个值由单独的公钥验证（图 2–29）。


![alt_text](images/image29.png "image_tooltip")


图 2–29

多重签名的第二种类型允许将公钥值聚合成一个共同的值，该值将用于检查单个聚合签名值。在这种情况下，参与方最初形成共享的公钥值并发布它。在签名过程中，每个方分别得对所需的消息进行签名，但接收到的签名值可以“添加”，并且可以使用共享的公钥验证结果（图 2–30）。


![alt_text](images/image30.png "image_tooltip")


图 2–30

这种签名类型有哪些优势？主要优势在于减少存储多重签名所需的内存量。与标准的多重签名不同，后者的大小会随签署者数量的增加而线性增加，而由多个参与者计算的签名的大小，例如使用 Schnorr 算法[22]，与单个签名的大小没有区别。

另一个优势是这种方案中参与者的保密性。由于共享的公钥是一个聚合值，第三方很难恢复签名者的公钥并将其与这些密钥的所有者关联起来。所有系统参与者只看到共享的公钥与签名的聚合值，它在视觉上与通常的单个签名没有区别。

***门限签名***

门限签名是多重签名的一种变体，其一个重要区别在于交互参与者的公钥具有不同的权重值。

这种方法，即确定特定操作所需的权重，并为公钥分配权重值，经常在会计系统中使用。因此，用户可以使用具有最大权重值的一个密钥对，最初为他的账户创建所谓的签名者（一组公钥），并为每个公钥设置自己的权重值。

在验证签名时，验证者检查签名消息的权重总和是否满足所需的门限（图 2–31）。在这种情况下，门限为 1。


![alt_text](images/image31.png "image_tooltip")


图 2–31

***群签名***

群签名是一种机制，允许用户代表一个群体签署特定消息。群签名具有以下特性。


```
只有群成员可以生成正确的签名
验证者可以确定特定签名是由群成员之一计算的
验证者无法确定哪个群成员签署了消息
在争议情况下，群管理员可以披露签署者的身份
```


最初提出的群签名类型需要完全信任的*群管理员*。

群管理员首先生成大量的密钥对。然后，他将私钥分发给群成员。之后，他形成一个包含群成员公钥的列表，并将这些密钥以随机顺序洗牌。

最后，他公布这个列表。

当群成员之一想要签署文件时，他随机选择一个私钥并计算签名。当验证者检查签名的值时，他在公钥列表中搜索与签名匹配的公钥。如果他找到了合适的公钥，那么签名是由群成员之一生成的 （图 2–32）。


![alt_text](images/image32.png "image_tooltip")


图 2–32

这是群签名方案的最简单实现，但存在一些缺点：



* 群管理员可以代表群成员签署消息
* 添加新的群成员很困难
* 每个群成员的密钥子集应足够大，以增加将密钥与其所有者关联的分析难度

目前有大量的群签名算法可以消除列出的缺点。当用户自己生成他们的私密信息时，对群成员对管理员的信任问题得以解决。在这种情况下，管理员只提供给他们一组值，这些值对于生成私钥和计算可由群公钥验证的签名是必要的。

在这种情况下，验证者使用群公钥检查签名，无法发现它与特定参与者的关联。这样的方案支持向群组添加新成员的简单机制。同时，提供了我们之前考虑的群签名的基本属性。

***环签名***

*环签名*是一种数字签名类型，允许群组中的一个成员（称为环）代表整个群组签署消息。要生成这样的签名，用户需要其他用户的公钥和他自己的密钥对。在验证签名时，验证者可以检查它是否由环中的某个成员计算，但无法准确确定是由谁计算的。

环签名算法由阿迪·沙米尔（Adi Shamir）、雅埃尔·陶曼（Yael Tauman）和罗纳德·李维斯特（Ronald Rivest）提出了，并于 2001 年在 Asiacrypt 国际会议上宣布[22]。在他们的论文标题中，创始人试图强调生成此签名时缺乏中心协调结构：“环是一个具有同质周界但没有中心的几何图形”。

与群签名不同，在环签名方案中不存在预先准备好的参与者群体；创建或修改这样的群组不需要任何准备工作。主要求是每个参与者必须与一个密钥对相关联。这使得签名者可以选择一个任意的可能签名者集合（其中包括自己），并独立使用可能的其他参与者的公钥和自己的私钥计算签名。

想象一个由 n 个用户组成的群体，如图 2–33 所示。每个用户都有自己的密钥对：*私钥和公钥*（*sk，PK*）。*私钥*只有各自的所有者知道，而*公钥*则为系统中的所有参与者所知。


![alt_text](images/image33.png "image_tooltip")


图 2–33

为了代表群体创建签名，用户必须将所有环参与者的公钥（包括自己的）作为算法的输入，并使用自己的私钥作为密钥。每个参与者的公钥对于系统中的所有人都是可用的。图 2–34 以示例形式展示了如何为用户 4 形成环签名。


![alt_text](images/image34.png "image_tooltip")


图 2–34

当验证者检查签名值时，他可以确信签名是由群体成员之一生成的，但无法确定是由谁生成的。他只能以 *1/n* 的概率确定签名是由特定的环参与者计算的。只有在所有其他群体成员勾结的情况下，才能确定签名者（如图 2–35 所示）。


![alt_text](images/image35.png "image_tooltip")


图 2–35

因此，环签名方案可在需要确保签名者匿名性并独立于其他参与者的情况下使用，同时保证消息的完整性和真实性；接收者将确信消息是由某个特定群体的成员发送的，而不是由群体外的某人发送的。

值得一提的是，还存在一次性环签名。这种算法意味着使用公钥图像值，该值允许跟踪（链接）使用同一私钥生成的所有签名，即使使用了不同的环也是如此。

这种属性在许多领域都很有用，例如电子投票（每个参与者只能投一次票）、数字货币（电子硬币只能花费一次）等。

使用环签名的一个例子是一种名为 Monero 的分散会计系统及其环保密交易（RingCT）机制。它基于多层可链接的自发匿名群（MLSAG）签名，这是对常规环签名的改进版本，具有额外的密码学机制。它通过隐藏交易方的金额、来源和目的地来保护交易方的隐私，同时又是可验证的和无需信任的。

RingCT 没有实际交易金额，而是具有数学证明，证明交易的输入和输出是相等的（这是一个基本的协议要求，防止了硬币从空气中出现）。而接收者则可以揭示交易的价值并使用其输出。

MLSAG 签名的一个重要特点是签名者使用密钥对向量而不是单个密钥。这个向量是签名者的密钥对集合。这允许证明输入地址和输入承诺秘钥的知识。

为了能够签署交易，用户首先需要生成密钥。MLSAG 生成算法生成以下密钥对向量，输入为 1k，其中 k 是安全参数。

[(sk1, pk1),...,(skm, pkm)]，其中

*ski *是私钥，一个从 ℤq 中选择的随机值（这是 Ed25519 基础字段），*pki=xiG* 是一个公钥，G 是一个基点。

另外，一个键值图像 I 的计算方法如下。

I = skiHp(pki)，其中 

*Hp* 是一个安全散列函数，返回一个点，对于 G 的对数是未知的。

签名者的键对向量的密钥图像向量定义为

I[I1,...,Im][sk1Hp(pk1),...,skmHp(pkm)]

它强制签名者只使用一次密钥，否则算法的链接阶段将拒绝它。这也防止在给定密钥中进行双重消费。

签名者 Aj 可以代表环 A1,...,An 对消息 M 进行签名，具有密钥对向量和密钥图像向量。首先，需要从 ℤq 中选择一个随机值。然后计算以下值。

Lj G

RjHp(pkj)

cj+1Hs(M,Lj,Rj)

Hs 是一个密码哈希函数，返回 ℤq 中的一个值。然后，

Lj+1 sj+1G+cj+1pkj+1

Rj+1sj+1Hp(pkj+1)+cj+1Ij

cj+2Hs(M,Lj+1,Rj+1)

…

Lj-1 sj-1G+cj-1pkj-1

Rj-1sj-1Hp(pkj-1)+cj-1Ij

cjHs(M,Lj-1,Rj-1)，其中

对于所有的 *c1,...cn*。

sj=-cjxj mod l，其中 l 是 Ed25519 的曲线阶数。

基于此，以下是真实的

Lj=G=sjG+cjskjG=sjG+cjpkj

Rj=Hp(pkj)=sjHp(pkj)+cjI

cj + 1 = Hs(M,Lj,Rj)

签名的验证如下进行。

=(I,c1,s1,...sn)

*验证者*计算所有 i 的 Li、Ri 和 ci，并检查是否满足 cn + 1 = ci。对于签名被认为有效，必须满足以下条件：

cn+1=Hs(M,Li,Ri)

对于所有的 i mod n。

***盲签名***

盲签名机制用于一方形成消息，另一方签署（确认）该消息，而消息的创建者想将其中的某些部分隐藏起来。盲签名机制可用于银行结构之间的资金转移。实际上，可以将这种交互想象成向另一方发送的被盲化的支票：资金所有者生成这样的支票，银行在看不到唯一支票标识符的情况下签署它；之后，这张支票可以传递给任何一方，并且可以兑现，而不需要透露其发送者。

盲签名机制的工作原理如下：



1. 
发送方生成具有相同转账金额但具有不同唯一标识符的 n 个不同交易。在发送之前，用户使用随机生成的乘数对交易进行盲化（加密）。然后，所有交易被转移到签署者处。


2. 
签署者从发送方请求 n-1 个与签署者选择的交易相对应的盲化因子。实际上，这确定了他想要披露的交易。


3. 
发送方传输一组盲化因子。签署者使用它们对被盲化的交易进行去盲化，并验证转账金额是否相同，以及用户是否有足够的资金进行转账。


4. 
如果某些交易中的金额不相等，则签署者会拒绝用户。否则，他将在不查看其内容的情况下签署剩余的交易，并将其发送回给用户。


5. 
用户去除交易中的盲化。同时，对于去除了盲化的交易，签名也仍然正确。


6. 
用户可以将这个“支票”发送给任何人。任何时候，接收者都可以将这张支票传递给签署它的一方，并收到其中指定的金额。验证者只能确保签名是正确的，而不知道具有这种标识符的支票是由谁发行的（图 2–36）。

![alt_text](images/image36.png "image_tooltip")


图 2–36

*****常见问题*****

*“哪些系统目前使用了门限签名和多重签名机制？”*

多重签名和门限签名机制被用于系统中以确保容错性和对管理流程责任的分离。许多加密货币允许用户将资金锁定在多重签名地址上，这使得用户即使丢失一个（或多个）密钥也可以访问其资金。此外，使用多重签名允许在某些已有的会计系统之上构建大量协议（原子交换、支付通道等）。当需要更大程度的用户权限划分时，门限签名机制被使用。此外，每个特定密钥的权重可以配置（通常甚至取决于单个操作），以便尽可能有效地配置对会计系统服务的访问策略。许多资产管理平台，如 Stellar，采用了类似的方法。

*“在使用环签名时，签名者的匿名级别和环的大小之间如何相关？”*

在使用环签名时，验证者只能以很小的概率确定谁签署了特定的消息。环的大小越大，特定消息被特定环参与者签署的可能性越小。例如，如果一个环由 10 个参与者组成，那么只有以 10% 的概率可以确定签名确切是由谁计算的。当然，签名者的身份也可以被揭示，但只有在所有其他环中参与者勾结的情况下才有可能。


    **2.5 Shamir 秘密共享方案**

让我们想象一种情况，我们需要保护一些数据，同时确保其保密性和可用性。例如，爱丽丝拥有一家面包店，并希望保密她的馅饼配方。假设她加密了配方并将密钥存放在附近某处，在需要时提供访问权限。一段时间后，她意识到这种解决方案不方便，因为每次都需要亲自到保险库里。此外，假如是在度假呢？或者更糟糕的是——假如密钥丢失了呢？

那么爱丽丝可以复制一份密钥，并委托一位面包店员工保管，但是，这样做的话，密钥被盗的风险也增加。

还有一个选项，不是复制原始密钥，而是将其一分为二，并将一部分交给信任的人。现在很明显，必须同时拥有两部分密钥才能将它们合并成一个密钥并打开存储设备。因此，要偷走食谱，攻击者需要同时拥有密钥的两部分，这比窃取一个密钥更困难。然而，这种方案与使用单一密钥并没有太大差别，因为如果其中一部分丢失了，完整的密钥就无法恢复。

爱丽丝意识到，理想情况下，密钥必须分散在多个员工之间，这样可靠性就不会依赖于一个人。此外，必须对员工数量设定一定的限制，以便在一部分丢失或无法访问时，仍然可以恢复整个密钥。

这个问题的解决方案是由阿迪·沙米尔（Adi Shamir）在 1979 年提出的 [78]。他提出了一种秘密共享方案，也称为插值多项式方案。

***门限秘密共享方案***

门限秘密共享方案是一种方案，其中恢复秘密所需的参与者数量可以少于总参与者数量。假设 n 是总参与者数量，t 是恢复秘密所需的参与者数量。任何 t 个或更多的参与者组成的小组都可以恢复秘密，而任何少于 t 个的参与者将无法了解秘密。阿迪·沙米尔方案的实现可以分为以下阶段：



* 准备阶段
* 秘密部分生成
* 秘密的重建

第一阶段是准备阶段。假设存在一个秘密 S，需要将其分成 n 份，只有当至少有 t 份时才能获取该秘密。首先我们需要选择一个素数 p，使得 *p > S，p > n*。它将确定域的大小。我们需要构建一个通过点 (*0, S*) 的多项式，在这个域上。它将如下所示：

F(x)=( +  + ... +  + S)，其中 *, **, ... ,* 是随机选择的自然数。如果我们计算 *F(0)*，则可以稍后恢复秘密。

重建秘密所需点的数量取决于多项式的次数。如果我们要使用 *t *份重建秘密，则多项式的次数必须为 *t - 1*。

这是为什么呢？让我们想象一下，我们有一个如下形式的一次多项式 *y = S + a1x*，比如 *y = 3 + 2x*。它对应于一个图形，我们至少需要两个点才能唯一确定它。与此同时，只有一个点，可以通过它画出无数条直线（图 2–37）。


![alt_text](images/image37.png "image_tooltip")


图 2–37

同样地，如果我们有二次多项式，我们至少需要三个点，因为通过两个点我们可以画出无数条二次曲线（图 2–38）。


![alt_text](images/image38.png "image_tooltip")


图 2–38

因此，如果我们想要使用 *t *个部分来恢复秘密，我们将不得不构造一个 *t-1* 阶的多项式。

接下来的阶段是*秘密部分生成*。秘密的每个部分都是属于使用多项式构建的图形的点。为了得到下一个点，我们需要生成一个自然数，然后将其代入*多项式中*。在这个过程中生成了 n 个不同的点。这个阶段由秘密的所有者执行，以防止其泄露。

当秘密部分生成时，每个参与者都会收到一个部分 *(xi, f(xi))*。所有参与者都知道多项式的阶数 *t-1* 和域的大小* p*。

最后一个阶段是*秘密的重建*。有两种方法可以重建秘密：解线性方程组或计算拉格朗日插值多项式。第二种方法对于软件实现来说更容易，并且可以用来计算秘密本身，而无需计算多项式系数。当需要知道秘密时，任何 *t *个参与者组成的小组都会执行这个阶段。

拉格朗日插值方程如图 2–39 所示。它可以用来构造多项式。重建秘密所需的仅仅是计算 *F(0)*。


![alt_text](images/image39.png "image_tooltip")


图 2–39

***秘密分享示例***

让我们通过一个示例来看看这个方案是如何工作的。假设需要将秘密 S = 7 分配给六个参与者，以便其中任意四个都可以恢复它。

**步骤1**。首先要做的是选择一个素数 *p*，使得 *p > S*。我们以 *p = 13* 为例。然后需要构造一个如图 2–40 所示形式的多项式，其中 *、**、** *是随机选择的自然数，用作系数。


![alt_text](images/image40.png "image_tooltip")


图 2–40

**步骤2**。为了获得秘密部分，需要在多项式中代入六个不同的随机选择的自然数。为方便起见，我们选择 *{1,2,3,4,5,6}*。这些数字不能按顺序排列，并且它们在模p下应具有不同的值。结果，我们得到六个点，需要分配给参与者（图 2–41）。然后可以销毁多项式的系数，六个参与者中的任意四个都可以恢复秘密。根据目标的不同，也可以销毁秘密。然后只能使用其部分进行重建。


![alt_text](images/image41.png "image_tooltip")


图 2–41

**步骤3**。现在，可以使用任意四个点构建一个方程组并解决它，或者使用拉格朗日插值公式恢复原始多项式（图 2–42）。在这个例子中，使用了点 *p*。


![alt_text](images/image42.png "image_tooltip")


图 2–42

知道 *S = F(0)*，因此可以轻松计算秘密：*F(0) = 7*。

***Shamir 方案的优势***


```
弹性
动态性质
可扩展性
```


*弹性*。要重建秘密，攻击者需要 t 部分。任何减少部分的数量都无法使他甚至重建秘密值的一部分。在这种情况下，即使攻击者具有重大的计算能力，他也无能为力，因为没有办法验证计算部分的正确性。

*动态性质*。可以多次应用相同的秘密方案，每次都获得不同的部分集合，创建无限数量的不同多项式和相应的点。如果攻击者知道基于不同多项式的秘密部分，这并不会帮助他获得有关秘密本身的任何知识。然而，创建新的部分集合并不会消除使用旧部分恢复秘密的可能性。想象一下：爱丽丝打算留下她的秘密食谱的遗嘱。对于她的亲戚，她可以使用方案 (2,3)，对于她的朋友 - (5,7)，对于员工 - (10,14)。那么只有 2 个亲戚或 5 个朋友，或 10 名员工可以获得食谱。

*可扩展性*是通过选择适当阶数的多项式来确保的，从而可以使秘密持有者的数量任意大。

***Shamir 方案的缺点***


```
在分离和重建过程中，秘密必须在同一设备上
无法验证提供的秘密部分的准确性
```


使用该方案分割秘密时，*秘密必须在同一设备上*。在恢复过程中，秘密部分也必须在同一设备上。例如，当爱丽丝留下她的配方遗嘱时，她需要保留整个配方直到分享它。在重建后窃取秘密的风险也存在。在这些时刻，竞争对手窃取配方的风险尤其高。

其中一部分的所有者可能提交一个不正确的值。因此，秘密将被错误地恢复，其余人将不知情。他们甚至无法检查是哪个部分出错了。


```
注意：有一些修改过的 Shamir 方案使用校验和来最小化使用不正确部分的概率。还有一些秘密共享方案，其中每个参与者都可以验证秘密部分的有效性。一个例子是 PVSS——公开验证的秘密共享（Publicly Verified Secret Sharing）。
```


***Shamir 方案的应用***

最常见的情况是将门禁密钥的私钥存储在门禁服务器上，以及在云环境和电子投票方案中使用阈值密码术。

此外，Shamir 方案可以应用于分层访问结构。这些结构是树状的，其中每个节点都可以访问比其父节点更少的数据量。树的根节点可以访问所有数据。Shamir 在他的作品[78]中提出了实现该方法的方法。

让我们考虑一个具体的例子，即使用 Shamir 方案的应用。这个方案被巴黎公司 SatoshiLabs 用于解决存储私人钱包密钥的问题。它允许用户将他们的密钥“分割”成几部分。然后，通过组合这些部分的一些预定子集，可以恢复它们。SatoshiLabs 的备份算法允许创建多达 16 个部分（这些部分也可以进一步分割）。这个备份是一个开放的标准，因此其他公司可以在将来在其钱包中使用它。

