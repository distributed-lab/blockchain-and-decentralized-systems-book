# 1 分散化作为信息系统中的范式


## 1.1 点对点网络和 BitTorrent 协议

BitTorrent 协议是最早展示文件分享服务如何实现分散化的协议之一。它比中心化解决方案更快，其中下载速度受服务器性能和连接限制，同时更抗审查。该协议通过展示如何在一个系统内分离存储和传输数据的过程，在分散技术领域发挥了重要作用。我们将考虑协议的基本概念、提供的属性以及这项技术如何在下一代系统中得到发展和应用。


### 传统的客户端-服务器架构

为了理解 BitTorrent 的工作原理，让我们看看传统的中心化文件分享系统是如何运作的，以及为什么这种方法效率低下。我们首先介绍三个基本术语：客户端、服务器和客户端-服务器架构。客户端是使用服务器服务的硬件和/或软件。服务器是提供数据给其他软件和/或硬件设备（即其客户端）的软件和/或硬件。

那么，客户端-服务器架构是什么意思呢？让我们用简单的语言来描述。想象一下存储大型数据集的一些服务器。如果需要，客户端联系其中一个服务器请求某个数据子集。服务器处理客户端的请求，并提供（或不提供）对所需内容的访问（图 1–1）。

![图 1–1](/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.1-Traditional-client-server-architecture.png "图 1–1")

> ***注意：*** *在中心化文件分享系统中，客户端和服务器角色被严格区分，大多数情况下不能相交。此外，这些系统还带来一些额外的限制和缺点。*

> ***中心化系统在客户端-服务器架构方面的问题***  
> * *受审查的主体*  
> * *单一故障点*  
> * *服务器端的容量限制*  
> * *难以恢复丢失的数据集*

其中一个最突出的问题是在控制服务器的中心化方一侧的内容审查。例如，在许多国家，与政治和社交媒体相关的审查非常严格；如果有人具有足够的影响力并决定你不应该访问某些内容（电影、视频等），则可能无法访问该内容 [1]。

第二个问题是在单一中心存储大量数据；对该中心的攻击可能导致所有数据的完全丢失，或者限制对其的访问时间。许多服务，如 Google，使用预备份和在大量地理分离的服务器上复制存储的数据 [2]。这种方法可以保护数据免受丢失。但请注意，并非每个服务都能负担得起这样的保护措施，因此必须解决服务器之间实时数据同步的问题。

中心化服务的第三个限制是数据下载速度。通常，它取决于许多因素，例如传输协议的类型、服务器容量、其他客户端的活动连接数量等。

由于数据通常由服务器作为一个单一副本存储在一个地方，如果许多客户端同时请求相同的数据，它可能会大大降低整个系统的性能。

还值得注意的是，某些内容可能只存储一个副本；如果服务器（之前存储请求的内容的服务器）崩溃并且内容丢失，即使是 Google 也无法帮助恢复它（图 1–2）。

![图 1–2](/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.2-Сontent-becomes-unavailable-when-it-is-lost-by-the-server.png "图 1–2")


### 构建点对点文件共享网络的原则

点对点（P2P）文件共享系统的体系结构与传统系统根本不同。网络中的每个节点既是服务器又是客户端。每个网络参与者都可以参与将文件分发到其他节点，同时也可以从它们那里接收文件（图 1–3）。

![图 1–3](/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.3-Principle-of-operation-of-peer-to-peer-file-sharing-system.png "图 1–3")

当节点软件找到具有所请求内容的网络参与者时，它直接从这个来源下载数据。当请求内容的一部分时，你是客户端。当其中一个参与者需要访问你存储的数据时，你的软件将充当服务器并共享存储的数据。


### BitTorrent 发展历史

BitTorrent 协议是由布莱姆·科恩（Bram Cohen）于 2001 年创建的[3]。他成功解决了互联网出现后社会面临的最重要的任务之一：在容量较低且定期拒绝服务的传输通道环境中可靠地传输大量数据。

BitTorrent 公司成立于 2004 年。该项目在许多领域引起了关注，特别是在涉及非法分发媒体产品的领域。他们将 BitTorrent 协议变成了另一个 Napster（一种用于共享 mp3 文件的服务）。不幸的是，BitTorrent 并没有像其技术一样成功。几次尝试成为媒体公司未能取得期望的结果。有一点是肯定的：BitTorrent 协议已经成为一种颠覆性技术，展示了一个分散的文件共享系统如何运作。

2019 年，超过 1.7 亿人使用了 BitTorrent 协议：Facebook [4]和 Twitter [5]使用 BitTorrent 部署服务器，荷兰大学使用它来更新工作站 [6]。BitTorrent 协议被广泛使用，因为它允许在连接不稳定且容量低的网络中进行可靠的数据传输。


### BitTorrent 如何运作？

BitTorrent 协议是用于在点对点系统中共享文件的开放协议，它涉及系统参与者之间的 P2P 数据传输，不存在中央服务器方。

为了访问特定的数据部分，网络参与者会与一个被称为跟踪器的服务器通信，该服务器监视连接到网络的计算机。其任务是提供拥有所需内容部分的系统中活动参与者的 IP 地址。请注意，参与者从不直接从跟踪器下载数据：跟踪器只负责提供活动节点的必要 IP 地址。

在收到活动节点列表后，用户向它们请求所需的数据片段。请注意，参与者会逐步下载数据的小部分，并在下载过程中检查其完整性。这允许保存所请求内容的特定片段，而缺失的片段可以从其他来源下载或在重新连接后下载，即使其中一个节点关闭。通过这种方式，可以从不同的部分和不同的来源获取所需的内容（图 1–4）。

![图 1–4](/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.4-Obtaining-data-fragments-from-system-participants.png "图 1–4")

为了达到更高程度的分散化，BitTorrent 协议在 2013 年添加了实施 DHT（分布式哈希表，英文：Distributed Hash Table）的机制。我们将在第 1.2 节中更详细地探讨 DHT 的操作原理。简而言之，这一改进避免使用集中式跟踪器来搜索内容站点，使站点的交互更加独立和分散。

然而，大多数跟踪器并不喜欢这个更新，因为它允许在分散化的文件共享网络中消除所有中介。为了应对这一情况，跟踪器采用了在种子文件的信息部分添加特殊标志的方法。如果用户决定删除这个标志并使用 DHT，种子文件的标识符将完全改变。这导致用户分歧，因为使用 DHT 的节点无法从使用跟踪器的节点那里获取所需的文件。而且，找到使用跟踪器的种子文件要容易得多，毕竟媒体站点的所有者就是通过这种方式赚钱的。因此，集中式跟踪器仍然很受欢迎并广泛使用。

值得一提的是，BitTorrent 协议规定了对积极参与网络的参与者进行奖励。节点在文件分发中参与得越积极，其总下载速度就越高。相反，那些很少参与文件分发的用户（下载所需内容然后离开分发）下载内容的速度较慢。协议还要求保留部分通道带宽，这不仅允许特定节点仅下载内容，还要求其分发数据。

BitTorrent 协议的另一个特性是稀有片段的初次分发。例如，如果包含整个数据集的单个节点收到其他想要获取此数据集的节点的请求，它会平均分配所有数据片段给参与者，并不向每个参与者传输整个序列（图 1–5）。这个特性对速度有积极的影响，因为收到片段的节点可以自行进一步分发它。此外，所有片段的存储是分布式的，避免了许多节点仅存储第一个片段，而仅有一个节点存储所有其他片段的情况。

![图 1–5](/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.5-Arbitrary-transmission-order-of-file-fragments.png "图 1–5")


### 数据分片

许多读者熟悉种子文件（.torrent），但并不是每个人都知道它们是如何形成以及包含了什么内容。我们之前已经确定内容是以小部分（片段）下载的。让我们考虑一下这些片段是如何形成的以及在哪里获取它们的下载链接。

在创建种子文件时，将初始数据分成小部分（大小可变，从128 KB 到 2-4 MB）。从每个接收到的片段中获取 SHA-1 哈希值，并将其放入种子文件中（图 1–6）[7]。

![图 1–6](/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.6-Creation-of-a-torrent-file.png "图 1–6")

> ***注意：*** *在分发大量数据时，片段的大小可以达到 32–64 MB。*

此外，种子文件中还放置了指向跟踪器（或多个跟踪器）的链接，以便接收源种子文件的用户知道哪个跟踪器可以提供与之对应的内容存储节点的地址。首次将特定数据发布到网络并创建种子文件的网络参与者被称为初始种子者。

当参与者之一拥有种子文件并希望获取与之相对应的内容时，他联系文件中指定的跟踪器，并请求存储在文件中指定的片段的节点的电子邮箱地址。跟踪器返回地址列表后，节点将使用片段的哈希值向收到的地址发送请求，然后等待其他节点返回所需的片段。在从网络下载片段时，节点可以迅速简单地检查是否已下载所需的片段，因为它具有相应的哈希值。这种方法通过检查片段的完整性来防止下载文件时出现错误，并检查所有接收内容的完整性。


### 协议的限制

请注意，除了其明显的优势之外，BitTorrent 协议还存在一些限制。

> * *文件下载速度取决于包含文件副本的活动节点数量*  
> * *与下载片段中存在恶意代码相关的威胁*  
> * *许多节点仅使用协议进行下载，而不支持网络（即它们不分发文件）*  
> * *无法选择性地限制内容的分发（侵犯版权）*

下载速度取决于存储文件的活动系统节点数量。如果内容受欢迎，那么很可能被大量网络参与者存储，访问它将不是问题。然而，如果对内容没有特别的需求（例如，捉蛾子的教科书），并且只有一个网络节点存储了该内容，那么任何通信故障或此节点的关闭都将禁用对所请求内容的访问。

当用户收到一个种子文件时，他只有一组哈希值和在哪里下载所需内容的信息。他只能猜测下载的内容是否与期望的相同。如果在内容旁边，实际上你下载了几个浏览器而不是一段恶意代码，那已经是一个好的开始。

另一个重要问题是节点没有维护网络的动机。很多时候，节点下载了请求的内容片段，却没有保持在分发中。BitTorrent 协议提供了奖励积极分发者的机制（增加接收内容的能力），但由于奖励是非货币性的，效果相当有限。这个问题在 IPFS 协议中得到了部分解决，我们将在 1.5 中更详细地讨论。

最后但同样重要的问题是最让版权持有者担忧的是通过传输盗版内容版权侵权。根据统计，仅音乐行业每年因盗版而损失超过 100 亿美元。此外，超过 40% 的用户软件是盗版的，全球超过 75% 的计算机至少安装了一个非法软件 [8]。

### \*\*\*常见误区\*\*\*

*追踪器和 DHT 不能同时使用。*

实际上，每个用户可以同时使用这两种方法来同时下载不同的文件。该限制仅对同时下载单个文件的两种方法的使用施加，因为在这些情况下，种子文件的哈希值将不同。请注意，大多数追踪器会检查标志是否存在，并在其站点上出现 torrent 时添加标志。

*使用 DHT 显著降低了 BitTorrent 的性能。*

这是一个最常见的谬论之一。而且，许多使用过追踪器和 DHT 的读者会说这不是谬论，系统性能确实降低了。然而，这与技术本身无关。有效使用 DHT 甚至可以提高生产力，但在使用过程中存在许多限制：用于构建 DHT 的空间大小、系统参与者的数量、存储的内容总大小、中心化追踪器的影响等。

### \*\*\*常见问题\*\*\*

*“BitTorrent 中的做种（Seeding）是什么？”*

做种是将文件在网络上分发到其他节点的过程。在从网络下载文件片段的同时，每个客户端会自动将它们分发到其他节点，从而提高网络的操作速度。此外，每个参与者都可以在完全下载后继续分发文件以维护网络，以便其他节点可以更快地下载它们。这个过程被称为做种。

*“谁是 leechers 和 peers？”*

Leecher 是一个下载比在网络上分发的信息更多的用户。目前，协议本身并不惩罚这种行为，尽管社区的一部分支持引入惩罚。Peer 是连接到分发文件的参与者的用户。在 peer 完全下载文件后，他会成为一个 seeder。

*“在 BitTorrent 网络上有确保用户匿名性的方法吗？”*

BitTorrent 协议并不确保其用户的匿名性。任何用户都可以在其种子客户端的节点列表中看到所有节点的 IP 地址。因此，在一些国家，版权保护组织可以向用户的互联网服务提供商报告个别用户侵犯版权的行为，并在法律上起诉用户。为了做到这一点，他们获取非法分发受版权限制信息的用户的 IP 地址。

*“互联网服务提供商能够限制 BitTorrent 流量吗，如何防止这种情况发生？”*

由于 BitTorrent 占据了大部分流量，一些互联网服务提供商会限制（减慢）BitTorrent 传输。为了解决这个问题，许多种子客户端使用协议头加密和消息流加密。这些流量掩码方法有助于使 BitTorrent 流量难以被检测，从而防止提供商进行调控。


## 1.2 DHT 的工作原理和应用

DHT（分布式哈希表）是分散网络的基石协议之一[9]。该协议是在 90 年代末发明的，旨在解决大量数据的索引和搜索问题。尽管数据本身（例如文件）可以存储在不同的服务器上，但数据链接表可能无限大，因此不适合在一个地方存储。此外，对中心节点进行攻击的防护是一个重要的问题。DHT 的开发旨在解决这两个问题。


### DHT 解决的问题

DHT 解决了在分散网络中通过其哈希值（InfoHash）查找内容的问题。

> ***DHT 协议工作的条件***  
> * *参与者不相互识别*  
> * *参与者的数量可以无限制*  
> * *没有中心服务器*  
> * *内容由参与者自行存储（提前不知道由谁存储）*  
> * *每个参与者只能与有限数量的其他参与者通信*

对于正在搜索数据的参与者，任务是获取另一个存储了具有特定 InfoHash 的内容部分参与者的网络地址。

存储和搜索内容的环境完全分布式，就是借助于许多运行特定版本 DHT 协议并进行独立消息传递的计算机。


### DHT 如何运作？

根据协议，每个系统参与者都有一个唯一的全局标识符。这个标识符是与 InfoHash 相同维度的数字（通常为 160 位或更多）。参与者自己选择标识符，因为没有决策中心，所有参与者都是独立的。要开始运行，新的参与者需要具有实现协议的程序和至少一个更多活跃参与者的网络地址（为了连接到现有网络是必要的）。

根据协议规定，每个参与者为自己的表分配一些内存（默认为 5-50 MB）。在这个表中，他存储了 InfoHash 和内容之间以及参与者标识符与它们的网络地址之间的映射关系（图 1–7）。

![图 1–7](/resources/img/volume-2/1.2-Operation-principle-and-application-of-DHT/Figure-1.7-Network-node-s-table.png "图 1–7")

表中的所有记录都按第一列（标识符或 InfoHash）排序，并根据以下规则不断更新：  
1. 如果参与者在与其他人通信时检测到一个新的参与者（标识符+网络地址），则将此条目放入表中。  
2. 如果参与者下载或生成内容，那这个内容的 InfoHash被都计算，并将相应的映射也放入表中。  
3. 如果表的大小接近分配内存的限制，则删除与参与者自己的标识符差异最大的行。

因此，表的顶部和底部行将被删除（图 1–8）。在一段时间内，参与者将形成自己的表。它将存储与自己的标识符尽可能接近的标识符，因为它们是按递增顺序排序的。因此，每个参与者都存储其他参与者的标识符并存储与他们自己标识符尽可能接近的内容链接列表。

![图 1–8](/resources/img/volume-2/1.2-Operation-principle-and-application-of-DHT/Figure-1.8-Table-row-deletion-scheme.png "图 1–8")

为了找到所需的内容，活跃的网络节点只需知道相应的 InfoHash。参与者通过访问自己的表来开始搜索特定内容。从表中选择与 InfoHash 最接近的标识符行。该行将存储最接近所需内容的参与者的网络地址。然后，搜索参与者朝着这个地址打开连接，并发送一个搜索特定 InfoHash 的请求。作为响应，他要么收到所需的内容，要么收到另一个距离此内容更近参与者的网络地址（图 1–9）。请求将重复直到收到所需的内容。在失败的情况下，可以在确定时间后重复请求。

![图 1–9](/resources/img/volume-2/1.2-Operation-principle-and-application-of-DHT/Figure-1.9-Search-request-propagation-scheme.png "图 1–9")

每个参与者都在本地存储和更新映射表，如图 1–9 所示。由于列表是有序的，因此可以快速搜索和插入新行。请注意，对于标识符相近的参与者，表的某些部分可能是相同的（图 1–10）。

![图 1–10](/resources/img/volume-2/1.2-Operation-principle-and-application-of-DHT/Figure-1.10-State-of-tables-of-participants-with-close-identifiers.png "图 1–10")

为了提高搜索的可靠性和速度，请求在几个附近的网络参与者上并行执行。这种搜索机制具有相当高的可靠性，不受审查且可扩展性良好。网络参与者的数量和存储的内容片段数量实际上是无限的。有许多修改版本的该协议，旨在改善其各种属性，如搜索隐瞒、更大的数据存储、对 Sybil 攻击的抵抗、对热门内容的加速搜索，以及确保请求和响应的完整性。

DHT 协议是许多流行项目（包括 I2P、IPFS、GNUnet、BitTorrent 和 Tox）的不可或缺的必要部分。

在 DHT 出现之前，类似的内容搜索问题是通过使用集中式服务或一组相互同步的集中式服务来解决的。这种集中式服务还具有用于请求的公共 API，而且在大多数情况下有注册的域名。事实上，这些服务存储了 InfoHash 和网络地址之间的完整映射表，而这些表的体积远远超过了 50 MB。Torrent Tracker 就是这类服务的一个例子。正如上面所强调的，这些跟踪器很容易受到审查并可能被屏蔽。


### 内容被攻击者屏蔽的问题

对 DHT 协议的最常见攻击是攻击者几乎完全屏蔽一个特定的内容片段。假设一个名叫塔拉斯的人决定限制访问中本聪的真实照片，因为一个感兴趣的方可能通过获取这样的信息对比特币网络造成无法弥补的损害。

为实现这一点，他启动了一系列经过特殊修改的节点。修改的意思在于选择的 InfoHash 最接近目标内容的 InfoHash，而不是随机生成它。此外，修改后的节点对该 InfoHash 的搜索请求作出不同的反应：它们返回不存在的网络地址。因此，大量的虚假节点包围了中本聪照片的标识符，因此几乎所有寻找这一内容的参与者都被引导到这些地址（图 1–11）。这就是如何暂时阻止对一个特定内容的访问。

![图 1–11](/resources/img/volume-2/1.2-Operation-principle-and-application-of-DHT/Figure-1.11-Scheme-of-blocking-a-specific-piece-of-content-when-being-searched.png "图 1–11")


### \*\*\*常见误区\*\*\*

*使用 DHT 需要大量的磁盘空间。*

这并不完全正确。值得注意的是，对 DHT 数据库大小的要求完全取决于网络节点的数量。在使用该技术的分布式网络中节点数量越多，对存储在表中的数据量的要求就越低。

*DHT 的运行速度很慢，在处理大量数据的系统中难以使用。*

实际上，使用 DHT 进行内容搜索比使用传统方法要慢。然而，DHT 更具有容错性并是在分散系统特别必要的。例如 BitTorrent 和 IFPS。

*通过对节点的 IP 地址进行哈希运算得到的标识符可以被视为安全的。*

这种方法在理论上对 IP 欺骗攻击是脆弱的。IP 地址欺骗的概念是攻击者修改 IP 数据包头部，以模仿另一个节点。如果攻击者设法获取对他的请求的响应，这意味着他可以为自己分配几乎任何 IP 地址。因此，建立一个安全性依赖于可用 IP 地址有限空间的系统可能极为危险。

### \*\*\*常见问题\*\*\*

*“DHT 用户的隐私是否得到保障？”*

不是。由于表格的所有哈希值都是公开可见的，因此追踪分布是一个现实可能性。

*“DHT 的实现为 BitTorrent 带来了哪些好处？”*

DHT 允许减少对跟踪器的流量负载。DHT 还消除了对跟踪器的依赖，因为它使用了纳入种子文件中的信息。现在，BitTorrent 可以选择是否继续使用跟踪器或通过 DHT 节点集。


## 1.3 Web-of-trust 的概念

今天，大多数人使用互联网。他们在家里购物，通过社交网络发送消息等等。为了保护传输的数据，广泛使用了非对称加密、数字签名和数字密钥算法。

在这个背景下，正确地将特定用户映射到他的公钥是很重要的，以避免中间人攻击，其中攻击者用自己的密钥替换了传输的公钥。这种攻击方式允许他以目标用户的名义发送和签署消息。

为了确保数字签名和其他非对称算法的使用可靠性，就使用密钥认证机构（英语：Certification authorities；CA）。这种集中式方法有两个主要缺点：1）根认证机构的私钥可能会被破坏，2）用户必须信任认证机构。然而，有一种解决方案——一个完全分散的方法，被称为“信任网络”（英语：Web of Trust；WoT）。


### 公钥证书概念

为了更好理解信任网络的方法，让我们考虑传统公钥基础设施是如何组织的。

*公钥基础设施（英语：Public key infrastructure；PKI）是一组工具、方法和策略，用于创建并处理公钥证书，从而实现非对称加密算法的可靠操作* [65]。

*公钥证书是一份建立公钥与其所有者之间关联的文件；它由其中一个 CA 签名和颁发* [65]。

根据 X.509 标准[64]，公钥证书的结构如表 1–1 所示。

![表 1–1](/resources/img/volume-2/1.3-Web-of-trust-concept/Table-1.1.png "表 1–1")

公钥证书中的主要字段是 *主题公钥* 和由认证机构计算的 *证书签名* 。请注意，通过数字签名，认证机构确认了公钥与特定个人的映射关系。


### 分层的公钥基础设施如何工作？

分层的公钥基础设施的工作原理是一种传统的组织模型，假定认证机构（CAs）以层次树结构相互连接（见图 1–12）。

![图 1–12](/resources/img/volume-2/1.3-Web-of-trust-concept/Figure-1.12-Certificate-authorities-hierarchy-scheme.png "图 1–12")

分层 PKI 具有以下特征：

> * *每个子 CA 与父 CA 之间的关系都由父节点签署的单独证书表示（根证书是自签名的）。*  
> * *根 CA 除外，所有 CA 都隶属于一个父 CA。*  
> * *CA 可以有从属 CA，并向它们或最终用户签发证书。*  
> * *所有用户都信任相同的根 CA。*

基于这些特征，解释分层 PKI 模型的工作原理相当简单。在最顶层，有根密钥认证机构。根机构有用于签署下级认证机构的证书自己的密钥对。同时，根认证机构还拥有为自己生成的公钥证书。

每个 CA 在收到证书时都有权独立为其子 CA 签发证书。证书链这样一直延续到最终用户，该证书链中每个从属证书都由其父证书签署。

这种 PKI 设计方法的一个优点是，由于每个用户和 CA 都有一个由正好一个父 CA 签发的证书，因此建立和验证证书链相对简单。因此，证书链相对较短，且都通向一个单一的根 CA。

为了更好理解所描述的结构，让我们考虑一个例子，其中爱丽丝需要验证鲍勃的证书（以确保她收到的季度报告确实是由鲍勃签名的）。同时，爱丽丝和鲍勃的证书是由不同的认证中心发行的。这个方案可以表示如下（图 1–13）。

![图 1–13](/resources/img/volume-2/1.3-Web-of-trust-concept/Figure-1.13-Hierarchical-PKI-scheme.png "图 1–13")

爱丽丝拥有她自己的公钥证书，由 CA1 签发并存储。鲍勃也有类似的证书（然而，它是由 CA2 颁发并存储的）。在这种情况下，CA1 和 CA2 也有自己的证书，这些证书由相同的根 CA0 颁发了。

当爱丽丝想要验证鲍勃的公钥的真实性（她用来验证数字签名值的公钥），她从鲍勃收到一个公钥证书，并检查是谁签发了这个证书。显然，它是由 CA2 签发的。由于爱丽丝个人不信任 CA2，她还请求由根 CA0 颁发的公钥证书。爱丽丝信任 CA0（因为这个证书颁发给了 CA1），并确保鲍勃的公钥确实属于他。请注意，在这个例子中有两个证书在证书链中（我们检查了鲍勃和 CA2 的证书）。如果鲍勃的证书是由 CA1 签发的，那么爱丽丝可以直接联系 CA1 并立即验证证书是否正确。

分层方法的优势还在于能够迅速应对终端用户私钥的泄露（如果发生泄露，用户需要联系上级 CA）。

*密钥泄露是指实际上或被怀疑时第三方获知用户私钥的事件。* 泄露还包括密钥所有者对其密钥失去物理控制的情况。

假设属于鲍勃的私钥被塔拉斯偷走。现在塔拉斯可以以鲍勃的名义向每个人发送伪造的消息，并使用鲍勃的私钥进行签名。在这种情况下，鲍勃必须立即通知 CA，他的私钥已经泄露。CA 可以迅速做出反应，将鲍勃的证书标记为无效，然后为他颁发一张带有新公钥的新证书。

如果爱丽丝收到用鲍勃的旧密钥签名的消息，她会将此事通知给 CA2。与之前的情况一样，CA2 告知爱丽丝所需公钥的证书已不再有效，并可能有人试图愚弄她（图 1–14）。

![图 1–14](/resources/img/volume-2/1.3-Web-of-trust-concept/Figure-1.14-Alice-verifies-Bob-s-certificate.png "图 1–14")

然而，如果其中一个 CA（例如 CA2）的密钥被泄露，而不是终端用户的密钥，会发生什么呢？在这种情况下，CA2 告知根 CA0 其密钥已被泄露。CA0 将 CA2 的证书标记为无效，并为其颁发一张带有新公钥的新证书，从而将受损的权威重新引入层次结构。然而，由于旧的 CA2 公钥不再有效，该 CA 签发的所有证书都变得无效。因此，受影响的区段中的用户失去了使用 PKI 服务的能力（其证书也变得无效；除非用户停止互动或更新证书，否则可能会被攻击者窃取 CA2 的秘密密钥的攻击者愚弄）。

现在让我们考虑一下，如果根 CA 的私钥被泄露会发生什么。后果是相同的，但它们对整个系统产生了全球性的影响：整个基础设施必须暂停一段时间。请注意，及时通知系统中所有参与者有关某个 CA 泄露的情况是至关重要的，因为在这种情况下，攻击者可以颁发虚假证书、吊销有效证书等。

分层 PKI 具有明显的优势：构建和跟踪证书链的速度快，而且在用户和 CA 的私钥都被泄露的情况下能够迅速重新颁发证书。然而，这种模型也有一些缺点。

> ***分层 PKI 的缺点：***  
> * *需要验证整个证书链*  
> * *根 CA 的私钥被泄露会导致严重的情况，因为整个网络可能会崩溃*  
> * *与 CA 之间同步的问题*  
> * *用户实际上不能管理自己的身份*  
> * *系统兼容性的困难（签名算法等）*


### 信任网络的运作原则

信任网络是分层 PKI 模型的一种替代方案。这个概念首次应用1991年于 PGP 协议中的用户公钥认证。此外，这种办法可以用于分散环境中的身份验证机制和评级系统（有许多使用信任网络机制的浏览器插件用于在线站点评级）。

在某种程度上，信任网络模型可靠运作的基础是社会共识：没有用户会信任另一个用户的证书，除非该参与者从第一个用户信任圈内的至少一个参与者那里获得对其公钥的确认。

在直接深入了解信任网络的原则之前，让我们定义两个与彼此密切相关且是整个概念基础的概念—— *信任* 和 *有效性* 。

*有效性* 确定了一个用户对第二个用户的了解程度。我们将有效性水平表示为从 0 到 1，其中 0 表示第一个用户对第二个用户一无所知（以下简称为他对第二个用户拥有的密钥一无所知），而 1 表示他完全确信公钥与特定用户关联。

*信任* 确定了用户之间的信任级别，也就是一个用户有多大程度上信任另一个用户来识别其他参与者。

因此，让我们回到分散化 PKI。我们有一个系统，其中每个参与者都拥有一对密钥。此外，每个参与者确定了他自己的其他网络参与者密钥列表，他已经验证了这些密钥（例如，在咖啡馆与他们见面并亲自获得了他们的公钥），以及对这些用户的有效性和信任。他用自己的私钥签署接收到的密钥，换句话说，为其他用户生成公钥证书。每个用户维护一个表，大致如下（表 1–2）。

![表 1–2](/resources/img/volume-2/1.3-Web-of-trust-concept/Table-1.2.png "表 1–2")

在这种情况下，用户可以与那些在他的列表中且有效性水平为 1 的系统参与者安全地互动。

但是，如果需要与一个系统参与者进行通信，而该参与者的公钥不在你的列表中怎么办？在这种情况下，你需要联系那些受信任的用户（其信任级别相对较高），询问他们是否在其联系人列表中具有所需用户的公钥。如果其中一个联系人包含所需网络参与者的签名公钥，那么根据用户与目标参与者之间的信任和有效性水平可以确定使用提供的目标用户的公钥的安全性。

意大利黑手党的例子

为了让事情更清晰，让我们考虑一个例子，其中意大利黑手党老板（科利昂先生（Don Corleone）、塔塔利亚先生（Don Tattaglia）和法努奇先生（Don Fanucci））决定组织一个共享业务网络，并使用信任网络来组织公钥基础设施。请注意，在这种情况下，密钥将用于加密和签署消息。

为此，他们组织了一个家族头目的会议，在会议上互换了公钥（图 1–15）。

![图 1–15](/resources/img/volume-2/1.3-Web-of-trust-concept/Figure-1.15-Exchange-of-public-keys-between-heads-of-the-families.png "图 1–15")

每个老板都形成了自己的表格，在会议后填写了表格。例如，我们考虑科利昂先生形成的表格（表 1–3）。

![表 1–3](/resources/img/volume-2/1.3-Web-of-trust-concept/Table-1.3.png "表 1–3")

> ***注意：*** *在这种情况下，有效性水平被设置为 1，因为各位老板在他们的会议上亲自交换了密钥。对于法努奇的信任由科利昂确定为 0.8，因为相应的公钥是在没有足够尊重的情况下提供的。*

现在，使用其余家族头目的公钥，科利昂老板可以发送加密消息，而不必担心别人可以阅读它们（同时，收件人可以通过数字签名值对验证发件人的身份）。

但是，如果其中一位老板需要联系索洛佐，而他的公钥不在他的列表中怎么办？为此，他向塔塔利亚老板求助，想知道他是否有相应的公钥。塔塔利亚老板表示确实存在这样的密钥，并由他签名，而其有效性和信任度均为 1（即塔塔利亚老板完全验证并完全信任索洛佐）。由于科利昂老板完全信任塔塔利亚老板（信任度为 1），而塔塔利亚老板确信该公钥属于索洛佐，因此科利昂老板对索洛佐的有效性为 1（他可以放心地使用接收到的密钥加密消息）。

然而，由于旧的分歧，科利昂老板实际上不信任索洛佐对其他网络参与者的识别，并填写自己的表格（表 1–4），如下所示。

![表 1–4](/resources/img/volume-2/1.3-Web-of-trust-concept/Table-1.4.png "表 1–4")

这样，科利昂先生强调对他而言，索洛佐签发的每个证书的有效性都为 0.1。

现在让我们想象一下有巴尔齐尼先生（Don Barzini），他的公钥被索洛佐和塔塔利亚都保留（而且索洛佐的有效性为 1，塔塔利亚先生的有效性为 0.3）。如果科利昂想写信给巴尔齐尼先生，他向索洛佐和塔塔利亚请求证书，他们都寄给他相应的证书。

收到证书后，科利昂计算有效性。也就是说，他检查接收到的公钥的有效性水平是否与巴尔齐尼相对应（顺便说一句，如果索洛佐想欺骗并自己读消息，它们可能会有所不同）。

我们没有在自己列表中的公钥的有效性定义如下：  
validity( *PK* ) = validity( *PK<sub>i</sub>* ) \* trust( *PK* )，其中  
* validity( *PK* ) 是不在列表中的密钥有效性  
* trust( *PK* ) 是对中介的信任水平  
* validity( *PK<sub>i</sub>* ) 是目标密钥的中介有效性

因此，科莱昂先生认为巴尔齐尼先生拥有的密钥有效级别为 0.24（塔塔利亚先生）和 0.1（索拉左）。这些值相当小，科莱昂先生不敢用收到的密钥加密消息，因此他决定直接拜访巴尔齐尼先生。


### 信任网络技术的优势和局限

WoT 技术的主要优势在于其能够在完全分散的环境中运作，其中相互作用的各方不愿信任中央认证机构。

请注意，在使用信任网络时，由于一个或多个用户的私钥被破坏而导致整个系统失败是不可能的。如果在完全分布的环境中使用信任网络，那么一个节点的故障只会影响与该特定节点的交互能力，而不会对其他节点之间的运作产生很大影响。

然而，信任网络技术存在一些限制，会影响系统的运作。

> ***信任网络的限制***  
> * *在某些情况下，很难找到具有高有效性水平的公钥证书*  
> * *重建网络是一个复杂的过程，需要大量时间*  
> * *找到所需的证书可能需要更多的时间*  
> * *存储证书数据库需要节点上一定的空间*

第一个限制是特定于信任网络协议的。使用信任网络的网路只有在所有节点都是诚实的且具有最大有效性和信任的情况下，才能良好而有效地运作。在大多情况下，用户对其他用户的信任水平远未达到最大值，这导致了在决定使用哪个特定密钥时的寻宝游戏。

如果用户密钥中的一个被破坏，重建网络将比具有集中结构的情况花费更多时间。为了做到这一点，用户必须通知存储其证书的所有节点，他已经受到了损害（而且他需要以一种令人信服的方式进行，因为节点可能将其视为恶意消息并什么都不做）。此外，如果用户是一个新的网络参与者，他需要长时间保持诚实的行为，以便其他节点能够提高对他的信任水平。

第三个限制与在网络参与者众多的情况下查找特定证书的困难有关。这个问题可以通过使用 DHT 部分解决（详见 1.2），但这种方法需要额外的软件和资源。

最后一个问题也与网络参与者的数量增加有关。网络越大，每个节点需要存储的证书数量越多（网络的效率直接取决于此）。

### \*\*\*常见误区\*\*\*

*WoT 保证能够找到有效的用户证书，但可能需要很长时间。*

由于网络节点之间的信任特性，这种说法是一种谬见。很少有一个节点完全信任另一个节点的证书。信任水平可能很高，但很少达到 100%。因此，有可能找不到一个对你信任水平足够的用户证书。例如，客户端可以配置其软件，使得只有通过中间节点的信任水平达到 95% 或更高时，证书才被视为有效。然后可能会通过 3-4 个节点引导到特定证书的链条，并它们之间的信任水平为 95%。然而，由于在请求节点和目标节点之间计算信任水平的特殊性，最终的信任水平可能不会超过 85%。

*在信任网络中，通过创建许多虚假身份和相应地建立多条对自己的最大有效值的信任线，你可以增加对自己（你的评级）的信任水平。*

你可以创建虚假身份和信任线，但这绝不会影响真实用户对你评级的计算，因为这种计算是针对每个特定用户及其外发的信任线进行的。虚假人的意见不会被真实用户所接受，因为他们并未与其建立信任线。

### \*\*\*常见问题\*\*\*

*“一个用户可以为他的几个各种密钥创建多个证书吗？”*

是的，可以这样做。如果不同的密钥用于不同的通信领域（例如，个人和企业），这不会影响证书的确认级别，也不会使交互方感到困扰。

*“WoT 协议是否容易受到 Sybil 攻击，这种攻击是否会影响节点对具有初始低信任级别的证书的接受性？”*

该协议不限制网络中节点的数量，这意味着理论上攻击者可以创建大量完全信任其证书的“参与者”。然而，这无法影响网络中的其他参与者，因为节点之间的信任是单向的。实际上，如果节点不信任新参与者，它们将不会存储其证书，因此数量并不重要。

然而，当先前诚实的节点突然开始恶意行为并将不存在的参与者的证书添加为目标用户时，就会出现问题。结果，网络可能会不再信任此用户，然而，系统的重建是一个复杂的过程，无法轻松完成；攻击者可能会利用这一点。


## 1.4 BitMessage 协议概览

在爱德华·斯诺登（Edward Snowden）报告全球有 60 个国家的 10 亿人受到监控后[10]，创建真正保密的通信手段的需求变得明显。

BitMessage 客户端的第一个测试版本于 2013 年 3 月 21 日上映。BitMessage 协议的一个关键创新是缺乏处理用户数据的中央服务器或任何中心。该协议遵循点对点范式，意味着每个节点同时是客户端和服务器，没有单一的中央服务器。


### 协议的运作原理

对于那些关心保护个人或企业隐私的人来说，比特信 （英语：BitMessage） 是常规即时通讯工具的一个良好替代品。

> * *支持对传输的消息进行端到端加密*  
> * *消息中不明确指明发件人和收件人*  
> * *每个节点存储网络上所有最新的消息*  
> * *工作量证明用于防范网络垃圾信息*  
> * *支持检查接收消息的完整性和作者身份*  
> * *支持公共广播频道*  
> * *支持私人群组聊天*

协议的关键思想是支持对传输的消息进行端到端加密。这意味着只有发送者和接收者能够阅读消息，中间节点无法具备这种能力。为了加密消息数据，使用具有 256 位块长度的 AES 算法，它以 CBC（Cipher Block Chaining）模式运行。在这种情况下，密钥根据 ECDH 方案作为发送者和接收者之间的共享秘密计算。发送者可以自主获取这样的秘密，无需与接收者互动。为此，他需要使用自己的私钥与接收者的公钥。接收者使用自己的私钥和发送者的公钥，以获取完全相同的秘密。因此，两个参与者对于消息加密具有相同的秘密。此外，为了提高安全性，可以使用共享的随机生成器代替ECDH算法，为每条新消息生成一个新的加密密钥。

> ***注意：*** *CBC 模式意味着前一数据块的加密值被用来加密每个随后的数据块。*

BitMessage 消息不指定消息发送者和接收者的标识符。那么接收方如何确定这个特定的消息是发给他的呢？为了做到这一点，每个网络节点尝试解密它收到的所有消息。由于加密密钥只有消息的发送者和接收者才能获得，因此只有他们能够访问消息的内容。

正如前面提到的，节点会尝试解密每一条收到的消息。如果成功（如果消息确实是发给它的），接收者就能看到这条消息的内容。但对于无法解密的消息该怎么办呢？BitMessage 协议暗示每个节点会存储所有收到的消息，保存时间为两天。这样做是为了使消息的接收者即使在消息发送时不在线也能访问到它。用户连接到网络的时候，会向邻居节点请求之前未收到的所有消息并尝试解密它们。

为了防止网络垃圾邮件，BitMessage 使用工作量证明。发送者必须解决一个资源密集型的任务才能发送消息。工作量证明的难度取决于消息的大小和消息中附件的体积。

此外，该协议提供了使用数字签名为验证每条发送的消息的完整性和作者身份的功能

比特信协议允许创建广播频道和秘密聊天。广播频道意味着发送者使用其公钥的哈希值加密消息。具有发送者公钥的每个网络成员都可以解密这样的消息。秘密聊天涉及在一组用户之间创建用于加密的共享秘密。重要的是要注意，这样的秘密聊天不能被第三方审查。


### BitMessage 里的地址

BitMessage 协议还暗示用户有地址。让我们观察一下地址是如何生成以及为什么需要的。

每个 BitMessage 地址都映射到两个密钥对：一对用于签署消息（ECDSA），另一对用于创建共享秘密（ECDH）。为了创建一个 BitMessage 地址，需要使用两个公钥（图 1–16）。

![图 1–16](/resources/img/volume-2/1.4-Overview-of-the-BitMessage-protocol/Figure-1.16-BitMessage-address-generation-scheme.png "图 1–16")

公钥被连接并使用 SHA512 进行哈希，然后再次使用 RIPEMD160 计算结果的哈希值。输出是一个 160 位（20 字节）的数字。该值与 Version（协议版本值）、Stream（消息流 - 我们将在下面更详细地讨论它）和 Checksum（帮助防止写地址时的错误的值）连接在一起。"BM"前缀用于指示该地址属于 BitMessage 网络。因此，BitMessage 地址如下所示：  
*BM-BcbRqcFFSQUUmXFKsPJgVQPSiFA3Xash*

BitMessage 支持两种类型的地址：

> * *确定性地址*  
> * *随机地址*

要获得确定性地址，用户必须设置用于生成它的种子值。可以类比用户设置注册服务的密码的方式。

由于种子直接由用户设置，这涉及一些利弊。优势在于地址恢复的简便性。当使用另一台设备时，用户只需输入种子值（用户可能不想确定随机种子值，而是将其设置为易于记忆的值）。然后，设备独立生成地址。风险包括破解的简易性（暴力攻击或字典攻击），因为种子不是随机值而是用户定义的值。

随机地址使用伪随机值作为种子生成地址，不知道此值就无法恢复地址。请注意，在这种情况下，用户还需要输入种子以恢复地址，但由于种子是一个随机值，因此失去了恢复的便利性，而在与系统互动时增加了安全性。


### BitMessage 里的消息结构

接下来，我们更详细地看一下 BitMessage 协议中的消息结构，如表 1–5 所示。

![表 1–5](/resources/img/volume-2/1.4-Overview-of-the-BitMessage-protocol/Table-1.5.png "表 1–5")

消息包含 5 个字段，如表中所列。其中第一个字段是 *magic* ，它是一个常数，用于标识数据流。通过这个值，你可以确定其后的数据属于 BitMessage 网络。相同的值也用于比特币协议（这里，它被定义为 0xD9B4BEF9）。

接下来的字段是 *command* ，它包含消息类型。根据类型，消息分为广播消息、私人消息或 ACK（私人消息的投递通知）。每种消息类型都有其特定的目的，我们稍后将讨论这些。

接下来的字段是 *length* ，它指示传输消息的字节长度。消息越长，其发送者需要解决的任务越耗费资源。请注意，最新协议版本中的消息最大大小限制为 256 KiB。

消息的下一个组成部分是 *checksum* 字段，其中包含传输数据的 SHA512 哈希值的前 4 个字节。

消息的关键字段是 *payload* ，其中包含传输的数据和作为工作证明的 nonce（只使用一次的号码）。当接收到消息时，节点首先计算 payload 的哈希值，如果接收到的哈希值满足所需的难度参数，就会将这样的消息保存在本地并在网络上传递。如果哈希值不满足所需的参数，这条消息将被删除且不会传递。


### BitMessage 的消息类型

正如前面提到的，BitMessage 支持三种类型的消息。

> * *广播消息*  
> * *私人消息*  
> * *ACK 消息*

*广播消息* 可以被包含了发送者地址的任何节点解码。广播消息使用发送者公钥的哈希值进行加密。接收到这样一条消息的节点确定它是一条广播消息（通过消息中的 command 字段），然后开始逐个计算其地址列表中所有地址的哈希值。使用计算出的哈希值，节点尝试解密接收到的消息。如果消息无法解密，则尝试下一个地址。如果消息成功解密，它将被显示给用户。

通过发送这样一条消息，发送者不会收到传递通知。因此，重新发送广播消息只能手动进行。默认情况下，节点会保存广播消息 2 天。

要发送 *私人消息* ，使用端到端加密，该加密基于发送者和接收者之间的共享密钥。只有具有相应密钥的接收者和发送者才能阅读这些消息。

默认情况下，节点会保存私人消息两天半。如果在此期间，某个消息的接收方未出现在网络上，该消息将会被重新发送。对于消息的每次重新发送，都需要重新计算 PoW。由于接收方向发送者发送通知，软件允许自动中继私人消息。

*ACK 消息* 是私人消息的传递通知。ACK 消息由私人消息的接收方发送。这种消息类型的加密方式与私人消息相同，节点也会将此消息保存两天半。


### BitMessage 里 stream 的意义

在前文中，我们提到了在生成 BitMessage 地址的背景下流（stream）的含义。现在，我们将更详细地了解这个值的作用以及为什么它在协议中被使用。

可扩展性问题是 BitMessage 协议的关键问题。尽管该协议可以提供高度的匿名性和传输消息的机密性，但在每个网络成员都存储所有数据的系统中使用它是非常低效的。想象一下，如果有数百万人使用 BitMessage，每个参与者都需要存储其他参与者的所有消息。出于明显的原因，这样的系统无法可靠地运行。

解决方案是在系统的匿名性和可扩展性之间进行权衡，这意味着将用户划分为所谓的流（streams）。每个流定义了一个用户组，他们将接收并存储与其流相对应的消息。

流是一个二进制结构，如图 1–17 所示。

![图 1–17](/resources/img/volume-2/1.4-Overview-of-the-BitMessage-protocol/Figure-1.17-Scheme-of-the-division-of-network-nodes-into-streams.png "图 1–17")

流编号包含在系统参与者的地址中，确定了发送者必须连接到哪个流，以便消息能够到达其收件人。请注意，每个网络成员存储与其自身流和子流相对应的消息。

### \*\*\*常见问题\*\*\*

*“BitMessage 节点需要保持多少个连接？”*

要与 BitMessage 网络通信，必须至少连接到其中一个节点。与其他参与者的不同节点建立更多的连接会导致网络更加集成，且消息丢失的可能性较低。然而，协议规定了关于最大出站连接数的限制：不超过八个。与此同时，最大入站连接数要大几十倍。

*“我是否可以向当前未连接到网络的用户发送消息？”*

是的，用户可以向 BitMessage 网络发送消息，而无论接收者是否在线。发送的消息会被所有节点存储两天。在重新连接时，接收者进入网络并从连接的节点下载所有新消息。如果接收者超过两天未在线，则消息将被删除，需要重新发送。

*“根据协议，从发送者到接收者的消息传递时间是多少？”*

实际上，消息传输时间取决于两个值：在网络上传播的时间和在等待解密消息队列中的时间。从发送节点到接收节点，消息在网络上传输的时间最长可达 30 秒，具体取决于中间节点的数量。它将在队列中平均约为 5 秒与所有其他消息一起等待解密。因此，如果接收节点在线且同步，它将在发送后 20-30 秒内看到传入的消息。

*“如何使节点被动地工作？”*

如果攻击者能够追踪网络或窃听它，用户可以完全被动地工作，而无需发送 ACK 消息。然而，用户更明智的做法是通过另一个节点发送 ACK 消息，甚至可能对此一无所知。例如，鲍勃害怕夏娃在他的网络中窃听，他将消息直接发送给他的朋友或随机节点，而不是直接向爱丽丝发送 ACK 消息。后者反过来分发此消息并同时确认。


## 1.5 IPFS 协议的结构和特点

在第 1.1 节中，我们研究了一个分散的文件共享网络的工作原理：它不受任何单一方或实体的管制，对审查具有抗性，并直接由其参与者支持。为了组织这样一个网络，实施了 BitTorrent 协议，它安定了支持点对点交易的基本设计概念，但与此同时，它也有一些限制，包括使用范围狭窄。

在 2018 年 10 月 10 日，引入了一种新的组织分散文件共享网络的协议，称为 IPFS。它应用了 BitTorrent 的关键概念，并对其进行了一些新的增强。随后，IPFS 被用作许多分散化应用程序的平台。在这个小节中，我们将详细介绍 IPFS 的基本概念，该协议相对于构建分散化文件共享网络其他协议的优势，以及 IPFS 如何用于实现分散化应用程序。


### 协议的基本原理

IPFS（星际文件系统；英语：InterPlanetary File System）是一种分散的文件共享系统协议。该协议使用 DHT 概念（参见 1.2）来分发内容并在参与者之间启用搜索。IPFS 使用 MDAG（哈希有向无环图；英语：Merkle directed acyclic graph）来组织内容链接的方便结构。与 BitTorrent 协议类似，IPFS 并不简单地在每个系统节点上存储所有文件：每个系统参与者仅存储其认为必要的内容部分。

> * *分布式内容存储*  
> * *内容链接的树结构（类似于传统文件系统）*  
> * *检查和排除重复文件*  
> * *具备文件历史版本的能力*

除了内容之外，每个节点还存储自己的哈希表。该表包含特定标识符与数据之间的映射，可能是内容的一部分或另一个参与者的网络地址。

与许多其他协议不同，IPFS 的一个关键特性是支持内容版本控制。这里有一个例子：你将文档上传到分散网络并在其他参与者之间分发。然后，你决定修复一些错误并在文档上传到网络后更新文档。在诸如 BitTorrent 之类的系统中，无法用新文件替换旧文件（理论上可以做到，但只有在所有节点同意删除旧版本的情况下才能实现）。相反，一个与旧文件没有关联的新文档将发布到网络上。这对于那些与文档版本控制密切相关的应用程序来说是一个巨大的不便。IPFS 也不允许将旧文件替换为新文件。一旦文件被添加到网络中，只有在所有人都同意的情况下才能删除它。然而，IPFS 支持单个文件的版本控制。这意味着，当你更新某个文档时，可以将新版本与旧版本关联起来。这个特性与 Google Docs 或 GitHub 的工作方式相当相似：可以保留更改历史，并在需要时恢复旧版本。


### IFPS 如何运作？

IPFS 的设计与 BitTorrent 相同，即 IPFS 提供了一个面向内容的模型，而不是内容源的模型。该协议还意味着将内容分成文件块（片段），其中一个文件块的大小不能超过 256 KB。每个文件块都有其自己的标识符 - 即其哈希值。同时，该协议并没有严格限制使用特定的哈希函数（可以使用 SHA-1、SHA-256、KECCAK、SHAKE、X11、BLAKE、MD5 等）。请注意，哈希函数标识符用作文件标识符的前缀。因此，用户取决于标识符将能够确保他正在使用所需的哈希算法下载必要的文件。

每个 IPFS 文件有与如表 1–6 一样的结构。

![表 1–6](/resources/img/volume-2/1.5-Architecture-and-features-of-IPFS-protocol/Table-1.6.png "表 1–6")

IPFS 中的文件可以分为四种基本类型。

> ***IPFS 文件类型***  
> * *Blob（数据集）*  
> * *列表*  
> * *提交（状态）*  
> * *树*

*Blob* 是最终的片段，包含下载文件的一部分。 *列表* 包含指向 blob（它们的标识符）的链接和/或链接到其他列表的链接（当文件超过 8 MB 时，一个列表不足以放置文件所有部分的标识符）。 *树* 是一个包含指向其他树、列表和 blob 链接的文件。树和列表的区别在于列表指向单个文件的链接，而树可以类比为目录（其中包含许多不同的列表和文件）。 *提交* 是指向父文件的文件并包含一些修改。

让我们来看看在 IPFS 中发送文件的过程。假设你想将一个小文本文件发送到 IPFS 网络。如果它小于256 KB，那么你将对文件进行哈希处理并将其标识符发送到网络。现在，你的文本文件，即 blob，与接收到的标识符相关联（图 1–18）。

![图 1–18](/resources/img/volume-2/1.5-Architecture-and-features-of-IPFS-protocol/Figure-1.18-Scheme-of-adding-a-small-file-to-the-blob-structure.png "图 1–18")

现在，考虑在这个上下文中列表是什么。列表是对 blob 的链接的集合，可以从中组装出完整的文件。

假设你想要将一个大于 256 KB 的文件（照片、视频等）发送到网络，那需要将文件分成四个部分进行发送。在完成此操作并获得每个部分的标识符后，它们没有以任何方式连接。因此，你创建一个其中指定了所有片段标识符的列表（可以类比为一个 .torrent 文件）。在这种情况下，为了访问整个文件，网络参与者需要通过其标识符获取列表（图 1–19）。

![图 1–19](/resources/img/volume-2/1.5-Architecture-and-features-of-IPFS-protocol/Figure-1.19-Scheme-of-adding-a-large-file-to-the-list-structure.png "图 1–19")

请注意，列表标识符完全取决于 blob 的标识符，而 blob 的标识符又取决于文件部分的内容。如果一个部分被修改，这个列表将无法引用它。然而，正如我们之前提到的，IPFS 允许版本控制；接下来，我们将深入探讨 IPFS 中版本控制的工作原理。

树是指向大量不同内容片段的链接。它们可能包含到其他树、列表和文件的链接。树的标识符完全取决于其所有链接的标识符（因此，任何文件的修改都将被注意到）。从图形上看，树可以表示如下（图 1–20）。

![图 1–20](/resources/img/volume-2/1.5-Architecture-and-features-of-IPFS-protocol/Figure-1.20-Tree-structure-formation-scheme.png "图 1–20")

现在让我们看看提交是什么。当用户想要更新他已发布到网络的文件之一时，他不能只删除旧文件并添加新文件，因为网络是分散的，并谁都不知道哪些节点存储了这个文件。此外，用户不能重新定义旧文件的链接，使其指向新文件，因为每个片段的标识符完全取决于其内容。因此，用户别无选择，只能将新文件添加到网络。在这种情况下，它将具有新的唯一标识符。在 BitTorrent 协议中，这两个文件在协议级别根本无法连接，只有存储文件的节点可以告诉其他节点它们有问题的两个或更多版本的文件。

相反，IPFS 允许在协议级别链接所有版本的内容。对于每个新版本都创建一个引用父文件的提交文件。请注意，如果某些片段未更改，则替代树和列表也将引用这些片段。在图 1–21 中，以示意形式显示了提交。

![图 1–21](/resources/img/volume-2/1.5-Architecture-and-features-of-IPFS-protocol/Figure-1.21-Commit-structure-formation-scheme.png "图 1–21")


### IPFS 的使用

所列的操作原则允许在 IPFS 网络之上构建各种分散的应用程序。

> ***在 IPFS 上的分散应用程序***  
> * *即时通讯和电子邮件*  
> * *媒体平台*  
> * *版本控制系统（Git）*  
> * *网站*

在 IPFS 之上构建的第一个应用之一是一个信使。即时信使的运作方式如下：用户对新消息进行哈希处理，然后将其发送到网络。所有聊天消息都链接在一个列表中，每条新消息都会更新列表的版本（commit）。两个著名的例子是 Orbit Chat [11]和 PubSub Chat [66]。

当然，IPFS 被用于支持多媒体应用程序，使其能够实现视频和音乐的交流。IPFS 允许创建 YouTube 和 Google Play Music 的分散的原型，其中服务器是参与者本身。dTube 就是这样一种应用程序[12]。

IPFS 的版本控制系统使得首次可以创建需要版本控制的应用程序。想象一下一个无法被任何法律机构或商业公司审查的分散 GitHub。这些项目已经存在，尽管它们在市场上的需求远远低于集中式产品[13]。

IPFS 的另一个应用领域是创建分散网站。与持有网站的服务器不同，可以创建一个树文件，其中包含到所有页面的链接。因此，每个用户都可以通过站点的树文件的标识符值下载所有页面（可执行脚本也可以放在单独的文件中）。

> ***注意：*** *特别是，IPFS 的网站还在 IPFS 可用。*


### Filecoin

许多读者可能还记得他们下载种子文件的所有片段，然后停止他们的网络节点的操作，从而停止分发存储的内容。实际上，这影响了一些用户仍然需要的内容。那么，如何激励用户存储他们实际上对存储不感兴趣的文件呢？Protocol Labs 公司（顺便说一下，它还提出了 IPFS）推出了 Filecoin，这个项目在一定程度上可以解决这个问题。让我们来看看该协议的基本概念。

> * *网络参与者支付存储和接收数据的费用*  
> * *网络参与者因存储数据而获得奖励*  
> * *执行分散的网络服务的订单*  
> * *数据保存者定期提供数据已存储的证明*

Filecoin 的主要理念是，愿意在系统中存储其数据或访问其他数据的系统参与者，使用内置货币支付相关服务。在这种情况下，矿工的任务是确保数据的存储并在适当的费用下提供这些数据。每个矿工节点的所有者都可以个人确定提供的磁盘空间量。

存储内容片段的价格由供需关系决定。矿工发送关于提供的空间量和记录成本的报价。其他用户发送包含他们愿意支付用于存储数据的硬币数量的报价（订单）。在匹配了这些报价后，参与者创建交易，其中客户在一定时间后分期支付矿工。请注意，为了获得奖励，矿工必须在这些时间间隔内证明内容仍然由他存储。


### Filecoin 中的共识算法

在 Filecoin 协议中，提出了 *时空证明* （ *proof-of-spacetime* ）共识算法。在这种共识机制中，网络参与者挖掘区块的概率不取决于其节点的计算能力，而是取决于用于存储数据的存储容量大小（相对于所有其他网络参与者）。与经典的容量证明（详细信息见 5.4）不同，Filecoin 中的共识算法并不意味着存储任意数据（仅用于证明存储已满的无用数据），而是存储对用户有用的内容。

每个参与数据存储的网络节点都参与共识达成。同时，每个矿工的存储是公开可见的，这意味着每个网络成员都可以获取有关矿工分配的存储空间的信息，并在那里记录他们的数据。存储也是公开验证的：对于仓库的每个部分，矿工必须生成时空证明以确认他们确实存储相关数据（值得注意的是，该证明不会披露有关存储内容的任何信息，这是零知识证明）。矿工随时可以增加存储空间并提供给网络参与者使用。


### Filecoin 协议的优势

Filecoin 协议设计它允许实现分散式文件共享系统中所需的多个特性的方式。

> * *激励数据存储和惩罚不诚实的系统参与者*  
> * *每个网络成员都可以验证矿工存储某些数据（可审计性），同时无需访问实际内容（零知识）*  
> * *能够随时间取得存储的数据（可检索性）*  
> * *能够确保数据的机密性*

Filecoin 协议暗示着对积极的系统参与者进行奖励。首先，参与者会因形成区块而获得奖励。其次，协议为实际存储有用数据而支付奖励。

### \*\*\*常见问题\*\*\*

*“是否可以删除添加到 IPFS 的数据，需要多长时间？”*

是的，可以删除数据，但有一些值得注意的方面。在分散式文件共享系统中，添加和删除数据与使用集中式存储系统有很大的分别。特殊之处在于，数据由多个独立的参与方存储，只有在删除了所有数据保管者的情况下才能删除数据。大多数情况下，数据保管者没有理由存储他们没有收到报酬的数据，因此从网络中删除数据的过程可能需要几分钟或几小时。但是，如果保管者出于某种原因不想删除数据，那么数据实际上在网络上保留，其所有者无法影响其删除。

*“添加到 IPFS 的数据是否可以进行加密？”*

是的，客户端可以在数据发送到网络之前加密数据；实际上，在 IPFS 网络上进行数据加密是一种常见做法。节点不关心以什么形式和什么数据存储。加密数据也可以被索引并放置在网络上。唯一的区别在于只有在具有适当密钥的情况下才能访问存储数据的内容。

*“基于 IPFS 的私有网络是否可以部署？”*

是的，可以基于 IPFS 创建一个私有网络[14; 15]。为此，用户需要拥有自己的节点，该节点将客户端连接到彼此（连接到公共节点没有意义，因为在这种情况下，网络将是公共的），以及一个群体密钥，该密钥将由所有网络参与者共享。群体密钥是一个标识符，允许 IPFS 节点相互连接。例如，如果两个节点尝试相互通信，其中一个节点具有群体密钥，另一个节点是否具有类似的密钥的事实被检查了。如果密钥存在且一致，节点将相互连接。

