# METHODS FOR ENSURING PRIVACY IN MODERN ACCOUNTING SYSTEMS

## 6.1 CryptoNote standards
The main difference of modern accounting systems from traditional ones is that they use cryptographic operations, such as digital signatures, to prove coin ownership and confirm all changes made to the accounting system’s database. However, standard cryptographic algorithms often limit the privacy of network participants (the simplicity of transaction chains unraveling). In these cases such methods as confidential transactions, ring signatures, stealth addresses, and other methods come into play.

In 2013, a series of CryptoNote standards were introduced. Anonymous cryptocurrencies, such as Monero, Bytecoin, Karbo and others, were built based on these standards. In this section, we will consider some key concepts of these standards, look at technologies that they use, and also consider how anonymity and untraceability are achieved in these protocols.

The CryptoNote series consists of ten standards that describe the basic concepts for building anonymous cryptocurrency. These standards detail technologies for building a shared transaction history, block and transaction  structure as well as how keys are used to generate addresses and sign transactions (using the ring signature mechanism) [51].

In this section, we will consider the technological features of CryptoNote standards and look at how these concepts are applied in the example of the Monero cryptocurrency.

### Signatures in CryptoNote standard
The transaction signature algorithm was described in the first standard of the series, however, later it was replaced by another one (the improved version of signature). CryptoNote describes a one-time ring signature algorithm. This approach allows the user to sign a transaction while staying anonymous. This works because the validator can check that the signature was generated by a participant of some group without knowing who exactly did it (we extensively described the characteristics of digital signature in section 2.4). To prevent a double-spending attack, it was decided to use a one-time signature mechanism (using a private key image).

Let's examine what a one-time ring signature is and how it is calculated. Similar to  calculating the value of an ordinary signature, the user needs to have a key pair consisting of private and public keys. However, when the ring signature is used, the public keys of other participants are also used. Now,  why is this necessary?

When an ordinary signature is used, the validator unambiguously can link the signature value to the existing public key (user’s identifier) since the public key is used to check the signature (Fig. 6.1).

<img width="50%" alt="Figure 6.1 – Classic digital signature scheme" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.1-Classic-digital-signature-scheme.png"/> 

To calculate a ring signature, in addition to the user's private key, it is necessary to use his public key and public keys of all group members. Ring signatures allow the validator to check that this signature was formed by one of the group members. Since all public keys are required for the verification process, it is impossible to say exactly who was the signer (Fig. 6.2).

<img width="50%" alt="Figure 6.2 – Ring signature scheme" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.2-Ring-signature-scheme.png"/> 

### The connection between keys and addresses
Unlike most cryptocurrencies, where a user owns one key pair to manage a single address/account, CryptoNote standards assume that each user has two key pairs. In fact, the user generates two large secret values that act as his private keys. Just like in the other systems, public keys are the result of the multiplication of these secrets by the value of the base point. Public keys have the following names: public spend key and public view key (later we will discuss why).

The address is formed by concatenating the prefix (18 for the main network), two public keys, and the checksum from the previous fields (Fig. 6.3). The checksum is a KECCAK hash value truncated to 4 bytes. The result is encoded in Base58 [52].

<img width="42%" alt="Figure 6.3 – Address formation scheme" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.3-Address-formation-scheme.png"/> 

### Stealth addresses
Most cryptocurrencies require an open address/account. Any third party can link all transactions that are related to this address, and its owner respectively if the connection of at least one transaction and an involved party was disclosed. In this case, it is recommended to create a new address for each new incoming payment and change. However, this approach is not the most convenient since it involves frequent key generation, and the user can’t enjoy the convenience of having one address/account.

Cryptonote standards imply using so-called stealth addresses. Only the private key owner has access to them, and it is difficult for any third party to disclose the relationship between the regular address and the stealth address. Let's look at how these addresses are generated and how the user gets access to coins that are locked in such an address (Fig. 6.4).

<img width="50%" alt="Figure 6.4 – Sending payment to the stealth address" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.4-Sending-payment-to-the-stealth-address.png"/> 

Alice tentatively generates two key pairs for herself and forms an address. To receive payment at the first stage, Alice sends her address to Bob. Bob receives the address and extracts the values of two public keys from it. Then Bob generates a one-time secret value r and multiplies it by the base point to obtain *R*. Bob then uses this obtained values to form a one-time public key to which coins will be pegged; only the owner of the corresponding secret key will be able to access them. In this case, the one-time public key is calculated as follows:

**P = H(r * A1 || n) * G + A2 (n – output index).**

During the next step Bob forms the transaction and sends it to the network. To do this, he creates a transaction, submits unspent outputs as the input, adds a transfer amount and a one-time public key value to the output and puts the value *R* in the extra field (this will be considered later). Then, during the third step, Bob sends the transaction to be confirmed by validators.

Since coins were sent to a one-time public key and not directly to Alice's address, even she doesn’t know which outputs she owns at first. Therefore (fourth step), she checks all outputs of all confirmed transactions looking for the one addressed to her.

For each of the outputs, she calculates the following value:

**P' = H(a1 * R || n) * G + A2.**

If this value is equal to the one in the output of transaction *P*, then the output legitimately belongs to Alice. To unlock it, she needs to calculate the corresponding secret key

**p = H(a1 * R || n) + A2**

and sign the next transaction that spends this output.

### Double-spending protection mechanism
Using ring signatures in their pure form allows a user to perform a double-spending attack. Let's look at the example when there are four users in the network and each of them owns one unspent output (Fig. 6.5).

<img width="50%" alt="Figure 6.5 – Unspent outputs of ring participants" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.5-Unspent-outputs-of-ring-participants.png"/> 

Each output is assigned to an individual public key. To create a ring signature, the user collects public keys from other unspent outputs and then forms a ring signature. Let’s say Alice wants to send coins to her other address so she forms a transaction. She signs the transaction by combining the public keys of Alice, Bob, and Carol (Fig. 6.6).

<img width="40%" alt="Figure 6.6 – Alice’s transaction formation" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.6-Alice’s-transaction-formation.png"/> 

In fact, the validator can check whether an unspent output is assigned to each key and whether the signature indicates that this output is spent. However, the validator does not know which of these outputs is being spent. Therefore, nothing prevents Alice from creating an alternative transaction that sends the same coins to a different address and then signs it using Bob’s and Dave’s public keys (Fig. 6.7).

<img width="40%" alt="Figure 6.7 – Alice tries to perform a double-spending attack" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.7-Alice-tries-to-perform-a-double-spending-attack.png"/> 

If no additional protection mechanism is introduced, then the validator will see this signature as the correct one. In this scenario the funds would  be transferred twice. Thus, the CryptoNote standard involves using a private key image as a way to protect the system against double-spending attacks. This mechanism enables detecting whether multiple signatures were calculated using the same private key without revealing the key itself. The image of the secret key is its hash value. It is used to verify the signature so it can’t be substituted.

If Alice tries to pull off the same thing, the validator will see that the signatures were calculated using the same private key and the conflicting transaction will be rejected.

### Block structure in CryptoNote
CryptoNote standards are organized into a blockchain transaction history. Each block is associated with the previous one through a unique identifier that is the block’s hash value. Let's take a closer look at the block structure in CryptoNote (Fig. 6.8).

<img width="36%" alt="Figure 6.8 – Block structure according to CryptoNote" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.8-Block-structure-according-to-CryptoNote.png"/> 

As you can see from the Figure, the block consists of three components: block header, transaction’s coinbase body and the list of included transaction identifiers. Note that the block itself does not contain any transaction data except for identifiers. This is done to achieve a small block size; however, full nodes still need to store all transactions.

The key difference of a block in Monero to similar cryptocurrencies is its block dynamic size [53]. Monero's average block size is calculated as the mean value of the previous 100 blocks sizes. The maximum block size cannot exceed the average size by more than 2 times. Let’s also note that the protocol provides a mechanism for penalizing miners for mining blocks with a size bigger than the average value. The penalty is calculated as follows:

**P = R * ((B / M) – 1)2**, where
> *P* – penalty size;
> *R* – base reward for block mining;
> *B* – mined block size;
> *M* – median value of last 100 blocks.

Thus, if the formed block has the maximum allowed size, then the reward for its creation is equal to the penalty. It is also worth noting that the amount of the penalty is paid to the validator of the next mined block.

Let's take a closer look at the block header and all its fields (Table 6.1).

Table 6.1
<img width="50%" alt="Table 6.1" src="/resources/img/volume-2/6.1-CryptoNote-standards/Table-6.1.png"/> 

In the *minorVersion* and *majorVersion* fields, the protocol versions are specified: the first and the one that is supported by the validator node respectively. The *timestamp* field indicates the time of the block creation (in UNIX timestamp format). The prevID field contains the hash value (identifier) of the previous block in the chain, and the *nonce* field contains the value necessary to prove the solution of a resource-intensive task.

In addition to the header and list of transaction identifiers, the block contains a transaction’s coinbase body, which pays a reward to the validator. The coinbase transaction (i.e., whether the reward amount corresponds to the block height, etc.) should also be checked by other participants. We will look at the coinbase transaction structure a bit later.

Let's consider how the block identifier is formed according to the CryptoNote standard. The CryptoNight hash function is used to calculate the hash value of a block. A distinct characteristic of this hash function is that it always exactly equals the amount of necessary memory (about 2 MB), which makes application-specific integrated circuits (ASICs) inefficient. Today Monero uses CryptoNight v. 2, an algorithm that was designed by Bitmain in 2017. The process of block identifier generation is shown in Figure 6.9.

<img width="42%" alt="Figure 6.9 – Block identifier generation" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.9-Block-identifier-generation.png"/> 

Note that the KECCAK-256 function is used to obtain the Merkle Root value. For example, let's look at one of the confirmed blocks in the Monero network (Fig. 6.10).

<img width="50%" alt="Figure 6.10 – An example of the block generated by Monero protocol" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.10-An-example-of-the-block-generated-by-Monero-protocol.png"/> 

### Transaction structure in CryptoNote
The transaction structure is defined in the fourth part of the standards series. Transactions in anonymous currencies based on this protocol are similar to Bitcoin transactions and  employ the UTXO model as well (each transaction contains inputs – links to transactions from which coins were received – and outputs that contain conditions to spend coins).

Each transaction consists of two components: a transaction prefix and a set of signatures. The transaction prefix contains basic data (who transfers to whom and how much) and has the following structure (Table 6.2).

Table 6.2
<img width="50%" alt="Table 6.2" src="/resources/img/volume-2/6.1-CryptoNote-standards/Table-6.2.png"/> 

Let’s take a real Monero transaction as an example and look at its fields (Fig. 6.11).

<img width="50%" alt="Figure 6.11 – Monero transaction" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.11-Monero-transaction.png"/> 

The transaction header has 2 fields: *version* and *unlock_time*. The first field shows the transaction version number. In this case, it equals 2, which means that the transaction supports the ring confidential transaction mechanism. The first protocol version only had the implementation of a one-time ring signature to hide the history of the coins’ origin. When ring confidential transactions were introduced, they allowed to also hide the transfer amounts. The unlock_time field indicates the time after which the transaction can be confirmed.

Then there are transaction inputs. The transaction input contains fields *amount*, *key_offsets* and *k_image*. The *amount* field contains the number of coins in the input. In our case, this field equals 0, meaning that the input amount is hidden. The key_offsets field contains key offset index numbers (each successive index denoting an offset relative to the previous one). In fact, these are indexes for unspent outputs in the UTXO database. The outputs group is needed to form a ring signature. In our case, key_offsets contains 11 values. It means that, in addition to the sender’s key pair, 10 public keys of other users are used for the ring signature calculation. The k_image field contains the value of the private key image to prevent a double-spending attack.

After the inputs, there are transaction outputs. In our case, the number of outputs equals 2 and each of them contains two fields: *amount* and *key*. The amount field contains the sum of a transaction output (in a blinded form), and a key – the recipient’s public key. As we noted earlier, the key is disposable and no third party can associate it with the recipient’s master public key (stealth addresses method).

All other transaction data contains proof that the transaction is correct and can be confirmed. In fact, these proof pieces are digital signatures (including range proofs and ring signatures). Note that this proof takes up more than 70% of the transaction size and that the average transaction size in Monero is more than 8 times bigger than the size of a standard Bitcoin transaction.

## 6.2 MimbleWimble
On July 19th, 2016 a paper titled “MIMBLEWIMBLE” was published [54]. In fact, it was a network building protocol with a high level of user privacy and high system scalability. A little later, Andrew Poelstra, one of the most famous people in the Bitcoin community, published a more detailed document, which described the details and technical features of the protocol [55].

What problems does the MimbleWimble protocol solve? The first problem is that most digital assets require storing a complete transaction history, which grows substantially  over time. Thus, validators need to allocate more and more physical memory to store transaction history (otherwise complete transactions verification would be impossible).

The second problem is that it’s difficult to ensure the confidentiality of payments in a permissionless system. If we look at the Bitcoin accounting system, in the classic version, the transaction details indicate the public key, the coins sender signature, the transfer amount and the recipient’s address. This allows validators to check if the specific user owns coins that he is going to spend and that the sum of outputs doesn’t exceed the sum of inputs. Openness is the most important feature of the Bitcoin accounting system; however, this does not ensure the confidentiality of transfers and allows the deanonymization of transaction participants. In addition, you can lose the interchangeability of coins (coins that owners of specific addresses interacted with can be distinguished from other coins).

MimbleWimble combines several concepts: confidential transactions to ensure the confidentiality of transfers, range proofs to prove that the sum of specific input and output doesn’t exceed certain boundaries, CoinJoin for more obfuscating coins history, and cut-through to optimize the size of stored data and reduce transaction and block sizes.

> **MimbleWimble features**
>> * Privacy of transfers
>> * Simple scalability
>> * No need to store the full transactions history
>> * User addresses are not stored in transaction details

Before we dive into how MimbleWimble works, let's consider some basic properties of elliptic curves.

1. Irreversibility. The operation of multiplying the base point by a scalar is fairly simple; however, it is quite difficult to receive the scalar with known result values of the base point. Having the values of the private key *x* and the base point *G*, we can easily calculate the public key value *X = x ∗ G*, but it’s practically impossible to retrieve the private key value from the known public key.
2. Distributive property. The sum of two points on the elliptical curve is equal to the sum of scalars multiplied by the base point value: *x ∗ G + y ∗ G = (x + y) ∗ G*.
3. Commutative property. Reordering the base point multipliers don’t change the result: *x ∗ (y ∗ G) = y ∗ (x ∗ G) = x ∗ y ∗ G*.
	
### MimbleWimble transaction model
Like the Bitcoin protocol, MimbleWimble supports the UTXO transaction model. It means that the transaction contains a set of inputs (links to the previous outputs and proofs of owning them) and a set of outputs containing the transfer amount and the information about new coins owner. Note that the outputs are spent completely (you cannot spend only part of a specific output) and the change is a separate output, the ownership of which can be proven by the sender himself.

Let's look at an example when we gradually move from fully open transactions (similar to the ones in Bitcoin) to transactions with privacy mechanisms. Let's say Harry wants to send 8 coins to his friend Hedwig. He just has two unspent outputs for 3 and 5 coins. So the transaction will look like the one shown in Figure 6.12.

<img width="40%" alt="Figure 6.12 – Unblinded transaction inputs and outputs values" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.12-Unblinded-transaction-inputs-and-outputs-values.png"/> 

To confirm the transaction, validators check that Harry actually owns the outputs of previous transactions and that the sum of the outputs for the confirmed transaction does not exceed the sum of its inputs. In this case, this something very easy to do since the amounts are open (the only thing validators need to do is sum up all inputs and outputs and compare the result). However, Harry doesn’t want validators to know how many coins he transfers (especially Filch with his strange cat). That’s why he needs to blind (hide) the input and output values of transactions.

To do this, the MimbleWimble protocol uses a Pedersen commitment for each transaction input and output value. A Pedersen commitment is represented by the following expression:

**v ∗ H + x ∗ G**, where
*v* – the sum of specific input or output;
*H* – generally known point on the elliptic curve;
*x* – blinding value (a secret that is generated by the user);
*G* – another generally known point on the elliptic curve.

> **_Note._** *At this phase, it should be noted that an additional blinding secret is needed. If we hide the transferred amount only by multiplying it by the base point, the irreversibility property could work, but since the transfer amount is limited to a small value, the other party can figure it out by brute-forcing and find the suitable transfer amount.*

Let’s look at input and output values after this modification. For example, Harry, having the same inputs as in the previous example, uses secrets 19 and 37 to blind them. Thus, by applying the Pedersen commitments, he forms a transaction as in Figure 6.13.

<img width="40%" alt="Figure 6.13 – Blinded transaction input and output values" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.13-Blinded-transaction-input-and-output-values.png"/> 

Now, the transfer amounts are hidden from the validators, while they can still verify that the sum of the outputs does not exceed the sum of the inputs:

**(3H + 19G) + (5H + 37G) – (8H + 56G) = 0.**

However, this transaction structure has one global problem: it requires the sum of blinding factors at the inputs of a transaction to be equal to the sum of blinding factors at its outputs. Thus, after this transaction was sent, Harry knows Hedwig’s blinding factor (secret), which means that he can steal coins from her ( you should not be allowed to do this with a polar owl) (Fig. 6.14).

<img width="30%" alt="Figure 6.14 – The surprised owl formation scheme" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.14-The-surprised-owl-formation-scheme.png"/> 

MimbleWimble solves this problem as well. What if in order to receive a transaction, Hedwig would also have to determine her secret value? Suppose Hedwig generated her secret value equal to 45. Then the transaction would look as follows (Fig. 6.15):

<img width="40%" alt="Figure 6.15 – Blinded values of transaction inputs and outputs" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.15-Blinded-values-of-transaction-inputs-and-outputs.png"/> 

Now the sum of outputs and inputs is not equal to 0 as before; instead, it equals

**(3H + 19G) + (5H + 37G) – (8H + 45G) = 11G.**

In this case, how can the validator verify that the transaction does not create new coins? In fact, it is quite simple. If the sum of inputs is equal to the sum of outputs, the resulting balance will be a public key on *G* (this is possible only if *v_in * H – v_out * H = 0*). The value obtained after calculating (11G) is called the transaction kernel.

In order to confirm the transaction, validators must check that this value is indeed the public key on the curve and that the parties collectively own its shared secret key. The easiest way to prove this is by using a digital signature, which can be verified using the resulting public key (transaction kernel). The digital signature mechanism in MimbleWimble allows the parties that own portions of the shared secret to calculate this shared value.

### Range proofs
At this stage, everything seems to make sense. But there is another pitfall – a scheme of such a kind only works if the values of the inputs and outputs are positive. However, the user can still spend several outputs even if one or more of them are negative (Fig. 6.16).

<img width="40%" alt="Figure 6.16 – Blinded values of transaction inputs and outputs" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.16-Blinded-values-of-transaction-inputs-and-outputs.png"/> 

As we can see, one of the transaction outputs has a negative value in it; however the total amount adds up, and from the validator’s perspective, the transaction is correct:

**(3H + 19G) + (5H + 37G) – (–13H + 25G) – (21H + 7G) = 24G.**

To prove that output and input sums are positive and don’t exceed the maximum possible value, range proofs are used. They are also cryptographic commitments. In 2019, MimbleWimble uses Bulletproofs as an algorithm for forming and verifying such commitments [56].

### All transaction stages
After we have considered the main features of transactions in MimbleWimble, let's consider how these transactions are formed, transmitted and validated. So, Harry has an unspent output of 100 coins and wants to transfer only 50 to Hedwig. Among the remaining coins, he wants to pay 5 coins for a fee and return 45 as change. Therefore, he forms a transaction (Fig. 6.17) of the following type (V1 is the secret to unlock coins, V2 is the secret to receive change, X is the sum of inputs, outputs, and fee, m is additional data).

<img width="40%" alt="Figure 6.17 – Transaction template that is transferred off-chain from sender to recipient" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.17-Transaction-template-that-is-transferred-off-chain-from-sender-to-recipient.png"/> 

Harry also prepares range proofs for each of the transaction outputs. Then he sends this transaction to Hedwig.

When Hedwig receives the transaction, she checks fields and generates her own secret value (blinding factor), forms a public key and calculates the commitment for output addressed to her. Then Hedwig signs the transaction kernel that covers the redundant value, fee and transaction metadata. Then Hedwig returns a set of the following values to Harry (Fig. 6.18).

<img width="40%" alt="Figure 6.18 – Dataset that recipient transfers to sender" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.18-Dataset-that-recipient-transfers-to-sender.png"/> 

When Harry receives this dataset he can form the final transaction and send it to the network for confirmation. In fact, a transaction consists of two parts: the body and the kernel. The transaction body stores the commitment values for all transaction inputs and outputs as wells as range proofs for each output (fig. 6.19). A transaction kernel stores the redundant value (the shared public key), the signature value (Harry can aggregate his signature value and the value that Hedwig has formed), the fee value and additional metadata (if any).

<img width="35%" alt="Figure 6.19 – Transaction structure" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.19-Transaction-structure.png"/> 

### Transaction verification and distribution
When Harry has completely formed the transaction, he sends it to one of the validators. A node that receives this transaction has to check its validity before distributing it among other nodes in the network. Transaction verification occurs as follows:

1. The validator checks that all transaction inputs are unspent. Each full node, based on the transaction history, stores the final state in the form of an unspent outputs list. If Harry's transaction output is on this list, then it can be successfully spent.
2. The validator checks whether the amounts in transaction outputs are within the specified range (verifies range proofs).
3. The validator checks whether the sum of the inputs is equal to the sum of the outputs and the fee. To do so, it has to add all commitments on inputs and outputs and make sure that the received value equals the redundant one and that the redundant value is a point of an elliptic curve (valid public key).
4. After that, it is verified whether the signature of the transaction kernel matches the obtained public key.
5. Finally, the system checks are performed that are not related to the protocol rules, e.g., it is checked whether the fee amount is enough for the transaction to be confirmed by validators.

### No addresses
There are no addresses in MimbleWimble. Each transaction must be initiated by both the sender of the coins and their recipient. To form a transaction, the parties communicate off-chain directly with each other. Note that coins cannot be transferred without the participation of the recipient (compared to Bitcoin, where you can send coins to any address without any action from the recipient).

Through the interaction, the sender indicates unspent outputs and their amounts. The recipient generates an output indicating the calculated blinded value. Then they both form the proof that the sums of the outputs do not exceed the sums of the inputs and range proofs.

### Cut-through method
MimbleWimble uses the cut-through method to remove redundant outputs that are listed in the same block as inputs. This method allows us to free the block from unnecessary data and reduce the amount of data that is stored in the blockchain. Figure 6.20 shows how redundant outputs are removed.

<img width="50%" alt="Figure 6.20 – History versions before and after the redundancy was removed" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.20-History-versions-before-and-after-the-redundancy-was-removed.png"/> 

Thus, validators can still make sure that no new coins were created (except the reward for mining a block) since the amounts at the inputs equal the ones at the outputs.

Moreover, such destruction of outputs (reducing the history of coins transfer) can be used not only within one block but also between several blocks (since inputs of one transaction, in any case, refer to the outputs of the previous ones, with the exception of coinbase transactions). As a result, the blockchain size can decrease during the system operation if the validator forms a block with a large number of inputs (which destroy previous outputs) and a small number of outputs. That is, validators can reduce inputs and outputs, but at the same time, they must keep a history of all transaction kernels.

### Transaction and block structure
A MimbleWimble block consists of a header, a set of inputs, a set of outputs, and a set of transaction cores.

Table 6.3
<img width="50%" alt="Table 6.3" src="/resources/img/volume-2/6.2-MimbleWimble/Table-6.3.png"/> 

Let's take a closer look at the block header structure using a confirmed block in the network as an example (Fig. 6.21).

<img width="50%" alt="Figure 6.21 – Block header example in Grin" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.21-Block-header-example-in-Grin.png"/> 

So, each block header contains a protocol version under the rules of which it was generated. The block header also contains the hash value of a previous block and the Merkle root value from the previous block’s header fields (more specifically, the Merkle mountain ranges root [57]). The next value is the block timestamp.

Next, there are three Merkle Root values: for block outputs, for range proofs and for transaction kernels. They are followed by a set of values associated with solving a resource-intensive task: complexity, the algorithm used, etc. The last element of the block is an aggregated value from the kernels of all validated transactions.

## 6.3 Introduction to zk-SNARKs
In the first volume of the textbook we talked about zero-knowledge proofs, what they are used for and what are the main differences between interactive and non-interactive protocols. Interaction between two parties is generally required since the proof cannot be verified by a third party. In  non-interactive protocols, it needs to be ensured that the knowledge of proof can be verified by all validators. In this section, we will explain the working principles of non-interactive proofs and look at their real application on the example of zk-SNARKs.

These structures originate from 2013 when the fundamental article by several mathematicians was published. The article described a so-called quadratic arithmetic program [58] that became the basis for modern zk-SNARKs constructions. Today, SNARKs consist of a large number of components that need to be understood, so we can make sense of how these constructions work [74].

> * Homomorphic encryption
> * Polynomial blind evaluation 
> * Algebraic circuit
> * Rank-1 constraint system (R1CS)
> * Quadratic Arithmetic Programs (QAP)

### Homomorphic encryption principles
A homomorphic cryptosystem allows performing certain operations on encrypted data to obtain a result. Such systems are used, for example, in blind signature schemes that were considered in Section 2.4. To understand how homomorphic encryption schemes are used for evidence with zero-knowledge proofs, we need to look at the basic properties of such schemes first.

> * Difficulty getting source data from the ciphertext
> * Change in the source data leads to a change in the function outputs
> * With several known encrypted data values, an arithmetic operation can be performed between them

The first property is that the third party cannot get the original value if it has an encrypted value. That means if we denote the homomorphic encryption function as *E(x)*, where *x* is the initial value, then the party that receives the result of *E(x)* cannot retrieve *x* (Fig. 6.22).

<img width="40%" alt="Figure 6.22 – The irreversibility of the homomorphic encryption function" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.22-The-irreversibility-of-the-homomorphic-encryption-function.png"/> 

The second property ensures that if the original values are not equal, the corresponding encrypted values will also be different (with the exception of very low probability). Formally, this can be denoted as follows: 

if *x ≠ y*, then *E(x) ≠ E(y)*.

The last property is the most interesting: a party that has two encrypted values can perform an arithmetically correct operation on them without revealing the secret values. Thus, if a user knows the value of *E(x)* and *E(y)*, he can, for example, receive and check the result of *E(x + y)* without revealing neither the value of *x* nor the value of *y*.

Let's look at an example that illustrates this approach. Say, Alice wants to prove to Bob that she knows two numbers, the sum of which will be equal to 15. Take the values of secrets are *x = 13* and *y = 2*. The parties collectively determine the module *n = 17* and the value of the base point *g = 3* (we will use RSA as an encryption algorithm). To prove to Bob that she knows the secrets, Alice blinds them and gets two values, which she sends to Bob:

*E(x) = g<sup>x</sup> mod n = 3<sup>13</sup> mod 17= 12 mod 17,
E(y) = g<sup>y</sup> mod n = 3<sup>2</sup> mod 17 = 9 mod 17*.

Bob, in turn, needs to make sure that the sum of the secrets is actually 15. For this, he “adds” both values received from Alice as follows:

*E(x + y) = g<sup>{x+y}</sup> mod n = g<sup>x</sup>g<sup>y</sup> mod n = 12・9 mod 17 = 6 mod 17*.

Then he independently encrypts the known result 15 and compares the obtained values:

*E(15) = g<sup>15</sup> mod n = 3<sup>15</sup> mod 17 = 6 mod 17 ⇒ E(x + y) = E(15)*.

Since the results are the same, Alice can prove to Bob that she knows two numbers that add up to 15 without disclosing them, instead of transmitting them in an encrypted (blinded) form. Therefore, the properties that we noted earlier are fully guaranteed.

It is also worth noting that homomorphic systems support linear operations as well. Thus, if we need to multiply the blinded value by a scalar, this is done as follows:

*E(ax) = (g<sup>x</sup>)<sup>a</sup> mod n = E(x)<sup>a</sup>*.

### A bit about polynomials and their blind evaluation
First, let’s recap what a polynomial is. The polynomial is represented in the following form:

*F(x) = a0 + a1x + a2x2+ ... + an - 1xn - 1*, where
*x* is a variable and $а$ are fixed coefficients.

So, suppose Bob knows a specific polynomial and wants to make sure that Alice also knows its coefficients (she does not want to disclose them). To do this, he wants to get the blinded value of *E(F(x))* from Alice. Zero-knowledge proofs weren’t used, then Bob could send the value $x$ to Alice and receive *F(x)*. But what if Bob doesn't want to pass on the secret meaning to Alice?

To do this, homomorphic encryption, which we examined earlier, can be used. Bob initially forms *E(F(x))* and “remembers” it in order to compare it with the value received from Alice. After that, he forms a set of blinded values of the polynomial components and sends them to Alice:

*E(1), E(x), E(x<sup>2</sup>) ,..., E(x<sup>n-1</sup>)*.

Note that if at this stage Alice knows the coefficients of the polynomial, she will be able to provide the correct value of *E(F(x))*. How does this happen? We examined earlier how the blinded value is multiplied by a scalar. The same happens in this case. Alice can multiply blinded values she received from Bob by coefficients she knows. As a result, she will receive the following value:

*E(F(x)) =E(1) <sup>a<sub>0</sub></sup> ･ E(x) <sup>a<sub>1</sub></sup> ･ E(x<sub>2</sub>) <sup>a<sub>2</sub></sup> ... E(x<sub>n-1</sub>) <sup>a<sub>n-1</sub></sup>*.

The resulting blinded value is transmitted to Bob and compared with the one that was previously calculated. If the values are the same, then Bob is sure that Alice knows the polynomial coefficients (except for a very low probability). At the same time, the properties of the zero-knowledge proof are fulfilled: Alice doesn’t know Bob’s secret, keeps the coefficient values to herself, but convinces Bob that she knows them.

### Algebraic circuit
For now, let's move a little away from the concept of polynomials blinding and look at what *quadratic arithmetic programs (QAPs)* are and what role they play in zero-knowledge proofs. The point is that for SNARKs and many other protocols to function, the original task needs to be modified in some way. QAPs are used exactly for this task [75].

For example, Alice wants to prove to Bob that she knows one of the values of *x*, which satisfies the following equation, without disclosing the secret value itself:

*x<sup>2</sup> - x - 6 = 0*.

We can present the same equation as the following function:

<img width="35%" alt="Function" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/function.png"/> 

In fact, Alice has to pass the secret value as the function input and if the output equals 0, then she proves that she knows the needed secret. However, that is impossible in the current form since in order for Bob to check Alice's knowledge, he must independently perform this function and in this case, he would find out her secret value.

To create QAP, first we need to simplify this function by converting it into a sequence of operators that can have only two types [76]:

1. The assignment operator (=);
2. The arithmetic operator (+, −, /, ∗).

Thus, you transform the function into a set of state transitions, which can be depicted both in the diagram and in the form of function operations sets (Fig. 6.23).

<img width="50%" alt="Figure 6.23 – The process of initial program simplification" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.23-The-process-of-initial-program-simplification.png"/> 

### Rank-1 constraint system (R1CS)
Now we can convert the received states (simplified version of the code) to R1CS. To do this, we first need to create a state vector (Fig. 6.24), which contains all variables of the simplified program and the value 1 (to represent constant values).

<img width="30%" alt="Figure 6.24 – The vector of current program states" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.24-The-vector-of-current-program-states.png"/> 

In fact, R1CS is a list of vector triplets *(a, b, c)* for which the following condition is true:

*< a̲<sup>i</sup> · s̲ > × < b̲<sup>i</sup> · s̲ > - < c̲<sup>i</sup> · s̲ > = 0* (6.1)

This equality must be true for each line of simplified code. It means that the correspondence of each logical transition to a new state is controlled.

> **_Note._** *The · operation means the multiplication of the vector values and the subsequent addition of results. Thus, if there are two vectors a and b for them, this operation is performed as follows:
a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> · (b<sub>1</sub>, b<sub>2</sub>, ..., bn) = a<sub>1</sub>b<sub>1</sub> + a<sub>2</sub>b<sub>2</sub> + ... + a<sub>n</sub>b<sub>n</sub> .*

Note that the vector *s* must act as a solution to the equation (6.1). In fact, the vector *s* is a witness, and all of its values can be calculated using the initial secret and simplified program operations (Fig. 6.25). The party that knows the secret can independently calculate all *witness* values.

<img width="56%" alt="Figure 6.25 – Calculating the witness vector" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.25-Calculating-the-witness-vector.png"/> 

Based on this example, let's form a vector triplet that satisfies the condition (6.1) for the first transition (Fig. 6.26).

<img width="30%" alt="Figure 6.26 – Vector triplet for the first transition" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.26-Vector-triplet-for-the-first-transition.png"/> 

To verify if vectors were formed correctly let’s check if the condition is met. In fact, we need to multiply each of the vectors by the solution vector s and then verify that multiplications *a ･ s* and *b ･ s* are balanced out by the value of *c ･ s*. The checking process is shown in Figure 6.27.

<img width="40%" alt="Figure 6.27 – Checking the correctness of chosen vectors for the first transition" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.27-Checking-the-correctness-of-chosen-vectors-for-the-first-transition.png"/> 

Thus, we can see that these vectors are formed correctly and indeed they are the mapping of the simplified program’s first line. Similarly, we need to form vectors for the next two logical transitions (Fig. 6.28).

<img width="50%" alt="Figure 6.28 – Vector sets for second and third transitions" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.28-Vector-sets-for-second-and-third-transitions.png"/> 

Figures 6.29 and 6.30, as in the previous case, show a condition checking (6.1) for the second and third transitions.

<img width="40%" alt="Figure 6.29 – Checking the correctness of chosen vectors for the second transition" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.29-Checking-the-correctness-of-chosen-vectors-for-the-second-transition.png"/> 

<img width="40%" alt="Figure 6.30 – Checking the correctness of chosen vectors for the third transition" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.30-Checking-the-correctness-of-chosen-vectors-for-the-third-transition.png"/> 

### Quadratic arithmetic programs
The next step is to convert the R1CS structure to QAP. Note, at this stage we have a triplet of vector sets that display the state change at each stage of the program execution (Fig. 6.31).

<img width="56%" alt="Figure 6.31 – Vector sets for all logical transitions" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.31-Vector-sets-for-all-logical-transitions.png"/> 

To perform the transition to QAP, it is necessary to transform the set of vectors into the set of polynomials *A*, *B*, and *C* [77]. Out of the three groups (each contains 3 vectors), we have to get 15 third-degree polynomials. To obtain a polynomial, we need to determine the points through which the graph described by this polynomial passes. Then, using these points (Fig. 6.32) and Lagrange interpolation, we obtain polynomials.

> **_Note._** *When using the Lagrange interpolation, the polynomial is calculated as follows:*
<img width="50%" alt="Formula" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/formula-1.png"/>

<img width="40%" alt="Figure 6.32 – The set of points for polynomial values" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.32-The-set-of-points-for-polynomial-values.png"/> 

Next, based on the obtained point values, we transform the vectors into the next set of polynomials as in Figure 6.33.

<img width="40%" alt="Figure 6.33 – Obtaining the necessary polynomials" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.33-Obtaining-the-necessary-polynomials.png"/> 

The resulting set of polynomials acts as the QAP instance parameters. Note that all described actions are performed once and can be reused for the same function. To make sure that polynomials are formed correctly, we can check them. For this, we recalculate the output values for different (used) *x* values (Fig. 6.34).

<img width="40%" alt="Figure 6.34 – Checking the correctness of first transition polynomials" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.34-Checking-the-correctness-of-first-transition-polynomials.png"/> 

In Figure 6.34, we see that the state of the polynomial values gives the same vector that was used for the first simplified program’s transition. Similarly, we can verify that the polynomials correspond to the *a*, *b*, and *c* vector triplets for all other transitions.

Why did we do all these conversions? The idea is that QAP transformation allows us to convert equation (6.1) into an equation of the following type:

*A(x) ∗ B(x) - C(x) = 0*, where (6.2)
*A(x) = ­­­­A̲ ･ s̲, B(x) = B̲ ･ s̲, C(x) = C̲ ･ s̲*.

Note that, as in the previous case, this equation will be satisfied for each transition *(x = 1, 2, 3)*. However, we can verify the correspondence of our *witness* to this task. If we change the *witness* value, for example, instead of *[1, 3, 9, 6, 0]* we take *[1, 3, 10, 6, 0]*, then the equation for transitions will not be satisfied (Fig. 6.35).

<img width="40%" alt="Figure 6.35 – Checking the correspondence of witness to the first transition" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.35-Checking-the-correspondence-of-witness-to-the-first-transition.png"/> 

In this case, we can make sure that if Alice provides a solution for this task, Bob can verify its correctness considering that he knows the original program (the values of the polynomial vectors *A*, *B*, and *C*).

Thus, we completely change the structure of our original task, transforming it into the QAP form, the solution of which is the transition values vector. However, in this case, Alice still needs to publish her secret value in order to convince Bob that she knows this value.

It's time for another math trick. The trick is that the equation (6.2) will simultaneously satisfy all x values only if the resulting polynomial can be exactly divided by the following polynomial:

<img width="25%" alt="Formula" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/formula-2.png"/> 

In our case, since we have only 3 program transitions, the desired polynomial *Z(x) = (x − 1)(x − 2)(x − 3)*. Thus, we can again transform equation (6.2) into an equation of the following type:

*A(x) ∗ B(x) - C(x) = Z(x) ∗ H(x)*.

As a result, it is easier to check whether Alice knows the secret: in fact, she needs to prove that she knows the value of *H(x)* that satisfies the equation described above.

### Simplified knowledge-proof protocol	
Based on the concepts discussed, let's look at how Bob can check if Alice has a secret. Alice and Bob agree on a program that needs to be executed, and based on it they form a set of polynomials for its verification.

After that, Bob selects a random point x (transition number), forms a polynomial *Z(x)* and blinds it (we previously discussed how this process happens). He passes the obtained value of *E(Z(x))* to Alice.

Alice uses the generated *witness* proof to form the polynomials *A(x)*, *B(x)*, *C(x)* and *H(x)*. It allows her to prove the divisibility of the resulting polynomial by the value she received from Bob. Then Alice can blind the resulting polynomials and pass them to Bob.

Bob cannot disclose the values he obtained. However, the properties of homomorphic encryption come to help him. Bob can perform operations on the blinded values and verify that the following equation is true (if Alice actually knows the *witness*):

*E(A(x)B(x) - C(x)) = E(Z(x)･ H(x))*.

Note that what was discussed above is still not zk-SNARKs. It’s more like an interactive test of Alice's knowledge; however, we have seen some basic concepts that are used in non-interactive zero-knowledge proof protocols. To turn this protocol into a non-interactive zero-knowledge proof, we need to add additional modifications that will be discussed in the next volume of this textbook.

[EVOLUTION OF DECENTRALIZED TECHNOLOGIES](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-2/en/7-evolution-of-decentralized-technologies.md)
