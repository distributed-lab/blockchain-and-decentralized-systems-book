# 3 ТЕХНОЛОГІЧНІ ДЕТАЛІ ФУНКЦІОНУВАННЯ BITCOIN

## 3.1 Будова й особливості Bitcoin Script

Існує три основні підходи до завдання умов щодо розподілу та витрати монет:

* повні за Тьюрингом мови (Ethereum – Solidity);
* неповні за Тьюрингом мови (Bitcoin – Bitcoin Script);
* шаблонні смарт-контракти (Bitshares, Stellar и др.).

Для кращого розуміння відмінностей кожного із способів розглянемо рисунок нижче (рис 3.1):

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.1-Three-approaches-to-setting-conditions.png" alt="Рисунок 3.1 – Три підходи до задання умов"/> 

Повні за Тьюрингом мови дозволяють задавати довільні умови витрати монет і реалізовувати найскладніші смарт-контракти з циклами, викликами функцій і багато чим іншим. Деяким обмеженням є необхідність суворого аудиту коду, так як заздалегідь не зрозуміло, до чого можуть призвести помилки в коді смарт-контракту.

Неповні за Тьюрингом мови, такі як Bitcoin Script, дозволяють використовувати набір заздалегідь заданих операцій і при цьому використовувати їх в будь-якій послідовності. Зазвичай набір таких операцій обмежений кількома десятками, але при цьому операції реалізовані безпечно і використовуючи їх можливо без проблем поставити найбільш розповсюджені і вживані умови.

Шаблонні смарт-контракти представляють собою набір готових рішень для використання. Цей набір сильно обмежений і користувач не може додати будь-яку додаткову функціональність (по крайній мірі, швидко – для цього потрібно провести оновлення протоколу). Однак реалізація цих функцій найбільш оптимальна і безпечна.

У цьому розділі ми детально розглянемо будову Bitcoin Script, основні доступні операції та принципи їхнього функціонування, особливості застосування та реальні приклади використання Bitcoin Script як засобу для задання умов виконання транзакцій. Незважаючи на те, що Bitcoin Script не дозволяє написати довільний смарт-контракт, він все одно активно використовується розробниками для реалізації протоколів, які працюють на вищому рівні над протоколом Bitcoin. Таким чином, можна реалізувати сценарій, за яким монети можна витратити або при наявності декількох цифрових підписів і тільки по закінченню певного часу, або при інших умовах.

Як ми відзначали в першій частині навчального посібника, верифікація транзакцій в Bitcoin полягає у перевірці _доказів володіння монетами_, які повинні задовольняти _умовам витрати монет_. Повторимо, що докази володіння монетами знаходяться у вході транзакції, а умови витрати – у відповідних виходах (рис 3.2).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.2-Bitcoin-Transaction-Structure.png" alt="Рисунок 3.2 – Схема Bitcoin-транзакції"/> 

Ці умови та докази зазвичай формуються цифровими гаманцями автоматично. Для їх опису в протоколі Bitcoin використовується спеціальна мова – Bitcoin Script. Крім платежів на звичайні адреси, ця мова дозволяє описувати доволі складні умови витрати монет, зокрема ті, яким можна задовольнити тільки в певний момент часу.

Як відомо, у кожній транзакції є поля під назвою scriptPubKey і scriptSig. Поле scriptPubKey містить опис деяких умов, яким користувач має задовольнити, щоб витратити монети. У полі scriptSig містяться дані, необхідні для задоволення таким умовам. Разом обидва поля є Script. Вузли мережі виконують цей скрипт і за результатами виконання вже вирішують, чи є транзакція валідною. Фактично, Bitcoin Script дозволяє верифікувати транзакції, умови в яких можуть бути описані в довільному порядку.

### Як виконується Bitcoin Script?

Bitcoin Script – це неповна за Тьюрингом мова опису інструкцій. У Bitcoin вона використовується для завдання правил витрати монет і задоволення цих правил. Мова є стековою (stack-based) і використовує «зворотній польський запис» («reverse-polish notation») для операндів.

Неповна за Тьюрингом мова означає, що мова має обмежену функціональність і не підтримує виконання переходів і циклів. Отже, для скрипта виключена можливість входження в вічний цикл, що дозволяє обмежити можливості зловмисних сторін щодо створення складних транзакцій і уповільнення роботи всієї системи.

«Reverse-polish notation» має на увазі, що оператор слідує після операндів, а читання виразу відбувається зліва направо. Такий тип запису виразів значно простіше алгебраїчного, отже, тягне за собою меншу кількість обчислювальних помилок. Як приклад розгляньмо виконання кількох арифметичних операцій над числами. У звичайному алгебраїчному поданні вираз виглядає так:

**(2 + 4) * 5 / 10**

Якщо ж уявити даний приклад у формі набору стекових операцій, то він буде мати такий вигляд:

**24 + 5 * 10 /**

Трохи незвично, правда? Однак, на схемі нижче наочно представлена послідовність всіх обчислювальних етапів (рис. 3.3).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.3-Example-of-processing-Stack-Elements.png" alt="Рисунок 3.3 – Приклад обробки елементів стеку"/> 

Покроково все виконується наступним чином:

1. Спочатку до стеку поміщається значення 2.
2. Потім до стеку поміщається значення 4. Тепер на вершині стеку знаходиться значення 4, а під ним значення 2.
3. Далі виконується операція додавання. Для цього виймаються два верхніх стекових значення, складаються між собою і результат поміщається до вершини стеку. Тепер на вершині стеку знаходиться значення 6.
4. Далі на вершину стеку поміщається значення 5.
5. Виконується добуток верхніх двох значень стеку 5 і 6 і результат у формі 30 записується в вершину стеку.
6. До стеку поміщається значення 10.
7. Під час операції ділення в якості дільника виступає верхній операнд (10), і результат у формі 3 записується до вершини стеку..

Як бачимо, обчислення за допомогою даної схеми досить прості і однозначні. Однак вище ми розглянули приклад з простими арифметичними операціями, де операндами були натуральні числа. У Bitcoin Script операції і операнди є більш складними і різноманітними. 

### Операції в Bitcoin Script

Для операцій в Bitcoin Script існує спеціальна форма запису – OP_code (далі OP-код). Кожен OP-код можна розглядати з двох частин: префікса «OP_» і безпосередньо назви операції. Конкретний OP-код вказує комп'ютеру (віртуальному процесору), яка саме послідовність дій повинна відбуватися при його виконанні. Кожна операція представлена ​​набором бітів, який зчитується віртуальним процесором і виконується.

> **Операції в Bitcoin Script**
>> * _7 операцій управління виконанням_
>> * _19 операцій взаємодії зі стеком_
>> * _27 арифметичних операцій_
>> * _10 криптографічних операцій_

До операцій управління виконанням відносяться такі OP-коди, як: OP_IF, OP_ELSE, OP_NOTIF, OP_ENDIF, OP_RETURN, що дозволяють використовувати в біткоін-скрипті операції розгалуження (і тим самим надавати можливість створення декількох незалежних умов витрати монет). Логіка таких операцій нічим не відрізняється від логіки виконання _if/else_ операторів в звичних мовах програмування. Нагадаємо, що Bitcoin Script є неповним по Тьюрингу, тому в ньому відсутні оператори циклів, як-от _for_, _while_ й інші.

Операції взаємодії зі стеком представлені такими ОР-кодами, як OP_DROP, OP_DUP, OP_ROLL, OP_SWAP, OP_ROT та ін. Вони призначені для роботи зі значеннями зі стека і дозволяють як завгодно керувати його елементами (видаляти, переміщати, дублювати елементи тощо).

До операцій порівняння елементів стека відносяться операції OP_EQUAL і OP_EQUALVERIFY. Відмінність між цими операціями в тому, що OP_EQUAL тільки повертає значення true/false (результат порівняння операндів), а OP_EQUALVERIFY на підставі цього припиняє або продовжує виконання наступних операцій скрипта.

До арифметичних операцій відносяться: додавання (OP_ADD), порівняння (OP_NUMEQUAL), операції знаходження мінімального і максимального чисел (OP_MIN, OP_MAX) і багато інших.

Криптографічні операції. Операції OP_RIPEMD160, OP_SHA1, OP_SHA256 дозволяють обчислити відповідні геш-значення. Операції OP_HASH160 і OP_HASH256 обчислюють подвійний геш (в першому випадку це послідовне обчислення SHA-256 і RIPEMD, у другому – двічі взятий геш SHA-256). Також включені операції перевірки як одиночного підпису, так і мультипідпису (OP_CHECKSIG, OP_CHECKMULTISIG).

Варто відзначити, що всі операції, крім операцій додавання значень до стеку, безаргументні. Це означає, що дані операції працюють тільки зі значеннями, які знаходяться в стеку, і неможливо помістити на вхід операції значення, яке знаходиться поза стеком. Тому в процесі задання умов потрібно враховувати, що максимальна місткість стека при використанні Bitcoin Script обмежена розміром 520 байт.

Отже, викладений вище матеріал дозволяє сформувати уявлення про особливості обчислень в Bitcoin Script і наявні операції. Тепер розглянемо, як він застосовується в реальних bitcoin-транзакціях.

### Приклад виконання Bitcoin Script для P2PKH

Розглянемо приклад витрати для ситуації, де монети відправляються на звичайну адресу, до якої прив'язаний геш одного відкритого ключа (P2PKH, або pay-to-public-key-hash). Скрипт, який задає умови витрати, об'єднаний зі скриптом, який задовольняє цим умовам, наведено на рисунку 3.4.

З лівого боку схеми ми бачимо стек даних, а праворуч – сам скрипт. Перші два компоненти рядки Script – значення підпису і відкритого ключа – так званий _unlocking script_, тобто скрипт, який вказується у вході транзакції, яка витрачає монети (знаходиться в полі scriptSig). Після цього слідує набір даних, який вказується в виході транзакції – це називається _locking script_ (поле scriptPubKey транзакції).

Інакше кажучи, на схемі представлена ​​конкатенація двох скриптів: скрипт, що відпирає монети, і скрипт, що замикає монети. Коли транзакція буде затверджувати вже вузлом мережі, ці два скрипта об'єднуються для виконання перевірки умов витрати монет.

Після конкатенації скриптів відбувається послідовне виконання повного набору операндів. Точка виконання йде послідовно по кожному операнду і кожній ділянці даних. Якщо точка виконання потрапляє на ділянку даних, то вони будуть додані до стеку. Як ми бачимо на схемі, курсор виконання скрипта в верхній частині вказує на дані підпису, які пізніше поміщаються до стеку. Далі, курсор виконання вказує на відкритий ключ – він також додається до стеку. Третім кроком йде виконання операції дублікації, що має на увазі копіювання значення, яке знаходиться на вершині стека, і розміщення цих даних повторно до стеку (в вершині було значення відкритого ключа).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.4-The-first-step-of-script-execution.png" alt="Рисунок 3.4 – Перший крок виконання скрипта"/> 

Після цього виконується гешування за допомогою OP_HASH160 (рис. 3.5). Це означає, що верхнє значення стека гешується спочатку алгоритмом SHA-2 на довжині 256 біт, а потім функцією RIPEMD-160 на довжині 160 біт. Операція точно така сама, як за гешування відкритого ключа при отриманні адреси. Фактично отримане значення і є адреса.

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.5-The-second-step-of-script-execution.png" alt="Рисунок 3.5 – Другий крок виконання скрипта"/> 

Ми маємо в стеку підпис, відкритий ключ і геш-значення відкритого ключа. Курсор виконання скрипта вказує на адресу, яку було поставлено в виході транзакції. Ця частина даних теж потрапляє до стеку (рис. 3.6).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.6-The-third-step-of-script-execution.png" alt="Рисунок 3.6 – Третій крок виконання скрипта"/> 

Наступною виконується операція порівняння OP_EQUALVERIFY. Два верхніх елемента стека порівнюються. Якщо вони рівні, то ці дані видаляються зі стека, повертається значення true (це значення не додається до стеку, але від нього залежить, чи продовжить скрипт своє виконання) і вважається, що перевірка пройшла успішно. Після цього в стеку залишаються значення підпису і відкритого ключа. Відповідно, операція OP_CHECKSIG бере ці два операнда і перевіряє підпис відкритим ключем (рис. 3.7).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.7-The-fourth-step-of-script-execution.png" alt="Рисунок 3.7 – Четвертий крок виконання скрипта"/> 

Якщо підпис правильний щодо транзакції (підпис покриває поля транзакції), то результат перевірки – true, і це значення поміщається до стеку. На цьому виконання скрипта закінчується. Дані передаються в викликаючу функцію і там перевіряються. Якщо в стеку знаходиться значення true, значить верифікація даного входу транзакції пройшла коректно. Якщо всі входи транзакції були коректно перевірені, то і вся транзакція вважається правильною.

### Приклад з multisignature

Тепер розглянемо, як за допомогою Bitcoin Script задається мультипідпис. Умова, що вимагає кілька ключів, блокується наступним скриптом (як приклад реалізуємо мультипідпис 2 з 3):

**scriptPubKey : OP_0 OP_2 \<pubKeyA> \<pubKeyB> \<pubKeyC>  OP_3 OP_CHECKMULTISIG**

Скрипт розблокування буде виглядати наступним чином:

**scriptSig : \<sig1> \<sig2>**

В даному випадку OP_2 позначає кількість підписів, які необхідно надати в scriptSig, а ОР_3 – кількість наданих публічних ключів, яким повинні відповідати підписи.

Скрипт починає виконуватися з того, що в стек додаються значення підписів, які знаходяться в полі scriptSig (рис. 3.8).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.8-The-first-step-of-script-execution.png" alt="Рисунок 3.8 – Перший крок виконання скрипта"/> 

Далі в стек додається значення 0 і 2 (за кількістю підписів, які необхідно перевірити), як на малюнку 3.9. Значення 0 не несе ніякого навантаження, воно додано через особливості операції OP_CHECKMULTISIG, яка при виконанні видаляє одне додаткове значення в стеку.

<img width="60%" alt="Рисунок 3.9 – Другий крок виконання скрипта" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.9-The-second-step-of-script-execution.png"/> 

Після цього до стеку додаються всі значення відкритих ключів (рис. 3.10) і значення 3 (за кількістю значень відкритих ключів).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.10-The-third-step-of-script-execution.png" alt="Рисунок 3.10 – Третій крок виконання скрипта"/> 

Після чого виконується операція OP_CHECKMULTISIG (рис. 3.11).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.11-The-fourth-step-of-script-execution.png" alt="Рисунок 3.11 – Четвертий крок виконання скрипта"/> 

OP_CHECKMULTISIG виконується наступним чином. Спочатку ця операція перевіряє відповідність ключа, який знаходиться вгорі стека, і підпису, який розташований ближче до вершини стека. Після цього, в будь-якому випадку, ключ видаляється (оскільки кожен з ключів перевіряється тільки один раз, тому їх розташування повинне відповідати розташуванню наданих підписів). Процес повторюється до тих пір, поки всі підписи не будуть перевірені. Якщо всі підписи дійсні, то повертається значення true, в іншому випадку – false.

Подібна схема рідко використовується, тому що в цьому випадку обсяг даних в поле scriptPubKey виходить досить великий і, відповідно, розмір комісії за транзакцію також зростає. Замість подібної схеми часто використовується схема P2SH (pay-to-script-hash), де уся умова передається у вигляді її геш-значення і сторона, якій потрібно буде розблокувати монети, повинна надати сам скрипт і дані для його виконання.

### Використання механізму locktime

За допомогою Bitcoin Script ми також можемо задати умову, за якої монети будуть витрачатися тільки через певний час. Задання такої умови здійснюється за допомогою наступного скрипта:

**\<time> OP_CHECKLOCKTIMEVERIFY OP_DROP OP_DUP OP_HASH160 \<address_В> OP_EQUALVERIFY OP_CHECKSIG**

Варто зазначити, що вміст відрізняється від скрипту P2PKH присутністю частини <time> OP_CHECKLOCKTIMEVERIFY OP_DROP. Розгляньмо, як виконується саме ця частина, так як інший скрипт виконується ідентично розглянутому спочатку.

Спочатку до вершини стеку поміщається значення часу блокування (рис. 3.12).

<img width="60%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.12-The-first-step-of-script-execution.png" alt="Рисунок 3.12 – Перший крок виконання скрипта"/> 

Далі операція OP_CHECKLOCKTIMEVERIFY порівнює параметр <time> з полем lock_time, яке міститься в заголовку транзакції (рис. 3.13). Трата монет здійснюється, тільки якщо значення lock_time більше за значення верхнього елементу стека (<time>).

<img width="30%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.13-The-second-step-of-script-execution.png" alt="Рисунок 3.14 – Третій крок виконання скрипта"/> 

Після цього операція OP_DROP видаляє верхнє значення стека (рис. 3.14), яке буде в собі містити значення часу для розблокування, і яке нам більше не знадобиться, якщо OP_CHECKLOCKTIMEVERIFY поверне TRUE і тим самим продовжить виконання скрипта.

<img width="30%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.14-The-third-step-of-script-execution.png" alt="Рисунок 3.14 – Третій крок виконання скрипта"/> 

### Нестандартні транзакції за допомогою Bitcoin Script

13 грудня 2012 року до ланцюжка блоків Bitcoin була додана транзакція, яка платить 1 біткоін тому, хто надасть дані, геш-значення від яких буде відповідати заданому. Транзакція містила наступний скрипт:

**OP_HASH256
6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000 
OP_EQUAL**

Як ви зрозуміли, транзакція, яка набула назву «Transaction puzzle», вимагала від отримувача таких даних, які б внаслідок гешування давали значення, яке зберігається в умовах витрати монет. Схематично роботу скрипта можна зобразити на малюнку 3.15.

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.15-Hash-function-preimage-validation-scheme.png" alt="Рисунок 3.15 – Схема перевірки прообразу геш-функції"/> 

На цьому різноманітність транзакцій не закінчується. У мережі зустрічаються транзакції, умова в яких вимагає певного значення підпису; також транзакції, умови в яких містять безліч розгалужень, тощо. Bitcoin Script – це потужний інструмент для задання умови витрати монет. Його структура і організація не дозволяють зловмисним сторонам задати складний сценарій, який може істотно навантажити мережу. Але в той же час, правильно використовуючи всі його можливості, користувачі можуть точно вказати, яким саме чином можуть бути витрачені монети.

### Статистика транзакцій в мережі Bitcoin

Якщо проаналізувати транзакції ланцюжка блоків Bitcoin за період з серпня 2018 по серпень 2019 року, статистика використання різних видів Bitcoin Script і відповідних типів транзакцій має такий вигляд (рис. 3.16) [23]:

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.16-Transactions-Outputs-Type-Statistics.png" alt="Рисунок 3.16 – Статистика типів виходів транзакцій"/> 

Тут важливо звернути увагу на P2SH-транзакції. У багатьох вже, напевно, виникло здивування, що за останній рік не було відправлено жодної P2SH_MULTISIG транзакції. Однак це не так. Справа в тому, що до того моменту, поки виходи P2SH-транзакції не витрачені, не можна сказати, який скрипт вона містила (там вказано тільки геш-значення скрипта) і, відповідно, який тип операції проводила. Якщо ж ми подивимося на статистику входів транзакцій за останній рік, то ми вже зможемо побачити кількість кожного типу P2SH-транзакцій (рис 3.17).

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.17-Transaction-Output-Type-Statistics.png" alt="Рисунок 3.17 – Статистика входів транзакцій"/> 

Однак зазначимо, що при цьому кількість відправлених транзакцій не завжди говорить про кількість монет, яка передається таким чином. Тому, якщо ми проаналізуємо статистику транзакцій щодо суми переданих монет, то переконаємося, що більший обсяг платежів припадає на P2SH транзакції (більше 58%), хоча загальна кількість відправлених транзакцій говорить про те, що близько 50% є P2PKH транзакціями (рис. 3.18) .

<img width="50%" src="/resources/img/volume-2/3.1-Bitcoin-Script-design-and-features/Figure-3.18-Transferred-Coins-Amount-by-Transaction-Type-Statistics.png" alt="Рисунок 3.18 – Статистика обсягу переданих монет від типу транзакції"/> 

**Найбільш поширені питання**

*— Які ще «transaction puzzles» можна знайти в транзакціях Bitcoin?*

У 2013 до мережі була додана транзакція, для отримання коштів з якої потрібно було надати дві різні рядки тексту, які б після обчислення повернули однакове геш-значення за алгоритмом SHA-1. Іншими словами, щоб розблокувати ці кошти, потрібно було виявити колізію. У 2017 році колізія все-таки була виявлена та кошти були переказані на адресу користувача, якому вдалося вирішити це завдання.

## 3.2 Формати ключів у Bitcoin

Передусім, зазначимо, що світова тенденція в оцифруванні активів, швидше за все, рано чи пізно поставить користувача перед необхідністю керувати своїми цифровими активами безпосередньо. Як браузер дозволяє просто працювати з web-сайтами, здійснюючи водночас складні взаємодії на програмному рівні, так і цифровий гаманець є зручним засобом для управління оцифрованими активами. Тільки в цьому випадку користувачеві потрібно вміти працювати з ключами, оскільки доступ до активів здійснюється за допомогою ключів. Тому питання форматів ключів тільки здається другорядним, і достатня обізнаність в цьому випадку виявиться корисною навіть звичайному користувачеві.

Отже, щоб управляти своїми монетами, в системі Bitcoin використовуються три об'єкти: особистий ключ, відкритий ключ і bitcoin-адреса. На даному етапі підійдуть найпростіші визначення кожного компонента. Особистий ключ – це випадково сгенерированное число довжиною 256 біт; відкритий ключ обчислюється з особистого ключа (довжина відкритого ключа дорівнює 512 біт), а bitcoin-адреса є геш-значенням відкритого ключа (160 біт), отриманим в результаті застосування двох різних алгоритмів гешування.

Далі ми розглянемо формати кодування особистих і відкритих ключів, які найчастіше використовуються при роботі з Bitcoin. Кожен з форматів має свої відмінні риси, тому їх слід вивчити окремо.

> **Основні формати кодування ключів для Bitcoin**
>> * _Hex (Base16 encoding)_
>> * _WIF (Wallet Import Format)_
>> * _BIP38 (зашифрований особистий ключ)_

Оскільки в Bitcoin використовується криптографія на еліптичних кривих, відкритий ключ є точкою на кривій, яка має дві координати. Таким чином, ми можемо записати будь-який відкритий ключ у вигляді просто двох координат: _X_ і _Y_. Однак це не єдина можлива форма запису відкритого ключа.

Розглянемо, як виглядає відкритий ключ в декартовій системі координат (рис. 3.19). На графіку еліптичної кривої знаходиться точка _P_ (_X_; _Y_), яка і є відкритим ключем користувача. Ця точка має дві координати: абсциса – _X_, і ордината – _Y_. Відповідно, цілком можливо обчислити значення _Y_ по аргументу _X_, підставивши у рівняння кривої значення координати _X_ точки _P_.

<img width="30%" src="/resources/img/volume-2/3.2-Key-formats-in-Bitcoin/Figure-3.19-X-coordinate-point-calculation-scheme.png" alt="Рисунок 3.19 – Схема обчислення точки за координатою Х"/> 

Але оскільки в рівнянні еліптичної кривої (*Y<sup>2</sup> = X<sup>3</sup> + 7</nobr>*) присутній *Y<sup>2</sup>*, то для кожного аргументу _X_ існує два значення _Y_: додатне та від'ємне. Для того щоб строго задати і потім відрізнити потрібну точку (_Р_) від симетричної (_-Р_), крім аргументу _X_, потрібно також знати знак значення функції _Y_. Виходячи з цих правил, був побудований формат стисненого відкритого ключа.

### Поняття стиснутого відкритого ключа

Отже, спочатку з особистого ключа утворюється звичайний відкритий ключ, у якого є координати _X_ і _Y_. Після цього значення координат конкатенуються, а на початку серіалізованого ключа додається спеціальний префікс, який дозволяє строго відрізнити цей формат від інших. У шістнадцятковій системі числення такий префікс має значення «04». В результаті нестислий відкритий ключ являє собою послідовність у 65 байт.

Щоб отримати стислий формат такого відкритого ключа, досить координати _X_, точки _P_ і спеціального префікса, який вказує на знак координати _Y_ (а також на те, що це не просто стислий формат відкритого ключа). Префікс «02» використовується для додатного значення _Y_, а префікс «03» – для від'ємного (рис. 3.20). При цьому змінюється формат запису відкритого ключа, який тепер представляє собою послідовність довжиною 33 байта. А оскільки адреса є результатом подвійного гешування відкритого ключа, він також змінюється.

<img width="50%" src="/resources/img/volume-2/3.2-Key-formats-in-Bitcoin/Figure-3.20-Public-Key-Formats.png" alt="Рисунок 3.20 – Формати запису відкритого ключа"/> 

Відповідно, для одного і того ж особистого ключа може бути дві адреси. Тому формати ключів, які будуть розглянуті далі, будуть мати два варіанти: стислий і звичайний. Це потрібно, щоб ми могли чітко розуміти, які відкриті ключі нам потрібно обчислювати на основі цього формату: стислі або звичайні.

### Формати особистих ключів

Є безліч форматів подання особистих ключів. Мало не щодня з'являються пропозиції з приводу різних удосконалень або нових форматів особистих ключів, оскільки існує багато завдань, для яких вони можуть бути застосовані. Утім, у будь-якому форматі часто використовуються одні й ті ж дані, а відрізняється лише спосіб їх кодування. Нижче будуть розглянуті три основні формати в їх звичайному та стислому варіантах.

Hex, або Base16, – це формат, який передбачає запис числа в шістнадцятковій системі числення. Він використовується переважно в програмному забезпеченні, наприклад, під час спілкування між вузлами мережі і мобільними гаманцями; це спрощує пошук помилок і налагодження програми за рахунок підвищення читабельності даних.

Варто відзначити, що звичайний hex – це просто особистий ключ, але існує варіант hex для стисненого особистого ключа. У цьому варіанті, крім особистого ключа, в кінці додається один байт даних, який в шістнадцятковій системі числення має вигляд «01» (рис. 3.21). На перший погляд тут виходить деяка невідповідність, оскільки стислий особистий ключ довше, ніж звичайний особистий ключ. Однак це зроблено для того, щоб користувачі могли визначити, які відкриті ключі слід породжувати з цього особистого ключа.

<img width="50%" src="/resources/img/volume-2/3.2-Key-formats-in-Bitcoin/Figure-3.21-Private-key-presentation-in-hex-encoding.png" alt="Рисунок 3.21 – Подання особистого ключа в кодуванні hex"/> 

Іншим важливим форматом особистих ключів є wallet import format (WIF). Він дозволяє зручно створювати резервні копії особистих ключів або переносити їх з одного гаманця до іншого. Отже, однією з основних особливостей цього формату є його підвищена зрозумілість для людини. Для цього використовується спеціальна система кодування Base58Check, особливістю якої є наявність контрольної суми і додаткового байта, що вказує на версію (допомагає як користувачу візуально розпізнати формат і зрозуміти, що саме перед ним знаходиться, так і програмному забезпеченню ідентифікувати, що саме було отримано на вхід).

У разі звичайного WIF версійний байт при кодуванні Base58Check перетворюється в символ «5». Стислий варіант WIF аналогічний звичайному, але є одна відмінність: вхідні дані – це стислий особистий ключ, де присутня комбінація символів «01» в кінці. Незважаючи на те, що версійний байт залишається таким же, як і в звичайному WIF, префікс в закодованому значенні змінюється з «5» на «K» або «L» (рис. 3.22). Фактично, змінюється довжина вхідних даних. Через це збільшується розряд і змінюється перший символ, незважаючи на те що версійний байт залишається колишнім.

<img width="50%" src="/resources/img/volume-2/3.2-Key-formats-in-Bitcoin/Figure-3.21-Private-key-presentation-in-hex-encoding.png" alt="Рисунок 3.22 – Представлення особистого ключа в WIF"/> 

Останнім з форматів особистих ключів розглянемо зашифрований особистий ключ. Загальною і основною проблемою всіх попередніх форматів є зберігання особистих ключів у відкритому вигляді. Відповідно, відкритим залишається дуже важливе питання про безпеку зберігання особистого ключа, який забезпечує повний доступ до монет користувача. Тому розробники BIP38 запропонували ввести новий формат кодування особистих ключів – так званий зашифрований особистий ключ [50]. Він дозволяє зробити резервну копію особистого ключа або перенести його в інший гаманець або в іншу систему, причому зробити це захищеним способом.

Тут використовується спеціальний алгоритм шифрування, який на вхід приймає особистий ключ і парольну фразу, відому лише користувачеві. Зазвичай в цьому випадку особистий ключ представлений в форматі WIF, але застосовується і будь-який інший формат. За допомогою парольної фрази особистий ключ зашифровується, і вихідні дані кодуються за допомогою Base58Check. При цьому версійний байт підібраний так, щоб вихідний рядок починався з «6P» (рис. 3.23).

<img width="50%" src="/resources/img/volume-2/3.2-Key-formats-in-Bitcoin/Figure-3.23-Encrypted-private-key.png" alt="Рисунок 3.23 – Представлення особистого ключа в зашифрованому вигляді"/> 

Якщо користувач побачить будь-які дані, які мають відношення до Bitcoin і починаються на «6P», найбільш імовірно, це буде зашифрований особистий ключ. Щоб його використовувати, доведеться дістати парольну фразу, якою він зашифрований.

Розшифрувати зашифрований особистий ключ можна у зворотному порядку. Для цього користувачеві досить ввести зашифровані дані в свій гаманець (більшість гаманців підтримує розшифрування ключа в цьому форматі), а після потрібно ввести парольну фразу (passphrase). Гаманець розшифровує особистий ключ і видасть його користувачеві у відкритому вигляді, доступному для застосування.

Вище були розглянуті формати особистих ключів. Тепер перейдемо до форматів відкритих ключів.

### Формати відкритих ключів

Відкриті ключі використовуються переважно в програмному забезпеченні. Кінцеві користувачі зазвичай не оперують відкритим ключем, бо якщо ви користувач Bitcoin, в залежності від цілей, вам буде зручно користуватися або особистим ключем, або bitcoin-адресою, а відкритий ключ – це проміжна ланка.

Виділяють два формати відкритих ключів: hex і hex-compressed (стислий варіант hex). Аналогічно до особистого ключа hex – це запис відкритого ключа в шістнадцятковій системі числення. Єдина відмінність полягає в тому, що тут використовується трохи інша схема, щоб відрізняти стислий відкритий ключ від звичайного, – додається спеціальний префікс. У разі звичайного відкритого ключа додається префікс «04», в разі стисненого додається один з префіксів: «02» або «03» (рис. 3.24).

<img width="50%" src="/resources/img/volume-2/3.2-Key-formats-in-Bitcoin/Figure-3.24-Public-key-in-compressed-and-uncompressed-forms.png" alt="Рисунок 3.24 – Відкритий ключ у стисненій і нестисненій формі"/> 

Чому цих префіксів два? Наявність двох префіксів для стисненого варіанту відкритого ключа обумовлена тим, що координата Y може бути додатною чи від'ємною. Відповідно, префікс «02» вказує на додатну Y, а якщо префікс «03» – на від'ємну.

**Найбільш поширені питання**

*– Який алгоритм шифрування особистого ключа використовується в BIP38?*

Використовується алгоритм AES в режимі Cipher Block Chaining (CBC), де застосовується особистий ключ довжиною 256 біт. Детальніше про це можна прочитати безпосередньо в BIP38 [24].

*– В одному гаманці може бути багато bitcoin-адрес і багато особистих ключів, чи означає це, що потрібно експортувати і імпортувати всі їх окремо?*

Існує три варіанти імпорту/експорту особистих ключів: окремо, списком і імпорт/експорт основного секрету в разі ієрархічного породження ключів. Якщо ключі не пов'язані між собою (кожен з них генерувався окремо), то перенесення їх на інший пристрій можливе тільки окремо або списком. Однак якщо використовується ієрархічне породження, то після перенесення основного секрету всі ключі можуть бути локально породжені з нього і відновлені.

*– Які ще існують формати особистого ключа?*

Крім перерахованих у даному розділі, існують також міні-ключі та ієрархічні ключі. Перший формат генерується певним чином для того, щоб отримати ключ довжиною в 30 символів. Головне його застосування – QR-коди і фізичні монети, як, наприклад, Casascius. Принцип генерації ієрархічних ключів полягає в тому, що використовується певне seed-значення, з якого породжуються всі особисті ключі, що використовуються. Перевага цього методу в тому, що досить зробити резервну копію основного секрету, з якого можна відновити інші ключі.

## 3.3 Формати серіалізації транзакцій і блоків у Bitcoin

Bitcoin-транзакції передаються між вузлами в серіалізованому вигляді (_raw format_), а саме у формі байтової послідовності даних. Ця послідовність також використовується для гешування та подальшого отримання ідентифікатора транзакції. Тому для коректної обробки транзакцій і блоків вузлами мережі є строгий порядок для їх серіалізації.

Дуже часто користувач бачить транзакцію вже в людиночитній формі (перетворену оглядачем ланцюжка блоків або bitcoin-гаманцем). У цьому розділі ми навчимо вас читати серіалізовані транзакції і блоки з одного погляду, розуміти, у якій формі вони передаються мережею та як обробляються вузлами.

### Серіалізація bitcoin-транзакції

Для кращого сприйняття пропонуємо відразу почати з прикладу і розглянути серіалізовану транзакцію, яку дійсно було підтверджено в мережі Bitcoin. Для початку подамо її в форматі JSON (рис. 3.25) [25].

<img width="40%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.25-JSON-Bitcoin-Transaction.png" alt="Рисунок 3.25 – Bitcoin-транзакція в форматі JSON"/> 

У першій частині навчального посібника ми вже розглядали поля транзакції в такій формі. Тепер же розгляньмо, як ту саму транзакцію подано в серіалізованій формі (рис. 3.26) та де розташовано відповідну інформацію [26].

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.26-Serialized-transaction.png" alt="Рисунок 3.26 – Транзакція в серіалізовані вигляді"/> 

Перші 4 байти визначають версію протоколу Bitcoin, згідно з якою була складена транзакція.

Далі йде байт, у якому вказується кількість входів транзакції. Услід за ним поміщаються 32 байти геш-значення від попередньої транзакції (звідки були отримані монети) (рис. 3.27).

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.27-Number-of-inputs-and-link-to-the-previous-transaction.png" alt="Рисунок 3.27 – Кількість входів і посилання на попередню транзакцію"/> 

Наступні 4 байти відповідають за індекс виходу попередньої транзакції (рис. 3.28). У цьому випадку «00000000» означають, що індекс попереднього виходу дорівнює 0.

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.28-The-output-index-of-the-previous-transaction.png" alt="Рисунок 3.28 – Індекс виходу попередньої транзакції"/> 

Далі йде байт, який вказує на розмір scriptSig, тобто докази володіння монетами. У цьому випадку він дорівнює «8с», тобто такі 140 байтів міститимуть скрипт доказу володіння монетами (рис. 3.29‑А).

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.29-А-ScriptSig-value-of-the-transaction.png" alt="Рисунок 3.29‑А – Значення scriptSig транзакції"/> 

Розгляньмо детальніше, що містять ці 140 байтів (рис. 3.29‑Б). Їх можна розділити на 4 частини. Перша частина складається з одного байта «49» і позначає операцію «OP_PUSHDATA (73)», яка поміщає в стек 73 байти даних, які йтимуть за цією операцією. Це будуть дані цифрового підпису транзакції. Після значення підпису йде байт «41» – операція «OP_PUSHDATA (65)», за якою йдуть 65 байтів значення відкритого ключа.

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.29-B-The-detailed-script.png" alt="Рисунок 3.29‑Б – Детальне значення скрипта"/> 

Далі йдуть 4 байти, у яких розташоване значення sequence (рис. 3.30). Нагадаємо, що це значення використовується для позначення версії входу, який витрачає той самий вихід (це актуально для роботи механізму _replace-by-fee_). За замовчуванням воно дорівнює «ffffffff» і зменшується з кожною наступною версією входу (відповідно, з кожним наступним варіантом цієї транзакції).

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.30-Sequence.png" alt="Рисунок 3.30 – Значення sequence"/> 

За цим значенням йде байт, який позначає кількість виходів транзакції. У нашому випадку це «01», що означає, що транзакція має рівно 1 вихід. Потім зазначається сума переказу, під яку виділено 8 байтів (рис. 3.31). Ця транзакція переводить приблизно 0,01 BTC (якщо точно, 999938 сатоші).

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.31-Number-of-Outputs-and-Transfer-Amount.png" alt="Рисунок 3.31 – Кількість виходів і сума переказу"/> 

Далі в тілі транзакції розташований байт, який указує на розмір scriptPubKey (умови витрачання монет). У нашому разі він дорівнює «19» (рис. 3.32‑А), тобто умови поміщено в наступні 25 байтів.

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.32-А-ScriptPubKey-Size.png" alt="Рисунок 3.32‑А – Розмір scriptPubKey"/> 

Розгляньмо, що є в умовах витрачання монет. Дані можна розділити на 6 частин, як на рисунку 3.32‑Б. Байт «76» позначає операцію «OP_DUP», тобто дублювання верхнього значення стека (відкритий ключ користувача). Далі байт «a9» вказує на операцію «OP_HASH», тобто обчислення адреси з відкритого ключа. Після цього байт «14» відповідає за операцію «OP_PUSHDATA (20)», яка поміщає наступні 20 байтів (адреса одержувача) в стек. Далі виконується операція «OP_EQUAL» (байт «88»), після чого виконується перевірка цифрового підпису – операція «OP_CHECKSIG», якій відповідає байт «ac».

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.32-B-Coins-Spending-Conditions.png" alt="Рисунок 3.32‑Б – Умови витрачання монет"/> 

Останні 4 байти транзакції «00000000» – це relative locktime, що дорівнює 0 (рис. 3.33).

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.33-Relative-lockTime.png" alt="Рисунок 3.33 – Значення relative locktime"/> 

### Серіалізация блоку в Bitcoin

Тепер перейдемо до серіалізації блоку Bitcoin. Для цього візьмемо блок, який містить розглянуту вище транзакцію. Серіалізований блок зображений на малюнку 3.34 [27].

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.34-Serialized-block.png" alt="Рисунок 3.34 – Блок в серіалізовані вигляді"/> 

Складний на вигляд, однак варто зазначити, що цей блок містить 4 транзакції, які також включені в серіалізовані значення. Ці транзакції зображені на рисунку 3.35.

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.35-Placement-of-Transactions-in-a-transaction-block-in-a-block.png" alt="Рисунок 3.35 – Розміщення транзакцій в блоці"/> 

Оскільки ми вже розглянули формат серіалізації транзакції, то, фактично, залишається розглянути, що приховано за наступним фрагментом (рис. 3.36).

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.36-Serialized-Bitcoin-Block-Header.png" alt="Рисунок 3.36 – Тема блоку Bitcoin в серіалізованому вигляді"/> 

Перші 4 байта також є значенням версії протоколу, за правилами якого був сформований блок. У нашому випадку це версія «1» (рис. 3.37), яка підтримувалася з моменту genesis block до вересня 2012 року (Bitcoin Core 0.7.0). Останньою на поточний момент версією протоколу є версія 4, яку було впроваджено з листопада 2015. Далі знаходиться 256-бітне геш-значення попереднього блоку.

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.37-Hash-value-of-the-previous-block.png" alt="Рисунок 3.37 – Геш-значення попереднього блоку"/> 

Після цього знаходиться 256 бітове значення Merkle Root від всіх ідентифікаторів транзакцій (рис. 3.38). Відзначимо, що під час формування блоку як перша транзакція завжди використовується coinbase транзакція, інші можуть розташовуватися в довільному порядку; єдина вимога – те, щоб входи були розташовані нижче за виходи, які вони витрачають.

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.38-Merkle-root-value.png" alt="Рисунок 3.38 – Значення Merkle root"/> 

Наступне значення в блоці – це мітка часу його формування в Unix-форматі (рис. 3.39), що складається з чотирьох байтів.

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.39-Block-Formation-Unix-Timestamp.png" alt="Рисунок 3.39 – Unix timestamp формирования блока"/> 

Далі йдуть два значення: перше з них – параметр difficulty, який визначає складність розв'язання поточного завдання proof-of-work; друге – nonce як доказ вирішення цього завдання. Останнє значення визначає кількість транзакцій в блоці (рис. 3.40).

<img width="50%" src="/resources/img/volume-2/3.3-Serialization-formats-of-transactions-and-blocks-in-Bitcoin/Figure-3.40-The-difficulty-parameter-nonce-value-and-the-number-of-transactions-in-the-block.png" alt="Рисунок 3.40 – Параметр difficulty, значення nonce і кількість транзакцій в блоці"/> 

## 3.4 Обмін повідомленнями між вузлами мережі Bitcoin

Архітектура мережі Bitcoin передбачає однорангову мережу, кожен вузол якої рівноправний і самодостатній. На взаємодію вузлів мережі Bitcoin так само, як і на інші процеси цієї системи, не накладаються додаткові обмеження. Консенсус досягається незалежними учасниками, а обмін повідомленнями між ними аналогічно незалежний і децентралізований. Кожен учасник мережі сам вирішує, на підставі якого блоку будувати подальшу історію, так само як мережеві вузли самостійно вирішують, з якими вузлами спілкуватися і як обробляти отриману інформацію.

У першій частині навчального посібника ми вже розглядали важливі моменти влаштування Bitcoin-мережі і роль вузлів в її функціонуванні. У цьому розділі ми розглянемо технічні деталі взаємодії вузлів між собою, а саме: яким чином відбувається обмін повідомленнями між учасниками мережі Bitcoin. Також охарактеризуємо стан мережі Bitcoin за даними на вересень 2019 року, розглянемо протоколи розповсюдження інформації, вимоги до них, проблемні питання таких протоколів і можливі шляхи вирішення.

### Ролі вузлів у мережі Bitcoin

Раніше ми вже зазначали, що вузли можна умовно розділити на три групи:

> * _Повний вузол мережі (аудитор)_
> * _Вузол-валідатор_
> * _SPV-валідатор_

Тепер постараємося трохи розширити класифікацію, спираючись на функції, які можуть реалізувати вузли мережі. Кожен Bitcoin-вузол може складатися з низки модулів, різних за функціями, що вони виконують.

> * _Модуль, який виконує зберігання всієї історії транзакцій_
> * _Модуль, який виконує верифікацію транзакцій_
> * _Модуль, відповідальний за спілкування з іншими вузлами мережі_
> * _Модуль, який формує proof-of-work для майнінгу_
> * _Модуль, який реалізує користувацький гаманець_

Прикладом вузла, що містить всі модулі, є ПК окремого користувача з реалізацією Bitcoin Core або подібної до нього. Такий вузол можна уявити схематично на рисунку 3.41.

<img width="40%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.41-Bitcoin-Full-Node.png" alt="Рисунок 3.41 – Повний вузол мережі Bitcoin"/> 

Кожен з таких вузлів зберігає всю історію транзакцій, тому вони можуть автономно верифікувати наступні блоки в ланцюжку, без необхідності довіряти третій стороні як джерела даних. Такі вузли беруть участь в досягненні консенсусу, тобто нарівні з усіма іншими вузлами беруть участь в прийнятті рішень з підтвердження транзакцій. Наявність модуля мережевої взаємодії дозволяє таким вузлам спілкуватися безпосередньо з іншими учасниками системи, а модуль гаманця використовує локальну копію бази даних для обробки необхідних транзакцій.

Другий тип – вузли, які підтримують мережу Bitcoin і беруть участь в ухваленні рішень, фактично будучи вузлами-валідаторами, але у них може бути відсутнім модуль гаманця (рис. 3.42).

<img width="40%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.42-Bitcoin-Validator-Node.png" alt="Рисунок 3.42 – Вузол-валідатор у Bitcoin"/> 

Третім типом є вузол-аудитор. Такий вузол обов'язково містить два модулі: модуль зберігання всієї історії транзакцій і мережевий модуль, що дозволяє йому повноцінно обмінюватися повідомленнями з іншими вузлами для отримання актуального стану ланцюжка блоків. Такий тип вузлів знайшов застосування у бірж і оглядачів облікових систем. Такий вузол підтримує мережу Bitcoin, так як зберігає локальну версію ланцюжка блоків. Однак якщо у вузла відсутній модуль, що дозволяє створювати блоки, такий вузол не бере участь в досягненні консенсусу (рис. 3.43).

<img width="40%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.43-Auditor-Node.png" alt="Рисунок 3.43 – Вузол-аудитор"/> 

Наступним типом вузлів, що також мають два модуля (але на цей раз модуль гаманця і мережевий модуль), є SPV-вузол. Ми розглядали принцип функціонування такого вузла раніше (в підрозділі 2.3 першої частини навчального посібника). Такий вузол не має власної історії транзакцій, а зберігає тільки заголовки блоків (отримані від повних вузлів або інших SPV-вузлів). Але при цьому він особисто звертається до повних вузлів, і виходячи з отриманих значень Merkle Branch, може визначити: чи дійсно конкретна транзакція була додана в ланцюжок блоків. Схематично місце SPV-вузла в мережі Bitcoin можна зобразити на рисунку 3.44.

<img width="40%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.44-Bitcoin-SPV-node.png" alt="Рисунок 3.44 – SPV-вузол в мережі Bitcoin"/> 

Виділяють ще два елементи мережі, які фактично не є вузлами, так як не підтримують мережу і не беруть безпосередньої участі в досягненні консенсусу. Перший тип – гаманець, який використовує довірений вузол. З назви випливає, що такий елемент мережі має тільки модуль гаманця. Він зв'язується з конкретними повними вузлами мережі (дуже часто тільки з одним) і отримує від них всі дані про транзакції, пов'язані з адресами користувача (рис. 3.45). Однак він не зберігає історію всіх транзакцій і не виконує їх верифікацію.

<img width="50%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.45-Digital-Wallet-Connected-to-the-Network.png" alt="Рисунок 3.45 – Цифровий гаманець з підключенням до мережі"/> 

Другий тип – вузли, які містять тільки модуль, який виконує рішення ресурсномісткого завдання, тобто займаються майнінгом. Такі вузли отримують завдання від повного вузла (mining pool leader) і займаються формуванням proof-of-work, з подальшою його відправкою повному вузлу в разі успіху. Такі вузли є учасниками mining pool (його клієнтами), а власник вузла-валідатора є його оператором (рис. 3.46).

<img width="35%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.46-Mining-pool-structure.png" alt="Рисунок 3.46 – Структура mining pool"/> 

> **_Зауваження._** *За оцінками, зробленими в квітні 2019 року, Bitcoin використовує понад 30 мільйонів користувачів. Кількість повних вузлів, водночас, – близько 9,5 тисяч (більше трьох тисяч користувачів на один повний вузол). До речі, кількість інтернет-провайдерів в світі теж наближається до позначки 10 тисяч, при більш ніж 3,9 млрд активних користувачів.* 

У двох останніх типах вузлів був відсутній модуль, який відповідає за обмін повідомленнями в Bitcoin-мережі. Далі ми розглянемо функціонування саме цього модуля, а значить у контексті будуть використовуватися поняття повного вузла та SPV-вузла.

### Поточний стан мережі Bitcoin 

Умовно в мережі Bitcoin виділяють два види вузлів: публічні та приватні. Публічний вузол (_public-IP node_) є загальнодоступним тобто не вимагає дозволу на підключення до нього. ПЗ такого вузла «слухає» порт в глобальній мережі Інтернет та приймає запити на підключення. Публічні вузли допомагають новим учасникам знайти до кого приєднатися. Якщо буде досить мала кількість публічних вузлів, то новим учасникам буде складно знайти до кого приєднатися і в підсумку мережа не зможе зростати або взагалі розпадеться на підмережі.

Приватний вузол (_private-IP node_) приєднується до інших публічних вузлів, але сам не приймає вхідних з'єднань. Приватного вузла досить для того щоб проводити аудит облікової системи, відправляти свої транзакції і в загальному підтримувати повну функціональність цифрового гаманця (рис. 3.47).

<img width="40%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.47-Bitcoin-network-structure.png" alt="Рисунок 3.47 – Структура Bitcoin-мережі"/> 

На практиці ж видів вузлів більше, зважаючи на особливості організації підмереж. Наприклад, є підмережа з'єднаних між собою університетів, доступ до якої мають тільки вони. Такі публічні вузли можуть запускати університети, але тільки для своєї приватної підмережі, а приєднуватися до глобальної мережі тільки через приватні вузли.

> **_Зауваження._** *Далі ми будемо використовувати тільки поняття публічного і приватного вузлів, оскільки це найбільш поширені види.*

У ПЗ вузла мережі Bitcoin за замовчуванням закладені обмеження на кількість мережевих з'єднань з іншими вузлами:

* кожен вузол прагне створити 8 вихідних (outbound) з'єднань, тобто вузол мережі при запуску знаходить 8 вузлів і з'єднується з ними;
* публічні вузли допускають до 117 вхідних (inbound) з'єднань.

Значення 8 і 117 Сатоші Накамото вибрав як компроміс між надійною зв’язністю мережі і оптимальним мережевим навантаженням. Висока зв'язність дозволяє зробити мережу безпечнішою. Наприклад, якби вузли приєднувалися до одного вузла замість восьми, то була б високою ймовірність ситуацій, коли зловмисники створювали б вузли, які б передавали неправдиві дані про стан системи, і проводили б різного роду атаки. З іншого боку, якщо вузли приєднувалися б не до 8, а, скажімо, до 1 000 інших вузлів, то кожному доводилося б зберігати стан цих підключень. А це, в свою чергу, спричиняє великі витрати пам'яті на зберігання даних про активність вузла, етапи передачі повідомлень тощо. Крім того, якщо вузол має 1000 мережевих з'єднань, то крім зберігання даних про статки цих з'єднань, йому також необхідно по кожному з них синхронізувати нові транзакції, блоки, а також відповідати на вхідні запити, що в результаті створює великі потоки трафіку.

На сьогоднішній день загальна кількість активних вузлів в мережі Bitcoin варіюється від 60 до 100 тисяч вузлів і при цьому остання версія Bitcoin 0.17 запущена тільки на третині вузлів, на іншій третині вузлів запущена попередня версія Bitcoin 0.16, і решта – це ще старіші версії і альтернативні імплементації протоколу (рис. 3.48) [28].

<img width="50%" alt="Рисунок 3.48 – Використання версій протоколу станом на вересень 2019 року" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.48-Using-protocol-version-(September-2019).png"/> 

Якщо проаналізувати кількість публічних вузлів, то можна помітити, що з 60-100 тисяч вузлів в мережі на сьогоднішній день тільки 10 тисяч є публічними. Отже, співвідношення публічних вузлів до решти дорівнює приблизно 1/8. Дане співвідношення обумовлено згаданими вище двома значеннями 8 і 117 тому, що цим 10-ти тисячам публічних вузлів потрібно обслуговувати близько 80 тисяч приватних вузлів. Тому і вибрано число 117, яке дозволяє зберегти цілісність мережі в таких умовах. Карта на малюнку 3.49 показує, що публічні вузли доступні в різних країнах по всьому світу [29].

<img width="50%" alt="Рисунок 3.49 – Карта концентрації доступних Bitcoin-вузлів по всьому світу" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.49-Concentration-map-of-available-Bitcoin-Nodes-around-the-world.png"/> 

### Структура повідомлень в Bitcoin

Розглянемо структуру повідомлень, якими учасники мережі Bitcoin обмінюються один з одним. Всі повідомлення в Bitcoin мають структуру, наведену в таблиці 3.1.

Таблиця 3.1.
<img width="50%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Table-3.1.png" alt="Таблица 3.1."/> 

Одне з найголовніших повідомлень, без яких вузли мережі не можуть почати повноцінну взаємодію – це _version_ повідомлення. Вузли обмінюються _version_ повідомленням або _handshake_, коли в перший раз з'єднуються один з одним. Повідомлення має наведену в таблиці 3.2 структуру.

Таблиця 3.2.
<img width="50%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Table-3.2..png" alt="Таблица 3.2."/> 

### Протокол розповсюдження інформації

Розповсюдження інформації є основним завданням мережі Bitcoin, для виконання якої потрібні системні повідомлення. Таким чином в мережі Bitcoin використовується 27 видів повідомлень, основні з яких наведені на малюнку 3.50 [31].

<img width="20%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.50-The-main-Types-of-Messages-on-the-Bitcoin-Network.png" alt="Рисунок 3.50 – Основні види повідомлень в мережі Bitcoin"/> 

У даному переліку можна помітити, що більшість повідомлень, пов'язаних з передачею транзакції (inv, tx, getdata), переважно використовують трафік, а наприклад повідомлення, перевіряючі чи в мережі ваш вузол (ping, pong), споживають лише малу частину всього трафіку.

### Початок роботи вузла в мережі Bitcoin

Вузол мережі, який запускається вперше і починає взаємодію з іншими вузлами мережі, проходить наступні етапи:

> * _Відправлення запиту DNS-серверу (підтримуються членами спільноти), щоб отримати мережеві адреси активних вузлів у мережі_
> * _Підключення до вузлів_
> * _Завантаження історії транзакцій (initial blocks downloading)_
> * _Обмін блоками і транзакціями з вузлами_

На першому кроці вузлу необхідно надіслати запит на один з DNS серверів, які підтримуються розробниками ядра Bitcoin і членами спільноти і зберігають базу даних про існуючі активних вузлах (мережеві адреси цих серверів вшиті в ПО вузла).

Після запиту на DNS сервер вузол дізнається IP-адреси вузлів, до яких він може підключитися. Далі він підключається до цих вузлів і відбувається протокол звірки версій. 

Далі новому вузлу потрібно запросити і завантажити всі блоки з уже існуючою ланцюжка блоків. Для цього використовується метод Initial Block Download, тобто початкове скачування блоків. Після того як існуючі блоки синхронізовані, новий вузол починає брати повну участь в протоколі передачі даних по мережі – обмінюватися новими блоками і транзакціями з іншими вузлами.

### Протокол розповсюдження інформації Flooding

Для передачі блоків і транзакцій по мережі Bitcoin використовується модифікація протоколу Flooding [32]. Згідно з цим протоколом вузли передають нові/отримані блоки і транзакції всім своїм вузлам, крім тих, які про ці блоки і транзакції вже знають (рис. 3.51). 

<img width="30%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.51-General-Flooding-Protocol.png" alt="Рисунок 3.51 – Загальна схема роботи протоколу Flooding"/> 

Для економії трафіку використовують протокол що складається з трьох повідомлень. Його суть полягає в тому, що як тільки вузол отримує нову транзакцію або блок, він відправляє геш-значення цього об'єкта INV(hash(tx)) вузлів. Кожен вузол звертається до своєї локальної бази даних для перевірки наявності в ній цього геша; якщо не знаходить, то запитує у вузла GETDATA(hash(tx)) потрібний блок або транзакцію, відповідну отриманому геш-значенню. Вузол, отримавши такий запит, відправляє у відповідь повний блок або повну транзакцію. Завдяки даній модифікації з трьома повідомленнями можна уникнути повторного отримання наявної транзакції або блоку, а позаяк розмір кожної транзакції зазвичай становить 150–500 байт, то досягається істотна економія мережевого трафіку. Схематично розглянемо приклад розповсюдження транзакції в мережі Bitcoin на рисунку 3.52.

<img width="40%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.52-Network-Transaction-Distribution-Example.png" alt="Рисунок 3.52 – Приклад розповсюдження транзакції мережею"/> 

Припустимо, вузол А отримав транзакцію tx з мобільного клієнта і збирається нею поділитися з вузлами B, C і D. У цих вузлів немає цієї транзакції, тому вони отримають її в момент часу t1. У момент часу t2 вузол В спробує відправити цю транзакцію вузлу С, але так як вузол С уже має у своєму розпорядженні дану транзакцію, то він не запросить повну версію цієї транзакції, і тому транзакція не буде передана по цьому з'єднанню. Вузли Е і G не знають про цю транзакції, і тому у відповідь на повідомлення про нову транзакції вони її запросять і отримають в рамках моментів часу t2. Даний процес триває до тих пір, поки всі вузли мережі не матимуть дану транзакцію.

### Diffusion – розширення Flooding

Насправді Bitcoin використовує протокол Diffusion [32] для передачі транзакцій, який є розширенням протоколу Flooding. Згідно з цим протоколом кожен вузол в мережі, отримавши нову транзакцію, не відправлятиме її відразу, а буде чекати протягом випадкового проміжку часу від 0 до 5 секунд. Таким чином, вузол акумулює транзакції, перш ніж розповсюджувати їх далі. Це допомагає економити трафік, пов'язаний з заголовками повідомлень, ускладнити шпигунство, пов'язане з дослідженням часу, в момент якого отримана транзакція, і уникнути колізій «на льоту» (коли два вузла одночасно відправляють один одному одну транзакцію).

Існує кілька складнощів, пов'язаних з протоколами передачі даних в мережі Bitcoin.

> * _Дотримання анонімності користувачів_
> * _Стійкість до атак різного роду_
> * _Вимоги до потужності обладнання та пропускної здатності_
> * _Час розповсюдження даних мережею_

Далі ми розглянемо, яким чином вирішується кожна з перерахованих проблем.

### Приклади проблем в протоколах і їх рішення

Розглянемо задачу анонімності. Її можна сформулювати таким чином: як унеможливити (або зробити дуже дорогим) визначення походження транзакцій в мережі, тобто як унеможливити зв'язування певної транзакції в мережі Bitcoin і мережевої адреси вузла, з якого вона почала розповсюдження мережею?

Нижче на схемі (рис. 3.53) можна помітити, що _supernode_ – це вузол, який приєднаний до всіх вузлів в мережі. За моменту часу, в який цей вузол вперше дізнається про транзакції від інших вузлів, він може визначити її джерело. Таким чином, supernode може зв'язати цю транзакцію з тією чи іншою IP-адресою.

<img width="30%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.53-Transaction-Source-Disclosure-Example.png" alt="Рисунок 3.53 – Приклад розкриття джерела транзакції"/> 

Щоб протидіяти таким атакам, був запропонований протокол Dandelion [32], потім Dandelion ++ [33]. Розглянемо, як діє цей протокол.

Даний протокол розповсюджує транзакції по мережі в двох фазах:

> _Анонімна фаза (stem phase)_ – кожен вузол відправляє транзакцію тільки одному з пов'язаних з ним вузлів.

> _Фаза розповсюдження (fluff phase)_ – кожен вузол транслює транзакцію в мережу передаючи її всім пов'язаним з ним вузлам.

Кожен вузол з імовірністю 0.9 розповсюджує транзакцію в анонімній фазі і з ймовірністю 0.1 в фазі розповсюдження (рис. 3.54). У підсумку виходить, що транзакція йде по одному шляху до моменту, коли вона починає розповсюджуватися. Таким чином, існує 10% ймовірності, що транзакція почне розповсюджуватися з нульового вузла, 10% – що з першого, 10% – що з другого тощо. Отже, визначити справжнє джерело транзакції стає дуже складно. В середньому через 10 таких стрибків від одного вузла до іншого транзакція розповсюджується за допомогою звичайного протоколу Flooding.

<img width="50%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.54-Dundelion++Protocol.png" alt="Рисунок 3.54 – Протокол Dundelion++"/> 

Тепер розглянемо проблеми безпеки в мережі Bitcoin. Одним з основних завдань забезпечення безпеки полягає в тому, щоб підвищити вартість здійснення атаки до рівня, коли вона стає економічно невигідною. Як приклад розглянемо Eclipse attack.

Сценарій цієї атаки полягає в тому, що вузли, підконтрольні атакуючому, ізолюють чесні вузли від загальної мережі Bitcoin і транслюють їм помилковий стан бази даних.

Оскільки чесні вузли приєднані тільки до вузлів атакуючого, то у них немає шансів дізнатися про блоки, які є частиною цього ланцюга, якщо атакуючий буде показувати їм тільки блоки, які він сформував сам (рис. 3.55). Таким чином можна здійснювати подвійну витрату та деякі інші атаки.

<img width="30%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.55-Eclipse-attack.png" alt="Рисунок 3.55 – Eclipse атака"/> 

Як протидію цій атаці самі її автори запропонували кілька способів модифікації протоколу, наприклад, диверсифікація сполук по IP (підключення до різних регіонів). Таким чином, якщо у кожного вузла є 8 вихідних з'єднань, то атакуючому потрібно буде володіти дуже великою кількістю вузлів в мережі, причому з різних частин світу, що робить атаку набагато дорожче для виконання.

Тепер розглянемо проблему споживання ресурсів. Як знизити вимоги щодо пристрою і трафіку повного вузла Bitcoin? Один з основних принципів Bitcoin – це його доступність як для машин з великою обчислювальною потужністю, так і для машин з низькою. Тому дуже важливо розробляти Bitcoin таким чином, щоб він зберігав свою працездатність, надмірно не навантажувати глобальну мережу й не вимагав дорогого обладнання для підтримки вузлів. Прикладом проблеми в даному контексті є ситуації в яких вузли, які знаходяться ближче (мережею) до вузлів-валідаторів, отримують нові блоки раніше за інших. Як тільки блоки отримані і верифіковані, вузли відразу ж повинні відправити даний блок всім своїм сусіднім вузлам. Так як більшість сусідніх вузлів не чула про цей блок, вони відправлять запит на його отримання, і таким чином будуть спостерігати стрибок у споживанні трафіку.

Стрибок в споживанні трафіку призводить до складнощів з інтернет-з'єднанням, так як в один момент часу потрібно задіяти дуже велику частину пропускної здатності. Як вирішення цієї проблеми був сформований BIP 152: Compact Block Relay (Matt Corallo) [34]. Давайте розглянемо, як працює ця пропозиція.

Замість одного протоколу передачі блоків в мережі, їх буде три і вони будуть використовуватися в залежності від контексту.

Спочатку розглянемо Legacy Relaying (рис. 3.56 – A), тобто старий спосіб розповсюдження блоків. Вузол А отримує новий блок, валідує його і відправляє заголовки (headers of inv) вузлу В. Так як у вузла В немає цього блоку, він запросить його дані (getdata) і вузол А відповість йому вмістом повного блоку (block).

Далі з'явилося два нових види запуску цього протоколу, а саме High Bandwidth Relaying (з високим споживанням трафіку) і Low Bandwidth Relaying (з низьким споживанням трафіку).

<img width="45%" src="/resources/img/volume-2/3.4-Messaging-between-Bitcoin-network-nodes/Figure-3.56-Compact-Block-Relay.png" alt="Рисунок 3.56 – Compact Block Relay"/> 

Тепер розглянемо нові види протоколу: High Bandwidth Relaying і Low Bandwidth Relaying. У кожному з даних видів протоколу передбачається, що в першу чергу вузол В повинен повідомити вузлу А, за яким типом цього протоколу вони будуть працювати. У випадку з високим споживанням трафіку вузол В повідомляє вузлу А (sendcmpct (1)), у випадку ж з низьким вузол В повідомляє – (sendcmpct (0)).

Розглянемо High Bandwidth Relaying (рис. 3.56 – В). Вузол В повідомляє вузлу А, що вони будуть працювати за типом протоколу з високим споживанням трафіку (sendcmpct (1)). Працюючи за цим типом протоколу вузол А, отримавши блок, не виконує його повну верифікацію, а тільки перевірку його заголовка. Далі вузол А анонсує цей блок вузлу В і пробує передбачити на основі попередніх передач даних, яких транзакцій бракує вузлу В (cmpctblock). Після цього вузол В, звіривши цей блок з тим, що у нього є, запитує транзакції, які йому необхідні (getblocktxn), і вже після повної верифікації блоку вузол А відправляє транзакції що залишилися вузлу В.

Розглянемо Low Bandwidth Relaying (рис. 3.56 – С). Вузол В повідомляє вузлу А, що вони будуть працювати за типом протоколу з низьким споживанням трафіку (sendcmpct (0)). У цьому ж випадку вузол А анонсує блок вузлу В тільки після повної верифікації цього блоку.

Тепер розглянемо проблеми швидкого розповсюдження даних по мережі. Як розповсюджувати по мережі транзакції і блоки максимально швидко? Питання полягає в тому, що швидке розповсюдження блоків і транзакцій по мережі дійсно дуже важливо. Наприклад, чим повільніше розповсюджуються блоки, тим вище стає Orphan rate (число блоків, які довелося відкинути з основного ланцюжка тому, що вони були створені не на основі останнього відомого блоку). В результаті таких затримок підвищується обсяг марно виконаної роботи (proof-of-work), який знижує рівень безпеки системи.

Як вирішення цієї проблеми було запропоновано організувати додаткову мережу – Bitcoin FIBRE [35]. У цій мережі будуть знаходитися тільки вузли-валідатори і, в першу чергу, вони обмінюються блоками в даній мережі. Це дозволяє забезпечити низький Orphan rate.

**Найбільш поширені питання**

*– Яка вигода від запуску повного вузла Bitcoin?*

У деяких випадках використання довіреного вузла або SPV-вузла недостатньо і потрібно запускати повний вузол. Наприклад, якщо ви хочете просто забезпечити максимальний захист своїх коштів від атак, то вам потрібен повний вузол (досить приватного вузла, який не приймає вхідні з'єднання). Це потрібно, щоб самостійно перевіряти всю історію транзакцій і PoW, стежити за альтернативними гілками ланцюжка блоків і своєчасно перемикатися на останній актуальний стан мережі. Бути впевненим у достовірності виконання цих процесів неможливо, якщо ви використовуєте для цього стороннє джерело. Якщо ви хочете допомогти мережі (зробити її більш зв'язковою і надійної), ви можете запустити публічний вузол. Тоді інші вузли зможуть приєднатися до вас (що збільшить загальну кількість з'єднань вашого вузла), це допоможе мережі рости, а всі описані переваги приватного вузла також будуть доступні.

*– Чому не можна структурувати мережу Bitcoin (наприклад, топологія «зірка»)?*

Топологія «зірка» передбачає наявність центрального комп'ютера, до якого приєднуються всі інші. Так як Bitcoin націлений на децентралізацію облікової системи та мінімізацію необхідного рівня довіри, то його топологія повинна бути розподіленою (близькою до випадкового графу). У топології «зірка» потенційно вразливим буде центральний вузол, який при пошкодженні або атаці загрожує працездатності всієї системи. 

*– Чому небажано розкривати топологію мережі?*

Існує думка серед розробників протоколу Bitcoin, що відома топологія мережі робить її більш вразливою до ряду мережевих атак. Наприклад, якщо хтось дізнається, що в мережі є вузьке горлечко (bottleneck), варіант, коли мережа розбита на дві підмножини вузлів, які з'єднані тільки одним підключенням, то атакуючий, отримавши контроль над двома цільовими вузлами, може порушити процес досягнення консенсусу і реалізувати double-spending або подібні атаки.

*– Чому не можна розповсюджувати тільки блоки (без окремої передачі транзакцій)?*

Кілька років тому в Bitcoin був запропонований опціональний режим роботи blocks-only. Даний режим дозволяє вузлу не слухати нові транзакції, а слухати тільки вже створені валідаторами блоки. Така опція актуальна для вузлів, які мають намір економити свій трафік. Якщо ж всі вузли в мережі будуть використовувати дану опцію, то ми будемо спостерігати стрибки в споживанні трафіку публічних вузлів, які передають всім іншим новий блок цілком. Але найбільша проблема цієї ситуації полягає в тому, що нові транзакції не зможуть дістатися до вузлів-валідаторів, щоб отримати підтвердження. Тоді для передачі транзакції доводилося б цифровий гаманець безпосередньо підключати до вузла-валідатора.

*– Чи шифрується трафік, який виробляють вузли?*

Ні, не шифрується. Дане питання було предметом дискусій протягом останніх кількох років. Був запропонований протокол шифрування трафіку, який допоміг би, наприклад, приховати від провайдерів факт того, що ви користуєтеся Bitcoin. Зараз ваш інтернет-провайдер або адміністратор вашого роутера може побачити, що ви користуєтеся Bitcoin і, можливо, навіть визначити які з транзакцій в мережі ваші, а які ні. Вважається, що це розкриває частину ідентифікаційних даних власників вузлів, тому в даний момент активно ведуться розробки нових альтернативних протоколів шифрування каналів, які будуть працювати в цьому специфічному середовищі.

*– Який тип поновлення потрібен, щоб змінити протокол обміну повідомленнями?*

Ні hardfork, ні softfork не потрібні, щоб змінити ці протоколи, але потрібно розробляти протоколи і відповідні оновлення ПЗ вузла таким чином, щоб вони були сумісні і щоб неоновленні вузли могли приєднуватися до оновлених і нормально працювати. Прикладом такого протоколу є Compact Blocks Relay [34], розглянутий вище. У ньому передбачено обмін повідомленнями зі старими вузлами так само, як і з новими.

## 3.5 Testnet і складнощі оновлення протоколу

Testnet – це альтернативна відносно основної мережа вузлів, яка працює за таким самим протоколом, але підтримується меншою кількістю учасників і є своєрідна «пісочниця», до якої може приєднатися будь-хто охочий для проведення тестів. Testnet має свій genesis block, а монети в ньому відокремлені від монет ув основній мережі та не мають жодної реальної вартості.

Це дозволяє розробникам застосунків або тестувальникам експериментувати без потреби проводити операції з реальними монетами та засмічувати основний ланцюжок транзакціями. Саме в testnet команда розробників протоколу Bitcoin проводить тестування оновлень і нового ПЗ, а також навантажні тести мережі перед упровадженням цих оновлень ув основній мережі. Testnet поділяють на два види: private testnet і public testnet.

### Testnet в Bitcoin і його призначення

_Public testnet_ в Bitcoin працює так само, як і основна мережа (mainnet) з єдиною відмінністю в тому, що люди не надають цінності монетам цієї системи. При цьому користувачі можуть як самостійно майнити тестові монети, так і звернутися до учасників, які роздають невеликі частки монет бажаючим з метою тестування програмного забезпечення вузлів, гаманців тощо.

Крім публічної тестової мережі, з якої можуть працювати всі бажаючі, можна створити _private testnet_ (regtest, Regression Test Mode) – локальну (приватну) версію Bitcoin. Цей варіант тестової мережі зручний тим, що можна швидко оновити ПО всіх вузлів мережі і провести демонстрацію або тестування змін без необхідності схвалення з боку інших учасників. У цього методу є три основні переваги:

> * _Відсутність необхідності підключення до публічної мережі_
> * _Повний контроль над мережею і проведеними в ній транзакціями_
> * _Більшість параметрів мережі зберігається, що дозволяє самостійно змінювати тестовані параметри або впроваджувати нові функції_

### Оновлення протоколу

У процесі оновлення протоколу децентралізованої системи розробникам доводиться стикатися з певним труднощами. Особливо складною є ситуація, коли оновлення потрібно провести в permissionless системі і не можна допустити зупинки її функціонування навіть на короткий проміжок часу. Традиційні протоколи допускають наявність різних версій в мережі, але, наприклад, в Bitcoin і подібних облікових системах вузли повинні обробляти блоки однакового формату. Отже, деяка група учасників не може вільно перейти на нову версію протоколу, не враховуючи версії ПЗ решти вузлів мережі (саме в таких випадках і виникають форки).

Для впровадження будь-якої зміни протоколу необхідно враховувати такі питання: як вузли домовляться між собою щодо нових правил, чи з'являться в результаті поновлення уразливості або баги і наскільки безпечним буде оновлений протокол?

Причини для оновлення можуть бути різними, наприклад, додавання нових функцій, усунення відомих вразливостей або зміна ключового правила в протоколі. На рисунку 3.57 наведено узагальнену схему оновлення протоколу децентралізованої системи.

<img width="60%" src="/resources/img/volume-2/3.5-Testnet-and-challenges-of-protocol-updating/Figure-3.57-Protocol-update-steps-diagram.png" alt="Рисунок 3.57 – Схема етапів оновлення протоколу"/> 

Процес оновлення починається з того, що з'являється нова версія протоколу, яка анонсується учасникам мережі. Після анонса, деяка частина вузлів починає генерувати блоки вже нового формату, в той час як інші можуть залишатися на минулій версії. При цьому кожен вузол приймає рішення щодо оновлення самостійно.

Через певний час, все більше вузлів-валідаторів починають створювати блоки з відміткою про те, що вони вже готові перейти на нові правила. Далі вузли відстежують, коли набереться критична маса таких блоків, і за загальним правилом розраховують висоту блоку або позначку часу в майбутньому, коли вони переключаться на нові правила. Це повинно відбутися одночасно для всіх вузлів, тоді оновлення вважається активним. Нагадаємо, що існує два види оновлення протоколу – _softfork_, коли присутня зворотна сумісність, блоки старіших версій приймаються, якщо вони не суперечать новим правилам, і _hardfork_ – більш «жорстке» оновлення, в якому немає зворотної сумісності і всі вузли повинні перейти на нову версію, інакше їх блоки будуть відхилятися.

Для того, щоб краще розібратися з процесом оновлення протоколу, наведемо приклад, як це відбувається в Bitcoin. Давайте визначимо ключові характеристики кожного оновлення і розглянемо параметри, які є у кожного оновлення в таблиці 3.3.

Таблиця 3.3
<img width="50%" src="/resources/img/volume-2/3.5-Testnet-and-challenges-of-protocol-updating/Table-3.3.png" alt="Таблица 3.3"/> 

Оновлення може перебувати в одному з п'яти статусів (табл. 3.4).

Таблиця 3.4
<img width="50%" src="/resources/img/volume-2/3.5-Testnet-and-challenges-of-protocol-updating/Table-3.4.png" alt="Таблица 3.4"/> 

Проілюструємо процес детальніше за допомогою схеми (рис. 3.58). Спочатку оновленню привласнюється статус defined, визначаються значення _starttime_ і _timeout_. Після закінчення _starttime_, якщо минулий час не перевищує _timeout_, оновлення переходить в статус _started_. Якщо валідаторів, що публікують в мережу блоки із зазначенням нової версії, до закінчення _timeout_ буде більшість, то оновлення перейде в стан _locked_in_, після чого автоматично перейде до _active_. В іншому випадку, воно буде вважатися невдалим і перейде в стан _failed_.

<img width="40%" src="/resources/img/volume-2/3.5-Testnet-and-challenges-of-protocol-updating/Figure-3.58-The-life-cycle-of-updates.png" alt="Рисунок 3.58 – Життєвий цикл оновлення"/> 

### Найбільш значні оновлення протоколу Bitcoin

_Обмеження на розмір блоку в 1 МБ_. Рядок коду, в якому з'явилося обмеження розміру, був додан 15 липня 2010 года (версія 0.3.1 rc1). При цьому невідомо, коли було прийнято рішення це зробити і хто брав участь в обговоренні. Головною мотивацією обмеження було знизити ефективність DDoS-атак. Однак таке суворе обмеження призвело до несумісності з попередніми версіями, через що багато власників вузлів-валідаторів вкрай негативно до нього поставилися.

_Pay-to-Script Hash_. Додавання механізму Pay-to-Script Hash (BIP 16), який дозволяє відправляти транзакції на захищену адресу. Відповідна перша спроба впровадження провалилася, друга була зроблена 1 квітня 2012 року в версії 0.6.0rc2. Протягом наступних кількох місяців 45% валідаторів, що не оновилися, продовжували робити некоректні блоки, через що виникли проблеми з активацією.

_Segregated Witness_. Механізм Segregated Witness (SegWit), описаний в BIP 141, 143 і 147 [68–70], був покликаний оптимізувати транзакції та блоки шляхом винесення підписів в окрему структуру. Вперше SegWit був запропонований в кінці 2015 року, а випуск відбувся в жовтні 2016 (версія 0.13.1). Поріг для активації був встановлений на 95%. Однак, власники великих майнінг-пулів, включаючи F2Pool, HaoBTC, AntPool, заявили, що підтримають оновлення тільки в разі збільшення розміру блоку до 2 МБ.

### Адаптація нових версій Bitcoin серед вузлів

Незважаючи на те, що далеко не всі оновлення протоколу Bitcoin були успішними, вони грають украй важливу роль, впроваджуючи нову функціональність і виправляючи старі недоліки. Проте, статистика вказує на те, що власники деяких вузлів вкрай повільно реагують на появу нових версій, продовжуючи використовувати старі.

На рисунку 3.59 наведено графік, який показує історію поширення версій із квітня 2018 по квітень 2020. На графіку видно, як після поновлення кількість вузлів, що підтримують нову версію, починає поступово зростати [36].

Проте можна помітити, що навіть після появи версії 0.19.1 оновилися швидше вузли версії 0.18.1, в той час, як кількість вузлів, що працюють на більш старих версіях протоколу, продовжує скорочуватися так само поступово, як і раніше.

<img width="50%" src="/resources/img/volume-2/3.5-Testnet-and-challenges-of-protocol-updating/Figure-3.59-Bitcoin-Version-Distribution-Timeline.png" alt="Рисунок 3.59 – Графік поширення версій Bitcoin за часом"/> 

Головна причина, з якої користувачі не переходять на нову версію протоколу відразу ж після виходу, криється в побоюваннях щодо її безпеки і наявності вразливостей. Власники вузлів вирішують почекати протягом певного часу, щоб переконатися в тому, що в новій версії немає критичних вразливостей.

Утім, деякі до цих пір користуються вкрай застарілими версіями протоколу, аж до 0.10.2 (рис. 3.60) [28].

<img width="50%" src="/resources/img/volume-2/3.5-Testnet-and-challenges-of-protocol-updating/Figure-3.60-Bitcoin-node-version-ratio.png" alt="Рисунок 3.60 – Співвідношення версій вузлів у Bitcoin"/> 

### Ризик розколу спільноти

Будь-яка зміна в децентралізованій обліковій системі здійснюється тільки тоді, коли відкрита спільнота найбільш активних користувачів досягає згоди щодо цієї зміни. Проекти такого плану складно напряму монетизувати, тому дуже важлива наявність великої спільноти волонтерів, які підтримуватимуть роботу облікової системи.

Коли в спільноті виникають сперечання, вони зазвичай вирішуються думкою більшості. Але може статися так, що члени спільноти не домовляться. Протиріччя між сторонами збільшується і може закінчитися розколом спільноти (рис. 3.61). Прикладами можуть бути розділення таких проектів:

> * _Ripple і Stellar_
> * _Ethereum й Ethereum Classic_
> * _Bitcoin і Bitcoin Cash_
> * _Monero та Monero Classic_

<img width="45%" src="/resources/img/volume-2/3.5-Testnet-and-challenges-of-protocol-updating/Figure-3.61-Accounting-system-community-split.png" alt="Рисунок 3.61 – Розкол спільноти облікової системи"/> 

Виходить, що одна з найбільших переваг іноді може перетворитися на грізний недолік. Замість того, щоби працювати над проблемою спільними зусиллями та шукати шляхи оптимального оновлення протоколу, спільнота может загрузнути в сперечаннях та розділитися на дрібні групи, які починають просуватися до своїх мет.

**Найбільш поширені питання**

*— Чи можуть зловмисники використовувати testnet, щоб ввести користувача в оману та продати йому тестові монети, і як уникнути цього?*

Найчастіше зловмисники користуються неуважністю користувачів або їх бажанням отримати більш вигідні умови покупки монет, переказуючи їм монети на тестовий гаманець. Щоб не натрапити на таку хитрість, варто звертати увагу на те, на який гаманець ви збираєтеся отримати кошти, і в жодному разі не дозволяти сторонній людині створювати гаманець за вас. Також зловмисники можуть створити multisig-гаманець і потім відправити кошти на іншу адресу, якою ви не володієте.

## 3.6 Основні класи атак на Bitcoin

Поява Bitcoin викликала справжню цікавість серед фахівців з комп'ютерних наук. Дуже багато хто спочатку поставився до нього скептично, так як з одного боку здавалося, що це чергова спроба втягнути людей в сумнівне фінансове підприємство, з іншого – можна було подумати, що Bitcoin просто поєднує добре відомі стандарти криптографічних схем – алгоритми гешування та цифрового підпису, – не пропонуючи нічого нового. Для криптографів це було занадто просто, а для дослідників інтернет-безпеки – надто абстрактно. Однак після 2014 року ситуація різко змінилася. Багато хто усвідомив, що Bitcoin посів певну нішу в цифрових платежах і надалі залучає дедалі більше користувачів. У цей момент він став полігоном для тестування атак (що важливо – анонімним) і методів захисту децентралізованих систем. У цьому підрозділі ми розглянемо основні класи атак на Bitcoin і знову звернемо увагу на питання про те, чому Bitcoin влаштований саме таким, яким ми його бачимо.

Інженери з усього світу протягом декількох десятиліть шукали спосіб досягнення консенсусу щодо коректних транзакцій в умовах повноцінної децентралізації та анонімності учасників. Як бачимо, ця задача дійсно дуже складна, і саме творець Bitcoin вперше запропонував ефективне рішення. Власне, за це досягнення Satoshi Nakamoto був номінований на здобуття Нобелівської премії [71].

Суть рішення полягає в тому, щоб дозволити будь-кому брати участь у формуванні списку підтверджених транзакцій. Найпростіше цього досягти, якщо учасники обмінюватимуться думками з приводу транзакцій, які вони вважають правильними. Однак водночас потрібно надійно захиститися від підроблених повідомлень і перевантаження чесних вузлів мережі підробленими даними злочинних вузлів. Далі буде описано деталі проведення таких атак і принципи захисту від них.

### Flood-атака і механізм захисту

Сатоші Накамото запропонував оригінальне рішення: кожен потенційний валідатор для отримання права голосу повинен надати доказ виконаної роботи. Фактично, у цьому й полягає суть алгоритму досягнення консенсусу proof-of-work. Учасник повинен витратити деякі ресурси і запропонувати свій набір правильних транзакцій, що є засобом захисту від фальшивих думок.

Застосування proof-of-work для захисту від небажаних розсилок запропонував Адам Бек (Adam Back) ще в 1997 році, тоді це було рішенням для захисту користувачів email-протоколів від спаму. Пізніше такий підхід ліг в основу архітектури HashCash  – однієї з ранніх спроб А. Бека створити незалежну цифрову валюту. На момент 2019 року А. Бек залишається одним з провідних криптографів й ідеологів в Bitcoin-спільноті.

### Spam-атака та її наслідки

Під терміном spam зазвичай маються на увазі нав'язливі небажані повідомлення у великій кількості. Мета spam-атаки – вивести зі стану нормального функціонування один або декілька вузлів мережі. Організувати таку атаку можна, але є деякі особливості. Можна взяти програмний гаманець, внести в нього деякі зміни, так щоб він створював багато транзакцій, відправляючи монети зі своїх старих адрес на нові. Кожна транзакція при цьому повинна включати комісію і в залежності від цього пропонуємо розглянути три різні сценарії.

У першому випадку зловмисник включає дуже низьку або нульову комісію. Тоді його транзакції не будуть розходитися по мережі взагалі, тому що кожен вузол встановлює значення мінімально допустимої комісії. Якщо фактична комісія за транзакцію нижче цього порогового значення, то вузол відразу ж відхиляє транзакцію. Таким чином, зловмисник може відсилати такі транзакції тільки тим вузлам, з якими має пряме з'єднання, і то недовго. До того ж це буде малоефективно, тому що його транзакції будуть відразу відхилятися. А через деякий час у цих вузлів ще й спрацює фільтр, який розірве з'єднання з марними або з тими, що передають некоректні повідомлення, вузлами.

У другому випадку зловмисник включає середню комісію (вище порогового значення, але не достатню для швидкого підтвердження). Його транзакції поширюються всією мережею, і ця атака буде трохи ефективніше попередньої. Всі вузли мережі будуть верифікувати, зберігати і транслювати транзакції зловмисника. Таким чином можна зайняти значну частину пам'яті внизу черги непідтверджених транзакцій. Але вузли мають обмеження на максимальний розмір черги, і через час такі транзакції втечуть, якщо не будуть підтверджені. При цьому транзакції інших користувачів з достатньою комісією будуть підтверджуватися належним чином.

У третьому випадку зловмисник включає достатню комісію. Тоді його транзакції практично можуть заповнити всю пропускну здатність валюти. Важливо розуміти, що при цьому гаманці інших користувачів також почнуть завищувати комісію за транзакцію, щоб отримати обслуговування. Тому зловмиснику потрібно буде платити все більше і більше за кожну наступну транзакцію, щоб інші транзакції залишалися внизу черги. Витрати на таку flood-атаку будуть занадто великими.

### Тимчасове зупинення підтвердження нових транзакцій (DoS)

Чи можливо створити атаку на Bitcoin, яка зупинить роботу валідаторів, через що не підтверджуватимуться нові транзакції? Теоретично така атака можлива. Може виявитися так, що хтось, добре розбирається в програмуванні та безпеці ПЗ, виявить у вихідному коді повних вузлів критичні уразливості і захоче експлуатувати їх, наносячи шкоду мережі, замість того щоб запропонувати виправлення. Передбачити такий сценарій або гарантовано захиститися від нього практично неможливо.

Але ймовірність того, що таке станеться насправді, дуже мала. Оскільки Bitcoin існує вже досить довго, спроби знайти уразливості вже багато разів робилися і дослідники продовжують працювати в цьому напрямку. До того ж, перед прийняттям чергових оновлень протоколу, вихідний код проходить суворий аудит і тестування безліччю незалежних членів спільноти.

### Long-range атака

Принцип даної атаки простіше зрозуміти, якщо згадати вже відому _атаку 51%_. У традиційному уявленні це виглядало б так. Зловмисник відправляє 50 біткоінів на щойно створену адресу. Після цього він відправляє монети мерчанту, у якого обмінює їх на іншу валюту (наприклад, лайткоіни). Продавець чекає 6 підтверджень транзакції і відправляє іншу валюту на гаманець користувача.

Зловмисник паралельно працює над новим ланцюжком на базі блоку, який знаходиться перед блоком з транзакцією, в якій він відправляє 50 біткоінів мерчанту. Користувач формує нову транзакцію, в якій відправляє монети собі на іншу адресу. Маючи більше половини обчислювальної потужності мережі, користувач перенаправляє її на новий ланцюжок блоків. Незабаром його ланцюжок стає основним і всі вузли за правилами роботи протоколу Bitcoin переключаться на нього. В результаті успішної атаки користувач збереже свої біткоіни і придбає лайткоіни. У разі long-range атаки користувач починає свою ланцюжок _не 6 блоками раніше_, а _від genesis block_.

Маючи комп'ютер з обчислювальною потужністю в 1 TH/s, цілком можливо всього за 5 хвилин побудувати новий ланцюжок від genesis block до блоку з порядковим номером 300 000. До речі, станом на вересень 2019 року майнінгове обладнання для біткоін з обчислювальною потужністю в 14 TH/s можна було придбати за ціною 3000 USD. Мінімальне значення параметра mining difficulty дорівнює числу, яке представлено нижче в системі числення за основою 16.

**00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff**

Коли користувач будує свій ланцюжок, він може записати будь-який час, витрачений на створення блоку (може підробити мітку часу в заголовку блоку), і водночас складність майнінгу залишається мінімальною. Якщо подивитися на такий ланцюжок блоків у готовій формі, то він ніяк не відрізнятиметься від справжнього.

Коли нові вузли приєднуються до мережі, чи можуть вони відрізнити справжню історію блоків від підробленої? Навіть на середньому по потужності обладнанні не знадобиться багато часу, щоб створити такий ланцюжок. Чи встоїть Bitcoin перед атакою в тисячі таких ланцюжків?

Річ у тім, що для протоколу Bitcoin це не вразливість, оскільки розробники врахували можливість такої атаки. З цією метою правила прописувалися таким чином, що вони враховують не тільки довжину ланцюжка, а й параметр складності, який визначає виконану роботу на побудову основної ланцюжка. Тому вузли дуже швидко можуть відрізнити справжній ланцюжок від підробленого.

З цією загрозою також допомагає боротися механізм _checkpoints_ (докладно розглядався в першій частині цього навчального посібника). Однак потрібно пам'ятати, що чекпоінти не є trustless рішенням. Той, хто їх додає в ПЗ, може виявитися зловмисником, тому тут присутня довіра і до розробників ПЗ, і до автора checkpoints.

### Routing-атаки

Незважаючи на те, що вузлом Біткоіна можна управляти з будь-якої точки Землі, на сьогодні вузли у всьому світі поширені нерівномірно. За результатами досліджень (рис. 3.62), Біткоін-вузли переважно розміщуються в декількох провайдерах інтернет-послуг (ISP): 13 інтернет-провайдерів (що становить 0,026% всіх інтернет-провайдерів) уміщують 30% вузлів всієї мережі Біткоіна (зображено на лівому графіку). Більш того, велика частина трафіку, яким обмінюються вузли Біткоіна, перетинає кілька інтернет-провайдерів. Дослідження показують, що 60% всіх можливих з'єднань Біткоіна перетинають 3 інтернет-провайдери. Тобто, ці 3 інтернет-провайдери можуть бачити 60% всього трафіку Біткоіна (зображено на правому графіку).

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.62-Ratio-between-the-total-number-of-nodes-and-connections-between-them.png" alt="Рисунок 3.62 – Графік відношення загальної кількості вузлів і з'єднань між ними"/> 

Є трюк BGP – це routing-атака, у якій інтернет-провайдер некоректно пересилає трафік на основі підроблених повідомлень щодо маршрутизації в системі інтернет-маршрутизації. Атаки такого типу трапляються доволі часто (рис. 3.63), до сотні тисяч щомісяця. Деякі з них спрямовані на величезну кількість мережевих адрес: до 30 000 IP-префіксів (зображено на лівому графіку).

Такі атаки вже сьогодні впливають на мережу Bitcoin. Щомісяця щонайменше 100 біткоін-вузлів є жертвами трюків BGP, а в листопаді 2015 року захопленими виявилися 447 вузлів, що становить 8% вузлів Bitcoin (зображено на правому графіку).

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.63-Statistics-of-BGP-tricks-performed.png" alt="Рисунок 3.63 – Статистика відтворення трюків BGP"/> 

Зловмисник за допомогою routing-атаки може переслідувати дві мети. Перша полягає в тому, щоб розбити мережу Bitcoin на частини, не дозволяючи вузлам кожної з них синхронізуватися між собою. Таким чином зловмисник змушує вузли створювати альтернативні гілки, замість спільного ланцюжка блоків. Після припинення атаки всі блоки, які були сформовані меншою групою, будуть відкинуті. Транзакції меншої гілки виявляться непідтвердженими, а винагорода за формування блоків недійсною. Така атака виконується за таким сценарієм (рис. 3.64).

> Крок 0: вузли лівої і правої частини взаємодіють через з'єднання Bitcoin, позначені синіми лініями.

> Крок 1: зловмисник хоче розбити мережу на дві непересічні частини: одна з лівого боку і одна з правого.

> Крок 2: зловмисник захоплює трафік, що направляється на ліві вузли, виконуючи трюк BGP.

> Крок 3: незабаром після захоплення усього трафіку, відправлення справа наліво, проходитимуть через зловмисника (червоні лінії).

> Крок 4: зловмисник розриває ці сполуки, ефективно розбиваючи мережу на дві частини.

> Крок 5: під час атаки вузли в кожній частині продовжують зв'язок з вузлами тієї ж сторони.

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.64-Attack-routing-scheme.png" alt="Рисунок 3.64 – Схема routing-атаки"/> 

Друга мета, яку може переслідувати зловмисник, – це затримка доставки блоку вузлу жертви на 20 хвилин. При цьому зловмисник залишається абсолютно непоміченим. Протягом цього періоду жертва не знає про самий останній здобутий блок і відповідних транзакціях. Наслідки цієї атаки залежать від типу жертви. Якщо жертвою є мерчант, то він схильний до атаки подвійний витрати. Якщо жертва – валідатор, то він марно витрачає обчислювальну потужність свого обладнання. Нарешті, якщо жертвою є звичайний користувач, то він не може внести свій вклад до мережі, поширюючи останні актуальні блоки. Така атака виконується за наступним сценарієм (рис. 3.65).

> Крок 0: вузли А і В оголошують один і той же блок жертві С.

> Крок 1: вузол С запитує блок за допомогою GETDATA від вузла А. Зловмисник змінює вміст GETDATA так, щоб доставити старий блок з вузла А.

> Крок 2: старий блок доставлений.

> Крок 3: незадовго до 20 хвилин після запиту вузла С, зловмисник запускає його доставку, змінюючи одне повідомлення GETDATA, створене вузлом С.

> Крок 4: блок поставляється за 20 хвилин. Жертва не відключається від вузла А.

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.65-Block-Delay-Attack-Scheme.png" alt="Рисунок 3.65 – Схема атаки затримки блоку"/> 

### Інші технічні та соціальні атаки

_Аналіз мережевого трафіку (packet sniffing)_. Той, хто може бачити весь ваш інтернет-трафік, може визначити, коли ви відправляєте транзакцію, яку ви не отримали від іншого вузла (що передбачає, що ви її створили). Інтернет-провайдери або національні фаєрволи можуть фільтрувати трафік протоколу Bitcoin, тим самим приносячи деякі незручності звичайним користувачам. Але питання з фільтрацією мережевих пакетів може бути вирішене. Наприклад, Bitcoin Core має хорошу інтеграцію з Tor (децентралізована мережа анонімізування трафіку).

Атака _block withholding (selfish mining)_ передбачає наявність часової затримки для щойно сформованих блоків перед їх відправленням іншим вузлам. Зловмисником є валідатор із досить великою обчислювальною потужністю, він створює нові блоки ланцюжка, але відразу не повідомляє їх іншим вузлам мережі. Публікація цих блоків виконується пізніше, по одному чи групами, через що блоки інших валідаторів мережа відкидає як приналежні до іншого, коротшого ланцюжка (_orphan blocks_). У цій атаці жертвами стають інші валідатори, де, у підсумку, вони або беруть меншу участь у досягненні консенсусу, або взагалі не можуть створити жодного актуального блоку.

Є й інші різнопланові атаки, як-от сплановані форки, усілякі заборони на використання валют певних держав під час обміну біткоінів, блокування мережевого трафіку повного вузла мережі з боку інтернет-провайдерів, а також заборони на виробництво спеціалізованого обладнання чи його використання.

До найбільш специфічних атак можна віднести фізичне викрадення важливих членів спільноти та внесення шкідливих елементів ув апаратне чи програмне забезпечення.

### Bitcoin alert system і відмова від неї

Сигнальна система (alert system) в Bitcoin дозволяє транслювати клієнтам мережі повідомлення про випадки виявлення проблем і потенційних загроз (рис. 3.66).

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.66-An-example-of-Bitcoin-alert-system-message.png" alt="Рисунок 3.66 – Приклад повідомлення сигнальної системи в Bitcoin"/> 

Як заявив сам Сатоші на форумі bitcointalk.org ще на етапі розробки сигнальної системи, особистий ключ, яким він підписує повідомлення, є тільки у нього (рис. 3.67).

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.67-Message-on-the-forum-about-the-alarm-system.png" alt="Рисунок 3.67 – Повідомлення на форумі про сигнальну систему"/> 

Інакше кажучи, дана надбудова централізована. Однак Сатоші не бачив у цьому великої проблеми, оскільки вона з надлишком перекривалася соціальним консенсусом. Будь-який користувач міг перевірити дані на форумі та інших джерелах, якщо він сумнівався в достовірності проблеми (рис. 3.68).

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.68-Message-about-the-possibility-of-checking-data-by-each-user.png" alt="Рисунок 3.68 – Повідомлення щодо можливості перевірки даних кожним користувачем"/> 

Сатоші стверджував, що не може здійснювати ніяких дій віддалено. А дане нововведення покликане забезпечити збереження монет користувачів. Якщо під час роботи протоколу відбувається щось підозріле, що може загрожувати стану балансів користувачів, то кожен з них отримає про це повідомлення. Ігноруючи повідомлення про потенційну небезпеку, власник монет може їх втратити (рис. 3.69).

<img width="50%" src="/resources/img/volume-2/3.6-Basic-classes-of-attacks-on-Bitcoin/Figure-3.69-An-explanation-of-the-need-for-a-signal-system.png" alt="Рисунок 3.69 – Пояснення необхідності сигнальної системи"/> 

Пізніше Сатоші передав свій секретний ключ кільком довіреним розробникам Bitcoin Core. Учасники спільноти почали виказувати непокоєння, що якщо ключем заволодіє зловмисник, то він зможе розповсюджувати повідомлення, які здатні викликати паніку. До того ж, ставались інциденти, коли за допомогою цих ключів вчинялися спроби впливати на правила мережі, на комісії та на параметр складності.

Такий стан речей суперечив моделі безпеки Bitcoin. І вже в оновленні Bitcoin Core 0.13.0, в 2016 році, сигнальна система була повністю усунута.

### Деякі з виявлених і вирішених проблем протоколу

_BIP-0050_. У травні 2013 року був запропонований BIP 50 для вирішення однієї з таких проблем. У мережі хтось створював і розповсюджував блоки, які мали більшу кількість сумарних входів транзакцій, ніж попередній. 0.8-Bitcoin-вузли змогли впоратися з цим, але деякі з вузлів до версії 0.8 – ні, викликавши несподіване розгалуження ланцюжка блоків. У несумісному ланцюжку pre-0.8 тоді було близько 60% _hashrate_, чого не вистачало для автоматичного розв'язання розколу.

Щоб якомога швидше відновити канонічний ланцюг, BTCGuild і Slush знизили свої 0.8-біткоіни-вузли до 0.7, за рахунок чого їх пули також відхиляли блок, що містить більшу кількість входів. За цей час була проведена одна велика подвійна витрата. Але це було зроблено заради експерименту, а не зі злочинних міркувань.

Завдяки тому, що розкол мережі був швидко помічений, важких наслідків вдалося уникнути. Як наслідок, з'явилася оновлена ​​версія протоколу 0.8.1, яка містила такі правила:

* відхиляти блоки, які можуть викликати більше 10 000 блокувань;
* обмежити максимальний розмір створюваного блоку до 500 000 байт;
* створення оновлення безпеки для старіших версій, яке реалізує ті самі правила, але з обмеженням кількості максимальних блокувань до 120 000;
* створення веб-сторінки на bitcoin.org, яка змушує користувачів оновитися до версії 0.8.1. На сторінці також зазначено, як встановити DB_CONFIG на 120 000 блокувань.
* протягом наступних 2 місяців відправлялися серії попереджень користувачам старших версій про необхідність оновлення.

_CVE-2013-4166_. Ще одна уразливість, яка була виявлена ​​в мережі Bitcoin, полягає в такому. Зловмисник може відправити низку повідомлень, які спричинять цілочисельну помилку ділення на нуль в коді обробки Bloom Filter, унаслідок чого в Bitcoin-Qt або в bitcoind відбувається відмова в обслуговуванні. Bloom Filters були запропоновані у версії 0.8, отже, версії від 0.8.0 до 0.8.3 схильні до даної атаки відмови в обслуговуванні.

Після виявлення даної уразливості почав використовуватися алгоритм з постійним часом для перевірки спроб вгадування пароля RPC.

_CVE-2014-0160_. Ця уразливість пов'язана не безпосередньо з мережею Bitcoin, а з бібліотекою OpenSSL. Вона може дозволити віддаленому зловмиснику отримувати конфіденційні дані, включаючи облікові дані користувача і секретні ключі, шляхом неправильної обробки пам'яті в цій бібліотеці.

Для усунення цієї уразливості протокол OpenSSL був оновлений до версії 1.0.1g. Усі ключі, що генеруються в попередніх версіях, вважаються скомпрометованими, і їх має бути перегенеровано з використанням нової версії протоколу.

_CVE-2016-10724_. Bitcoin Core до версії 0.13.0 був вразливий до DoS-атак, викликаним системою віддаленого мережевого сповіщення, коли зловмисник підписує повідомлення з певним особистим ключем, відомим учасникам-жертвам. Це впливає на клони вихідного коду, такі як Bitcoin Knots до версії 0.13.0.knots20160814 та деякі альткоіни.

**Поширені міфи**

*Будь-який програміст може переконатися у відсутності вразливостей в Bitcoin.*

Теоретично це можливо, але в дійсності аналіз такої кількості вихідного коду – робота для великої професійної команди, причому на досить тривалий час.

**Найбільш поширені питання**

*– Якщо в користувача багато біткоінів у гаманці, і він готовий їх витратити, як йому технічно заспамити транзакціями mempool Bitcoin, щоб підвищити вартість транзакції?*

Дійсно, якщо у користувача багато біткоінів, він може витратити їх на проведення стрес-тесту. Для цього йому потрібно модифікувати ПЗ свого повного вузла. Досить простий варіант – це додавання циклу з генерацією нової адреси і відправкою на неї випадкової кількості монет (наприклад 0,5–2 BTC). Цей цикл краще запустити в окремому потоці та повторювати 2–3 рази в секунду. При цьому розраховувати оптимальну комісію, щоб ці транзакції потрапляли в середину mempool, але не підтверджувалися в першому ж блоці. Інакше кажучи, це дозволить не переплачувати комісійні та ефективно навантажувати всі вузли в мережі. Це оптимальний спосіб заповнити mempool настільки, що користувачам, які хочуть здійснити термінові платежі, доведеться включати дуже велику комісію, щоб їх транзакції потрапили в початок черги і з достатньою ймовірністю були включені в наступний блок.

*– Кажуть, що майбутньою загрозою Bitcoin будуть квантові комп'ютери. Що це означає?*

Під цим мається на увазі атака на алгоритм цифрового підпису, який використовує Bitcoin зараз. На цю мить немає квантових комп’ютерів, здатних реалізувати таку атаку (і все ще незрозуміло, чи будуть вони створені). Навіть якщо вони з’являться, то криптографію в Bitcoin буде оновлено і вона буде більш стійкою до квантових обчислень. Уже є алгоритми постквантової криптографії.

*– Чи може виробник майнінгових чіпів, взяти контроль над потужностями через вбудовану лазівку і провести атаку 51%?*

Потенційно можливо, хоча це доволі складно та, найімовірніше, економічно необґрунтовано для виробника. Утім, виявити закладку в майнінгових чіпах досить складно. Тому краще, коли є безліч незалежних виробників чіпів і жоден із них не перевершує решту, разом узяту, за обсягами виробництва. Крім того, багато альткоінів використовує ASIC-resistant геш-функції, для яких створення апаратних майнерів украй складне, – майнінг виконується на відеокартах або процесорах загального призначення.

*– Які інструменти застосовуються для атак на Bitcoin?*

Найчастіше це спеціалізоване ПЗ, створене на базі вихідного коду повного вузла мережі.

*– Що буде з Bitcoin, якщо інтернет між континентами пропаде, а потім з'явиться знову?*

На одному континенті буде одна історія транзакцій, а на другому інша. Коли з'єднання відновиться, то залишиться тільки один ланцюжок – той, на який було витрачено більше обчислювальних потужностей. Для людей з континенту з меншим ланцюжком, транзакції, які не конфліктують з основною ланцюжком, знову стануть не підтвердженими, але вони будуть пізніше підтверджені в наступних блоках.

*– Де гарантія, що немає backdoor в коді Bitcoin?*

Спеціалісти дотримуються думки, що спеціально вбудованих закладок немає, оскільки вихідний код від самого початку перебуває у відкритому доступі. Але можуть бути ненавмисні помилки, через які протокол може виявитися вразливим. Імовірність цього мала, оскільки проводиться ретельне тестування та опрацьовуються зловмисні сценарії поведінки зовнішніх вузлів. З іншого боку, додатково переконатися в цьому можна після самостійного аудиту вихідного коду або звернення за допомогою до довіреної сторони.

[BITCOIN ЯК ПЛАТФОРМА](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-2/ua/4-bitcoin-as-a-platform.md)
