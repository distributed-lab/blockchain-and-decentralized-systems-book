# 1 ДЕЦЕНТРАЛІЗАЦІЯ ЯК ПАРАДИГМА В ІНФОРМАЦІЙНИХ СИСТЕМАХ

## 1.1 Пірингові мережі та протокол BitTorrent

Протокол BitTorrent одним з перших показав, у який спосіб можна децентралізувати файлообмінні сервіси. Він працював набагато швидше за централізовані рішення, у яких швидкість завантаження обмежувалася продуктивністю та підключенням серверу, і водночас був стійкіший до цензури. Саме тому протокол відіграв одну з ключових ролей у галузі децентралізованих технологій, показавши, у який спосіб можна розділити процес зберігання та передачі даних у системі. Ми розглянемо основні концепції, що лягли в основу протоколу, те, які властивості системи вони можуть забезпечити, і те, як ця технологія може розвиватися та застосовуватися у системах наступного покоління.

### Традиційна клієнт-серверна архітектура

Щоб зрозуміти, як працює BitTorrent, важливо розглянути роботу традиційних (централізованих) файлообмінних систем і те, чому такий підхід виявляється здебільшого неефективним. Спочатку варто ввести три базових поняття: клієнт, сервер та клієнт-серверна архітектура. *Клієнт (client)* – частина аппаратного та/або програмного забезпечення (далі – ПЗ), що використовує послуги серверу. *Сервер (server)* – це апаратне та/або програмне забезпечення, що надає дані другому ПЗ та/або апаратним пристроям (тобто клієнту).

Що ж мається на увазі під словами «клієнт-серверна архітектура»? Якщо описати функціонування такої архітектури у простих словах, то є деякі сервери, що зберігають великий обсяг даних. За потреби клієнт звертається до одного з таких серверів із запитом на отримання порції даних. Сервер розглядає запит клієнта та надає (або не надає) доступ до контенту, який шукає клієнт (рис. 1.1).

<p align="center">
<img src="/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.1-Traditional-client-server-architecture.png" alt="Рисунок 1.1 – Традиційна клієнт-серверна архітектура" width="70%"/>
</p>

Дуже важливо розуміти, що в централізованих файлообмінних системах ролі клієнта та сервера строго розмежовані та здебільшого не можуть перетинатися. Водночас є низка обмежень та недоліків таких систем.

> **Недоліки централізованих систем з клієнт-серверною архітектурою**
> * _Схильність до цензурування_
> * _Єдина точка відмови_
> * _Обмеження пропускної здатності з боку серверу_
> * _Проблематичне відновлення втраченого набору даних_

Найбільший недолік – цензурування контенту з боку централізованого органу (органу влади чи будь-якої іншої зацікавленої сторони). Наприклад, у багатьох країнах діє сувора цензура на політичні та соціальні медіа; ви можете не отримати доступ до певного контенту (фільму, ролику тощо), якщо хтось, хто має достатній рівень політичного впливу, вирішив, що вам він не потрібен [1].

Друга й не менш гостра проблема – зберігання великої кількості даних в єдиному центрі, імовірна атака на який може спричинити якщо не втрату всіх розміщених на сервері даних, то принаймні блокування їх на невизначений проміжок часу. Багато сервісів (наприклад, Google) використовують попереднє резервування та дублювання даних, що зберігаються, на великій кількості носіїв (які, до того ж, рознесені територіально) [2]. Подібний підхід дозволяє убезпечити збережені дані від знищення. Однак відзначмо, що такі заходи по кишені далеко не кожному сервісу, і водночас потрібно вирішити завдання синхронізації даних між серверами в реальному часі.

Третє обмеження централізованих сервісів – швидкість завантаження даних, яка може залежати від низки параметрів, як-от типу протоколу передачі, пропускної здатності серверу, кількості активних підключень інших клієнтів та інших.

Позаяк дані сервер часто зберігає в єдиній копії в одному місці, це може суттєво знизити загальну продуктивність системи, якщо безліч клієнтів звертаються за тим самим набором даних.

Також варто врахувати, що деякий контент може зберігатися в єдиному екземплярі та за відмови серверу (який раніше зберігав потрібний контент) і втрати контенту навіть Google не допоможе вам його повернути (рис. 1.2).

<p align="center">
<img src="/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.2-Сontent-becomes-unavailable-when-it-is-lost-by-the-server.png" alt="Рисунок 1.2 – Проблема недоступності контенту за його втрати на сервері" width="70%"/>
<p>

### Принципи побудови однорангової файлообмінної мережі

Архітектура однорангових (пірингових) файлообмінних систем кардинально відрізняється від традиційних. Кожен вузол такої мережі – одночасно й сервер, і клієнт. Кожний учасник мережі може займатися як роздаванням файлів іншим вузлам, так й отриманням файлів від них (рис. 1.3).

<p align="center">
<img src="/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.3-Principle-of-operation-of-peer-to-peer-file-sharing-system.png" alt="Рисунок 1.3 – Принцип функціонування однорангової файлообмінної системи" width="70%"/>
<p>

Коли ПЗ вузла знаходить учасника мережі з потрібним контентом, воно завантажує дані безпосередньо з цього джерела. Коли ви запитуєте порцію контенту, ви – клієнт. Коли ж одному з учасників необхідно буде отримати доступ до даних, які зберігаєте ви, ваше ПЗ виконає роль серверу та поділиться збережуваними даними.

### Історія розвитку BitTorrent

Протокол BitTorrent створив Брем Коен (Bram Cohen) в 2001 році [3]. Він спромігся розв'язати одне з найважливіших завдань, яке постало перед суспільством з появою Інтернету: надійна передача великих масивів даних в середовищі з низькою пропускною здатністю та періодичною відмовою в обслуговуванні каналів передачі, що використовуються.

Компанія BitTorrent була заснована у 2004 році. Проект вельми зацікавив фахівців у багатьох сферах, особливо тих, хто здійснював нелегальне розповсюдження медіапродукції. Вони перетворили протокол BitTorrent в другий Napster (сервіс обміну mp3-файлами). На превеликий жаль, компанія BitTorrent не досягла такого великого успіху, як її технологія. Кілька спроб перетворення в медіакомпанію не дали бажаних результатів. Про одне можна сказати доволі точно: протокол BitTorrent став проривною технологією, яка показала, як може працювати децентралізована файлообмінна система.

У 2019 році протоколом BitTorrent користуються понад 170 мільйонів людей: Facebook [4] і Twitter [5] використовують BitTorrent для розгортання серверів, Голландський університет – для оновлення робочих станцій [6]. Широке застосування протоколу BitTorrent зумовлено тим, що він дозволяє забезпечити надійну передачу даних навіть у мережах із переривистим з'єднанням і низькою пропускною здатністю.

### Як працює BitTorrent

Протокол BitTorrent – це відкритий протокол обміну файлами в однорангових системах, який передбачає p2p передачу даних між учасниками системи та відсутність центральної серверної сторони. 

Для того, щоб отримати доступ до певного фрагменту даних, учасник мережі звертається до *трекера* – сервера, який відстежує підключені до мережі комп'ютери. Його завданням є надання вузлам IP-адрес активних учасників системи з потрібними порціями контенту. Відзначмо, що учасники ніколи не скачують дані з самого трекера: він займається тільки наданням необхідних IP-адрес активних вузлів.

Після отримання списку активних вузлів користувач запитує в них необхідні фрагменти даних. Відзначмо, що учасник завантажує дані невеликими порціями, водночас перевіряючи їх цілісність. Це дозволяє навіть за відключення одного з вузлів зберегти окремі фрагменти потрібного контенту та завантажити відсутні фрагменти або з інших джерел, або після відновлення з'єднання. У такий спосіб потрібний контент можна отримати маленькими частинами і з різних джерел (рис. 1.4).

<p align="center">
<img src="/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.4-Obtaining-data-fragments-from-system-participants.png" alt="Рисунок 1.4 – Отримання фрагментів даних від учасників системи" width="60%"/>
<p>

Для досягнення більшого рівня децентралізації в 2013 році до протоколу BitTorrent було додано механізм, який реалізує DHT (Distributed Hash Table), принцип функціонування якого ми детальніше розглянемо в підрозділі 1.2. Якщо коротко, то це вдосконалення дозволило уникнути використання централізованих трекерів для пошуку вузлів, що містять контент, і зробило взаємодію вузлів більш незалежною та децентралізованою.

Утім, більшості трекерів це оновлення не припало до вподоби, позаяк воно дозволяє усунути всіх посередників у децентралізованій файлообмінній мережі. Для цього трекери підтримали додавання спеціального прапора до інформаційної частини торент-файлу. Якщо користувач вирішив прибрати цей прапор і використовувати DHT, ідентифікатор торент-файлу змінювався повністю. Це розділило користувачів, оскільки вузли, які використовують DHT, не могли отримувати необхідні файли від вузлів, які використовували трекери. Через те, що набагато простіше було знайти торент-файли, що використовують трекери (адже на цьому заробляють власники медіасайтів), то й на сьогодні в пріоритеті – використання централізованих трекерів.

Згадаймо, що протокол BitTorrent передбачає заохочення активних учасників мережі. Чим активніше вузол мережі бере участь у розповсюдженні файлів, тим більшою буде його сумарна швидкість завантаження. Користувачі, які практично не беруть участь у розповсюдженні файлів (скачують потрібний контент і йдуть з роздачі), навпаки, мають нижчу швидкість завантаження контенту. Також протокол вимагає резервувати частину пропускної здатності каналу, яка не дозволяє конкретному вузлу займатися тільки завантаженням контенту, а використовується для розповсюдження даних.

Ще одна особливість, передбачена в протоколі BitTorrent, – пріоритетне розповсюдження рідкісних фрагментів. Наприклад, якщо одному вузлу, який містить увесь набір даних, приходять запити на отримання цього набору, він рівномірно розподіляє всі фрагменти даних між учасниками, а не передає кожному з них усю послідовність спочатку (рис. 1.5). Ця особливість позитивно впливає як на швидкість розповсюдження (вузли, які отримали фрагмент, далі самі можуть його розповсюджувати), так і на розподіленість зберігання всіх фрагментів (щоб не вийшло, що в один момент часу багато вузлів зберігають тільки перший з усіх фрагментів, і тільки один вузол зберігає всі інші фрагменти).

<p align="center">
<img src="/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.5-Arbitrary-transmission-order-of-file-fragments.png" alt="Рисунок 1.5 – Випадковий порядок передачі фрагментів файлу" width="60%"/>
<p>

### Розділення даних на фрагменти

Багато хто з читачів знайомий із торент-файлами (.torrent), проте далеко не кожен знає, як вони формуються та що в собі містять. Раніше ми вже визначили, що завантаження контенту відбувається невеликими порціями (фрагментами). Настав час розглянути, як формуються ці фрагменти та де взяти посилання для їх завантаження.

Під час створення торент-файлу вихідні дані поділяються на невеликі порції (розмір може варіюватися від 128 KB до 2–4 MB). Від кожного отриманого фрагмента береться геш-значення SHA-1, і саме воно поміщується в торент-файл (рис. 1.6) [7].

<p align="center">
<img src="/resources/img/volume-2/1.1-Peer-to-peer-networks-and-BitTorrent-protocol/Figure-1.6-Creation-of-a-torrent-file.png" alt="Рисунок 1.6 – Створення торент-файлу" width="70%"/>
<p>

> **_Зауваження._** *під час роздавання великого обсягу даних розмір фрагмента може досягати 32–64 MB.*

Також в торент-файл поміщується посилання на трекер (або кілька трекерів) для того, щоб користувач, який отримав вихідний торент-файл, знав, який із трекерів може надати йому адреси зберігачів контенту. Учасник мережі, який першим опублікував певні дані в мережі та створив торент-файл, називається *initial seeder*.

Коли один із учасників, маючи торент-файл, бажає отримати відповідний йому контент, він звертається до зазначеного у файлі трекеру та запитує адреси, вузли яких зберігають зазначені в торент-файлі фрагменти. Після того, як трекер повертає клієнту список адрес, вузол розсилає запити з геш-значеннями фрагментів на отримані адреси та чекає, поки хтось надішле йому потрібні фрагменти. Під час завантаження фрагментів із мережі, вузол може досить швидко й просто перевірити, чи потрібні фрагменти були завантажені, оскільки у нього є відповідні геш-значення. Такий підхід дозволяє запобігти виникненню помилок під час завантаження файлів і перевірити цілісність усього отриманого контенту за допомогою перевірки цілісності його фрагментів.

### Обмеження протоколу

Відзначмо, що поряд з незаперечними перевагами протокол BitTorrent має низку обмежень.

> * _Залежність швидкості завантаження файлу від кількості активних вузлів, які містять його копії_
> * _Загрози, пов'язані з наявністю шкідливого коду в завантажуваних фрагментах_
> * _Велика кількість вузлів використовують протокол тільки для скачування, не підтримуючи водночас мережу (не займаються розповсюдженням файлів)_
> * _Неможливість вибірково обмежити розповсюдження контенту (порушення авторських прав)_

Швидкість завантаження контенту залежить від кількості активних вузлів системи, які його зберігають. Якщо контент популярний, то, найімовірніше, його зберігає велика кількість учасників мережі та отримати доступ до нього буде непроблематично. Однак якщо на контент немає значного попиту (наприклад, підручник із ловлі равликів) і його зберігає тільки один вузол мережі, то будь-який збій зв'язку або відключення цього вузла призведе до неможливості отримати доступ до необхідного контенту.

Коли користувач отримує торент-файл, у нього є тільки набір геш-значень і дані про те, звідки можна скачати необхідний контент. Він може тільки здогадуватися про те, чи буде скачуваний контент відповідати очікуваному. І добре, якщо разом із контентом воднораз виходить скачати лише декілька браузерів, а не шматочок шкідливого коду.

Ще одна важлива проблема – відсутність мотивування вузлів підтримувати мережу. Дуже часто вузол завантажує потрібну порцію контенту та не залишається на роздаванні. Протокол BitTorrent, звичайно передбачає механізм заохочення активних вузлів, що розповсюджують дані (збільшення пропускної здатності для отримання контенту), однак він виявився недостатньо ефективним, тому що не вимірюється грошима. Цю проблему частково вирішено в протоколі IPFS, який ми детальніше розглянемо в 1.5.

Остання, але не менш важлива проблема, яка стосується здебільшого правовласників, – порушення авторського права через передавання піратських копій контенту. Згідно зі статистикою тільки через піратство в музичній галузі правовласники втрачають більш ніж 10 мільярдів доларів США на рік, більш ніж 40% ПЗ користувачів також піратське та понад 75% всіх комп'ютерів у світі мають щонайменше одну нелегально встановлену програму [8].

**Поширені міфи** 

*Не можна одночасно використовувати трекери та DHT.*

Фактично, кожен користувач може одночасно використовувати обидва підходи для одночасного завантаження різних файлів. Обмеження накладається тільки на використання двох підходів для завантаження однакового файлу, оскільки для цих випадків геш-значення торент-файлів будуть відрізнятися. Відзначмо, що більшість трекерів перевіряє наявність прапора та додає його, якщо він відсутній, коли торент з'являється на їхніх сайтах.

*Використання DHT значно знижує продуктивність BitTorrent.*

Це один з найбільш поширених міфів. До того ж, багато хто з читачів, які використовували і трекери, і DHT, скажуть, що це не міф і продуктивність системи дійсно знижується. Однак це жодним чином не пов'язане з самою технологією. Використання DHT може збільшити продуктивність, але цьому перешкоджає дуже багато обмежень: обсяг оперативної пам'яті, виділеної для побудови DHT, кількість вузлів, що роздають контент, загальний обсяг контенту, вплив централізованих трекерів тощо.

**Найбільш поширені питання**

*–  Що таке seeding в BitTorrent?*

_Seeding_ являє собою процес роздавання фрагментів файлів іншим вузлам мережі. Кожен клієнт під час завантаження файлу отримує запити від інших вузлів, що завантажують той самий файл, та передає їм тi фрагменти, що вже є у нього, але немає в них. У такий спосіб збільшується ефективність роботи мережі. До того ж, кожен учасник для підтримання мережі може роздавати файли й після завершення їх завантаження, щоб інші вузли могли швидше їх завантажувати. Процес, що виконує цей вузол, i називається seeding.

*– Хто такі leechers і peers?*

_Leecher_ – це користувач, який скачує більший обсяг даних, ніж роздає в мережі. На цю мить у самому протоколі немає покарання за таку поведінку, хоча частина спільноти виступає за те, щоби його впровадити. _Peer_ – це користувач, який підключається до учасника, що роздає файл. Після того, як peer повністю завантажує файл, він стає seeder.

*– Чи є опції щодо забезпечення анонімності користувачів у мережі BitTorrent?*

Протокол BitTorrent не забезпечує анонімність своїх користувачів. Будь-який користувач може побачити IP-адреси всіх вузлів у списку свого торент-клієнта. Завдяки цьому в деяких країнах організації, що займаються захистом авторських прав, дізнаються через список вузлів IP-адресу користувача, який незаконно поширює данi, обмежені авторським правом. Згодом вони повідомляють про неправомірні дії інтернет-провайдерам користувача й іншим сторонам, які відповідають за дотримання авторських прав.

*– Чи можуть інтернет-провайдери обмежити передачу трафіку за протоколом BitTorrent і як цьому перешкодити?*

Оскільки трафик за протоколом BitTorrent складає значну частину від загального навантаження, деякі інтернет-провайдерів обмежують (сповільнюють) передачу даних за цим протоколом. Для вирішення цієї проблеми в багатьох торент-клієнтах використовується шифрування заголовків повідомлень (protocol header encryption) або шифрування всього потоку повідомлень (message stream encryption). Ці методи приховують структурнi елементи даних під час передавання та допомагають перешкоджати виявленню трафіку BitTorrent, у такий спосіб перешкоджаючи спробам регулювання з боку провайдерів.

## 1.2 Принцип роботи та застосування DHT

Одним з наріжних протоколів децентралізованих мереж без перебільшення можна назвати DHT (Distributed Hash Table) [9]. Протокол був винайдений в кінці 90-х років для вирішення завдання індексації та пошуку серед великої кількості даних. Незважаючи на те, що самі дані (файли та ін.) можуть зберігатися на різних серверах, таблиця посилань на дані потенційно може бути нескінченно великою, що виключає варіант її зберігання в одному місці. Крім того, важливим завданням був захист від атак на центральний вузол-довідник. Якраз для вирішення цих двох проблем був розроблений DHT.

### Завдання, які вирішує DHT

DHT вирішує проблему пошуку контенту (інформації) по його геш-значенням (InfoHash) в децентралізованій мережі.

> **Умови, в яких працює протокол DHT**
> * _Учасники не ідентифікують один одного_
> * _Учасників може бути необмежена кількість_
> * _Центральний сервер відсутній_
> * _Контент зберігається у самих учасників (і заздалегідь невідомо, у яких саме)_
> * _Кожен з учасників може підтримувати зв'язок тільки з обмеженою кількістю інших учасників_

Для учасника, який шукає дані, завдання полягає в тому, щоб отримати мережеву адресу іншого учасника, що зберігає порцію контенту з певним InfoHash.

Середовище, в якому контент зберігається і в якому виконується пошук, стає повністю розподіленим: безліч комп'ютерів, які запустили певну версію протоколу DHT і ведуть незалежний обмін повідомленнями.

### Як працює DHT?

Відповідно до протоколу, кожен учасник в системі має глобальний унікальний ідентифікатор. Цей ідентифікатор являє собою число такої ж розмірності, як InfoHash (зазвичай 160 біт і більше). Учасник сам обирає ідентифікатор, оскільки центр прийняття рішень відсутній, а всі учасники незалежні. Щоб почати роботу, новому учаснику потрібно мати програму з реалізацією протоколу й мережеву адресу як мінімум ще одного активного учасника (необхідно для підключення до існуючої мережі).

Відповідно до правил протоколу кожен учасник виділяє пам'ять (за замовчуванням 5-50 МБ) для власної таблиці. У цій таблиці він зберігає відповідності між InfoHash і контентом, а також між ідентифікаторами учасників і їх мережевими адресами (рис. 1.7).

<p align="center">
<img src="/resources/img/volume-2/1.2-Operation-principle-and-application-of-DHT/Figure-1.7-Network-node-s-table.png" alt="Рисунок 1.7 – Таблиця вузла мережі" width="60%"/>
<p>

Усі записи в цій таблиці відсортовані за першим стовпчиком (ідентифікатор або InfoHash), і вона постійно оновлюється за такими правилами:
> 1. Якщо учасник в ході спілкування з іншими дізнається про нового для нього учасника (ідентифікатор + мережева адреса), то цей запис вноситься в таблицю.
> 2. Якщо учасник викачує або генерує контент, то від цього контенту обчислюється геш-значення (InfoHash), і ця відповідність також вноситься в таблицю.
> 3. Якщо таблиця за розміром наближається до межі виділеної пам'яті, то з неї видаляються ті рядки, ідентифікатор яких найбільше відрізняється від ідентифікатора самого учасника.

Таким чином, здійснюється видалення тільки найбільш верхніх і нижніх рядків таблиці (рис. 1.8). Через певний проміжок часу після початку роботи учасник формує власну таблицю. У ній будуть зберігатися ідентифікатори, максимально наближені до його власного ідентифікатора, позаяк вони відсортовані в порядку збільшення. Відповідно, кожен учасник зберігає список ідентифікаторів інших учасників і посилання на контент, які максимально наближені до його власного ідентифікатору.

<p align="center">
<img src="/resources/img/volume-2/1.2-Operation-principle-and-application-of-DHT/Figure-1.8-Table-row-deletion-scheme.png" alt="Рисунок 1.8 – Схема видалення рядків таблиці" width="60%"/>
<p>

Активному вузлу мережі для пошуку необхідного контенту потрібно знати тільки відповідний InfoHash. Процедура пошуку учасником конкретного контенту розпочинається зі звернення до власної таблиці. З таблиці вибирається рядок, який за ідентифікатором максимально наближений до InfoHash. У цьому рядку буде зберігатися мережева адреса того учасника, який за ідентифікатором найближче знаходиться до контенту, що шукається. Тоді учасник, що шукає цей контент, відкриває з'єднання за цією адресою та надсилає запит на пошук за InfoHash. У відповідь на запит він отримує або потрібну порцію контенту, або мережеву адресу учасника, який ще більше наближений до цього контенту (рис. 1.9). Запити будуть повторюватися, поки контент, що шукається не буде отриманий. У разі невдачі запити можна повторити через певний проміжок часу.

<p align="center">
<img src="/resources/img/volume-2/1.2-Operation-principle-and-application-of-DHT/Figure-1.9-Search-request-propagation-scheme.png" alt="Рисунок 1.9 – Схема поширення пошукових запитів" width="60%"/>
<p>

Виходить, що кожен учасник локально зберігає і оновлює таку таблицю відповідності, як показано на рисунку 1.9. Швидкий пошук і вставка нових рядків можлива завдяки відсортованому списку. Відзначимо, що у учасників з близькими ідентифікаторами частина таблиці може збігатися (рис. 1.10).

<p align="center">
<img src="/resources/img/volume-2/1.2-Operation-principle-and-application-of-DHT/Figure-1.10-State-of-tables-of-participants-with-close-identifiers.png" alt="Рисунок 1.10 – Стан таблиць учасників з близькими за значенням ідентифікаторами" width="70%"/>
<p>

Для підвищення надійності й швидкості пошуку запити виконуються паралельно за кількома наближеними учасникам мережі. На практиці такий механізм пошуку має досить високий ступінь надійності, не піддається цензурі та добре масштабується. Кількість учасників в мережі і кількість порцій контенту, що зберігається практично не обмежена. Є дюжина модифікованих версій цього протоколу, націлених на покращення різних його властивостей, таких як прихованість пошуку, збільшення обсягу збережених даних, стійкість до атак Сивіли (Sybil attack), прискорення пошуку популярного контенту, забезпечення цілісності запитів і відповідей та ін.

Протоколи DHT є незамінним компонентом багатьох популярних проектів: I2P, IPFS, GNUnet, BitTorrent, Tox.

До появи DHT подібну задачу пошуку контенту вирішували завдяки використанню централізованих сервісів або групи централізованих сервісів, які синхронізуються між собою. Також у централізованого сервісу реалізований публічний API для запитів і, як правило, зареєстровано доменне ім'я. По суті, такі сервіси зберігають повні таблиці відповідності між InfoHash і мережевими адресами, які за обсягом виходили значно більше 50 МБ. Прикладом такого сервісу є Torrent Tracker. Як відомо, такі трекери легко піддаються цензурі і можуть навіть блокуватися.

### Проблема блокування контенту зловмисником

Найпоширеніша атака на протоколи DHT полягає в тому, що зловмисник може майже повністю заблокувати один конкретний контент.

Припустімо, деякий Тарас вирішив обмежити доступ вузлів системи до справжньої фотографії Сатоші Накамото, тому що отримання такої інформації зацікавленою стороною може завдати непоправної шкоди мережі Bitcoin.

Для цього він запускає кілька десятків спеціально модифікованих вузлів. Модифікація полягає в тому, що в якості ідентифікатора учасника вибирається не випадкове число, а число близьке до цільового InfoHash (контент який потрібно заблокувати). Також ці вузли інакше реагують на запити пошуку по цьому InfoHash, віддаючи у відповідь неіснуючі мережеві адреси. Тоді виходить, що велика кількість фейкових вузлів оточують ідентифікатор фотографії Сатоши, за рахунок чого до них звертаються практично всі учасники, які шукають цей контент (рис. 1.11). Таким чином, доступ до одного конкретного контенту можна тимчасово заблокувати.

<p align="center">
<img src="/resources/img/volume-2/1.2-Operation-principle-and-application-of-DHT/Figure-1.11-Scheme-of-blocking-a-specific-piece-of-content-when-being-searched.png" alt="Рисунок 1.11 – Схема блокування конкретного контенту при пошуку" width="70%"/>
<p>

**Поширені міфи**

*Використання DHT вимагає великої кількості дискового простору.*

Це не зовсім так. Важливо відзначити, що вимога щодо обсягу бази DHT цілком залежить від кількості вузлів в мережі. Чим більше вузлів у розподіленій мережі, яка використовує технологію, тим менші вимоги щодо обсягу збережуваних у таблиці даних.

*DHT працює дуже повільно, і його важко застосовувати в системах, що оперують великими обсягами даних.*

Пошук контенту при використанні DHT дійсно повільніше традиційних способів, однак такий спосіб більш відмовостійкий і якраз в децентралізованих системах користується попитом. Прикладом тому є системи, такі як BitTorrent і IPFS (детальніше в 1.5).

*Ідентифікатор, отриманий шляхом гешування IP-адреси вузла, можна вважати безпечним.*

У цього підходу є одна теоретична вразливість перед IP-спуфінгом. Концепція IP-спуфінга полягає в тому, що зловмисник модифікує заголовок IP-пакета таким чином, щоб видати себе за інший вузол. Якщо зловмисникові при цьому вдасться отримати відповідь на свій запит, це означає, що він може залишити за собою практично будь-яку IP-адресу. Отже, будувати систему, безпека якої покладається на обмежений простір доступних IP-адрес, може бути вкрай небезпечно.

**Найбільш поширені питання**

*— Чи захищена конфіденційність користувачів, які використовують DHT?*

Ні. Оскільки усі геш-значення таблиці знаходяться у відкритому доступі, то цілком можливо відстежити роздачу.

*— Які переваги привнесла реалізація DHT в BitTorrent?*

DHT дозволяє знизити навантаження на трекер або взагалі від них відмовитися, так як тепер BitTorrent, використовуючи інформацію, вбудовану в торрент-файл, може вибрати, перейти до трекера або піти по набору вузлів з DHT.

## 1.3 Концепція web-of-trust

Зараз складно уявити сучасну людину, яка б не користувалася можливостями Інтернету: здійснення покупок, не покидаючи меж своєї кімнати, обмін повідомленнями в соціальних мережах та ін. Для захисту даних, що передаються, використовуються алгоритми асиметричного шифрування, цифрового підпису та цифрові ключі.

Водночас важливо правильно зіставити конкретного користувача з його відкритим ключем, щоб уникнути атак типу man-in-the-middle (зловмисник замінює відкритий ключ, що передається, на свій, після чого може відсилати й підписувати повідомлення від імені цільового користувача).

Для забезпечення надійності застосування цифрового підпису та інших асиметричних алгоритмів використовуються центри сертифікації ключів (ЦСК). Але централізований підхід має свої недоліки, пов’язані з компрометацією особистого ключа кореневого центру сертифікації та необхідністю довіри центрам сертифікації. Як вирішення цієї проблеми використовується повністю децентралізований підхід – web-of-trust (WoT).

### Поняття сертифікату відкритого ключа

Щоби краще зрозуміти web-of-trust підхід, розгляньмо, як організована традиційна інфраструктура відкритих ключів.

_Інфраструктура відкритих ключів (ІВК, PKI, Public Key Infrastructure) – комплекс засобів, методів, політик, необхідних для створення та обробки сертифікатів відкритих ключів, що дозволяє забезпечити надійне функціонування асиметричних криптоалгоритмів_ [65].

_Сертифікат відкритого ключа (public key certificate) – документ, що встановлює співвідношення між відкритим ключем і його власником; підписується та видається одним із ЦСК _[65].

Структура сертифікату відкритого ключа відповідно до стандарту X.509 [64] наведена в таблиці 1.1.

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Table-1.1.png" alt="Таблиця 1.1" width="60%"/>
<p>

Основні поля в сертифікаті відкритого ключа – значення відкритого ключа суб’єкта й цифровий підпис, обчислений з боку центру сертифікації. Відзначмо, що за допомогою цифрового підпису центр сертифікації підтверджує відповідність відкритого ключа конкретній особі.

### Як працює ієрархічна ІВК?

Ієрархічна ІВК – традиційна модель організації, яка передбачає, що центри сертифікації ключів (ЦСК, CA, Certification Authority) зв’язані в ієрархічну деревоподібну структуру (рис. 1.12).

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Figure-1.12-Certificate-authorities-hierarchy-scheme.png" alt="Рисунок 1.12 – Схема ієрархії центрів сертифікації" width="70%"/>
<p>

Для ієрархічної PKI характерна низка таких особливостей:

> * _Кожне відношення між дочірнім та батьківським CA подано окремим сертифікатом, який підписав батьківський вузол (кореневий сертифікат самопідписаний)_
> * _Усі CA, за винятком кореневого, підпорядковуються одному вищому (батьківському) CA_
> * _CA можуть мати підпорядковані CA і випускати сертифікати для них або кінцевих користувачів_
> * _Усі користувачі довіряють тому самому кореневому CA_

Спираючись на перелічені особливості, доволі просто пояснити загальну модель функціонування ієрархічної ІВК. На найвищому рівні розташований кореневий центр сертифікації ключів. Кореневий центр має власну ключову пару, за допомогою якої він може підписати сертифікати для центрів сертифікації нижчого рівня. Водночас кореневий центр сертифікації також має власний сертифікат відкритого ключа, який виробив він же.

За отримання сертифіката кожен із дочірніх CA отримує право самостійно випускати сертифікати для своїх дочірніх CA. Так ланцюжок сертифікатів, де кожен дочірній підписаний батьківським, продовжується й до кінцевих користувачів.

Серед переваг такого підходу побудови ІВК важливо виокремити простоту побудування та перевіряння ланцюжків сертифікації, позаяк кожен користувач і CA має сертифікат, який випустив рівно один батьківський CA. Водночас ланцюжки сертифікатів порівняно короткі й однозначно приводять до одного кореневого центру сертифікації.

Для закріплення матеріалу розгляньмо приклад, у якому Алісі потрібно перевірити сертифікат Боба (щоби переконатися, чи отриманий квартальний звіт дійсно підписав Боб). Водночас сертифікати Аліси та Боба видали різні центри сертифікації. Цю схему можна подати в такий спосіб (рис. 1.13):

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Figure-1.13-Hierarchical-PKI-scheme.png" alt="Рисунок 1.13 – Схема ієрархічної інфраструктури відкритих ключів" width="50%"/>
<p>

Аліса має власний сертифікат відкритого ключа, який підписав і зберігає ЦСК1. Аналогічний сертифікат має й Боб (проте його уже видав і зберігає ЦСК2). Водночас ЦСК1 і ЦСК2 також мають власні сертифікати, які видав той самий кореневий ЦСК0.

Коли Аліса хоче перевірити автентичність відкритого ключа Боба (за допомогою якого вона перевірила значення цифрового підпису), вона отримує від нього сертифікат відкритого ключа та перевіряє, хто цей сертифікат підписав. Виявляється, що його підписав ЦСК2. Оскільки Аліса особисто не довіряє ЦСК2, то вона запитує і його сертифікат відкритого ключа, який видав кореневий ЦСК0. Аліса довіряє ЦСК0 (бо цей центр сертифікації видав сертифікат ЦСК1) і переконується, що наданий відкритий ключ Боба дійсно належить йому. Відзначмо, що в цьому прикладі в ланцюжку перебуває два сертифікати (перевіряються сертифікати Боба та ЦСК2). Якби сертифікат Боба підписав ЦСК1, то Аліса могла б безпосередньо звернутися до ЦСК1 і відразу переконатися в коректності сертифікату.

Перевагою ієрархічного підходу також є можливість швидкого реагування на компрометацію особистого ключа кінцевого користувача (для цього користувачеві необхідно звернутися до батьківського ЦСК).

_Компрометація ключів (key compromise) – факт ознайомлення або підозра в ознайомленні третьої сторони з особистим ключем користувача_. До компрометації також належить утрата фізичного контролю ключа з боку його володільця.

Припустимо, що особистий ключ, яким володів Боб, викрав Тарас. Тепер він може відправляти всім неправдиві повідомлення від імені Боба й підписувати їх за допомогою особистого ключа Боба. У цьому разі Боб має відразу повідомити ЦСК, що його особистий ключ був скомпрометований. ЦСК може швидко відреагувати й позначити сертифікат Боба як недійсний, після чого видати йому новий сертифікат із новим відкритим ключем.

Якщо Аліса отримує повідомлення, підписане старим ключем Боба, вона звертається до ЦСК2. Як і в попередньому випадку, ЦСК2 повідомляє Алісі, що сертифікат необхідного відкритого ключа більше не дійсний і, найімовірніше, її намагаються обдурити (рис. 1.14).

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Figure-1.14-Alice-verifies-Bob-s-certificate.png" alt="Рисунок 1.14 – Аліса перевіряє сертифікат Боба" width="50%"/>
<p>

Що ж станеться, якщо буде скомпрометовано ключі не кінцевого користувача, а одного з ЦСК (наприклад ЦСК2)? У цьому випадку ЦСК2 повідомляє кореневому ЦСК0, що його ключі скомпрометовані. ЦСК0 позначає сертифікат ЦСК2 як недійсний і видає йому новий сертифікат із новим відкритим ключем, у такий спосіб повертаючи скомпрометований центр до інфраструктури. Але оскільки старий відкритий ключ ЦСК2 стає недійсним, водночас втрачають дійсність усі сертифікати, які видав цей ЦСК. Тому користувачі, що перебуває в скомпрометованому сегменті, утрачають можливість користуватися сервісами ІВК (їх сертифікати також стають недійсними; якщо користувачі не припинять взаємодію чи не оновлять сертифікати, то їх може обманути зловмисник, що викрав секретний ключ ЦСК2).

Залишилося розглянути, що ж трапиться, якщо раптом станеться компрометація особистого ключа кореневого центру сертифікації. У загальному випадку наслідки ті самі, тільки масштабніші: на деякий час усю інфраструктуру має бути зупинено. Відзначмо, що критично важливо сповіщати всіх учасників системи про компрометацію одного з ЦСК, позаяк зловмисник у цьому разі може випускати підроблені сертифікати, відкликати чинні сертифікати тощо.

В ієрархічних ІВК є явні переваги: висока швидкість побудування та відстеження ланцюжків сертифікатів, а також швидке перевипускання сертифікатів у разі компрометації особистих ключів як користувачів, так і ЦСК. Однак такі моделі мають і низку недоліків.

> **Проблеми ієрархічної ІВК**
> * _Необхідність перевіряння всього ланцюжка сертифікатів_
> * _Критичність компрометації особистого ключа кореневого центру сертифікації (ризик припинення функціонування всієї інфраструктури)_
> * _Проблеми пов’язані із синхронізацією центрів сертифікації між собою_
> * _Користувачі фактично не управляють своїми identities_
> * _Складнощі сумісності систем (алгоритми підпису тощо)_

### Принципи функціонування web-of-trust

Web-of-trust – це альтернатива ієрархічній моделі ІВК. Концепція вперше була застосована в 1991 році в протоколі PGP для автентифікації відкритих ключів користувачів. Також підхід web-of-trust можна використовувати для механізмів ідентифікації в децентралізованому середовищі й системах рейтингу (уже є безліч браузерних надбудов онлайн-рейтингу сайтів, що використовують механізм web-of-trust).

Якоюсь мірою основу надійної роботи моделі web-of-trust становить соціальний консенсус: жоден користувач не довірятиме сертифікату іншого користувача доти, поки цей учасник не отримає підтвердження свого відкритого ключа хоча би від одного учасника, що перебуває в колі довіри першого користувача.

Перш ніж перейти безпосередньо до принципів роботи web-of-trust, визначимо два необхідних надалі поняття, які досить тісно пов’язані один із одним і на які спирається вся концепція, – _trust_ і _validity_.

Validity визначає рівень того, наскільки добре один користувач знає іншого користувача. Якщо позначити рівень validity від 0 до 1, то за значення validity 0 перший користувач абсолютно не знайомий із другим (надалі – абсолютно не знає, яким ключем володіє цей користувач), а за значення 1 – повністю впевнений у зв’язку конкретного користувача і його відкритого ключа.

Trust визначає рівень довіри одного користувача іншому, тобто наскільки перший довіряє іншому ідентифікацію всіх інших учасників системи.

Отже, повернімося до децентралізованої ІВК. У нас є система, кожен з учасників якої володіє ключовою парою. Крім того, кожен з учасників визначає власний список ключів інших учасників мережі, верифікацію яких він провів (наприклад зустрівся з ними в кафе й особисто отримав відкритий ключ), а також рівень validity і trust цих користувачів. Отримані ключі (іноді й інші дані користувача) він підписує за допомогою свого особистого ключа, іншими словами, формує сертифікати відкритих ключів інших користувачів. Кожен із користувачів містить таблицю з приблизно такого змісту (табл. 1.2).

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Table-1.2.png" alt="Таблиця 1.2" width="70%"/>
<p>

У цьому випадку користувач може безпечно взаємодіяти з тими учасниками системи, ключі яких він має в списку й чий рівень validity дорівнює 1.

Але що, якщо потрібна комунікація з учасником системи, відкритого ключа якого користувач ще не має? У цьому разі він звертається до довірених користувачів (рівень trust яких вищий) і запитує в них із контактів відкритий ключ потрібного користувача. Таким чином, якщо один із його контактів має підписаний відкритий ключ учасника мережі, то він дивиться свій рівень trust до користувача й рівень trust і validity користувача до цільового абонента. Залежно від цього він визначає, наскільки безпечним буде використання наданого відкритого ключа цільового користувача.

### Приклад з італійською мафією

Для простоти розуміння наведемо приклад, у якому глави італійської мафії – дон Корлеоне, дон Татталья й дон Фануччі – вирішили створити спільну мережу для ведення бізнесу та використовувати web-of-trust для організації ІВК. Відзначмо, що ключі в цьому випадку використовуватимуться для шифрування й підписання повідомлень.

Для цього вони організовують зустріч глав сімейств, на якій відбувається обмін відкритими ключами (рис. 1.15).

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Figure-1.15-Exchange-of-public-keys-between-heads-of-the-families.png" alt="Рисунок 1.15 – Обмін відкритими ключами між главами сімейств" width="50%"/>
<p>

Кожен із донів формує власну таблицю, яку заповнює після зустрічі. Розгляньмо, наприклад, таблицю 1.3, яку сформував дон Корлеоне.

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Table-1.3.png" alt="Таблиця 1.3" width="70%"/>
<p>

> **_Зауваження._** *Рівень validity в цьому випадку встановлюється таким, що дорівнює 1, тому що дони обмінялися ключами особисто під час зустрічі. Рівень trust до дона Фануччі дон Корлеоне визначив як 0,8, тому що відповідний відкритий ключ був переданий без належної поваги.*

Відтепер дон Корлеоне може відправляти повідомлення, зашифровані відкритими ключами інших глав сімейств, не турбуючись про те, що їх може прочитати хтось інший (водночас одержувачі зможуть автентифікувати відправника за значенням цифрового підпису).

Але що, якщо дону необхідно зв’язатися із Солоццо, чийого відкритого ключа його список не містить? Для цього він звертається до дона Татталья із запитом, чи має він відповідний відкритий ключ. Дон Татталья каже, що має такий ключ, що він же його підписав і що рівень validity та trust визначено як 1 (тобто дон Татталья повністю верифікував Солоццо і повністю довіряє йому). Позаяк дон Корлеоне повністю довіряє дону Татталья (trust дорівнює 1) і дон Татталья впевнений, що відкритий ключ належить Солоццо, рівень validity дона Корлеоне до Солоццо дорівнює 1 (і він може впевнено шифрувати повідомлення, використовуючи отриманий ключ).

Водночас з огляду на старі розбіжності дон Корлеоне практично не довіряє Солоццо ідентифікацію інших учасників мережі й заповнює власну таблицю, як показано в табл. 1.4.

<p align="center">
<img src="/resources/img/volume-2/1.3-Web-of-trust-concept/Table-1.4.png" alt="Таблица 1.4" width="70%"/>
<p>

Цим дон Корлеоне підкреслює, що для нього кожен сертифікат, який випустить Солоццо, буде мати рівень validity 0,1.

Тепер уявімо, що є дон Барзіні, відкритий ключ якого зберігає як Солоццо, так і дон Татталья (причому Солоццо – з рівнем validity 1, а дон Татталья – з рівнем validity 0,3). Якщо дон Корлеоне хоче написати Барзіні, він запитує сертифікати в Солоццо й дона Татталья, кожен із яких надсилає йому відповідний сертифікат.

Отримавши сертифікати, дон Корлеоне розраховує рівень validity, тобто рівень того, що отримані відкриті ключі відповідають дону Барзіні (до речі, вони можуть бути різні, якщо, наприклад, Солоццо хоче обдурити дона й сам прочитати повідомлення).

Рівень validity відкритих ключів, яких немає у власному списку, визначається так:
> *validity(PK) = validity(PKi) * trust(PK)*, где
> * *validity(PK)* – рівень validity щодо ключа, якого немає в списку
> * *trust(PK)*  – рівень довіри до посередника
> * *validity(PKi)* – рівень validity посередника щодо цільового ключа

Відповідно, дон Корлеоне вірить, що отриманими ключами володіє дон Барзіні з рівнем validity 0,24 (дон Татталья) і 0,1 (Солоццо). Ці значення доволі малі, і дон Корлеоне не хоче ризикувати, шифруючи повідомлення отриманими ключами, і безпосередньо рушає в гості до дона Барзіні.

### Переваги й обмеження технології web-of-trust

Основна перевага web-of-trust – можливість функціонування в повністю децентралізованою середовищі, де сторони, що взаємодіють, не хочуть довіряти центральному органу сертифікації. За достатнього рівня зв’язності користувачів (теорія шістьох рукостискань) web-of-trust дозволяє учаснику розрахувати відносну репутацію будь-якого іншого учасника.

Відзначмо, що за використання web-of-trust неможливе припинення функціонування всієї системи через компрометацію особистого ключа одного або декількох користувачів. Якщо web-of-trust використовується в повністю децентралізованому (розподіленому) середовищі, то вихід із ладу одного вузла може вплинути тільки на можливість взаємодіяти з цим конкретним вузлом і не надто вплине на взаємодію інших вузлів.

Однак технологія web-of-trust має низку певних обмежень, які сильно впливають на роботу системи.

> **Обмеження web-of-trust**
> * *Складність знаходження сертифікату відкритого ключа з високим рівнем validity в низці випадків*
> * *Велика тривалість і складність перебудування мережі*
> * *Знаходження необхідного сертифіката може потребувати більш тривалого проміжку часу*
> * *База даних сертифікатів вимагає деякого обсягу пам’яті на вузлах*

Перше обмеження стосується специфіки протоколу web-of-trust. Мережа, яка використовує web-of-trust, буде добре й ефективно працювати, тільки якщо всі вузли поводяться чесно й мають максимальні рівні validity та trust. Здебільшого рівень довіри користувачів щодо інших не максимальний, що спричиняє лавинний ефект і складнощі прийняття рішення щодо використання конкретного ключа.

У разі компрометації одного з ключів користувачів перебудова мережі займе набагато більше часу, ніж централізований аналог, оскільки для цього користувач має повідомити всім вузлам, що зберігають його сертифікати, про компрометацію (причому повідомляти потрібно переконливо, позаяк багато вузлів можуть сприйняти таке повідомлення як атаку зловмисника й залишити сертифікат дійсним). Також, якщо користувач – новий учасник мережі, йому потрібно протягом тривалого часу поводитися чесно, щоб інші вузли підвищили рівень довіри до нього.

Третє обмеження пов’язане зі складністю знаходження певного сертифікату, якщо мережа має велику кількість учасників. Цю проблему можна частково вирішити за допомогою використання DHT (докладніше в 1.2), проте це вимагає додаткового ПЗ і ресурсів.

Остання проблема також пов’язана зі зростанням кількості учасників мережі. Що більший розмір мережі, то більшу кількість сертифікатів має зберігати кожний із вузлів (від цього безпосередньо залежить ефективність мережі).

***Поширені міфи***

*Web-of-trust дозволяє гарантовано знайти дійсний сертифікат користувача, однак може знадобитися великий проміжок часу для його знаходження.*

Це твердження є міф через особливості довіри між вузлами мережі. Дуже рідко трапляється, що один вузол абсолютно довіряє сертифікату другого вузла. Рівень довіри часто може бути дуже великим, проте вельми рідко він дорівнює 100 %. Через цю особливість може статися так, що ви не зможете знайти сертифікат користувача з достатнім для вас рівнем довіри. Наприклад, клієнт може налаштувати своє ПЗ так, що буде вважати дійсними тільки сертифікати, рівень довіри через посередників до яких дорівнює не менш ніж 95 %. Тоді може бути ланцюжок до конкретного сертифікату через 3–4 вузли, довіра між якими, наприклад, також дорівнює 95 %. Однак через особливості розрахування рівня довіри від вузла-запитувача до цільового вузла може статися те, що остаточний рівень довіри дорівнюватиме не більш ніж 85 %.

*У мережі web-of-trust можна підвищити рівень довіри до себе (свій рейтинг), створивши безліч підроблених особистостей і, відповідно, відкрити велику кількість ліній довіри до себе з максимальним значенням validity.*

Створювати підроблені особистості та лінії довіри можна, але це ніяк не вплине на розрахунки вашої оцінки реальних користувачів, оскільки цей розрахунок ведеться щодо кожного окремого користувача та ліній довіри, які виходять від нього. Думку підробленої особистості не беруть до уваги реальні користувачі, оскільки вони не відкривали лінію довіри їй.

***Часті запитання***

*— Чи може один користувач створити кілька сертифікатів для різних своїх ключів?*

Така можливість присутня. Але якщо різні ключі використовуються в різних колах спілкування (наприклад в особистому та робочому), то це не вплине на рівень підтвердження сертифікатів і не створить плутанину для співрозмовників.

*— Чи схильний протокол web-of-trust до атаки Сивілли й чи може ця атака вплинути на прийняття з боку вузла сертифіката з низьким рівнем довіри?*

Протокол не обмежує кількість вузлів у мережі, а отже, теоретично зловмисник може створити велику кількість «учасників», які повністю довіряють його сертифікату. Однак це не може в жодний спосіб вплинути на інших учасників мережі, оскільки відношення довіри від вузла до вузла односпрямоване. Вузли не додаватимуть собі сертифікати нових учасників, якщо вони не довіряють цим сертифікатам, а отже, їхня кількість несуттєва.

Однак є проблема, за якої раніше чесний вузол із високим рівнем довіри раптом починає поводитися зловмисно та додає сертифікати ненаявних учасників під іменем цільових користувачів. У результаті, мережа може перестати довіряти цьому користувачу, проте її перебудування доволі працеємне. Перебудову не може бути виконано в короткі терміни, чим зловмисник і може скористатися.

## 1.4 Протокол BitMessage

Після повідомлення Едварда Сноудена про те, що за більш ніж мільярдом людей в 60 країнах ведеться глобальне стеження [10], виникла необхідність створення дійсно конфіденційного засобу комунікації.

21 березня 2013 року вийшла перша бета-версія клієнта BitMessage. Ключовою інновацією протоколу BitMessage стала відсутність центральних серверів або будь-якого центру, який обробляє дані користувачів. Протокол працює за схемою peer-to-peer, тобто кожен вузол є і клієнтом, і сервером одночасно, а єдиний централізований сервер відсутній.

### Принципи функціонування протоколу

Для тих, хто зацікавлений в збереженні особистої або корпоративної конфіденційності, BitMessage – гарна альтернатива звичайним мессенджерам.

> * *Підтримка end-to-end шифрування повідомлень, що передаються*
> * *Відправник і одержувач явно не вказані в повідомленні*
> * *Кожен вузол зберігає всі останні повідомлення в мережі*
> * *Proof-of-work як захист мережі від спаму*
> * *Підтримка перевірки цілісності та авторства отриманих повідомлень*
> * *Підтримка відкритих широкомовних каналів*
> * *Підтримка закритих групових чатів*

Ключова ідея протоколу полягає в підтримці end-to-end шифрування переданих повідомлень. Це означає, що повідомлення може прочитати тільки відправник і одержувач, і ніякі проміжні ланки не мають такої можливості. Для шифрування даних повідомлення використовується алгоритм AES з довжиною ключа 256 біт, який працює в режимі CBC (Cipher Block Chaining). У цьому випадку ключ розраховується як загальний секрет між відправником і отримувачем за схемою ECDH. Такий секрет відправник може отримати автономно – без взаємодії з одержувачем. Для цього йому необхідно використовувати свій особистий ключ і відкритий ключ одержувача. Одержувач, використовуючи свій особистий ключ і відкритий ключ відправника, зможе отримати такий самий секрет. Таким чином обидва учасники мають однаковий секрет для шифрування повідомлень. Крім того, для підвищення рівня безпеки замість алгоритму ECDH може використовуватися спільний рандомізатор для генерації нового ключа шифрування для кожного нового повідомлення.

> **_Зауваження._** *Режим CBC (зчеплення блоків шифротексту) полягає в тому, що для шифрування кожного наступного блоку даних використовується зашифроване значення попереднього блоку.*

У повідомленнях BitMessage не вказуються ідентифікатори відправника і одержувача конкретного повідомлення. Яким же чином тоді одержувач визначає, що конкретне повідомлення адресовано йому? Для цього кожен вузол мережі намагається розшифрувати всі повідомлення, які проходять через нього. Так як ключ шифрування доступний тільки відправнику і одержувачу повідомлення, тільки вони можуть отримати доступ до перегляду повідомлення.

Як ми зазначали раніше, вузол намагається *розшифрувати кожне отримане повідомлення*. У разі успіху (якщо повідомлення дійсно було адресовано користувачеві) одержувач ознайомлюється з його вмістом. Але що робити з повідомленнями, які розшифрувати не вийшло? Протоколом BitMessage передбачено, що кожен вузол зберігає всі отримані повідомлення 2 дні. Це зроблено для того, щоб дозволити одержувачу повідомлення отримати до нього доступ навіть в разі його відсутності в мережі в момент відправки повідомлення. Коли у користувача з'являється інтернет-з'єднання, він запитує у сусідніх вузлів усі повідомлення, що не буди отримані раніше, та намагається розшифрувати їх.

Як захист мережі від спаму використовується proof-of-work. Щоб відправити повідомлення, відправнику необхідно вирішити ресурсномістке завдання. Складність proof-of-work залежить від обсягу повідомлення і обсягу вкладень, що входять в повідомлення.

Також відзначимо, що протокол передбачає можливість використання цифрового підпису для перевірки цілісності та авторства кожного відправленого повідомлення.

Протокол BitMessage передбачає можливість створення широкомовних каналів і секретних чатів. Широкомовні канали передбачають, що відправник шифрує повідомлення геш-значенням власного відкритого ключа. Кожен учасник мережі, у якого є відкритий ключ відправника, може розшифрувати таке повідомлення. Секретні чати передбачають створення загального секрету для шифрування між групою користувачів. Відзначимо, що такий секретний чат не може піддаватися цензурі третьою стороною.

### Адреси в BitMessage

У протоколі BitMessage також передбачено наявність адрес у користувачів. Давайте розглянемо, як генерується адреса і для чого вона потрібна.

Кожній BitMessage-адресі відповідають дві пари ключів: одна пара застосовується для підпису повідомлень (ECDSA), а друга – для створення загального секрету (ECDH). Для формування BitMessage-адреси використовуються обидва відкритих ключа (рис. 1.16).

<p align="center">
<img src="/resources/img/volume-2/1.4-Overview-of-the-BitMessage-protocol/Figure-1.16-BitMessage-address-generation-scheme.png" alt="Рисунок 1.16 – Схема генерації BitMessage адреси" width="60%"/>
<p>

Відкриті ключі конкатенуються та гешуються за допомогою SHA512, а для результату знову розраховується геш-значення, але вже за допомогою RIPEMD160. На виході виходить число довжиною 160 біт (20 байт). Це значення конкатенуються з Version (значення версії протоколу), Stream (потік повідомлень; його детальніше розглянемо нижче) і Checksum (контрольна сума, яка дозволяє запобігти помилкам при написанні адреси). Для позначення того, що адреса відноситься до мережі BitMessage, використовується префікс «BM». В результаті BitMessage-адреса виглядає наступним чином:

> *BM-BcbRqcFFSQUUmXFKsPJgVQPSiFA3Xash* 

BitMessage підтримує 2 типи адрес: детерміністичні та випадкові адреси.

> **Типи BitMessage-адресов**
> * *Deterministic address (детерміністична адреса)*
> * *Random address (випадкова адреса)*

Для отримання детермінованої адреси користувачеві необхідно задати значення seed для її породження. Можна провести аналогію з тим, як користувач задає пароль для входу на сервіс.

Оскільки seed задається безпосередньо користувачем, з цим пов'язані деякі переваги та ризики. Перевагою є простота відновлення адрес. При використанні іншого пристрою користувачеві потрібно просто ввести значення seed (швидше за все, користувач не захоче визначати випадкове значення seed, а задасть його значенням, яке легко буде згадати). Після цього пристрій самостійно генерує адресу. До ризиків можна віднести простоту злому (атака грубої сили чи атака зі словником), адже seed є не випадковим значенням, а заданий користувачем.

Випадково згенеровані адреси використовують псевдовипадкове значення в якості seed для генерації адреси, і, не знаючи цього значення, адреса не може бути відновлена. Важливо відзначити, що в цьому випадку користувачеві також необхідно ввести seed для відновлення адреси, але так як seed є випадковим значенням, втрачається зручність відновлення, хоч і підвищується безпека при взаємодії з системою.

### Структура повідомлень в BitMessage

Давайте детально розглянемо структуру повідомлень в протоколі BitMessage, наведену в таблиці 1.5.

<p align="center">
<img src="/resources/img/volume-2/1.4-Overview-of-the-BitMessage-protocol/Table-1.5.png" alt="Таблиця 1.5" width="70%"/>
<p>

Повідомлення містить 5 полів, які вказані в таблиці. Перше з них – _magic_ – є сталим числом, яке використовується для ідентифікації потоку даних. За цим значенням можна визначити, що дані, які за ним слідують, відносяться до мережі BitMessage. Таке ж значення використовується і для протоколу Bitcoin (в ньому воно визначається як 0xD9B4BEF9).

Нижче слід поле під назвою _command_, в якому міститься тип повідомлення. Залежно від типу, повідомлення діляться на _broadcast_ (широковещательное повідомлення), _private_ (ПП) або _ACK_ (повідомлення про доставку особистого повідомлення). У кожного з перерахованих типів повідомлення є своє призначення, про які ми поговоримо далі.

Далі знаходиться поле _length_, в якому вказується довжина переданого повідомлення в байтах. Чим більше довжина повідомлення, тим складніше ресурсоємне завдання потрібно вирішити його відправнику. Відзначимо, що максимальний розмір повідомлення в останній версії протоколу обмежений 256 KiB.

Наступна складова повідомлення – поле _checksum_, в якому містяться перші 4 байта геш-значення SHA512 від переданих даних.

Ключовим полем повідомлення є поле _payload_, що містить в собі дані, що передаються і значення _nonce_ як доказ виконаної роботи. При отриманні повідомлення вузол насамперед обчислює геш-значення від поля _payload_, і якщо отримане геш-значення задовольняє необхідному параметру складності, таке повідомлення зберігається локально і передається далі по мережі. Якщо геш-значення не задовольняє необхідному параметру, таке повідомлення видаляється і не передається далі.

### Типи повідомлень в BitMessage

Як згадувалося раніше, BitMessage підтримує три типи повідомлень.

> **Типи BitMessage-повідомлень**
> * *Broadcast message (широкомовне повідомлення)*
> * *Private message (персональне повідомлення)*
> * *ACK message (сповіщення про доставку особистого повідомлення)*

Особливість _broadcast_ повідомлення в тому, що його може розшифрувати будь-який вузол, в списку адрес якого є адреса відправника. _Broadcast_ повідомлення шифрується геш-значенням відкритих ключів відправника. Вузол, якому прийшло таке повідомлення, визначає, що це повідомлення типу _broadcast_ (по полю command в повідомленні), і починає по черзі обчислювати геш-значення всіх адрес, які перебувають в його списку. За допомогою обчисленого геш-значення вузол намагається розшифрувати отримане повідомлення. Якщо спроба розшифрування виявилася невдалою, вузол береться за наступне повідомлення. Якщо повідомлення розшифровано успішно, воно відображається користувачеві.

Відправивши таке повідомлення, відправник не отримує повідомлень про доставку. Отже, повторна відправка широкомовного повідомлення може виконуватися тільки вручну. За замовчуванням _broadcast_ повідомлення зберігаються вузлами протягом 2 діб.

Для відправки _private_ повідомлення використовується end-to-end шифрування, яке засноване на спільному секреті між відправником й отримувачем. Прочитати таке повідомлення може тільки одержувач (який має відповідний секрет) і сам відправник.

Вузли за замовчуванням зберігають _private_ повідомлення протягом 2,5 днів. Якщо за цей час користувач, якому було адресовано певне повідомлення, не з'явиться в мережі, повідомлення буде відправлено повторно. Для кожної повторної відправки повідомлення потрібно перераховувати PoW. Оскільки одержувач відправляє повідомлення відправнику, ПЗ дозволяє ретранслювати приватне повідомлення автоматично.

_ACK_ повідомлення – сповіщення про доставку особистого повідомлення. ACK повідомлення відправляється одержувачем _private_ повідомлення. Таке повідомлення шифрується таким же чином, як і особисте повідомлення, і вузли зберігають таке повідомлення також 2,5 доби.

### Поняття stream в BitMessage 

Раніше ми згадували значення stream в контексті формування BitMessage-адреси. Настав час зрозуміти, що визначається цим значенням і для чого воно використовується в протоколі.

Проблема масштабованості є ключовою для протоколу BitMessage. Незважаючи на те, що протокол може забезпечити високий рівень анонімності та конфіденційності переданих повідомлень, використання схеми, при якій кожен учасник мережі зберігає всі дані, вкрай неефективне. Уявімо ситуацію, в якій системою BitMessage будуть користуватися мільйони людей. У цьому випадку кожному з учасників необхідно буде зберігати всі повідомлення інших учасників. Насправді, така система не зможе надійно функціонувати.

Рішенням є компроміс між анонімністю і масштабованістю системи, який полягає у поділі користувачів на так звані потоки (streams). Кожен поток визначає групу користувачів, які будуть отримувати і зберігати повідомлення, відповідні їх потоку.

Потоки являють собою бінарну структуру, як на малюнку 1.17.

<p align="center">
<img src="/resources/img/volume-2/1.4-Overview-of-the-BitMessage-protocol/Figure-1.17-Scheme-of-the-division-of-network-nodes-into-streams.png" alt="Рисунок 1.17 – Схема поділу вузлів мережі на потоки" width="60%"/>
<p>

Номер потоку міститься в адресі учасника системи і визначає, до якого з потоків необхідно підключитися відправнику, щоб повідомлення досягло свого адресата. Відзначимо, що кожен учасник мережі зберігає повідомлення, відповідні його власному потоку та дочірнім потокам.

***Поширені запитання***

*– Яку кількість з'єднань необхідно підтримувати вузлу BitMessage для функціонування?*

Щоб спілкуватися з мережею BitMessage, необхідно з'єднання як мінімум з одним із вузлів. Але чим більше з’єднань з різними вузлами інших учасників, тим більше цілісна мережа і менше ймовірність втрати повідомлень. Однак протоколом визначено обмеження на максимальну кількість вихідних з'єднань: їх може бути не більш ніж 8. У той же час максимальна кількість вхідних з'єднань у десятки разів більша.

*– Чи можна відправити повідомлення користувачу, у якого на поточний момент відсутнє підключення до мережі?*

Так, користувач може відправити повідомлення в мережу BitMessage незалежно від того, чи знаходиться його одержувач в мережі. Відправлене повідомлення зберігається усіма вузлами протягом двох днів. При відновленні з'єднання одержувач заходить у мережу і завантажує з підключених вузлів все нові повідомлення. Якщо ж одержувача не було в мережі більше двох днів, тоді повідомлення буде видалено і вимагає повторного відправлення.

*– Який час доставки повідомлення передбачений протоколом від відправника до одержувача?*

На практиці час передачі повідомлення залежить від двох величин: часу поширення мережею і часу очікування в черзі на розшифрування повідомлення. Мережею від вузла відправника до вузла одержувача повідомлення може йти до 30 секунд в залежності від кількості вузлів-посередників. Очікувати розшифрування в черзі з усіма іншими повідомленнями воно буде в середньому близько 5 секунд. Таким чином, якщо вузол одержувача знаходиться в мережі та синхронізований, він побачить вхідне повідомлення через 20-30 секунд після його відправлення.

*— Як вузол може працювати в пасивному режимі?*

За можливості стеження або прослуховування мережі зловмисником користувач може працювати в повністю пасивному режимі, не відправляючи ACK повідомлення (повідомлення підтвердження отримання). Однак набагато розумніше з його боку відправляти ACK повідомлення через інший вузол, який може навіть про це не підозрювати. Наприклад, Боб, який боїться, що його мережа прослуховує Єва, замість того, щоб відправити Алісі ACK повідомлення безпосередньо, відправляє його своєму другові чи випадковому вузлу. Останній зі свого боку поширює це повідомлення й одночасно його підтверджує.

## 1.5 Архітектура й особливості протоколу IPFS

У підрозділі 1.1 ми розглядали, як може працювати децентралізована файлообмінна мережа: вона не регулюється будь-ким одноосібно, стійка до цензури та підтримується безпосередньо її учасниками. Протоколом організації такої мережі виступив BitTorrent, який заклав основні концепції побудови, але при цьому мав деякі обмеження і вузьку спрямованість використання.

10 жовтня 2018 року був представлений новий протокол організації децентралізованої файлообмінної мережі під назвою IPFS. Він застосував ключові концепції BitTorrent, додавши до них ряд нових поліпшень, що дозволяють використовувати IPFS в якості платформи для багатьох децентралізованих застосунків. В цьому підрозділі ми розглянемо основні концепції IPFS, переваги протоколу в порівнянні з іншими протоколами побудови децентралізованих файлообмінних мереж, як IPFS застосовується та як може застосовуватися для реалізації децентралізованих застосунків.

### Основні принципи протоколу

IPFS (InterPlanetary File System) є протоколом децентралізованої файлообмінної системи. Протокол використовує концепцію DHT (див. 1.2) для розподілу й пошуку контенту між учасниками і MDAG (Merkle Directed Acyclic Graph) для організації зручної структури зв'язку контенту. Як і протокол BitTorrent, IPFS не має на увазі зберігання всіх файлів на кожному з вузлів системи: кожен учасник системи зберігає тільки ту частину контенту, яку вважає необхідною.

> * *Розподілене зберігання контенту*
> * *Деревовидна структура зв'язків контенту (схожа на традиційну файлову систему)*
> * *Перевірка і виключення дублікатів файлів*
> * *Можливість версіонування історій файлів*

Окрім контенту, кожен з вузлів зберігає власну таблицю хеш-значень. Нагадаємо, що така таблиця містить зв'язок між конкретним ідентифікатором і даними, якими можуть бути або порція контенту, або мережева адреса іншого учасника мережі.

Ключовою особливістю IPFS, на відміну від багатьох інших протоколів, є підтримка версіонування контенту. Наприклад, ви завантажили документ в децентралізовану мережу (поширили його між іншими учасниками). Після цього ви вирішили виправити деякі помилки і оновити документ. У системах, таких як BitTorrent, ви не можете замінити старий файл новим (теоретично це можливо, тільки якщо всі вузли мережі погодяться видалити стару версію). Фактично, ви публікуєте в мережу новий документ, який не має ніякого зв'язку зі старим. Це не завжди добре через те, що багатьом застосункам, що використовують версіонування, вкрай незручно працювати з такою системою. IPFS також не дозволяє замінити старий файл новим (після додавання файлу в мережу видалити його можна, тільки якщо всі погодяться це зробити). Однак IPFS підтримує версіонування файлів, тобто при оновленні документа ви можете прив'язати нову версію до старої. Як приклади можна привести роботу Google Docs або GitHub – для таких продуктів дуже важлива історія змін і можливість відновлення старих копій.

### Як працює IPFS

IFPS влаштований так само, як і BitTorrent, а саме передбачає модель адресації контенту, а не джерел контенту. Протокол також передбачає поділ контенту на файли (фрагменти), до того ж розмір одного такого файлу не може перевищувати 256 KB. Кожному файлу відповідає власний ідентифікатор – його хеш-значення. При цьому протоколом суворо не обмежено використання певної геш-функції (можна використовувати SHA-1, SHA-256, KECCAK, SHAKE, X11, BLAKE, MD5 та ін.). Відзначимо, що ідентифікатор геш-функції використовується як префікс ідентифікатора файлу. Таким чином, користувач точно зможе переконатися, що він завантажує необхідний файл, використовуючи потрібний алгоритм гешування, в залежності від ідентифікатору.

Кожен IPFS-файл має структуру, що наведена в таблиці 1.6.

<p align="center">
<img src="/resources/img/volume-2/1.5-Architecture-and-features-of-IPFS-protocol/Таблица-1.6.png" alt="Таблиця 1.6" width="70%"/>
<p>

Файли в IPFS можна розділити на чотири основні типи.

> **Типи файлів в IPFS**
> * *Blob (набір даних)*
> * *List (список)*
> * *Commit (стан)*
> * *Tree (дерево)*

_Blob_ є кінцевим фрагментом і містить в собі частину завантаженого файлу. _List_ містить список посилань на _blobs_ (їх ідентифікатори) і/або посилання на інші списки (одного списку не вистачає для розміщення ідентифікаторів всіх частин файлу, коли файл більше 8 МB). _Tree_ є файлом, в якому розміщені посилання на інші _trees_, _lists_ і _blobs_. Різниця між tree і list полягає в тому, що list вказує на посилання одного файлу, а tree можна порівняти з каталогом (який містить в собі безліч різних каталогів і файлів). _Commit_ же являє собою файл, який посилається на батьківський файл і містить деякі зміни.

Давайте схематично розглянемо, що ж являє собою кожен файл в IPFS. Припустимо, ви хочете відправити в мережу IPFS невеликий текстовий файл. Якщо він менше 256 KB, тоді ви гешуєте файл і відправляєте його ідентифікатор в мережу. Тепер з отриманим ідентифікатором пов'язаний ваш текстовий файл, тобто _blob_ (рис. 1.18).

<p align="center">
<img src="/resources/img/volume-2/1.5-Architecture-and-features-of-IPFS-protocol/Figure-1.18-Scheme-of-adding-a-small-file-to-the-blob-structure.png" alt="Рисунок 1.18 – Схема додавання невеликого файлу в структуру blob" width="50%"/>
<p>

Розглянемо, що таке список. Список являє собою набір посилань на blobs, з яких можна зібрати цілісний файл. Припустимо, ви хочете відправити в мережу файл, що перевищує розмір в 256 KB (фотографію, відео та ін.). Припустимо, що для відправки цього файлу вам необхідно розділити його на чотири частини. Після того, як ви це зробили і отримали ідентифікатори частин, вони ніяк не пов'язані між собою. З цієї причини ви створюєте _list_, в якому вказуєте всі ідентифікатори фрагментів (аналогію можна провести з файлом .torrent). В такому випадку, щоб отримати доступ до всього файлу, учаснику мережі потрібно отримати list за його ідентифікатором (рис. 1.19).

<p align="center">
<img src="/resources/img/volume-2/1.5-Architecture-and-features-of-IPFS-protocol/Figure-1.19-Scheme-of-adding-a-large-file-to-the-list-structure.png" alt="Рисунок 1.19 – Схема додавання великого файлу в структуру list" width="50%"/>
<p>

Відзначимо, що ідентифікатор list повністю залежить від ідентифікаторів blobs, які, в свою чергу, залежать від вмісту частин файлу. Якщо хоча б одна частина піддається модифікації, цей list перестане на нього посилатися. Однак, як ми згадували раніше, IPFS передбачає можливість версіонування, принцип функціонування якого ми розглянемо далі.

Дерева (trees) є посилання на велику кількість різного контенту. Дерева, як згадувалося вище, можуть містити посилання на інші дерева, списки (lists) і файли. Ідентифікатор дерева повністю залежить від ідентифікаторів всіх його посилань (тому зміна будь-якого з файлів буде помітна). Схематично дерева можна представити таким чином (рис. 1.20).

<p align="center">
<img src="/resources/img/volume-2/1.5-Architecture-and-features-of-IPFS-protocol/Figure-1.20-Tree-structure-formation-scheme.png" alt="Рисунок 1.20 – Схема формування структури tree" width="50%"/>
<p>

Тепер розберемося, що з себе представляють commits. Коли користувач хоче оновити один з файлів, який він опублікував в мережу, він не може просто видалити старий файл і додати новий, так як мережа децентралізована і невідомо, який з вузлів зберігає цей файл. Також користувач не може перевизначити посилання на старий файл таким чином, щоб воно вказувало на новий, тому що ідентифікатор кожного фрагмента повністю залежить від його вмісту. Тому користувачеві нічого не залишається, крім як додати в мережу новий файл. У цьому випадку він буде володіти новим унікальним ідентифікатором. У протоколі BitTorrent такі два файли ніяк не можуть бути пов'язані між собою на рівні протоколу (тільки вузли, які зберігають файли, можуть повідомляти іншим, що у них зберігається 2 або більше версії одного файлу).

IPFS дозволяє зв'язати всі версії контенту на рівні протоколу. Для кожної нової версії створюється commit-файл, який посилається на батьківський. Відзначимо, що якщо до деяких фрагментів не внесено жодних змін, то альтернативні trees і lists теж посилаються на ці фрагменти. Схематично commit представлений на малюнку 1.21.

<p align="center">
<img src="/resources/img/volume-2/1.5-Architecture-and-features-of-IPFS-protocol/Figure-1.21-Commit-structure-formation-scheme.png" alt="Рисунок 1.21 – Схема формування структури commit" width="50%"/>
<p>

### Використання IPFS

Перераховані принципи функціонування дозволяють будувати ряд децентралізованих застосунків над IPFS.

> **Децентралізовані застосунки над IPFS**
>> * *Месенджери і електронна пошта*
>> * *Медіаплатформи*
>> * *Системи управління версіями (Git)*
>> * *Сайти*

Як не дивно, одними з перших застосунків, побудованих над IPFS, стали саме месенджери. Принцип функціонування таких месенджерів полягає в тому, що спочатку користувач гешує нове повідомлення і відправляє його в мережу. Повідомлення в чаті пов'язані між собою в list, версія якого оновлюється з кожним новим повідомленням (commit). Серед таких можна виділити чат Orbit [11] і PubSub Chat [66].

Звичайно ж, IPFS не міг не використовуватися для мультимедійних застосунків, які передбачали обмін відео і музикою. Протокол IPFS дозволяє створити децентралізовані прототипи YouTube і Google Play Music, де серверами є самі учасники системи. До таких застосунків можна віднести dTube [12].

Система версіонування в IPFS дозволила створення застосунків, для яких потрібно керувати версіями. Уявіть собі децентралізований GitHub, який неможливо цензурувати з боку державних органів або комерційних компаній. Такі проекти вже існують, хоча і набагато менше користуються попитом, ніж централізовані продукти [13].

Ще однією галуззю застосування IPFS є створення децентралізованих сайтів. Замість того, щоб тримати сервер з сайтом, можна створити файл tree з посиланнями на всі його сторінки. Таким чином, маючи значення ідентифікатора файлу tree сайту, кожен користувач може завантажити всі його сторінки (виконувані скрипти можна також помістити в окремі файли).

> **_Зауваження._** *Найцікавіше, що сайт IPFS також доступний в IPFS. *

### Filecoin

Незважаючи на велику кількість переваг, які надає децентралізована система IPFS, у неї залишається одне ключове обмеження, яке дуже сильно перешкоджає впровадженню всіх перерахованих застосунків, – відсутність мотивації користувачів зберігати дані, які не уявляють для них інтерес.

Багато хто з читачів може пригадати ситуацію, коли вони завантажували всі фрагменти торрент-файлу, після чого зупиняли роботу вузла мережі та припиняли роздавати збережуваний контент. І це відноситься до того контенту, який необхідний деякому користувачеві. Що ж тоді казати про ті файли, до яких користувач не має ніякого відношення?

Тому компанія Protocol Labs (до речі, вона ж запропонувала і саму IPFS) представила Filecoin – проект, який здатний в якійсь мірі вирішити цю проблему. Давайте розглянемо основні концепції протоколу.

> * *Учасники мережі платять за зберігання і отримання даних*
> * *Учасники мережі отримують винагороду за зберігання даних*
> * *Заявки на виконання послуг децентралізованої мережі*
> * *Зберігач даних регулярно надає доказ їх зберігання*

Основна ідея Filecoin полягає в тому, щоб учасники системи, які хочуть зберігати свої дані в системі або отримувати доступ до інших даних, оплачували послуги за допомогою вбудованої валюти. Завдання майнеру в цьому випадку – забезпечувати зберігання даних і їх надання за запитом за відповідну плату. Кожен власник вузла-майнера особисто визначає обсяг дискового простору для надання.

Ціна за зберігання фрагмента формується в залежності від попиту та пропозиції. Майнери відправляють свої пропозиції щодо кількості простору, що надаватимуть, і вартості запису. Інші ж користувачі відправляють пропозиції з кількістю монет, які вони готові заплатити за зберігання своїх даних (orders). Після того, як пропозиції зіставляються, учасники створюють транзакцію, в якій клієнт платить майнеру маленькими частинами через певні проміжки часу. Відзначимо, що для отримання винагороди майнер через ці проміжки часу повинен доводити, що контент все ще зберігається у нього.

### Алгоритм досягнення консенсусу в Filecoin

У протоколі Filecoin був запропонований алгоритм досягнення консенсусу proof-of-spacetime, в якому ймовірність видобутку блоку учасником мережі залежить не від обчислювальної потужності його вузла, а від розміру сховища, яке він використовує для зберігання даних (по відношенню до всіх інших учасників мережі). На відміну від класичного proof-of-capacity (детальніше в 5.4), алгоритм досягнення консенсусу в Filecoin передбачає зберігання не довільних даних (непотрібних, необхідних тільки для доказу заповнення сховища), а тих, які необхідні користувачам, тобто корисного контенту.

Кожен вузол мережі, який займається зберіганням даних, бере участь в досягненні консенсусу. При цьому сховище кожного майнера є загальнодоступним, тобто кожен учасник мережі може отримати інформацію про обсяг сховища, що виділив майнер і записати туди свої дані. Також сховище є публічно перевірюваним: для кожного сегмента сховища майнер повинен генерувати proof-of-spacetime для підтвердження того, що він дійсно зберігає відповідні дані (варто зазначити, що такі докази не розкривають ніякої інформації про  контент, що зберігається, тобто це zero-knowledge proof) . У будь-який момент часу майнер може збільшити обсяг сховища і надати його для використання учасникам мережі.

### Переваги протоколу Filecoin

Протокол Filecoin побудований таким чином, що дозволяє досягти ряду властивостей, які необхідні в децентралізованої файлообмінної системі.

> * *Мотивоване зберігання даних і покарання недобросовісних учасників системи*
> * *Кожен учасник мережі може перевірити, що майнер зберігає певні дані (auditability), при цьому не маючи доступ до фактичного вмісту (zero knowledge)*
> * *Можливість доступу до збережених даних з плином часу (retrievability)*
> * *Можливість забезпечення конфіденційності даних (confidentiality)*

Протокол Filecoin передбачає отримання винагороди активними учасниками системи. По-перше, такі учасники отримують винагороду за формування блоків. По-друге, винагорода сплачується за фактичне зберігання корисних даних.

***Найбільш поширені питання***

*– Чи можуть дані, додані в IPFS, бути видалені і скільки це займе часу?*

Так, дані можуть бути видалені, але при цьому існують деякі особливості. Процеси запису і видалення даних в децентралізованій файлообмінній системі сильно відрізняються від таких при використанні централізованого сховища. Особливості полягають в тому, що дані зберігаються декількома незалежними сторонами, і можуть бути видалені, тільки якщо їх видалили всі зберігачі цих даних. Найчастіше у зберігачів даних немає причин зберігати дані, за які вони не отримують винагороду, тому дуже часто процес видалення даних з мережі займає до декількох хвилин або годин. Однак якщо зберігачі з якихось причин не хочуть видаляти дані, то, фактично, вони залишаються в мережі, і їх власник не може вплинути на їх видалення.

*– Чи можуть дані, що додаються в IPFS, бути зашифровані?*

Так, клієнт може зашифрувати дані перед відправкою їх в мережу і, насправді, шифрування даних є поширеною практикою в мережі IPFS. Вузлам не важливо, в якому вигляді і які дані зберігати. Зашифровані дані можуть також бути індексовані і поміщені до мережі. Єдиною відмінністю є можливість доступу до вмісту даних, що зберігаються тільки при наявності відповідного ключа.

*— Чи можна розгорнути на основі IPFS приватну мережу?*

Так, на основі IPFS можна створити приватну мережу [14; 15]. Для цього потрібен власний вузол, який буде з'єднувати клієнтів один з одним (підключатися до публічного немає сенсу, оскільки в такому випадку мережа буде публічною), і swarm key, який буде у всіх учасників мережі. Swarm key – це ідентифікатор, який дозволяє вузлам IPFS підключатися один до одного. Наприклад, якщо два вузли намагаються зв'язатися між собою і у одного з них присутній swarm key, наявність аналогічного ключа перевіряється в іншого вузла. Якщо ключі є і збігаються, вузли з'єднуються між собою.

[КРИПТОГРАФІЯ В ДЕЦЕНТРАЛІЗОВАНИХ СИСТЕМАХ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-2/ua/2-cryptography-in-decentralized-systems.md)
