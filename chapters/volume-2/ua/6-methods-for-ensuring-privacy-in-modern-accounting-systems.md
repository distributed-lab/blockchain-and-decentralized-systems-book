# МЕТОДИ ЗАБЕЗПЕЧЕННЯ ПРИВАТНОСТІ В СУЧАСНИХ ОБЛІКОВИХ СИСТЕМАХ

## 6.1 Стандарти CryptoNote

Основна відмінність сучасних облікових систем – використання криптографічних операцій, зокрема цифрових підписів, для доведення володіння монетами та підтвердження всіх змін бази даних облікової системи. Однак дуже часто використання стандартних криптографічних алгоритмів у деякому сенсі обмежує приватність учасників мережі (простота розплутування ланцюжків транзакцій). У цьому разі доводиться вдаватися до методів, як-от confidential transactions, ring signatures, stealth addresses тощо.

У 2013 році світ побачив серію стандартів CryptoNote, на основі яких побудовані анонімні криптовалюти, такі як Monero, Bytecoin, Karbo та багато інших.

Серія стандартів CryptoNote складається з десяти стандартів, в яких описуються основні концепції побудови анонімної криптовалюти. У стандартах описані технології побудови загальної історії транзакцій, структура блоку і транзакції, використання ключів для формування адрес і підписання транзакцій (використання механізму кільцевого підпису) [51].

У цьому підрозділі ми розглянемо технологічні особливості стандартів CryptoNote, а також розглянемо, як ці концепції застосовуються, на прикладі криптовалюти Monero.

### Підписи в стандарті CryptoNote

Алгоритм підписання транзакцій був описаний в першому з серії стандартів, однак пізніше був замінений на інший (поліпшена версія підпису). CryptoNote описує алгоритм одноразового кільцевого підпису. Такий підхід дозволяє користувачеві підписати транзакцію і зберегти при цьому анонімність, оскільки верифікатор може переконатись, що підпис був вироблений одним з членів групи, не маючи можливості дізнатися, ким саме (детальніше ми розглядали особливості цифрового підпису в підрозділі 2.4). Для запобігання атаки подвійної витрати було вирішено використовувати механізм одноразового підпису (використання зображення особистого ключа).

Повторимо, що таке одноразовий кільцевий підпис і яким чином він обчислюється. Як і для обчислення значення звичайного підпису, користувачеві необхідно мати ключову пару – особистий і відкритий ключі. Однак у разі кільцевого підпису також повинні використовуватися відкриті ключі всіх інших учасників групи. Для чого це потрібно?

При використанні звичайного підпису верифікатор однозначно може зв'язати значення підпису з відповідним відкритим ключем (ідентифікатором користувача), оскільки відкритий ключ використовується для перевірки підпису (рис. 6.1).

<img width="50%" alt="Рисунок 6.1 – Схема функціонування класичного цифрового підпису" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.1-Classic-digital-signature-scheme.png"/> 

Для обчислення кільцевого підпису, крім особистого ключа користувача, необхідно використовувати його відкритий ключ, а також відкриті ключі всіх учасників групи. Кільцевий підпис дозволяє верифікатору переконатися, що підпис сформував один з учасників групи, але, оскільки для верифікації необхідні всі відкриті ключі, сказати точно, хто був підписантом, неможливо (рис. 6.2).

<img width="50%" alt="Рисунок 6.2 – Схема функціонування кільцевого підпису" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.2-Ring-signature-scheme.png"/> 

### Зв'язок ключів й адрес

На відміну від більшості криптовалют, де користувач володіє однією ключовою парою для управління однією адресою / акаунтом, стандарти CryptoNote припускають, що кожен користувач має дві ключові пари. Фактично, користувач генерує два великих секретних значення, які є його особистими ключами. Відкриті ключі так само, як і в інших облікових системах, є добутки цих секретів на значення базової точки. Вони мають назви public spend key та public view key (далі ми розглянемо, чому).

Адреса формується шляхом конкатенації префікса (18 для основної мережі), двох відкритих ключів, а також checksum від попередніх полів (рис. 6.3). Checksum є геш-значенням KECCAK, усіченим до 4 байт. Отриманий результат кодується по Base58 [52].

<img width="42%" alt="Рисунок 6.3 – Схема формування адреси" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.3-Address-formation-scheme.png"/> 

### Stealth addresses

Більшість криптовалют передбачає наявність відкритої адреси/акаунта. Будь-яка третя сторона може зв'язати всі транзакції, які мають відношення до цієї адреси, а відповідно, і до її власника, якщо зв'язок хоча б однієї транзакції і сторони, що бере участь в ній, буде розкрита. За таких умов рекомендується створювати нову адресу для кожного нового вхідного платежу та решти. Однак такий підхід є не найзручнішим, так як він припускає часту генерацію ключів і позбавляє користувача зручності володіння однією адресою/акаунтом.

Стандарти CryptoNote передбачають використання так званих stealth addresses. Доступ до них має тільки власник особистих ключів, причому будь-якій третій стороні складно розкрити зв'язок між звичайною адресою і stealth address. Розглянемо, у який спосіб відбувається формування таких адрес і як користувач отримує доступ до монет, які на такій адресі заблоковані (рис. 6.4).

<img width="50%" alt="Рисунок 6.4 – Схема відправки платежу на stealth address" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.4-Sending-payment-to-the-stealth-address.png"/> 

Попередньо Аліса генерує собі дві ключові пари і формує адресу. Для отримання платежу на першому етапі Аліса відправляє свою адресу Бобу. Боб отримує адресу і виокремлює з неї значення двох відкритих ключів. Після цього Боб генерує одноразове секретне значення _r_ і множить його на базову точку для отримання _R_. Далі Боб використовує отримані значення для формування одноразового відкритого ключа, до якого будуть прив'язані монети; тільки власник відповідного секретного ключа зможе отримати до них доступ. У цьому випадку одноразовий відкритий ключ обчислюється так:

**P = H(r * A<sub>1</sub> || n) * G + A<sub>2</sub> (n – індекс виходу).**

На другому кроці Боб ​​формує свою транзакцію. Він зазначає невитрачені виходи у входах, суму переказу та значення одноразового відкритого ключа у виходах, а значення _R_ у полі extra (розглянемо далі). Після цього, на третьому кроці, Боб відправляє транзакцію для підтвердження її валідаторами.

Позаяк монети відправлені на одноразовий відкритий ключ, а не безпосередньо на адресу Аліси, то вона сама спочатку не знає, які виходи їй належать. Зважаючи на це (четвертий крок) вона перевіряє всі виходи всіх підтверджених транзакцій в пошуках того, який адресований їй. Для кожного з виходів вона обчислює таке значення:

**P' = H(a<sub>1</sub> * R || n) * G +  A<sub>2</sub>.**

Якщо це значення дорівнює зазначеному в виході транзакції _P_, то вихід дійсно належить Алісі. Для його розблокування їй необхідно обчислити відповідний секретний ключ

**p = H(a<sub>1</sub> * R || n) + a<sub>2</sub>**

і підписати наступну транзакцію, яка витрачає цей вихід.

### Механізм захисту від подвійної витрати

Використання кільцевих підписів в чистому вигляді дозволяє користувачеві провести атаку подвійної витрати. Розгляньмо приклад, в якому в мережі є чотири користувача, кожен з яких володіє одним невитраченим виходом (рис. 6.5).

<img width="50%" alt="Рисунок 6.5 – Невитрачені виходи учасників кільця" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.5-Unspent-outputs-of-ring-participants.png"/> 

Кожен вихід закріплений за конкретним відкритим ключем. Для створення кільцевого підпису користувач збирає відкриті ключі з інших невитрачених виходів, після чого формує кільцевий підпис. Наприклад, Аліса хоче відправити собі монети на іншу адресу і формує транзакцію, яку підписує, об'єднуючи відкриті ключі Аліси, Боба і Керол (рис. 6.6).

<img width="40%" alt="Рисунок 6.6 – Формування транзакції Аліси" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.6-Alice’s-transaction-formation.png"/> 

Валідатор може перевірити, чи закріплений за кожним ключем невитрачений вихід і чи свідчить підпис про те, що цей вихід витрачається. Проте водночас валідатор не знає, який саме з цих виходів витрачається. Тому нічого не заважає Алісі створити альтернативну транзакцію, яка витрачає ті самі монети на іншу адресу, після чого підписати її, використовуючи відкриті ключі Боба і Дейва (рис. 6.7).

<img width="40%" alt="Рисунок 6.7 – Спроба Аліси провести атаку подвійний витрати" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.7-Alice-tries-to-perform-a-double-spending-attack.png"/> 

Якщо не введений додатковий механізм захисту, то для валідатора це значення підпису також буде коректним, а отже, кошти будуть переведені двічі. Тому стандарт CryptoNote передбачає використання зображення особистого ключа як засобу забезпечення захисту від атаки подвійної витрати. Фактично, цей механізм дозволяє виявити, чи були кілька підписів обчислені за допомогою одного і того ж особистого ключа, без розкриття самого ключа. Зображенням секретного ключа є його геш-значення, і воно використовується для перевірки підпису, що не дозволяє підмінити його.

Якщо Аліса намагається провернути те саме, валідатор побачить, що підписи були обчислені за допомогою одного і того ж особистого ключа, – і конфліктуюча транзакція буде відхилена.

### Структура блоків в CryptoNote

Стандарти CryptoNote передбачають організацію історії транзакцій в ланцюжок блоків. Кожен блок пов'язаний з попереднім за допомогою унікального ідентифікатора – геш-значення блоку. Розгляньмо детальніше структуру блоку в CryptoNote (рис. 6.8). 

<img width="36%" alt="Рисунок 6.8 – Структура блоку згідно CryptoNote" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.8-Block-structure-according-to-CryptoNote.png"/> 

Як бачимо з рисунку, блок складається з трьох компонентів: заголовка блоку (block header), тіла coinbase транзакції і списку ідентифікаторів включених транзакцій. Відзначимо, що сам блок не містить в собі ніяких даних транзакцій, крім їх ідентифікаторів. Це зроблено для досягнення невеликого розміру блоку, проте повним вузлам все ще необхідно зберігати всі транзакції.

Ключовою відмінністю блоків в Monero і подібних криптовалютах є їх динамічний розмір [53]. Середній розмір блоку в Monero розраховується як середнє значення від розмірів попередніх 100 блоків. Максимальний розмір блоку не може перевищувати середній у більш ніж 2 рази. Також відзначимо, що в протоколі передбачено механізм штрафування майнера за видобуток блоків, розмір яких перевищує середнє значення. Розмір штрафу розраховується так:

**P = R * ((B / M) – 1)<sup>2</sup>**, де
> *P* – розмір штрафу;
> *R* – базова винагорода за видобуток блоку;
> *B* – розмір видобутого блоку;
> *M* – середнє значення розмірів 100 останніх блоків.

Таким чином, якщо сформований блок має максимально припустимий розмір, то винагорода за його створення дорівнює штрафу. Також варто відзначити, що сума штрафу сплачується валідатору наступного сформованого блоку.

Розгляньмо детальніше заголовок блоку і всі його поля (табл. 6.1).

Таблиця 6.1
<img width="50%" alt="Таблиця 6.1" src="/resources/img/volume-2/6.1-CryptoNote-standards/Table-6.1.png"/> 

У полях _minorVersion_ і _majorVersion_ вказуються версії протоколу: відповідно перша і та, яку підтримує вузол-валідатор. В поле _timestamp_ вказується час створення блоку (в форматі UNIX timestamp). Поле _prevID_ містить в собі геш-значення (ідентифікатор) попереднього блоку в ланцюжку, а поле _nonce_ – значення, необхідне для доведення рішення ресурсномісткого завдання.

Крім заголовка і списку ідентифікаторів транзакцій, блок містить тіло coinbase транзакції, яка платить винагороду валідатору. Coinbase транзакція (а саме те, чи відповідає сума винагороди висоті блоку тощо) також повинна бути перевірена іншими учасниками. Структуру coinbase транзакції ми розглянемо трохи згодом.

Розглянемо, яким чином формується ідентифікатор блоку відповідно до стандарту CryptoNote. Для обчислення геш-значення блоку використовується геш-функція CryptoNight. Особливість цієї геш-функції – вимогливість до обсягів необхідної пам'яті (близько 2 MB), що робить використання спеціалізованих інтегральних схем (ASICs) неефективним. На сьогодні Monero використовує CryptoNight v. 2 – алгоритм, який був спроектований в 2017 році компанією Bitmain. Процедура отримання ідентифікатора блоку показана на рисунку 6.9.

<img width="42%" alt="Рисунок 6.9 – Схема формування ідентифікатора блоку" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.9-Block-identifier-generation.png"/> 

Відзначимо, що для отримання значення Merkle Root використовується функція KECCAK-256. Як приклад давайте розглянемо один з підтверджених блоків в мережі Monero (рис. 6.10).

<img width="50%" alt="Рисунок 6.10 – Приклад блоку, сформованого за протоколом Monero" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.10-An-example-of-the-block-generated-by-Monero-protocol.png"/> 

### Структура транзакцій в CryptoNote

Структура транзакцій визначається в четвертій частині серії стандартів. Транзакції в анонімних валютах, побудованих за цим протоколом, схожі за структурою з транзакціями в Bitcoin і будуються за моделлю UTXO (кожна транзакція містить входи – посилання на транзакції, з яких монети були отримані, – і виходи, в яких містяться умови витрати монет).

Кожна транзакція складається з двох компонентів: префікса транзакції і набору підписів. Префікс транзакції містить основні дані транзакції (хто, кому і скільки переводить) і має наступну структуру (табл. 6.2).

Таблиця 6.2
<img width="50%" alt="Таблиця 6.2" src="/resources/img/volume-2/6.1-CryptoNote-standards/Table-6.2.png"/> 

Розгляньмо на прикладі реальної транзакції в Monero її поля (рис. 6.11).

<img width="50%" alt="Рисунок 6.11 – Транзакція в Monero" src="/resources/img/volume-2/6.1-CryptoNote-standards/Figure-6.11-Monero-transaction.png"/> 

У заголовку транзакції є 2 поля: _version_ і _unlock_time_. Перше поле відображає номер версії транзакції. У цьому випадку він дорівнює 2, а значить, транзакція підтримує механізм _ring confidential transaction_. У першій версії протоколу була реалізація тільки одноразового кільцевого підпису для приховування історії походження монет. Впровадження _ring confidential transaction_ дозволило додатково приховувати суми переказів. В поле _unlock_time_ вказується значення часу, після якого транзакція може бути підтверджена.

Далі йдуть входи транзакції. Вхід транзакції містить поля amount, _key_offsets_ і _k_image_. В поле _amount_ міститься кількість монет на вході. У нашому випадку значення _amount_ дорівнює 0, що означає, що сума входу прихована. Поле _key_offsets_ містить індекси зсуву ключів (причому кожен наступний індекс позначає зсув щодо попереднього). Фактично, це індекси на невитрачені виходи в UTXO database. Наявність групи виходів необхідна для формування кільцевого підпису. У нашому випадку _key_offsets_ містить 11 значень. Це означає, що, крім ключової пари відправника, використовується ще 10 відкритих ключів інших користувачів для обчислення кільцевого цифрового підпису. Поле _k_image_ містить значення зображення секретного ключа і дозволяє уникнути атаки подвійної витрати.

За входами розташовані виходи транзакції. У нашому випадку кількість виходів дорівнює 2, кожен з яких містить два поля: _amount_ і _key_. Поле _amount_ містить суму виходу транзакції (в засліпленому вигляді), а _key_ – відкритий ключ одержувача. Як ми зазначали раніше, ключ є одноразовим і ніяка третя сторона не може зв'язати його з головним (master) відкритим ключем одержувача (метод stealth addresses).

Всі інші дані транзакції містять в собі докази того, що транзакція правильна та може бути підтверджена. Фактично, ці докази – цифрові підписи (включаючи дані range proofs і ring signatures). Відзначимо, що розмір цих доказів становить понад 70% розміру транзакції і що середній розмір транзакції в Monero більш ніж у 8 разів перевищує розмір звичайної транзакції в Bitcoin.

## 6.2 MimbleWimble

19 липня 2016 року була опублікована робота під назвою «MIMBLEWIMBLE» [54], яка фактично була протокол побудови мережі з високим рівнем конфіденційності користувачів і високою масштабованістю системи. Трохи пізніше Ендрю Пулстра (Andrew Poelstra), один з найвідоміших у спільноті Bitcoin людей, опублікував більш розлогий документ, у якому описав деталі та технічні особливості протоколу [55].

Які ж проблеми вирішує протокол MimbleWimble? Перша проблема полягає в тому, що більшість цифрових активів вимагають зберігання повної історії транзакцій, яка з часом може тільки збільшуватися. Відповідно, валідаторам необхідно виділяти все більше фізичної пам'яті для зберігання історії транзакцій (інакше повноцінна верифікація транзакцій буде неможлива).

Другою проблемою є складність забезпечення конфіденційності платежів в permissionless системі. Якщо ми візьмемо ту ж облікову систему Bitcoin, то в класичному варіанті в деталях транзакції вказуються відкритий ключ, підпис відправника монет, сума переказу та адреса одержувача. Таким чином, валідатори можуть перевірити, що конкретний користувач володіє монетами, які збирається витратити, а також перевірити те, що сума виходів транзакції не перевищує суму її входів. Відкритість є найважливішою особливістю облікової системи Bitcoin, однак при цьому не забезпечується конфіденційність переказів, а також досить просто деанонімізувати учасників транзакції. Крім того, можна втратити властивість взаємозамінності монет (монети, над якими виконували операції володільці конкретних адрес, можливо виявити з-поміж інших монет).

MimbleWimble поєднує декілька концепцій: _сonfidential transactions_ для забезпечення конфіденційності переказів, _range proofs_ для доведення, що сума конкретного входу та виходу не виходить за певні межі, _CoinJoin_ для заплутування історії монет, а також _cut-through_ для оптимізації збережуваних даних і зменшення розмірів транзакцій і блоків.

> **Особливості MimbleWimble**
>> * _Конфіденційність переказів_
>> * _Простота масштабування_
>> * _Відсутність необхідності зберігати історію транзакцій у повному обсязі_
>> * _Відсутність у деталях транзакції адрес користувачів_

> **_Зауваження._** *Перш ніж приступити до того, як працює протокол MimbleWimble, варто розглянути базові властивості еліптичних кривих.*
> 1. _Незворотність. Операція множення базової точки на скаляр є досить простою операцією, проте отримання скаляру при відомих значеннях результату і базової точки є дуже складним завданням. Маючи значення особистого ключа х і базової точки G, ми можемо досить просто обчислити значення відкритого ключа X = x * G, однак отримати значення особистого ключа з відомого відкритого умовно неможливо._
> 2. _Дистрибутивність. Сума значень двох точок на еліптичній кривій дорівнює сумі скалярів, помножених на значення базової точки: x * G + y * G = (x + y) * G._
> 3. _Комутативність. Зміна порядку множників базової точки не призводить до зміни результату: x * (y * G) = y * (x * G) = x * y * G._
	
### Модель транзакцій MimbleWimble

Як і протокол Bitcoin, MimbleWimble підтримує модель UTXO для проведення транзакцій. Це означає, що транзакція містить в собі набір входів (посилання на попередні виходи і докази володіння ними) і набір виходів, що містять суму переказів і інформацію про нового власника монет. Відзначимо, що виходи витрачаються повністю (не можна витратити тільки частину конкретного виходу), а решта є окремим виходом, довести володіння яким може сам відправник.

Давайте розглянемо приклад, в якому поступово перейдемо від повністю відкритих транзакцій (схожих з транзакціями в Bitcoin) до транзакцій з механізмами забезпечення конфіденційності. Припустимо, Гаррі хоче відправити своїй подрузі Буклі 8 монет. У нього якраз є два невитрачених виходи на 3 та 5 монет. Тоді транзакція буде виглядати так, як зображено на рисунку 6.12.

<img width="40%" alt="Рисунок 6.12 – Незасліплені значення входів і виходів транзакції" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.12-Unblinded-transaction-inputs-and-outputs-values.png"/> 

Для підтвердження транзакції валідатори перевіряють, що Гаррі дійсно володіє виходами попередніх транзакцій, а також що сума виходів транзакції, що підтверджується, не перевищує суми її входів. У цьому прикладі це дуже легко перевірити, так як суми відкриті (все, що потрібно зробити валідаторам, – підсумувати всі входи та виходи та порівняти результат). Однак Гаррі не хоче, щоб хто-небудь із валідаторів знав, скільки монет він передає (особливо Філч зі своєю дивною кішкою). Для цього йому потрібно засліпити (приховати) значення входів і виходів транзакцій.

Для цього протокол MimbleWimble передбачає використання зобов'язань Педерсена для кожного значення входу та виходу транзакції. Зобов'язання Педерсена представляються таким виразом:

**v ∗ H + x ∗ G**, де
*v* – сума конкретного входу або виходу;
*H* – загальновідома точка на еліптичній кривій;
*x* – засліплююче значення (секрет згенерований користувачем);
*G* – ще одна загальновідома точка на еліптичній кривій.

> **_Зауваження._** *На цьому етапі необхідно відзначити, що необхідно використовування додатковий засліплюючий секрет. Якщо ми будемо приховувати передану суму тільки за рахунок множення її на базову точку, властивість незворотності могла б спрацювати, але так як сума переказу обмежена невеликим значенням, друга сторона може підібрати його шляхом перебору і знайти потрібну суму переказу.*

Розгляньмо, як після такої модифікації зміняться значення входів і виходів транзакції. Наприклад, Гаррі, маючи такі ж входи, як в попередньому прикладі, використовує для засліплення секрети 19 і 37. Таким чином, застосовуючи зобов'язання Педерсена, він формує транзакцію так, як на рисунку 6.13.

<img width="40%" alt="Рисунок 6.13 – Засліплені значення входів і виходів транзакції" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.13-Blinded-transaction-input-and-output-values.png"/> 

Тепер суми переказів приховані від валідаторів, проте все ще можна перевірити, що сума виходів не перевищує суму входів:

**(3H + 19G) + (5H + 37G) – (8H + 56G) = 0.**

Утім, така структура транзакцій має одну глобальну проблему: вона вимагає, щоб сума засліплюючих факторів на входах транзакції дорівнювала сумі засліплюючих факторів на її виходах. Відповідно, після відправлення такої транзакції Гаррі знає засліплюючий фактор (секрет) Буклі, а значить, він може вкрасти у неї монети (погодьтеся, не можна давати можливість чинити так з полярною совою) (рис. 6.14).

<img width="30%" alt="Рисунок 6.14 – Схема формування здивованої сови" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.14-The-surprised-owl-formation-scheme.png"/> 

MimbleWimble вирішує й цю проблему. Що, якщо для отримання транзакції Букля також визначить своє секретне значення? Припустимо, Букля згенерувала своє секретне значення, рівне 45. Тоді транзакція виглядає так (рис. 6.15):

<img width="40%" alt="Рисунок 6.15 – Засліплені значення входів і виходів транзакції" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.15-Blinded-values-of-transaction-inputs-and-outputs.png"/> 

При цьому сума виходів і входів дорівнює не 0, як раніше, а

**(3H + 19G) + (5H + 37G) – (8H + 45G) = 11G.**

Як в цьому випадку валідатору перевірити, що транзакція не створює нових монет? Насправді, все досить просто. Якщо сума входів дорівнює сумі виходів, отриманий залишок буде відкритим ключем на G (це можливо, тільки якщо _v_in * H − v_out * H = 0_). Значення, отримане після обчислення (11G), називається _ядром транзакції_.

Для того, щоб підтвердити транзакцію, валідатори повинні перевірити, що це значення дійсно є відкритим ключем на кривій і що сторони спільно володіють загальним секретним ключем від нього. Найпростіший спосіб довести це – цифровий підпис, який можна перевірити за допомогою результуючого відкритим ключем (ядра транзакції). Механізм цифрового підпису в MimbleWimble дозволяє обчислити таке загальне значення сторонам, які володіють частинами загального секретного ключа.

### Докази діапазону

На цьому етапі начебто все збігається. Однак є ще один підводний камінь: така схема працює, тільки якщо значення входів і виходів додатні. Однак у користувача залишається можливість сформувати виходи, один або кілька з яких від’ємні (рис. 6.16).

<img width="40%" alt="Рисунок 6.16 – Засліплені значення входів і виходів транзакції" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.16-Blinded-values-of-transaction-inputs-and-outputs.png"/> 

Як бачимо, в одному з виходів транзакції присутнє від’ємне значення суми переказу, проте загальна сума збігається і для валідатора транзакція коректна:

**(3H + 19G) + (5H + 37G) – (–13H + 25G) – (21H + 7G) = 24G.**

Для доведення того, що суми виходів і входів додатні, а також не перевищують максимальне допустиме значення, використовуються докази діапазону (range proofs), які також є криптографічні зобов'язання. У 2019 році в MimbleWimble як алгоритм формування та перевіряння таких доказів використовуються bulletproofs [56].

### Усі етапи проходження транзакції

Після того, як ми розглянули основні особливості транзакцій в MimbleWimble, проаналізуймо, як така транзакція формується, передається і валідується. Отже, Гаррі має невитрачений вихід на 100 монет і хоче передати Буклі тільки 50. Із залишку монет він хоче сплатити 5 монет комісії і 45 повернути як решту. Тому він формує транзакцію (рис. 6.17) такого типу (V<sub>1</sub> – секрет для розблокування монет, V<sub>2</sub> – секрет для отримання решти, _Х_ – сума входів, виходів і комісії, _m_ – додаткові дані).

<img width="40%" alt="Рисунок 6.17 – Заготовка транзакції, що передається off-chain від відправника одержувачу" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.17-Transaction-template-that-is-transferred-off-chain-from-sender-to-recipient.png"/> 

Також Гаррі готує докази діапазону для кожного з виходів транзакції. Після цього він відправляє отриману транзакцію Буклі.

Букля при отриманні транзакції виконує перевірку полів, після чого генерує власне секретне значення (засліплюючий фактор), формує відкритий ключ і обчислює зобов'язання для виходу, який адресований їй. Услід за цим Букля підписує ядро ​​транзакції, що покриває надмірне значення, комісію та метадані транзакції. Далі Букля повертає Гаррі набір таких значень (рис. 6.18).

<img width="40%" alt="Рисунок 6.18 – Набір даних, який передається від одержувача відправнику" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.18-Dataset-that-recipient-transfers-to-sender.png"/> 

За отримання цього набору даних Гаррі може сформувати остаточну транзакцію і відправити її в мережу для підтвердження. Транзакція складається, фактично, з двох частин: тіла і ядра. Тіло транзакції зберігає значення зобов'язань для всіх входів і виходів транзакції, а також докази діапазону для кожного виходу (рис. 6.19). Ядро транзакції зберігає надмірне значення (загальний відкритий ключ), значення підпису (Гаррі може агрегувати своє значення підпису і значення, яке сформувала Букля), значення комісії та додаткові метадані (якщо вони є).

<img width="35%" alt="Рисунок 6.19 – Структура транзакції" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.19-Transaction-structure.png"/> 

### Перевіряння та поширення транзакції

Коли Гаррі закінчив формування транзакції, він відправляє її одному з валідаторів. Вузлу, який отримав транзакцію, необхідно перевірити, що вона правильна, перш ніж передати її іншим вузлам мережі. Перевірка транзакції виконується наступним чином:

1. Валідатор перевіряє, що всі входи транзакції невитрачені. Кожен повний вузол на підставі історії транзакцій зберігає кінцевий стан у вигляді списку невитрачених виходів. Якщо вихід транзакції Гаррі є в цьому списку, то він може бути успішно втрачений.
2. Валідатор перевіряє, чи знаходяться суми в виходах транзакції у встановленому діапазоні (перевіряє докази діапазону).
3. Валідатор перевіряє, чи дорівнює сума входів сумі виходів і комісії. Для цього йому необхідно скласти всі зобов'язання на входах і виходах транзакції і переконатися, що отримане значення дорівнює надлишковому, а також що надмірне значення є точкою на еліптичній кривій (дійсним відкритим ключем).
4. Слідом за цим перевіряється, чи відповідає підпис ядра транзакції отриманому відкритому ключу.
5. Останніми виконуються системні перевірки, які вже не відносяться до правил протоколу (наприклад, перевіряють, чи відповідає розмір комісії для того, щоб транзакцію підтвердили валідатори).

### Відсутність адрес

У MimbleWimble не використовуються адреси. Кожна транзакція повинна бути ініційована як відправником монет, так і їх одержувачем. Для формування транзакції, сторони спілкуються off-chain безпосередньо один із одним. Відзначимо, що монети не можуть бути передані без участі одержувача (на відміну від того самого Bitcoin, де можна відправляти монети на будь-яку адресу без будь-яких дій від їхнього отримувача).

Під час взаємодії відправник вказує невитрачені виходи, а також їх суми. Одержувач формує вихід, вказуючи обчислене осліплене значення. Після цього вони обидва формують доказ того, що суми виходів не перевищують суми входів, а також докази діапазону.

### Метод сut-through

MimbleWimble використовує метод cut-through для видалення надлишкових виходів, які вказані в тому самому блоці і як входи. Цей метод дозволяє скоротити місце в блоці та зменшити кількість даних, які повинні міститися в ланцюжку блоків. На рисунку 6.20 показано, яким чином відбувається видалення надлишкових виходів.

<img width="50%" alt="Рисунок 6.20 – Варіанти історії до та після видалення надлишковості" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.20-History-versions-before-and-after-the-redundancy-was-removed.png"/> 

Таким чином, валідатори все ще можуть переконатися, що в блоці не було створено нових монет (за винятком винагороди за видобуток блоку), так як суми на входах і виходах врівноважують один одного.

До того ж, таке знищення виходів (скорочення історії передачі монет) може використовуватися не тільки в межах одного блоку, а також між декількома блоками (так як входи одних транзакцій в будь-якому випадку посилаються на виходи попередніх, за винятком coinbase транзакцій). У результаті, розмір ланцюжка блоків може зменшуватися під час функціонування системи, якщо валідатор формує блок з великою кількістю входів (які знищують попередні виходи) і малою кількістю виходів. Тобто валідатори можуть скорочувати входи та виходи, але водночас вони повинні зберігати історію всіх ядер транзакції.

### Структура транзакції та блоку

Блок MimbleWimble складається з заголовка, набору входів, набору виходів і набору ядер транзакцій.

Таблиця 6.3
<img width="50%" alt="Таблиця 6.3" src="/resources/img/volume-2/6.2-MimbleWimble/Table-6.3.png"/> 

Детальніше розглянемо структуру заголовку блоку на прикладі підтвердженого блоку в мережі (рис. 6.21).

<img width="50%" alt="Рисунок 6.21 – Приклад заголовку блоку в Grin" src="/resources/img/volume-2/6.2-MimbleWimble/Figure-6.21-Block-header-example-in-Grin.png"/> 

Отже, кожен заголовок блоку містить версію протоколу, згідно з правилами якого він був сформований. Також заголовок блоку містить геш-значення попереднього блоку та значення Merkle root від полів заголовка попереднього блоку (а якщо точніше, то корінь Merkle mountain ranges [57]). Наступним значенням є мітка часу формування блоку.

Далі йдуть три значення Merkle root: для виходів блоку, для доказів діапазону, для ядер транзакцій. За ними йде набір значень, пов'язаних із розв'язком ресурсоємного завдання: складність,  використовуваний алгоритм тощо. Останнім елементом блоку є агреговане значення ядер всіх валідованих транзакцій.

## 6.3 Вступ до zk-SNARKs

У першій частині навчального посібника ми розглядали, що таке докази з нульовим розголошенням, для чого вони використовуються і які основні відмінності між інтерактивними (які вимагають взаємодії двох сторін і в яких докази не можуть бути верифіковані третьою) і неінтерактивними протоколами (які передбачають, що доказ знання може бути перевірений усіма валідаторами). В цьому розділі же ми спробуємо пояснити принципи функціонування неінтерактивних доказів і їх реальне застосування на прикладі zk-SNARKs.

Свій початок ці конструкції беруть в 2013 році, коли вийшла фундаментальна стаття від декількох математиків з описом роботи так званої квадратичної арифметичної програми (quadratic arithmetic program) [58], що, в свою чергу, стало основою для сучасних конструкцій zk-SNARKs. Сьогодні ж SNARKs складаються з великої кількості складових частин, розібратися в яких необхідно для розуміння функціонування цих конструкцій [74].

> * _Гомоморфне шифрування (homomorphic encryption)_
> * _Сліпе оцінювання полінома (polynomial blind evaluation)_ 
> * _Алгебраїчна схема (algebraic circuit)_
> * _Система обмежень із рангом 1 (rank-1 constraint system)_
> * _Квадратична арифметична програма (quadratic arithmetic program)_

### Принципи гомоморфного шифрування

Гомоморфна криптосистема дозволяє проводити деякі операції над зашифрованими даними для отримання результату. Такі системи використовуються, наприклад, для схем сліпого підпису, які ми розглядали в розділі 2.4. Щоб зрозуміти, яким чином схеми гомоморфного шифрування використовуються для доказів з нульовим розголошенням, для початку необхідно розглянути базові властивості таких схем.

> * _Складність отримання вихідних даних з шифротексту_
> * _Зміна вхідних даних призводить до зміни виходів функції_
> * _При декількох відомих значеннях зашифрованих даних, між ними може бути проведена арифметична операція_

Перша властивість характеризується тим, що третя сторона, маючи зашифроване значення, не може отримати початкове значення. Тобто якщо ми позначимо функцію гомоморфного шифрування як _E(x)_, де _x_ – початкове значення, то сторона, яка отримала результат _E(x)_, не може відновити _x_ (рис. 6.22).

<img width="40%" alt="Рисунок 6.22 – Незворотність функції гомоморфного шифрування" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.22-The-irreversibility-of-the-homomorphic-encryption-function.png"/> 

Друга властивість гарантує, що, якщо вихідні значення не рівні, відповідні зашифровані значення також будуть відрізнятися (за винятком дуже малої ймовірності). Формально це можна визначити в такий спосіб: якщо _x ≠ y_, то й _E(x) ≠ E(y)_.

Остання властивість є найбільш цікавою: сторона, яка має два зашифрованих значення, може провести над ними арифметично правильну операцію, не розкриваючи значення секретів. Таким чином, якщо користувач знає значення _E(x)_ і _E(y)_, то він може, наприклад, отримати і перевірити результат _E(x + y)_, не розкриваючи ні значення _x_, ні значення _y_.

Розглянемо приклад, який ілюструє даний підхід. Наприклад, Аліса хоче довести Бобу, що вона знає два числа, сума яких буде дорівнювати 15. Візьмемо значення секретів _x_ = 13 й _y_ = 2. Сторони спільно визначають модуль _n_ = 17 і значення базової точки _g_ = 3 (як алгоритм шифрування будемо використовувати RSA). Щоб довести Бобу знання цих секретів, вона засліплює їх і отримує два значення, які і передає Бобу: 

*E(x) = g<sup>x</sup> mod n = 3<sup>13</sup> mod 17= 12 mod 17*,
*E(y) = g<sup>y</sup> mod n = 3<sup>2</sup> mod 17 = 9 mod 17*.

Бобу ж, зі свого боку, необхідно переконатися, що сума секретів дійсно дорівнює 15. Для цього він "складає" обидва отримані від Аліси значення наступним чином:

*E(x + y) = g<sup>{x+y}</sup> mod n = g<sup>x</sup>g<sup>y</sup> mod n = 12・9 mod 17 = 6 mod 17*.

Далі він самостійно шифрує відомий результат 15 і порівнює отримані значення:

*E(15) = g<sup>15</sup> mod n = 3<sup>15</sup> mod 17 = 6 mod 17 ⇒ E(x + y) = E(15)*.

Оскільки результати збігаються, Аліса може довести Бобу, що вона знає два числа, які в сумі дають 15, при цьому не розголошуючи цих чисел, а тільки передаючи їх в зашифрованому (засліплення) вигляді. Тому властивості, які ми відзначили раніше, повністю забезпечуються.

Також варто відзначити, що гомоморфні системи також підтримують лінійні операції. Тобто якщо нам необхідно помножити засліплене значення на скаляр, то це виконується наступним чином:

*E(ax) = (g<sup>x</sup>)<sup>a</sup> mod n = E(x)<sup>a</sup>*.

### Стисло про сліпе оцінювання полінома

Для початку нагадаємо, що таке поліном. Поліном представляють в такому вигляді: 

*F(x) = a<sub>0</sub> + a<sub>1</sub>x + a<sub>2</sub>x<sup>2</sup> + ... + a<sub>n-1</sub>x<sup>n-1</sup>*, де
*x*  – змінна, а $а$ – фіксовані коефіцієнти.

Отже, припустимо, що Боб знає конкретний поліном і хоче переконається, що його коефіцієнти також відомі Алісі (яка не хоче розголошувати їх). Для цього він хоче отримати від Аліси засліплене значення _E(F(x))_. Якби не використовувалися докази з нульовим розголошенням, то Боб міг би передати Алісі значення x і отримати _F(x)_. Однак що, якщо Боб не хоче передавати секретне значення Алісі?

Для цього й може використовуватися гомоморфне шифрування, яке ми розглянули раніше. Боб спочатку формує _E(F(x))_ і «запам'ятовує» його для того, щоб порівняти з отриманим від Аліси значенням. Після цього він формує набір засліплених значень компонентів полінома і передає їх Алісі:

*E(1), E(x), E(x<sup>2</sup>) ,..., E(x<sup>n-1</sup>)*.

Відзначимо, що якщо на цьому етапі Аліса знає коефіцієнти полінома, то вона зможе надати коректне значення _E(F(x))_. У який спосіб це відбувається? Ми розглядали раніше, яким чином засліплене значення множиться на скаляр. Так само в цьому випадку Аліса може помножити на відомі їй коефіцієнти засліплені значення, отримані від Боба. У результаті, вона отримає таке значення:

*E(F(x)) =E(1) <sup>a<sub>0</sub></sup> ･ E(x) <sup>a<sub>1</sub></sup> ･ E(x<sub>2</sub>) <sup>a<sub>2</sub></sup> ... E(x<sub>n-1</sub>) <sup>a<sub>n-1</sub></sup>*.

Отримане засліплене значення передається Бобу і порівнюється з раніше розрахованим. Якщо значення збігаються, то Боб гарантовано переконується в тому, що Аліса знає коефіцієнти полінома (за винятком дуже малої ймовірності). При цьому усьому виконуються властивості доказів з нульовим розголошенням: Аліса не дізнається секрет від Боба, не розголошує Бобу значення коефіцієнтів, але переконує його в тому, що знає ці значення.

### Алгебраїчна схема

Поки трохи відійдемо від концепції засліплення поліномів і розглянемо, що таке quadratic arithmetic programs (QAPs) і яке місце вони займають в доказах з нульовим розголошенням. Справа в тому, що, щоб SNARKs і багато інших протоколів могли функціонувати, необхідно певним чином видозмінити вихідну задачу. Для цього і використовуються QAPs [75].

Наприклад, Аліса хоче довести Бобу, що знає одне зі значень x, яке задовольняє наступним рівнянням, при цьому не розголошуючи самого секретного значення: 

*x<sup>2</sup> - x - 6 = 0*.

Це ж рівняння ми можемо представити у формі наступної функції:

<img width="35%" alt="Function" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/function.png"/> 

Фактично, на вхід функції Алісі необхідно подати секретне значення, і якщо вихід функції буде дорівнює 0, то вона доведе, що знає потрібний секрет. Однак в такій формі це не може працювати, так як, для того щоб Боб міг перевірити знання Аліси, він повинен самостійно виконати цю функцію, внаслідок чого йому стане доступним секретне значення.
	
Для створення QAP спочатку необхідно спростити цю функцію, перетворивши її в послідовність операторів, які можуть мати тільки два типи [76]:
1. Оператор присвоєння (=);
2. Арифметичний оператор (+, −, /, *).

Таким чином, ви перетворюєте функцію в набір переходів стану, які можна зобразити як на схемі, так і у вигляді наборів операцій функції (рис 6.23).

<img width="50%" alt="Рисунок 6.23 – Процес спрощення вихідної програми" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.23-The-process-of-initial-program-simplification.png"/> 

### Система обмежень із рангом 1

Тепер ми можемо перетворити отримані стани (спрощену версію коду) в rank-1 constraint system (R1CS). Для цього спочатку нам необхідно сформувати вектор станів (рис. 6.24), який містить в собі всі змінні спрощеної програми і значення 1 (для подання константних значень).

<img width="30%" alt="РРисунок 6.24 – Вектор станів для початкової програми" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.24-The-vector-of-current-program-states.png"/> 

Фактично, R1CS є списоком триплетів векторів (a, b, c), для яких виконується наступна умова:

*< a̲<sup>i</sup> · s̲ > × < b̲<sup>i</sup> · s̲ > - < c̲<sup>i</sup> · s̲ > = 0* (6.1)

Це рівняння має виконуватися для кожного рядка спрощеного коду, тобто контролюється відповідність кожного логічного переходу до нового стану.

> **_Зауваження._** *Операція · позначає множення значень векторів з подальшим складанням результатів. Таким чином, якщо є два вектори a і b, то для них ця операція виконується наступним чином:*
*a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> · (b<sub>1</sub>, b<sub>2</sub>, ..., bn) = a<sub>1</sub>b<sub>1</sub> + a<sub>2</sub>b<sub>2</sub> + ... + a<sub>n</sub>b<sub>n</sub> .*

Відзначимо, що в якості рішення рівняння (6.1) має виступати вектор _s_. Фактично, вектор _s_ є свідченням (witness), і всі його значення можуть бути розраховані за допомогою початкового секрету і операцій спрощеної програми (рис. 6.25). Сторона, якій відомий секрет, може особисто розрахувати всі значення _witness_.

<img width="56%" alt="Рисунок 6.25 – Обчислення вектора witness" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.25-Calculating-the-witness-vector.png"/> 

Виходячи з цього прикладу, сформуємо для першого переходу триплет векторів (рис. 6.26), для яких виконується умова (6.1).

<img width="30%" alt="Рисунок 6.26 – Триплет векторів для першого переходу" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.26-Vector-triplet-for-the-first-transition.png"/> 

Для перевірки правильності формування векторів давайте перевіримо виконання умови. Фактично, потрібно помножити кожен з векторів на вектор рішення _s_, після чого перевірити, що добутки _a · s_ і _b · s_ врівноважуються значенням _c · s_. Процес перевірки зображений на рисунку 6.27.

<img width="40%" alt="Рисунок 6.27 – Процес перевірки правильності вибору векторів для першого переходу" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.27-Checking-the-correctness-of-chosen-vectors-for-the-first-transition.png"/> 

Таким чином, ми можемо помітити, що вектори сформовані правильно і що вони дійсно є відображення першого рядка спрощеної програми. У такий само спосіб нам потрібно сформувати і вектори для двох наступних логічних переходів (рис. 6.28).

<img width="50%" alt="Рисунок 6.28 – Набори векторів для другого і третього переходів" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.28-Vector-sets-for-second-and-third-transitions.png"/> 

На рисунках 6.29 і 6.30, як і в попередньому випадку, зображена перевірка умови (6.1) для другого та третього переходів.

<img width="40%" alt="Рисунок 6.29 – Процес перевірки правильності вибору векторів для другого переходу" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.29-Checking-the-correctness-of-chosen-vectors-for-the-second-transition.png"/> 

<img width="40%" alt="Рисунок 6.30 – Процес перевірки правильності вибору векторів для третього переходу" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.30-Checking-the-correctness-of-chosen-vectors-for-the-third-transition.png"/> 

### Квадратична арифметична програма

Наступним кроком є перетворення структури R1CS в QAP. Нагадаємо, що на цьому етапі у нас є триплет наборів векторів, які відображають зміну стану на кожному етапі виконання програми (рис. 6.31).

<img width="56%" alt="Рисунок 6.31 – Набори векторів для всіх логічних переходів" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.31-Vector-sets-for-all-logical-transitions.png"/> 

Для виконання переходу до QAP необхідно перетворити набір векторів у набір поліномів _A_, _B_ і _С_ [77]. З трьох груп, кожна з яких містить 3 вектори, ми повинні отримати 15 поліномів третього ступеня. Для отримання полінома нам необхідно визначити точки, через які проходить графік, що описується цим полиномом. Далі, використовуючи ці точки (рис. 6.32) і інтерполяцію Лагранжа, ми отримуємо поліноми.

> **_Зауваження._** *За використання інтерполяції Лагранжа поліном обчислюється таким чином:*
<img width="50%" alt="Формула" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/formula-1.png"/>

<img width="40%" alt="Рисунок 6.32 – Набір точок для отримання значень поліномів" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.32-The-set-of-points-for-polynomial-values.png"/> 

Далі на підставі отриманих значень точок, ми перетворюємо вектори в наступний набір поліномів так, як на рисунку 6.33.

<img width="40%" alt="Рисунок 6.33 – Отримання необхідних поліномів" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.33-Obtaining-the-necessary-polynomials.png"/> 

Отриманий набір поліномів є параметри екземпляру QAP. Відзначимо, що всі описані дії виконуються один раз і можуть використовуватися для тієї ж функції повторно. Щоб переконається, що поліноми сформовані правильно, ми можемо провести їх перевірку. Для цього можна спробувати перерахувати вихідні значення при різних (тих, що використовуються) значеннях x (рис. 6.34).

<img width="40%" alt="Рисунок 6.34 – Перевірка правильності обчислення поліномів, що описують перший перехід" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.34-Checking-the-correctness-of-first-transition-polynomials.png"/> 

На рисунку 6.34 ми бачимо, що стан значень поліномів дає той же вектор, який був використаний для першого переходу спрощеної програми. Можна таким же чином перевірити відповідність поліномів триплетів векторів a, b і c для всіх інших переходів.

Для чого ми зробили всі ці перетворення? Справа в тому, що трансформація в QAP дозволяє перетворити рівняння (6.1) в рівняння наступного типу:

*A(x) ∗ B(x) - C(x) = 0*, где (6.2)
*A(x) = ­­­­A̲ ･ s̲, B(x) = B̲ ･ s̲, C(x) = C̲ ･ s̲*.

Відзначимо, що, як і в попередньому випадку, це рівняння буде виконуватися для кожного переходу _(х = 1, 2, 3)_. Однак водночас ми можемо перевірити відповідність нашого witness цьому завданню. Якщо ми змінимо значення witness, наприклад, замість [1, 3, 9, 6, 0] візьмемо [1, 3, 10, 6, 0], то рівність для переходів не виконається (рис. 6.35).

<img width="40%" alt="Рисунок 6.35 – Перевірка відповідності witness першому переходу" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/Figure-6.35-Checking-the-correspondence-of-witness-to-the-first-transition.png"/> 

У цьому випадку ми можемо переконається, що, якщо Аліса надає рішення задачі, Боб, знаючи вихідну програму (тобто значення векторів полиномов A, B і С), може перевірити його коректність.

Таким чином, ми повністю змінюємо структуру нашого початкового завдання, приводячи його до форми QAP, рішенням якої є вектор значень переходів. Однак в цьому випадку Алісі все ще потрібно опублікувати своє секретне значення, щоб переконати Боба в знанні цього значення.

Настав час для ще одного математичного трюку. Цей трюк полягає в тому, що рівняння (6.2) буде задовольняти одночасно усім значенням х, тільки якщо результуючий поліном буде без залишку ділитися на наступний поліном:

<img width="25%" alt="Формула" src="/resources/img/volume-2/6.3-Introduction-to-zk-SNARKs/formula-2.png"/> 

У нашому випадку, так як ми маємо тільки 3 переходи програми, шуканий поліном _Z(x) = (x − 1)(x − 2)(x − 3)_. Таким чином, ми знову можемо перетворити рівняння (6.2) в рівняння наступного типу:

*A(x) ∗ B(x) - C(x) = Z(x) ∗ H(x)*.

У підсумку, перевірка того, чи знає Аліса секрет, спрощується: фактично, їй необхідно довести, що вона знає таке значення _H(x)_, яке задовольняє описаним вище рівняння.

### Спрощений протокол перевірки знання

На підставі розглянутих концепцій давайте розглянемо, у який спосіб Боб перевіряє, чи володіє Аліса знанням секрету. Аліса та Боб узгоджують програму, яка повинна виконається, і на її підставі формують набір поліномів для її перевірки.

Після цього Боб вибирає випадкову точку _x_ (номер переходу), формує поліном _Z(x)_ і засліплює його (ми раніше розглядали, як відбувається цей процес). Отримане значення _E(Z(x))_ він передає Алісі.

Аліса, використовуючи сформований доказ witness, може сформувати поліноми _A(x)_, _B(x)_, _C(x)_ і _H(x)_, що дозволяє довести подільність результуючого полінома на значення, отримане від Боба. Після цього Аліса може засліпити отримані поліноми і передати їх Бобу.

Боб не може розкрити отримані значення. Однак тут йому на допомогу приходять властивості гомоморфного шифрування. Боб може провести операції над засліпленими значеннями і переконатися в тому, що наступне рівняння виконується (якщо Аліса дійсно знає witness):

*E(A(x)B(x) - C(x)) = E(Z(x)･ H(x))*.

Відзначимо, що все розглянуте ще не є zk-SNARKs, а більше схоже на інтерактивну перевірку знання Аліси; однак при цьому відображаються основні концепції, які використовуються для неінтерактивних протоколів доказу з нульовим розголошенням. Для перетворення цього протоколу в неінтерактивний доказ з нульовим розголошенням необхідні додаткові модифікації, які ми розглянемо в наступній частині навчального посібника.

[РОЗВИТОК ДЕЦЕНТРАЛІЗОВАНИХ ТЕХНОЛОГІЙ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-2/ua/7-evolution-of-decentralized-technologies.md)
