# 7 РОЗВИТОК ДЕЦЕНТРАЛІЗОВАНИХ ТЕХНОЛОГІЙ

## 7.1 Будова протоколу Bitshares

Однойменна децентралізована платформа реалізує криптовалюту, смарт-контракти, торговий майданчик і ще багато цікавої функціональності. Bitshares є обліковою системою з хорошим компромісом між децентралізацією та пропускною здатністю [61]. Крім того, протокол Bitshares був узятий за основу в інших децентралізованих системах (Steemit, EOS).

Ідея протоколу Bitshares складається в створенні інструменту, за допомогою якого можна було б торгувати різними активами і валютами в децентралізованому середовищі без фактичного депонування їх на торговельний майданчик. 

### Призначення платформи Bitshares

Daniel Larimer, також відомий під ніком Bytemaster, є головний ідеолог і розробником протоколу. Платформа Bitshares дозволяє кому завгодно створювати user issued assets (UIA), або цифрові токени. Таким чином, на платформі враховується базова валюта, тобто криптовалюта BTS, і безліч користувацьких токенів.

Протокол реалізує децентралізовану біржу, де цими цифровими активами можна торгувати. Під час проектування облікової системи та механізму досягнення консенсусу розробники зробили великий акцент на пропускній здатності.

Bitshares позиціонує себе як платформа смарт-контрактів. Правда, смарт-контракти тут встановлені і їх кількість обмежена (реалізовані найбільш популярні контракти). Утім, вони більш енергоефективні та, відповідно, обходяться дешевше в контексті комісій.

Ще однією особливістю платформи є підтримка платежів із підвищеним рівнем конфіденційності користувачів, які можна використовувати опціонально. У Bitshares ця технологія називається stealth transfers.

### Модель акаунтів

Тепер розглянемо, як влаштовані акаунти в протоколі Bitshares. Тут використовується криптографія на еліптичних кривих, причому сама крива точно така ж, як в протоколі Біткоін. Формат адрес використовує геш-значення відкритого ключа, систему числення за основою 58, префікс BTS і не містить контрольної суми. Але цей формат використовується рідко, оскільки загальна база даних платформи оптимізована таким чином, що кожен об'єкт, зокрема акаунт користувача, має власний унікальний ідентифікатор, який є цілим числом розміром 8 байт (або 64 біт). У звичайних операціях відправки платежу вказується саме такий ідентифікатор акаунту. Крім того, протокол підтримує реєстрацію унікальних імен. Схожу функціональність вперше реалізували в протоколі Namecoin. Таким чином, у Bitshares можна зареєструвати зручний для сприйняття людиною рядок, який буде унікальним у межах відповідного блокчейну, і прив'язати до свого акаунту, щоб використовувати його замість account ID.

### Модель транзакций

Детальніше зупинимося на моделі транзакцій у Bitshares (рис. 7.1).

<img width="55%" alt="Рисунок 7.1 – Структура транзакції в протоколі Bitshares" src="/resources/img/volume-2/7.1-Bitshares-protocol-design/Figure-7.1-Transaction-structure-in-Bitshares-protocol.png"/> 

На схемі видно, що тіло транзакції складається з п'яти основних полів. Перші два поля транзакції необхідні для того, щоб прив'язати її до певного блоку. Це потрібно, щоб визначити ланцюжок блоків, в яку ця транзакція може бути додана, оскільки за правилами протоколу транзакція не може бути підтверджена в тому ланцюжку, до якого не прив'язана. Поле _expiration_time_ задає час, до якого транзакція може бути додана в блок. Якщо вона не була підтверджена до завершення цього періоду, то вона вважається невалідною і вже не може бути включена до ланцюжка блоків.

Поле _operations_veсtor_ особливе. Ця особливість полягає в тому, що в нього можна помістити багато різних операцій. Операція – це ще один ключовий об'єкт в протоколі Bitshares. Назвемо декілька найпопулярніших типів операцій: _transfer (переказ)_, _account_update_ (оновлення акаунта), _asset_issue_ (емісія токена) і _order_ (торгова пропозиція). Кожна операція має свій формат і необхідні параметри. Наприклад, операція _transfer_ вимагає вказівки акаунта відправника, типу активу, суми переказу та акаунта одержувача. Самі операції незалежні один від одного, але можуть бути виконані тільки разом, якщо транзакція буде прийнята.

Поле _extensions_ потрібно, щоб поточна версія ПО могла обробляти транзакції нової версії, де можуть бути додані додаткові поля. Звичайно ж, старе ПО не знатиме, як правильно верифікувати додаткові поля нових транзакцій, але хоча б зможе коректно обробляти транзакції згідно зі старими правилами.

Це формат непідписаної транзакції. Щоб транзакцію правильно підписати, потрібно проаналізувати всі операції з поля _operations_veсtor_ і скласти список акаунтів, які повинні підтвердити дану транзакцію. Тоді стане ясно, якими ключами потрібно підписувати транзакцію. Всі необхідні підписи містяться в окремому полі – _signatures_. Якщо не буде вистачати хоча б одного підпису, то вся транзакція буде вважатися неправильною.

Відзначимо, що за рахунок оптимізації розміру ідентифікаторів, фінальний розмір транзакції, яка містить одну операцію, буде дорівнювати приблизно 100 байт. Це дійсно дуже компактна транзакція в порівнянні з транзакціями в інших протоколах.

Щодо комісій в протоколі Bitshares реалізований особливий підхід. Кожна операція вимагає певну плату, яка знімається з балансу акаунту-ініціатора в момент підтвердження транзакції. Комісія за здійснення операцій може бути постійною, а може змінюватися. Для грубого порівняння можна відзначити, що комісії за звичайні перекази і торгівлю значно нижче, ніж комісії за емісію нових активів і реєстрацію нового акаунта.

### Децентралізований обмін активами

Тепер розберемося, як працює торгівля активами, які емітовані та враховуються на платформі Bitshares. Користувач може створювати транзакцію з такою операцією, де він заявляє, що готовий обміняти один актив на інший в певному співвідношенні на певну суму.

Ця транзакція поширюється мережею й отримує підтвердження, після чого інший користувач може таким же чином заявити, що хоче обміняти ті ж активи в тому ж співвідношенні. У момент підтвердження другої транзакції згідно з протоколом оновлюються баланси цих двох користувачів, тобто відбувається фактичний обмін активами на підставі того, що обидва користувачі підписали заяви щодо обміну, які відповідають один одному.

Оскільки така торгівля здійснюється на базі децентралізованої облікової системи, ця торгова площадка називається децентралізованою біржею. Однак на Bitshares не реалізований механізм cross-exchange, який дозволяє користувачеві обміняти актив не безпосередньо, а через ланцюжок orders.

### Гнучкість управління акаунтами

Ще однією важливою особливістю протоколу Bitshares є можливість гнучкого управління акаунтами. Система динамічних дозволів акаунта (dynamic account permissions) дозволяє задати управління акаунтом по декількох ключах, за принципом мультипідпису. Влаштовано це так, що кожен акаунт може управлятися зваженою комбінацією інших акаунтів або ключів цифрового підпису.

Такий підхід дозволяє створити ієрархічну структуру управління, організація якої подібна до системи дозволів в реальному житті. Виходить, що можна організувати на багато користувачів управління акаунтом і його балансами, де кожен користувач матиме певне політичне значення в прийнятті рішення. При цьому для проведення різних операцій можна встановити різні критерії. Такий механізм управління дозволяє значно знизити ризики крадіжки активів і втрати контролю над акаунтом (рис. 7.2).

<img width="50%" alt="Рисунок 7.2 – Схема динамічного управління акаунтом" src="/resources/img/volume-2/7.1-Bitshares-protocol-design/Figure-7.2-Dynamic-account-management-scheme.png"/> 

Уявімо це схематично. На вершині ієрархії є акаунт, від імені якого неможливо підтвердити транзакцію одним ключем. Це можна зробити тільки з підтвердження кількох інших акаунтів і ключів. Учасників нижніх рівнів ієрархії зазвичай називають підписантами (signers). Кожен з них має свою вагу в підтвердженні операції. Наприклад, за наведеною схемою підписанти мають вагу 25, 40, 35 і 40 одиниць, а необхідний поріг для підтвердження певного типу операцій може бути 50, 60 або 70 одиниць. Водночас для інших типів операцій може мати місце інший розподіл ваг і інше граничне значення.

Як це працює на рівні транзакцій? Один з підписантів створює транзакцію з певними операціями і підтверджує від імені свого акаунта. Операції, які входять в цю транзакцію, не виконуються, а знаходяться в режимі очікування подальшого підтвердження. Тоді інші підписанти бачать пропозицію та можуть або підтвердити, або відхилити її від імені свого акаунту за допомогою транзакцій, що містять спеціальні операції.

### Емісія UIA

Детальніше розберемо особливості емісії призначених для користувача активів на платформі Bitshares. Хто завгодно може сформувати транзакцію з операцією створення нового активу, сплатити певну комісію, задати параметри цього активу і почати емісію відповідних токенів. Ця функціональність протоколу реалізована у вигляді встановленого смарт-контракту і має деякі особливості.

За бажанням емітента можна задовольнити вимогам KYC (Know Your Customer – знай свого клієнта) за допомогою механізму white list (список дозволених акаунтів) і додаткового підтвердження (approve) емітента. White list містить акаунти, яким емітент активу дає дозвіл отримувати і тримати його токени. Механізм додаткового підтвердження дозволяє емітенту контролювати кожну транзакцію з перекладу або торгівлі токенами (він може відхилити або схвалити кожну транзакцію з його активом).

Крім того, емітент може обмежити торгівлю токенами і дозволити тільки зберігання і переклади або обмежити переклади, а дозволити тільки торгівлю. Емітент також може встановити додаткові комісії на переклади та торгівлю токенами.

Ще одна особливість полягає в тому, що емітент може активувати функцію вилучення і перерозподілу токенів. Це працює для випадків, коли потрібно підтримувати зовнішні механізми засудження угод і повернення платежів. Також відзначимо, що всі налаштування користувача активів задаються у вигляді параметрів смарт-контракту і що емітент задає які властивості він може міняти, а які будуть постійними. Наприклад, він може обмежити себе в додатковій емісії токенів, а може залишити можливість довільної емісії. Ці параметри контракту будуть видні всім користувачам.

Цікава властивість токенів, які емітовані на платформі Bitshares, полягає в тому, що при здійсненні операцій з ними користувач може оплачувати комісію або базовою валютою або цими самими токенами. Конвертація виконується на підставі обмінного курсу, який задає емітент.

### Механізм голосувань

За вивчення платформи Bitshares обов'язково потрібно згадати про механізм, який допомагає приймати рішення в децентралізованому середовищі, – щодо голосування. За допомогою голосування обираються члени комітету (committee members), валідатори (witnesses) і розробники (workers). Члени комітету потрібні, щоб голосувати за зміну деяких параметрів протоколу, таких як комісії, кількість валідаторів тощо. Валідатори, або делегати, потрібні, щоб верифікувати транзакції і формувати блоки. Розробники ж пропонують поліпшення ПО; якщо вони набирають достатню кількість голосів і вкладаються в терміни по розробці, то отримують винагороду.

Під час голосування вага голосу кожного акаунта пропорційна його балансу в базовій валюті. При цьому підтримується опція proxy voting, яка дозволяє віддати свій голос іншому виборцю. Це зручно тоді, коли користувач сам не знає, за кого з кандидатів краще голосувати, і віддає це право більш компетентному користувачеві. Загалом, голосування дуже важливе для забезпечення високої надійності платформи Bitshares.

### Механізм комісій

Тепер подивимося на механізм збору комісій за транзакції та винагороди активних учасників мережі. Існує такий баланс, який не належить нікому з користувачів платформи, а розпоряджатися ним можна виключно за правилами протоколу. Цей баланс називається reserve pool. Правила передбачають, що комісії за всі операції з усіх акаунтів потрапляють в reserve pool. На акаунти валідаторів і розробників виплачується винагорода з reserve pool як відсоток від його балансу. Крім цього, на збір і розповсюдження комісій можуть накладатися правила реферальної програми, яку також підтримує платформа (про неї ви можете прочитати окремо) (рис. 7.3).

<img width="50%" alt="Рисунок 7.3 – Схема збору та розповсюдження комісій" src="/resources/img/volume-2/7.1-Bitshares-protocol-design/Figure-7.3-Scheme-of-fees-payments-and-distribution.png"/> 

### SmartCoins

До цього ми говорили про смарт-контракт, який реалізує звичайні токени, а зараз поговоримо про інший смарт-контракт, який реалізує market pegged assets – токени, прив'язані за ціною до якого-небудь зовнішнього активу. Їх також називають SmartCoins. Працює це за принципом контракту на різницю (contract for difference). Відповідно, емітувати ці токени може хто завгодно, просто заморожуючи певну заставну суму, наприклад, в базовій валюті. Коефіцієнт застави значно вище одиниці, а рекомендоване значення – 2 і більше. Тут все працює за принципами маржинальної торгівлі (margin trading), де використовуються margin positions і автоматичні margin calls. Щоб на платформі з'явилися дані про ціну активу на зовнішніх ринках, використовуються довірені сторони, які розміщують дані про ціну активу в блокчейні Bitshares за допомогою операції спеціального типу. Тут цими довіреними сторонами є самі валідатори.

### Формат заголовка блоку

Заголовок блоку в Bitshares має більш просту структуру і менший розмір, ніж заголовок блоку в Біткоіні (рис. 7.4).

<img width="55%" alt="Рисунок 7.4 – Тема блоку в протоколі Bitshares" src="/resources/img/volume-2/7.1-Bitshares-protocol-design/Figure-7.4-Block-header-in-Bitshares-protocol.png"/>

Тут є такі поля: ідентифікатор попереднього блоку, позначка часу, ідентифікатор творця, геш-значення вхідних транзакцій і поле extensions для підтримки сумісності з новими версіями заголовку блоку.

Повний блок включатиме в себе заголовок блоку, підпис валідатора, який створив цей блок, і список транзакцій, що входять до цього блоку.

В рамках протоколу Bitshares є 4 поняття, які грають ключову роль в роботі платформи: блоки, транзакції, операції і об'єкти. Об'єктами тут називають акаунт, актив, баланс, пропозицію тощо.

### Множина операцій і особливості їх виконання

Розглянемо детальніше поняття операції в контексті цього протоколу. У Bitshares на момент 2019 року – близько 40 різних типів операцій; з новими оновленнями протоколу можна додавати нові типи. Операції дозволяють ініціювати деякі прості зміни в обліковій системі та використовувати більш складні механізми, такі як встановлені смарт-контракти. Вище вже було сказано, що одна транзакція може містити кілька операцій, які при успіху будуть виконуватися одночасно.

Тут наведено невеликий список найбільш популярних операцій:

* _transfer_operation_ переказує певний актив з балансу одного акаунта на інший;
* _limit_order_create_operation_ створює об'єкт заявки з обміну активів;
* _limit_order_cancel_operation_ скасовує таку заявку;
* _fill_order_operation_ виконується автоматично, коли дві заявки відповідають один одному; вона не вимагає створення транзакції, тому її також називають віртуальною операцією;
* _account_create_operation_ створює звичайний акаунт користувача;
* _blind_transfer_operation_ здійснює конфіденційний платіж;
* _asset_create_operation_ створює об'єкт нового активу;
* _asset_update_operation_ змінює параметри смарт-контракту існуючого токена;
* _asset_issue_operation_ емітує токени існуючого активу;
* _witness_create_operation_ створює акаунт кандидата валідатора.

Відносно статистики можна сказати, що навантаження на мережу Bitshares за кількістю транзакцій можна порівняти з навантаженням на мережу Bitcoin або Ethereum. Більш того, в деякі моменти 2018 року, платформа Bitshares обробляла більше транзакцій, ніж Bitcoin і Ethereum разом узяті. А результати навантажувального тестування показують, що максимальна пропускна здатність мережі Bitshares у сотні разів перевершує максимальну пропускну здатність мереж Bitcoin і Ethereum.

### Організація бази даних

Тепер розглянемо одну важливу архітектурну особливість протоколу Bitshares, яка допомагає досягти настільки високої пропускної здатності (рис. 7.5).

<img width="50%" alt="Рисунок 7.5 – Способи організації бази даних blockchain і ledger" src="/resources/img/volume-2/7.1-Bitshares-protocol-design/Figure-7.5-Blockchain-and-ledger-database-organization.png"/> 

Зліва на схемі зображено спосіб організації бази даних під назвою blockchain, за допомогою якого зазвичай організовано зберігання всієї історії транзакцій. Справа зображений інший спосіб організації бази даних – ledger. З його допомогою зазвичай організовано зберігання відповідностей між ідентифікаторами та станами (наприклад, акаунт і його баланс).

Властивості blockchain дозволяють легко перевірити цілісність бази даних і історію її змін, а також легко організувати синхронізацію і досягти консенсусу в децентралізованої середовищі.

Ledger зручний тим, що він компактним чином зберігає останній стан бази даних і при цьому забезпечує швидкий пошук, читання і оновлення записів. Саме тому системи, які використовують даний підхід принципово мають більш високу пропускну здатність. Ledger зазвичай застосовують в централізованих облікових системах.

Ідея Bitshares полягає в тому, щоб використовувати переваги обох способів організації бази даних одночасно. Таким чином, повний вузол мережі веде облік одночасно за допомогою двох баз даних, організованих за типом blockchain і ledger відповідно. Водночас вузли синхронізують дані один з одним за допомогою блоків і оновлюють локальну копію blockchain, а верифікацію та прийняття транзакцій вони проводять, орієнтуючись на останній стан бази даних, яка зберігає ledger. Більш того, розмір всіх даних, які становлять ledger, оптимізовані таким чином, що вузли мережі тримають їх в оперативній пам'яті. Це дозволяє істотно прискорити процес верифікації та прийняття нових транзакцій.

### Оптимізація виконання бізнес-логіки

Багато облікових систем використовують мову сценаріїв загального призначення для визначення всіх операцій. Ці облікові системи, в кінцевому підсумку, використовують «бізнес-логічний процесор» як віртуальну машину, і всі транзакції визначаються як скрипти, які будуть запускатися віртуальною машиною. Цей підхід використовує механізми синхронізації потоків реального процесора і об'єднує їх, виконуючи всі інструкції через віртуальний процесор. Віртуальний процесор навіть з компіляцією just-in-time завжди буде повільнішим, ніж реальний процесор, але підсумковий темп обчислень – не єдина проблема підходу, коли все є скриптом.

Коли транзакції визначені на такому низькому рівні, це означає, що велика частина статичних перевірок і криптографічних перетворень залишається в бізнес-логічній обробці і загальна пропускна спроможність падає. Для підвищення продуктивності облікової системи та швидкого виконання бізнес-логіки потрібно винести всі статичні перевірки, в тому числі всі криптографічні перетворення, за рамки модуля бізнес-логіки.

Ще одним кроком оптимізації є зберігання даних кінцевого стану облікової системи в оперативній пам'яті. Це означає, що «бізнес-логічний процесор» може швидко слідувати за вказівниками на області пам'яті і безпосередньо отримувати потрібні йому дані, а не виконувати витратні за часом запити до бази даних. Це також означає, що дані можуть бути доступні без копіювання і змінені прямо на своєму місці. Ця оптимізація забезпечує приріст продуктивності в порівнянні з використанням підходу, заснованого на базі даних.

Таким чином, створення облікової системи з високою продуктивністю не вимагає складних технологій і поділу процесів серед вузлів мережі. Все, що необхідно для створення високопродуктивного вузла-валідатора, – відділення всіх незалежних обчислень від основної бізнес-логіки, виконання її в одному потоці без переривань на синхронізацію і зберігання всіх залежностей верифікації в оперативній пам'яті.

### Опції підвищення конфіденційності користувачів

Вище було відзначено, що облікова система Bitshares використовує акаунти і баланси, на відміну від Bitcoin, де облік ведеться на підставі невитрачених виходів транзакцій (UTXO). Підвищити рівень конфіденційності на платформі Bitshares – це нетривіальне завдання, оскільки в контексті акаунтів і балансів ще простіше деанонімізувати користувачів, ніж в Bitcoin.

Однак розробники Bitshares вирішили це завдання цікавим чином. Вони реалізували можливість задавати кілька входів і виходів в рамках однієї операції. Тепер можна включати багато входів і виходів в одну транзакцію, що ускладнює аналіз грошових потоків і підвищує конфіденційність користувачів.

Крім того, ці операції за замовчуванням використовують методи confidential transactions і stealth addresses. Confidential transactions приховують суми на входах і виходах операції, але при цьому використовують доказ того, що сума виходів не перевищує суму входів. Stealth addresses ж приховує зв'язок між відкритим ключем, що використовується як ідентифікатор одержувача, і конкретною адресою, який вказується в виході транзакції.

У Bitshares за замовчуванням використовуються звичайні (неконфіденційні) платежі, але при бажанні користувачі можуть використовувати stealth transfers. Таким чином, облік монет на платформі ведеться двома різними способами.

Монети може бути переведено з одного способу обліку в інший. Для цього реалізовані окремі операції:
* transfer_to_blind_operation використовується для переказу монет з відкритого обороту в прихований;
* blind_transfer_operation для переказу монет прихованим чином;
* transfer_from_blind_operation для переказу монет з прихованого обороту у відкритий.

Ясна річ, що ці операції за обсягом даних більше звичайних і, відповідно, вимагають більшої комісії.

Примітно, що хто завгодно може порахувати, скільки монет пішло в прихований оборот, тому є поняття stealth supply (кількість монет в прихованому обороті). Але є один практичний недолік опції конфіденційності в Bitshares на даний момент (липень 2019). Справа в тому, що до цих пір немає зручних графічних інтерфейсів для простої роботи в режимі підвищеної конфіденційності.

**Найбільш поширені питання**

*– Чи підтримує Bitshares можливість задання довільних умов витрати монет, наприклад, за допомогою Bitcoin Script?*

Ні, поточна версія протоколу не підтримує таку функціональність. Навряд чи вона буде додана, тому що в Bitshares найзручніше буде створювати нові типи операцій і впроваджувати їх в оновленні протоколу.

## 7.2 Платформа Ethereum і смарт-контракти

Ethereum – це децентралізована платформа, призначена для виконання довільно запрограмованих смарт-контрактів [59]. Проект Ethereum має відкритий вихідний код і досить велику спільноту (розробники, тестувальники, розробники смарт-контрактів, користувачі). Ethereum реалізує розподілену базу даних для зберігання і синхронізації даних про стан акаунтів користувачів і акаунтів смарт-контрактів, а також базову валюту платформи (криптовалюту) ether.

Платформа Ethereum дозволяє розробникам смарт-контрактів створювати довільні децентралізовані додатки з вбудованими економічними функціями. Для програмування смарт-контрактів платформа реалізує власну мову – Solidity.

### Особливості роботи платформи Ethereum

На платформі Ethereum є тільки два типи акаунтів: акаунт користувача й акаунт контракту.

Акаунт користувача управляється тільки особистим ключем цифрового підпису. Власник облікового запису генерує свою пару ключів для електронного підпису за алгоритмом ECDSA. Змінювати стан цього акаунта можуть тільки підписані цим ключем транзакції.

Для акаунта смарт-контракту передбачена інша логіка. Він може управлятися лише за допомогою заздалегідь заданого програмного коду, який повністю визначає поведінку смарт-контракту: як він буде розпоряджатися своїми монетами за певних обставин, з ініціативи якого користувача і за яких додаткових умов ці монети будуть поширюватися. Якщо деякі моменти не передбачені розробниками в програмному коді, можуть виникнути проблеми. Наприклад, смарт-контракт може отримати якийсь певний стан, при якому він не приймає ініціювання подальшого виконання від жодного з користувачів. У такому разі монети, фактично, виявляться заблокованими, тому що смарт-контракт не передбачає виходу з цього стану.

### Створення акаунтів в Ethereum

Важливо відзначити, що Ethereum використовує для цифрового підпису точно такий самий алгоритм і точно таку саму еліптичну криву, як і Bitcoin, але адреса обчислюється дещо іншим чином. Тут вже не застосовується результат подвійного гешування, як у Bitcoin, а передбачено одноразове гешування відкритого ключа функцією KECCAK на довжині 256 біт. Використовуються лише молодші біти отриманого значення, а саме 160 молодших бітів вихідного значення геш-функції. У підсумку ми отримуємо ідентифікатор акаунту в Ethereum із розміром 20 байт.

Відзначимо, що ідентифікатор облікового запису в Ethereum кодується в шістнадцятковій формі без застосування контрольної суми, на відміну від Bitcoin і багатьох інших систем, де адреса кодується в системі числення за основою 58 з додаванням контрольної суми. Це означає, що працювати з ідентифікаторами акаунтів в Ethereum потрібно обережно: навіть одна помилка в ідентифікаторі гарантовано призведе до втрати монет.

Ще одна важлива особливість полягає в тому, що обліковий запис користувача на рівні загальної бази даних створюється в той момент, коли він приймає перший вхідний платіж.

Відносно створення акаунта смарт-контракту застосовується зовсім інший підхід. Спочатку хтось із користувачів пише вихідний код смарт-контракту, після чого код пропускається через спеціальний для платформи Ethereum компілятор і виходить байт-код для віртуальної машини Ethereum. Отриманий байт-код поміщається в спеціальне поле транзакції. Ця транзакція завіряється від імені акаунта ініціатора; далі вона поширюється мережею і розміщує код смарт-контракту. Комісія за проведення транзакції і, відповідно, за виконання контракту знімається з балансу облікового запису ініціатора.

Кожен смарт-контракт обов'язково містить свій конструктор. Він може бути порожнім або містити код аналогічно до конструкторів об’єктів ув об’єктно-орієнтованих мовах програмування. Після того, як конструктор виконується, створюється ідентифікатор облікового запису смарт-контракту, який може бути використано для відправлення монет, викликання методів смарт-контракту тощо.

Всі облікові записи містить в собі чотири поля:

* _nonce_ – лічильник, який відображає кількість підтверджених транзакцій, ініційованих цим акаунтом;
* _balance_ – кількість wei, які належать адресі;
* _storageRoot_ – 256-бітове геш-значення кореневого вузла дерева Merkle Patricia, яке покриває вміст акаунта (в звичайних акаунтах поле пусте, в акаунтах контракту воно зберігає кореневе геш-значення від стану акаунта);
* _codeHash_ – геш-значення коду EVM, тобто значення коду, який виконається при отриманні цією адресою повідомлення виклику. Це поле не може бути змінено після створення облікового запису.

Код EVM – бінарний код смарт-контракту, який виконується на Ethereum virtual machine. Зазвичай смарт-контракт пишеться на Solidity, але віртуальна машина, яка виконує контракт, не розуміє цю мову, тому попередньо необхідно скомпілювати код в машинозчитуваний код EVM.

EVM є stack-based, тобто дані містяться в стек, а оператори [60] працюють безпосередньо зі значеннями в стеці.

### Повідомлення виклику в Ethereum

Контракти в Ethereum можуть відправляти «повідомлення» іншим контрактам. Повідомлення є віртуальні об'єкти, що не серіалізуются й існують тільки в мережі Ethereum. Кожне повідомлення містить таку інформацію:

* відправник повідомлення;
* одержувач повідомлення;
* кількість монет, переданих разом із повідомленням;
* поле для опціональних даних;
* значення STARTGAS (кількість максимальних кроків, які дозволено виконати для проведення транзакції).

Повідомлення дуже схоже на транзакцію, за винятком того, що воно ініціюється контрактом, а не користувачем. Повідомлення генеруються в момент, коли контракт, що виконується, викликає код CALL, який створює і виконує повідомлення.

### Комісійні збори та gas 

На відміну від деяких облікових систем, комісія за транзакції в Ethereum сплачується незалежно від того, чи була транзакція успішно проведена (чи був код що міститься в ній повністю виконаний). Навіть якщо транзакція не була успішно підтверджена, валідатори вже почали її обробку (верифікували і відправили її код на виконання віртуальною машиною); відповідно, ці обчислення повинні бути оплачені.

Максимальна вартість комісії за транзакцію визначається як добуток gasPrice і gasLimit. Параметр gasLimit визначається безпосередньо відправником транзакції і містить максимальну кількість одиниць gas, які готовий заплатити користувач для проведення транзакції. Подібне обмеження необхідно через природу смарт-контрактів в Ethereum. Оскільки Ethereum підтримує повні по Тьюрингу смарт-контракти, то не виключені ситуації, коли через помилку в коді контракт може виконуватися нескінченно (і витрачати всі монети користувача). Фактично, до обробки і підтвердження транзакції неможливо точно сказати, скільки gas вона зажадає для коректного завершення коду, тому що розгалуження в коді смарт-контракту можуть залежати від останнього актуального стану інших акаунтів. При цьому важливо розуміти, що якщо користувач задав недостатню для виконання контракту кількість одиниць gas, які він готовий заплатити, то смарт-контракт не буде до кінця оброблений валідаторами. Відповідно, транзакція не підтвердиться, але користувач усе ж витратить монети на оплату комісії. Відзначимо, що весь невикористаний gas конвертується назад в ether і повертається на баланс облікового запису відправника після коректної обробки транзакції.

Якщо користувач не хоче платити багато за транзакцію (або ж навпаки хоче заплатити більше), то існує параметр gasPrice, в якому ініціатор транзакції визначає кількість wei, які він готовий заплатити за одиницю gas. Що вище це значення, то ймовірніше, що валідатори візьмуться за оброблення транзакції, оскільки її додання до блока набагато вигідніше, ніж додання транзакції з порівняно малим значенням gasPrice. Фактична комісія за транзакцію обчислюється так:

**transactionFee = gas * gasPrice.**

### Структура транзакції в Ethereum

Щоб було зрозуміліше, ми приступимо до розгляду структури транзакції Ethereum і прикладу коду смарт-контракту. Транзакція Ethereum складається з полів, зображених на рис. 7.6.

<img width="50%" alt="Рисунок 7.6 – Структура транзакції в Ethereum" src="/resources/img/volume-2/7.2-Ethereum-platform-and-smart-contracts/Figure-7.6-Ethereum-Transaction.png"/> 

Поле _nonce_ – це деякий порядковий номер транзакції щодо самого акаунта, який її поширює і є її автором. Це потрібно для того, щоб відрізняти двійники транзакцій, тобто виключити ситуацію, коли та сама транзакція приймається двічі. Завдяки наявності такого поля кожна транзакція має унікальне геш-значення.

Далі знаходиться поле _gas price_. Тут указується ціна, за якою базова валюта ether конвертується в gas, яким оплачується виконання команд смарт-контракту і виділення ресурсу віртуальної машини. Що це означає?

У Bitcoin комісії оплачуються безпосередньо в базовій валюті – в біткоіні. Це можливо завдяки простому механізму розрахунку їхнього розміру: ми оплачуємо строго обсяг даних, який міститься в транзакції. У Ethereum ситуація складніша, тому що тільки від обсягу даних транзакції відштовхуватися вже недостатньо. Тут транзакція ще може містити програмний код, який буде запускатися на віртуальній машині, а кожна операція віртуальної машини може мати різну складність і час виконання. Існують також операції, які виділяють пам'ять для змінних і масивів даних. Вони також матимуть певну складність, від якої буде залежати їхня оплата. До того ж, на етапі формування транзакції невідомо, скільки буде операцій і які саме операції будуть виконані в момент прийняття цієї транзакції валідаторами.

Вартість кожної операції в еквіваленті gas буде константною. Він і вводиться спеціально для того, щоб визначити константну вартість кожної операції. Залежно від навантаження на мережу буде встановлюватися параметр gas price, відповідно до значення якого базова валюта буде конвертуватися в gas для оплати комісії.

Є ще одна особливість транзакції в Ethereum: байт-код, який вона містить для виконання у віртуальній машині, буде виконуватися доти, поки він не завершиться з якимось результатом (успішно/неуспішно) або поки не закінчиться обсяг монет, що виділено на оплату комісії. Саме з метою уникнення ситуації, у якій із акаунта відправника через якісь помилки витратилися б усі монети на комісію (наприклад, у віртуальній машині почав виконуватися якийсь нескінченний цикл), передбачено наступне поле – _start gas_ (його часто називають _gas limit_). Воно визначає максимальний обсяг монет, які відправник готовий витратити на виконання певної транзакції.

Наступне поле називається _destination address_. Сюди вписується адреса одержувача монет або адреса конкретного смарт-контракту, методи якого будуть викликатися. Після нього знаходиться поле value, куди вписується сума монет, які відправляються на баланс destination address.

Далі розташовується поле під назвою _data_. Сюди поміщається не просто значення, а ціла структура, в якій визначається код для віртуальної машини. Крім того, в це поле можна поміщати довільні дані; для цього існують спеціальні правила заповнення структури.

І останнє поле транзакції називається _signature_. Воно одночасно містить в собі і цифровий підпис ініціатора цієї транзакції, і відкритий ключ, яким буде перевірятися цей підпис. З відкритого ключа можна отримати ідентифікатор облікового запису (адресу) відправника цієї транзакції, тобто унікально ідентифікувати акаунт відправника в самій системі.

### Оброблення транзакцій

Після відправки будь-якої транзакції до мережі вона потрапляє до mempool кожного вузла, і якщо власники більшості обчислювальної потужності мережі Ethereum приймають її, то потім вона включається в один із нових блоків. Відзначимо, що для підтвердження транзакції в Ethereum має бути сформовано кілька блоків на основі того, який включає дану транзакцію. На практиці ця кількість становить 6-20 блоків. Строго кажучи, кількість підтверджень транзакції визначає сторона, яка буде приймати зміни, що вносяться транзакцією в стан свого акаунта. Наприклад, деяка транзакція додає на баланс облікового запису Аліси 1000 ether (сума чимала), тоді Аліса приймає рішення, що буде чекати 35 блоків, наступних за тим, який підтверджує цю транзакцію.

У кожному блоці Ethereum є щонайменше одна транзакція – нагорода за сформований блок. Ця нагорода так само, як і комісії, видається вузлу-валідатору, який вирішив ресурсоємне завдання першим. Правда, нагорода видається не відразу, а після появи (формування) певної кількості блоків.

Також в Ethereum існує таке поняття, як _uncle blocks_. Uncle blocks – блоки, які були здобуті і відповідають правилам протоколу, але через затримки в мережі (або з інших причин) були отримані вузлами мережі пізніше альтернативних і не можуть бути додані в основну ланцюжок блоків. У Bitcoin такі блоки відкидаються, але в Ethereum вони враховуються: проведені транзакції, які не конфліктують, підтверджуються, але водночас винагорода за знаходження uncle block менша і обчислюється так: *(U<sub>n</sub> + 8 − B<sub>n</sub>) * R / 8*, де _R_ – базова винагорода за блок, U<sub>n</sub>  – висота uncle block, а B<sub>n</sub> – висота останнього видобутого блока.

### Структура блока Ethereum

Блок в Ethereum складається з наступних полів (табл. 7.1).

Таблиця 7.1
<img width="50%" alt="Таблица 7.1" src="/resources/img/volume-2/7.2-Ethereum-platform-and-smart-contracts/Table-7.1.png"/> 

### Ethereum virtual machine 

EVM є важливим компонентом кожного вузла мережі Ethereum незалежно від того, чи є конкретний вузол валідатор або ні, оскільки вона відповідає за обробку стану мережі і виконання всіх необхідних обчислень. EVM відповідає за обробку такої інформації:

* Про баланси
* Про адреси
* Про стан gas
* Про смарт-контракти

Кожен вузол Ethereum запускає EVM для підтримки мережі Ethereum і досягнення консенсусу. Віртуальна машина повинна відстежувати стан перерахованих компонентів для успішної обробки і підтвердження транзакції, які, в свою чергу, впливають на стан децентралізованої облікової системи в цілому.

### Приклад вихідного коду смарт-контракту

Давайте зараз детально розглянемо найпростіший смарт-контракт на прикладі. Це вихідний код примітивного смарт-контракту, який може утримувати монети користувачів і повертати їх за вимогою.

Даний смарт-контракт називається Bank і він виконує наступні функції: накопичує на своєму балансі монети (тобто при підтвердженні транзакції і розміщенні такого смарт-контракту створюється новий акаунт, який може містити на своєму балансі монети); він запам'ятовує користувачів і розподіл монет між ними; має метод поповнення, виведення, а також перевірки балансу користувача (рис. 7.7).

<img width="50%" alt="Рисунок 7.7 – Приклад контракту в Ethereum" src="/resources/img/volume-2/7.2-Ethereum-platform-and-smart-contracts/Figure-7.7-Ethereum-contract-example.png"/> 

Розглянемо цей код рядок за рядком. У цьому контракті є константні поля. Одне з них типу address називається owner. Тут контракт запам'ятовує адресу користувача, який створив цей смарт-контракт. Далі є динамічна структура, яка зберігає в собі відповідності між адресами користувачів і балансами. 

Після цього знаходиться метод Bank – конструктор цього контракту. Тут відбувається присвоєння змінній owner адреси того, хто розмістив цей смарт-контракт на платформі. Структура msg – це саме ті дані, які були передані віртуальній машині разом з транзакцією, що містить весь код цього контракту. Відповідно, msg.sender – це адреса акаунта-ініціатора транзакції, яка розміщує цей код. Він і буде власником смарт-контракту.

Метод deposit дозволяє передати в транзакції певну кількість монет на акаунт контракту. Смарт-контракт, отримуючи ці монети, залишає їх у себе на балансі, але в структуру balances записує, хто саме був відправником цих монет, щоб запам'ятати, кому вони належать.

Метод withdraw приймає один параметр – ту суму монет, яку ініціатор хоче вивести з цього контракту. Тут відбувається перевірка того, чи достатньо монет на балансі користувача, який викликав цей метод, для виведення коштів. Якщо досить, тоді смарт-контракт відправляє на баланс користувача цю кількість монет.

Метод getMyBalance перевіряє поточний баланс користувача. Цільовий баланс зчитується зі структури відповідностей за адресою акаунта, що викликається. Варто відзначити модифікатор цього методу – view. Він позначає, що метод ніяк не змінює змінні свого класу (контракту) і, фактично, є лише методом читання. Окрема транзакція не створюється для виклику цього методу, комісія не сплачується, а всі обчислення виконуються локально, після чого користувач отримує результат.

Також є метод kill. Він потрібен для того, щоб деактивувати контракт і знищити відповідний його стан. Тут прописана додаткова перевірка того, чи є той, хто викликає цей метод, власником цього контракту. Якщо так, тоді контракт самознищується, причому функція самознищення приймає один параметр – ідентифікатор облікового запису, на який контракт відправить всі монети, що залишилися на його балансі. За самознищення контракту всі монети, що залишилися на його балансі, автоматично підуть на баланс власника контракту.

### Виконання контракту на платформі Ethereum

Розглянемо схематично, як виконуються смарт-контракти на платформі Ethereum і як працює повний вузол мережі.

Повний вузол мережі Ethereum повинен мати як мінімум чотири модулі (рис. 7.8).

<img width="50%" alt="Рисунок 7.8 – Модулі повного вузла Ethereum" src="/resources/img/volume-2/7.2-Ethereum-platform-and-smart-contracts/Figure-7.8-Ethereum-Full-Node-Modules.png"/> 

Першим є P2P networking module – модуль підключення до мережі і роботи з іншими вузлами, де йде обмін блоками, транзакціями, інформацією про інші вузли. Це обов'язковий компонент для будь-якої децентралізованої облікової системи.

Далі знаходиться blockchain – модуль зберігання ланцюжка блоків, обробки альтернативних ланцюжків, вибору пріоритетної гілки, доповнення блоків, від'єднання блоків, верифікації тощо.

Наступний модуль називається Ethereum virtual machine. Це і є віртуальна машина, яка приймає байт-код з транзакції в Ethereum. Цей модуль обробляє поточний стан певного облікового запису і виконує зміни його стану на базі отриманого байт-коду. Версія віртуальної машини на кожному з вузлів мережі повинна бути однаковою для отримання одного результату. Обчислення, що відбуваються на кожному вузлі Ethereum, абсолютно однакові, але в мережі вони відбуваються в асинхронному режимі: одні вузли раніше отримують і перевіряють деяку транзакцію, тобто виконують включений в неї код, а інші – пізніше. Відповідно, після свого створення транзакція поширюється в мережу, вузли її приймають і в момент верифікації (по аналогії з виконанням Bitcoin Script для транзакцій в Bitcoin) тут виконується байт-код віртуальної машини.

Транзакція вважається перевіреною, якщо весь код, що міститься в ній, був виконаний, було згенеровано новий стан певного облікового запису і було збережено новий стан доти, поки не буде зрозуміло, чи застосована ця транзакція. Якщо транзакція застосована, тоді цей стан вважається не тільки виконаним, а й актуальним. У кожного вузла мережі є база даних, яка зберігає стан кожного акаунта. З огляду на те, що всі обчислення відбуваються однаково і версія ланцюжка блоків однакова, база даних, яка містить стани всіх акаунтів, для кожного вузла теж буде однаковою.

### Обмеження платформи Ethereum

Давайте розглянемо обмеження, які притаманні схожим на Ethereum платформам смарт-контрактів, і, відповідно, розвіємо деякі міфи. Частина обмежень обумовлена наявністю віртуальної машини на кожному вузлі мережі.

> * _Виконання коду_
> * _Виділення пам'яті_
> * _Доступ до даних тільки з ланцюжка блоків_
> * _Відправлення платежів_
> * _Створення нового контракту_
> * _Виклик інших контрактів_

Дійсно, тут можна виконувати довільні логічні операції. Однак комісія оплачується окремо за кожну операцію і за кожну додатково виділену одиницю об'єму пам'яті.

Віртуальна машина може читати дані з бази даних блокчейна, щоб використовувати ці дані в якості тригеру для виконання тієї чи іншої логіки смарт-контрактів. Віртуальна машина може створювати і відправляти транзакції, створювати нові контракти і викликати методи інших смарт-контрактів, які вже опубліковані в мережі тощо.

Найбільш поширений міф полягає в тому, що смарт-контракти Ethereum можуть використовувати інформацію з будь-яких інтернет-ресурсів у своїх умовах. Правда полягає в тому, що віртуальна машина не може створити запит якомусь зовнішньому інформаційному ресурсу в Інтернеті, тобто не можна написати такий смарт-контракт, який буде розподіляти цінність між користувачами в залежності від того, припустимо, яка погода на вулиці, або того, хто виграв якийсь чемпіонат, або будь-якої іншої події в «зовнішньому світі», тому що даних про ці події просто немає в базі даних самої платформи. Тобто якщо подібні дані не з'являться в блокчейні, то і віртуальна машина не може використовувати їх в якості тригерів.

### Недоліки платформи Ethereum

> * _Помилки в коді (через складнощі при проектуванні і тестуванні)_
> * _Уразливості віртуальної машини_
> * _Складнощі завдання цін на операції_

Перший недолік полягає в тому, що є деякі складності при проектуванні, розробці та тестуванні смарт-контрактів в Ethereum. Практика показує, що причиною дуже великого відсотка помилок стає людський фактор. Це актуально і для вже написаних смарт-контрактів Ethereum, які мають середню або високу складність. Якщо для простих смарт-контрактів ймовірність помилки мала, то в складних смарт-контрактах дуже часто трапляються помилки, які призводять до розкрадання коштів, до їх заморожування, до передчасного знищення смарт-контрактів тощо.

Другий недолік полягає в тому, що сама віртуальна машина створена людьми і не може відусюди бути ідеальною. Вона може виконувати довільні команди – і в цьому криється вразливість: можна певним чином налаштувати ряд команд, помістити їх в транзакцію і відправити на виконання, що призведе до заздалегідь не передбачуваних наслідків. Це дуже складна сфера, але існує вже кілька досліджень, які показують, що ці уразливості є в поточній версії мережі Ethereum і вони можуть призвести до відмови роботи багатьох смарт-контрактів.

Ще одна велика складність, яку можна вважати недоліком, полягає в тому, що можна практично або технічно визначити деякий специфічний порядок операцій, які під час виконання сукупно дуже сильно навантажать віртуальну машину та сповільнять її непропорційно до тієї комісії, яка була сплачена за виконання цих операцій.

У минулому вже був такий період розвитку Ethereum, коли різні дослідники, детально розбираючись у роботі віртуальної машини, знаходили такі уразливості. Фактично, вони платили комісії дуже малого розміру, але на практиці сильно сповільнювали роботу всієї мережі. Такий ефект досягався за рахунок підбору певної послідовності команд віртуальної машини. Ці проблеми вирішуються дуже складно, оскільки  потрібно їх, по-перше, виявити, по-друге, скоригувати ціну за виконання цих операцій і, по-третє, провести hardfork (одночасне оновлення всіх вузлів мережі на нову версію ПЗ і одночасний вступ в дію цих всіх змін).

Що стосується платформи Ethereum загалом, то було проведено дуже багато досліджень і був отриманий дуже великий практичний досвід (як позитивний, так і негативний). Він був використаний при створенні інших децентралізованих платформ смарт-контрактів, таких як Bitshares, EOS. Проте залишаються складності та вразливості, з якими доведеться ще якось боротися.

**Часті запитання**

*– Якщо всі сторони чинного смарт-контракту хочуть змінити умови, чи можуть вони скасувати цей смарт-контракт за допомогою мультипідпису, а потім створити новий смарт-контракт із уже оновленими умовами?*

Тут відповідь буде двоякою. З одного боку, смарт-контракт задається раз, і він надалі не передбачає жодних змін; з іншого боку, він може мати заздалегідь прописану логіку, яка передбачає повну або часткову зміну якихось умов. Тобто якщо ви хочете щось змінити в своєму смарт-контракті після його публікації, то ви заздалегідь повинні прописати умови і додати функціональність заміни, за допомогою чого ви можете здійснювати оновлення вже існуючого контракту. Тільки таким чином можна організувати оновлення контракту. Утім, і тут можна допустити якусь помилку й отримати відповідну вразливість, тому такі дії потрібно дуже ретельно проектувати та тестувати.

*– Чи можна додати медіатора угоди до смарт-контракту? Що станеться, якщо медіатор увійде в змову з одним із учасників смарт-контракту?*

Медіатор необов'язковий у смарт-контракті, але можна передбачити одного або декількох медіаторів угоди. Для цього потрібно заздалегідь включити ідентифікатори медіаторів до контракту і прописати для них окремі методи, які вони будуть викликати для впливу на хід виконання угоди. Медіатори і вибираються таким чином, що їм довіряють одночасно всі залучені в процес сторони. Відповідно, учасники угоди просто не починатимуть взаємодію, переводити монети і викликати методи контракту, якщо він передбачає наявність медіатора, якому вони не довіряють. А всі ризики щодо змови вирішуються збільшенням кількості незалежних медіаторів.

*– Чи можна однією транзакцією Ethereum перевести багато різних токенів зі своєї адреси на різні цільові адреси, наприклад, біржові адреси, для торгівлі цими токенами?*

Це стосується моделі транзакцій в Ethereum і її відмінності від моделі в Bitcoin. Ця відмінність кардинальна. При моделі транзакцій в Ethereum, якщо ви просто переводите монети, конкретна їх сума, яку ви вказали, переказується лише з однієї адреси на іншу адресу без решти і без участі інших адрес. Тобто Ethereum працює не за моделлю невитрачених виходів (UTXO), а по моделі акаунтів і балансів. Отже, однією транзакцією провести кілька платежів не можна – потрібні окремі транзакції. Якщо ж платежі повинні бути в різних токенах, то кожна з транзакцій повинна викликати метод саме того контракту, який займається обліком відповідного токена.

*– В «Обмеженнях платформи Ethereum» було зазначено, що неможливо описати такі умови, які будуть залежати від даних зовнішнього інтернет-ресурсу. Чи можливо якось обійти це обмеження?*

Рішення полягає в тому, що сам смарт-контракт може передбачати одного або декількох так званих оракулів. Це довірені сторони, які збирають дані про стан «зовнішнього світу» і передають їх в смарт-контракти через спеціальні методи. Сам контракт, зі свого боку, повинен обробити всі отримані набори даних, приймаючи за правду ті, які отримані від більшості оракулів. У контракті може бути поставлено такий алгоритм, який не враховує дані від деяких оракулів, які суперечать більшості.

*– Чи можна створити свою платформу з реалізацією своїх власних контрактів? Наскільки це складно та що для цього потрібно?*

Теоретично це, авжеж, можливо, але для цього потрібно вирішити ряд проблем, пов'язаних із таким: розробкою ПЗ вузлів мережі, створенням застосунків користувачів, проектуванням системи мотивації валідаторів, розробкою механізму досягнення консенсусу тощо. Також варто визначити, чи потрібні довільно програмовані смарт-контракти чи достатньо буде реалізувати кілька шаблонів; в іншому разі кожен вузол мережі повинен буде запускати свою віртуальну машину, яку потрібно окремо розробляти. Так чи інакше, створення децентралізованої платформи смарт-контрактів «з нуля» – це дуже складне завдання. Передусім, варто відштовхуватися від вимог, яким повинна задовольняти система; може виявитися так, що простіше зробити клон уже наявної системи та налаштувати параметри під конкретних валідаторів і користувачів.

[ВИСНОВОК](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-2/ua/8-conclusion.md)
