# 2 КРИПТОГРАФІЯ В ДЕЦЕНТРАЛІЗОВАНИХ СИСТЕМАХ

## 2.1 Генерування й оброблення ключових даних

Криптографія на сьогодні має найбільший попит як механізм захисту даних, позаяк вона спирається тільки на математичні закони, а не фізичну захищеність каналів передачі або серверів зберігання інформації. Ефективність криптографії ґрунтується на двох компонентах: стійкість криптографічних алгоритмів і захищеність ключових даних (ключів) [16].

У цьому підрозділі ми розглянемо основні моменти, пов'язані з генеруванням й обробленням ключових даних.

### Основні функції ключів

Перш ніж розглянути основні функції ключів, розберімо, що таке криптографічний ключ. _Криптографічний ключ (cryptographic key) – це бітова послідовність, яка контролює виконання криптографічного перетворення даних (криптографічного алгоритму)_ [17].

> * _Зашифрування даних_
> * _Розшифрування даних_
> * _Обчислення (генерація) цифрового підпису_
> * _Перевірка цифрового підпису_
> * _Верифікація цифрового підпису_
> * _Обчислення MAC (message authentication code)_
> * _Верифікація MAC_
> * _Обчислення загального секрету_
> * _Вироблення додаткових ключових даних_

Розгляньмо, як безпека ключів може вплинути на використання перерахованих криптографічних алгоритмів. Нагадаймо, що за допомогою шифрування можна забезпечити конфіденційність даних (приховування змісту від стороннього спостерігача). Якщо криптографічний алгоритм стійкий, то доступ до вихідного повідомлення (plain text) можна отримати тільки при наявності відповідного ключа розшифрування.

У контексті цифрового підпису ключі також грають важливу роль. Нагадаємо, що користувач за допомогою свого особистого ключа підписує вихідне повідомлення, а друга сторона, використовуючи відкритий ключ користувача, може перевірити підпис. У цьому випадку, якщо зловмисник отримає доступ до особистого ключа користувача, він також зможе відправляти повідомлення від його імені. Можна тільки уявити, до чого це може привести.

Розгляньмо, що таке MAC (Message Authentication Code, код автентифікації повідомлення), і розберемося, чому для цього типу криптографічних алгоритмів важлива надійність криптографічного ключа. Значення MAC концептуально дуже близько до значення цифрового підпису, за винятком того, що MAC обчислюється і перевіряється за допомогою секретного ключа (рис. 2.1).

<img align="center" width="70%" src="/resources/img/volume-2/2.1-Key-data-generation-and-processing/Figure-2.1-MAC-function-operation-scheme.png" alt="Рисунок 2.1 – Схема функціонування MAC-функції"/>

Із пояснення вище (і малюнка) ми бачимо, що секретний ключ задіяний як під час обчислення коду автентифікації повідомлення, так і під час його перевірки. Це означає, що якщо зловмисник отримає ваш ключ, він також зможе відправляти повідомлення від вашого імені.

Ключі використовуються і для формування загального секрету, коли загальний ключ шифрування формується за рахунок використання ключів декількох користувачів.

Ще один варіант використання ключа – вироблення дочірніх ключів, які, в свою чергу, використовуються в перерахованих криптографічних операціях. Такий підхід, наприклад, використовується в HD wallets.

### Життєвий цикл ключа

Криптографічний ключ проходить через послідовність станів, які визначають його життєвий цикл (рис. 2.2). Основними станами є:

* очікування: ключ згенерований, але не активується для використання;
* активний: ключ використовується для криптографічного перетворення інформації;
* постактивний: ключ повинен використовуватися тільки для розшифровки або перевірки.

<img align="center" width="40%" src="/resources/img/volume-2/2.1-Key-data-generation-and-processing/Figure-2.2-The-lifecycle-of-a-key.png" alt="Рисунок 2.2 – Життєвий цикл ключа"/>

Розглянемо процеси, пов'язані з використанням криптографічних ключів:
 * генерація;
 * введення в дію: ключ стає придатним для криптографічних перетворень і поширюється в мережу;
 * призупинення дії: обмеження використання ключа (причиною може бути закінчення терміну дії ключа або його відгук);
 * поновлення дії: раніше неактивний ключ можна знову використовувати для криптографічних перетворень;
 * знищення: завершення життєвого циклу ключа (відбувається логічне знищення ключа).

Спочатку ключові дані повинні бути згенеровані, після чого вони переходять у стан очікування, в якому не використовуються для криптографічних операцій. Якщо протягом тривалого часу такі ключі не були використані, вони можуть бути знищені.

Коли ключі використовуються для криптографічного перетворення даних (шифрування, підпис тощо), вони переходять в активний стан.

Коли ключі знаходяться в постактивному стані, вони можуть використовуватися тільки для розшифрування і перевірки криптографічного підпису (або значення MAC). З цього стану можливий перехід в активний стан (використання ключів для перетворення даних) або їх знищення.

### Принципи генерації ключів

Криптографічні ключі можуть бути отримані декількома способами.
> * _За допомогою генератора випадкових/псевдовипадкових чисел_
> * _Вироблення з іншого ключа (або пароля)_
> * _Узгодження спільного ключа_

### Генератори випадкових послідовностей

Структурно основною відмінністю генератора випадкових послідовностей від генератора псевдовипадкових послідовностей є те, що в першому джерело ентропії обов'язково повинно мати фізичний датчик шуму. Підкидання монети, гральні кістки, оптоелектронні системи стеження за броунівським рухом – ось приклади випадкових механічних переміщень, які знімаються найпростішими фізичними датчиками шуму.

Через цю основну відмінність, генератори випадкових послідовностей переважно реалізовані апаратно. У сучасних генераторах випадкових послідовностей найчастіше використовуються електронні датчики шуму з широким спектром частот. Випадкові зміни параметрів (тепловий шум) спостерігаються в усіх електронних компонентах за температур вище за абсолютний нуль (за Кельвіном), через що фізичні датчики шуму можуть використовуватися будь-які електронні компоненти, як-от резистори, кремнієві діоди, електронні лампи й т. ін. Побудувати добрий апаратний генератор, з незміщеними та некорельованими послідовностями, насправді є складний процес.

### Генератори псевдовипадкових послідовностей

Як ми вже згадували раніше, псевдовипадкова послідовність є послідовністю, характеристики якої наближаються до випадкової послідовності, проте яку можна повторити при певних умовах.

На рисунку 2.3 зображена модель детермінованого (псевдовипадкового) генератора послідовностей. За замовчуванням кожен з елементів, зображених нижче, повинен бути присутнім у генераторі.

<img align="center" width="40%" src="/resources/img/volume-2/2.1-Key-data-generation-and-processing/Figure-2.3-Deterministic-sequence-generator-model.png" alt="Рисунок 2.3 – Модель детермінованого генератора послідовностей"/>

Розглянемо роботу псевдовипадкового генератора послідовностей:

1. Початкове значення завантажується у внутрішній стан спеціальною функцією переходу внутрішнього стану (seed), доступ до якої мають тільки авторизовані суб'єкти.

2. Внутрішній стан модифікується функцією переходу внутрішнього стану, яка приймає в якості вхідних даних нинішній внутрішній стан, будь-які додаткові вхідні дані, надані користувачем, і вихідні дані джерела ентропії.

3. Вихідні дані обчислюються функцією генерації вихідних даних, яка приймає в якості вхідного значення модифікований внутрішній стан.

4. Функція переходу внутрішнього стану (re-seed) оновлює внутрішній стан при подачі нового початкового значення, і в залежності від цієї функції поточний внутрішній стан може як залежати від попереднього, так і не залежати.

Основними вимогами до генераторів псевдовипадкових послідовностей є непередбачуваність, відновність, часова складність, необоротність, статистичні властивості, не відрізнювані від випадкової послідовності, і період повторення, який повинен бути не меншим за необхідний.

### Тестування генераторів випадкових і псевдовипадкових послідовностей

Варто враховувати, що для генераторів випадкових і псевдовипадкових послідовностей потрібна перевірка випадковості результату, який видається.

Розглянемо найбільш поширений серед розробників засобів криптографічного захисту інформації статистичний тест NIST STS, який використовується для оцінки випадковості генераторів випадкових та псевдовипадкових послідовностей. Пакет NIST STS має 15 статистичних тестів, за якими в результаті тестування формується вектор ймовірності
*P = {P<sup>1</sup>, P<sup>2</sup>, …, P<sup>n</sup>}* аналіз складових *P<sup>i</sup>* якого дозволяє вказати на конкретні дефекти випадковості послідовності, що тестується. Список тестів і загальний їх опис вказані в таблиці 2.1 [67].

Таблиця 2.1

| # |  Назва тесту  | Опис тесту |
|:-:|-------------|------------------|
| 1 | _Частотний побітовий тест_|Суть цього тесту полягає у визначенні співвідношення між нулями та одиницями у всій двійковій послідовності. Мета – з'ясувати, чи дійсно число нулів і одиниць в послідовності приблизно однакові.|
| 2 | _Частотний блоковий тест_| Суть тесту – визначення частки одиниць всередині блоку довжиною m біт. Мета – з'ясувати, чи дійсно частота повторення одиниць в блоці довжиною m біт приблизно дорівнює m/2.|
| 3 | _Тест на послідовність_ | Суть полягає в підрахунку повного числа рядів у вихідній послідовності, де під словом «ряд» мається на увазі безперервна послідовність однакових бітів. Мета даного тесту – зробити висновок про те, чи дійсно кількість рядів, що складаються з одиниць і нулів з різними довжинами, відповідає їх кількості у випадковій послідовності.    |
| 4 |_Тест на найдовшу послідовність одиниць в блоці_| В даному тесті визначається найдовший ряд одиниць всередині блоку довжиною m біт. Мета – з'ясувати, чи дійсно довжина такого ряду відповідає очікуваній довжині найдовшого ряду одиниць за абсолютно випадкової послідовності.|
|5  | _Тест рангів бінарних матриць_  | Тут проводиться розрахунок рангів непересічних підматриць, побудованих з вихідної двійкової послідовності. Метою цього тесту є перевірка на лінійну залежність підрядків фіксованої довжини, що становлять первісну послідовність. |
|6  | _Спектральний тест_  | Суть тесту полягає в оцінці висоти піків дискретного перетворення Фур'є вихідної послідовності. Мета – виявлення періодичних властивостей вхідної послідовності, наприклад, близько розташованих один до одного повторюваних ділянок.|
|7  | _Тест на збіг шаблонів, що не перекриваються_ |  В даному тесті підраховується кількість заздалегідь визначених шаблонів, знайдених у вихідній послідовності. Мета – виявити генератори випадкових або псевдовипадкових чисел, що формують занадто часто задані неперіодичні шаблони.|
|8  | _Тест на збіг шаблонів, що перекриваються_   | Суть даного тесту полягає в підрахунку кількості заздалегідь визначених шаблонів, знайдених у вихідній послідовності. Різниця між цим тестом і тестом № 7 полягає лише в тому, що якщо шаблон знайдений, вікно переміщається тільки на біт вперед, після чого пошук триває далі.|
|9  |_Універсальний статистичний тест Маурера_  | Тут визначається число біт між однаковими шаблонами у вихідній послідовності (міра, що має безпосереднє відношення до довжини стислій послідовності). Мета тесту – з'ясувати, чи може дана послідовність бути значно стиснута без втрат інформації. |
|10  | _Тест на лінійну складність_ | В основі тесту лежить принцип роботи лінійного регістра зсуву зі зворотним зв'язком (Linear Feedback Shift Register, LFSR). Мета – з'ясувати, чи є вхідна послідовність досить складною для того, щоб вважатися абсолютно випадковою.|
|11  | _Тест на періодичність_  | Даний тест полягає в підрахунку частоти всіх можливих перекривання шаблонів довжини m біт протягом вихідної послідовності бітів. Метою є визначення того, чи дійсно кількість появ 2m шаблонів, що перекриваються, довжиною m біт приблизно така ж, як за абсолютно випадкової вхідної послідовності біт.|
|12  |_Тест приблизної ентропії_   | Як і в тесті на періодичність, в цьому тесті акцент робиться на підрахунку частоти всіх можливих перекриттях шаблонів довжини m біт протягом вихідної послідовності бітів. Мета тесту – порівняти частоти перекривання двох послідовних блоків вихідної послідовності з довжинами m і m+1 з частотами перекривання аналогічних блоків ув абсолютно випадковій послідовності.|
|13  | _Тест кумулятивних сум_  | Тест полягає в максимальному відхиленні (від нуля) при довільному обході, що визначаються кумулятивною сумою заданих (-1, +1) цифр в послідовності. Мета даного тесту – визначити, чи є кумулятивна сума часткових послідовностей, що виникають у вхідній послідовності, занадто великою або занадто малою порівняно з очікуваною поведінкою такої суми для абсолютно випадковою вхідної послідовності. |
|14  | _Тест на довільні відхилення_ | Суть даного тесту полягає в підрахунку числа циклів, що мають строго k входжень за довільного обходу кумулятивної суми. Мета даного тесту – визначити, чи відрізняється кількість входжень певного стану всередині циклу від аналогічної кількості в разі абсолютно випадкової вхідної послідовності. |
|15  | _Інший тест на довільні відхилення_  | У цьому тесті підраховується загальна кількість входжень певного стану за довільного обходу кумулятивної суми. Мета – визначення відхилень від очікуваної кількості входження різних станів за довільного обходу. |

### Функції вироблення ключів

_Функція вироблення ключів (Key Derivation Function, KDF) – це функція, що формує один або кілька секретних ключів на основі певного секретного значення за допомогою псевдовипадкової функції_. Принципи роботи таких функцій дуже схожі на принципи роботи геш-функцій, тобто функція вироблення ключів є односпрямованою (дуже часто в якості псевдовипадкової функції використовують memory resistance криптографічні геш-функції). Односпрямованість функцій вироблення ключів не дозволяє дізнатися інформацію про початкове секретне значення або про будь-який з інших сформованих ключів.

Функції вироблення ключа на основі пароля часто використовуються для гешування паролів і їх подальшої верифікації. У цьому випадку в якості параметра, який використовується в зв'язці з секретним паролем, використовується значення salt.

**Найбільш поширені запитання**

*– Наскільки безпечно використовувати пароль для вироблення секретного ключа?*

Для вироблення ключових даних з пароля рекомендується використовувати випадковий пароль великої довжини. Таким чином, якщо ви використовуєте випадковий пароль великої довжини, наприклад, в 20 символів (при цьому використовуєте верхній і нижній регістри і числові значення), то фактично для перебору цього пароля і отримання ключової інформації зловмиснику знадобиться близько $2^{120}$ спроб, що цілком відповідає вимогам безпеки (особливо при використанні memory resistance геш-функцій). Однак на практиці такий пароль дуже складно запам'ятовувати, і дуже часто користувачі використовують набагато менші значення, які, до того ж, не є випадковими, а асоціюються з датою народження, прізвиськом домашньої тварини тощо.

*– Які ще існують тести випадкових послідовностей крім NIST STS?*

Крім NIST STS існує багато різних тестів генераторів випадкових послідовностей. Ось найвідоміші з них:

* Diehard: «класичний» набір статистичних тестів, розроблений George Marsaglia і вперше опублікований в 1995-му році.
* TestU01: набір статистичних тестів, який можна порівняти з Diehard. Містить реалізацію «класичних» і кілька сторонніх, запропонованих в літературі статистичних тестів.
* Dieharder: набір статистичних тестів, що включає в себе всі тести з Diehard, NIST STS і кілька додаткових тестів, розроблених RGB.

*– Що таке атака компромісу часу і пам'яті?*

Компроміс часу і пам'яті – це підхід, який дозволяє збільшити або зменшити час обчислень за рахунок, відповідно, зменшення або збільшення обсягу використовуваної пам'яті. У криптографії атака на основі компромісу часу і пам'яті використовується для скорочення часу атаки грубої сили. Як приклад можна привести таблиці пошуку прообразу геш-функції. Якщо спочатку виконати вичерпний перебір, можна зберігати отримані значення в пам'яті, здійснюючи наступний перебір практично миттєво.

## 2.2 Протоколи обмінювання ключами

Одна з головних задач під час обмінювання ключами або іншою інформацією – здійснити обмінювання так, щоби жодна неавторизована сторона не могла отримати доступ до змісту даних у каналі. Зазвичай це вимагає наявності довіреної третьої сторони чи іншого безпечного каналу.

_Протоколи обмінювання ключами (key exchange protocols)_ використовуються для створення захищеного каналу зв'язку між користувачами. Вони включають протоколи розподілення ключів і протоколи узгодження ключів.

_Протокол узгодження ключів (key agreement protocol)_ – встановлена ​​послідовність дій користувачів зі створення захищеного каналу зв'язку шляхом формування загального секретного ключа. Основна особливість полягає в тому, що кожна сторона вносить однаковий внесок у створення загального секретного ключа.

_Протокол розподілення ключів (key distribution protocol)_ – це встановлена ​​послідовність дій користувачів по створенню захищеного каналу зв'язку, яка полягає в генеруванні й обмінюванні сеансовими ключами і аутентифікації повідомлень.

Основним завданням протоколів розподілення ключів є вироблення учасниками (Алісою і Бобом) загального ключа. Разом з тим, і Боб, і Аліса повинні бути впевнені в тому, що зв'язок ведеться саме з співрозмовником, а не зі зловмисником або підставною особою. Такі протоколи здебільшого ґрунтуються на наявності довіреного центру (Трент), і передбачається, що кожному користувачу Трент виділяє секретний ключ. Таким чином, перед початком роботи протоколу всі ключі вже перебувають у користувачів.

Усі протоколи розподілення ключів так чи інакше діляться на наступні категорії (що перетинаються):
> * *Протоколи, базовані на симетричній криптографії*
> * *Протоколи, базовані на асиметричній криптографії*
> * *Протоколи, що використовують центр сертифікації (довірений центр)*

Також існують такі моделі розподілення ключів:
> * *Передача ключів за особистої зустрічі*
> * *За допомогою попереднього ключа*
> * *За допомогою довіреної третьої сторони*

Однак зазначимо, що всі ці методи в кінцевому рахунку зводяться до особистої зустрічі суб'єктів.

При симетричному шифруванні два учасники, які хочуть обмінюватися конфіденційною інформацією, повинні мати один і той же ключ. Частота зміни ключа повинна бути досить великою, щоб у супротивника не вистачило часу для повного перебору ключа. Отже, стійкість будь-якої криптосистеми багато в чому залежить від технології розподілення ключа. Цей термін означає передачу ключа двом учасникам, які хочуть обмінюватися даними таким способом, щоб ніхто інший не міг ні перехопити, ні змінити цей ключ. Для двох учасників, Аліси і Боба, розподіл ключа може бути виконаний одним із таких способів:

> * _Ключ може бути створений Алісою і фізично переданий Бобу (або навпаки)_
> * _Третя сторона може створити ключ і фізично передати його Алісі та Бобу_
> * _Аліса і Боб мають попередньо створений і недовго використовуваний ключ; один учасник може передати новий ключ іншому, застосувавши для шифрування старий ключ_
> * _Якщо і Аліса, і Боб мають безпечне з'єднання з третім учасником (Керол), то він може передати ключ з цього безпечного каналу від Аліси до Боба_

Перший і другий способи називаються ручним розподілом ключа. Це найбільш надійні способи розподілення ключа, однак у багатьох випадках користуватися ними незручно або навіть неможливо. У розподіленій системі будь-який вузол або сервер повинен мати можливість обмінюватися конфіденційною інформацією з багатьма автентифікованими вузлами і серверами. Таким чином, кожен вузол повинен мати набір ключів, який динамічно підтримується. Проблема особливо актуальна у великих розподілених системах.

Кількість необхідних ключів залежить від числа учасників, які повинні взаємодіяти. Якщо виконується шифрування на мережевому або транспортному рівні, то ключ необхідний для кожної пари вузлів в мережі. Таким чином, якщо є _N_ вузлів, то необхідне число ключів дорівнює $\frac{N(N-1)}{2}$. Якщо шифрування виконується на прикладному рівні, то ключ потрібен для кожної пари прикладних процесів, яких набагато більше, ніж вузлів.

Третій спосіб розподілення ключів може застосовуватися на будь-якому рівні стека протоколів, але якщо атакуючий отримує можливість доступу до одного ключа, то вся наступна послідовність ключів буде розкрита. Більш того, все одно має бути проведено початкове розповсюдження великої кількості ключів.

Тому у великих автоматизованих системах широко застосовуються різні варіанти четвертого способу. У цій схемі передбачається існування так званого _центру розподілення ключів_ (Key Distribution Centre, KDC), який відповідає за розподіл ключів для вузлів, процесів і додатків. Кожен учасник повинен розділяти унікальний ключ з KDC.

Використання центру розподілення ключів засноване на використанні ієрархії ключів. Як мінімум використовується два типи ключів: майстер-ключі і ключі сесії.

Для забезпечення конфіденційного зв'язку між кінцевими системами використовується тимчасовий ключ, званий ключем сесії. Зазвичай ключ сесії використовується для шифрування з'єднання на транспортному рівні і потім знищується. Кожен ключ сесії повинен бути отриманий по мережі з центру розподілення ключів. Ключі сесії передаються в зашифрованому вигляді, використовуючи майстер-ключ, який встановлюється між центром розподілення ключів і кінцевими користувачами.

Ці майстер-ключі також повинні розподілятися у деякий безпечний спосіб. Однак водночас істотно зменшується кількість ключів, які потребують ручного розподілення. Якщо є _N_ учасників, які хочуть встановлювати з'єднання, то в кожен момент часу необхідно $\frac{N(N-1)}{2}$ ключів сесії, але тільки _N_ майстер-ключів (по одному для кожного учасника).

Час життя ключа сесії, як правило, дорівнює часу життя самої сесії. Чим частіше змінюються ключі сесії, тим більш безпечними вони є, так як противник має менше часу для злому ключа поточної сесії. З іншого боку, розподіл ключів сесії затримує початок будь-якого обміну і завантажує мережу. Політика безпеки повинна збалансувати ці умови для визначення оптимального часу життя конкретного ключа сесії.

Якщо з'єднання має довгий час життя, то повинна існувати можливість періодично змінювати ключ сесії.

Для протоколів, які не підтримують з'єднання, таких як протокол, орієнтований на транзакції, немає явної ініціалізації або переривання з'єднання. Отже, невідомо, як часто треба змінювати ключ сесії. Більшість підходів грунтується на використанні нового ключа сесії для кожного нового обміну. Найбільш часто застосовується стратегія використання ключа сесії тільки для фіксованого періоду часу або тільки для певної кількості підписуються повідомлень.

### Протокол Діффі–Хеллмана

Протокол Діффі–Хеллмана (Diffie–Hellman, DH) – криптографічний протокол узгодження ключів, що дозволяє двом (чи більшій кількості) сторонам отримати загальний секретний ключ, використовуючи не захищений від прослуховування канал зв'язку. Отриманий ключ використовується для шифрування подальшого обміну за допомогою алгоритмів симетричного шифрування.

Схема розподілення відкритих ключів, яку запропонували Бейлі Вітфілд Діффі та Мартін Едвард Хеллман, здійснила справжню революцію в світі шифрування, так як знімала основну проблему класичної криптографії – проблему розподілення ключів.

У чистому вигляді протокол Діффі–Хеллмана вразливий для модифікації даних в каналі зв'язку, в тому числі для атаки man-in-the-middle (людина посередині), тому схеми з його використанням застосовують додаткові методи односторонньої або двосторонньої автентифікації.

Розглянемо протокол Діффі–Хеллмана, який використовується при формуванні загального секрету довгострокових ключів. У криптосистемі існують два великих простих числа як загальнодоступні параметри p і g (p – значення модуля, g – генератор групи).

Уявімо, що є канал передачі між трьома суб'єктами: Алісою, Бобом і Керол. Алісі і Бобу потрібно створити загальний секрет, який не знатиме Керол, яка при цьому бачить все, що вони передають по каналу зв'язку. Для створення загального секрету:
1. Аліса і Боб випадковим чином формують особисті ключі _1 < a < p_ (Аліса) і _1 < b < p_ (Боб).
2. За допомогою особистих ключів кожен з них створює свій відкритий ключ *A = q<sup>a</sup> mod p* (Аліса), *B = q<sup>b</sup> mod p* (Боб).
3. Потім передають їх по каналу передачі даних.
4. Обмінявшись відкритими ключами, Аліса і Боб можуть сформувати загальний секрет *S = B<sup>a</sup> mod p = A<sup>b</sup> mod p = g<sup>ab</sup> mod p* (рис. 2.4).

<img align="center" width="50%" src="/resources/img/volume-2/2.2-Key-exchange-protocols/Figure-2.4-Diffie-Hellman-protocol-operation-scheme.png" alt="Рисунок 2.4 – Схема функціонування протоколу Діффі–Хеллмана"/>                     

Використовуючи загальний секрет _S_ і одну функцію формування ключа (тут назвемо її _fk_), кожен з абонентів може сформувати узгоджений ключ _K_, наприклад, _K = fk(S, par)_, де par – це параметри узгодженого ключа. Більшої криптографічного стійкості можна досягти, окремо формуючи за тим же принципом сеансові ключі при кожному сеансі зв'язку.

Відзначимо, що даний алгоритм вразливий для атак man-in-the-middle. Якщо противник може здійснити активну атаку, тобто має можливість не тільки перехоплювати повідомлення, але і підміняти їх іншими, він може перехопити відкриті ключі учасників _A_ та _B_, створити свою пару відкритого і закритого ключа і надіслати кожному з учасників свій відкритий ключ. Після цього кожен учасник визначить ключ, який буде спільним з противником, а не з іншим учасником. Якщо немає контролю цілісності, то учасники не зможуть виявити подібну підміну. Здійснення такої атаки вимагає великого обсягу ресурсів, і в реальному світі такі атаки відбуваються рідко.

### Протокол Діффі–Хеллмана на еліптичних кривих

Також протокол Діффі–Хеллмана може працювати на еліптичних кривих (ECDH). В цьому випадку Аліса і Боб мають по секретному ключа _а_, _b_ і з відкритого ключа *Q<sub>a</sub>*, *Q<sub>b</sub>*. Кожен з відкритих ключів сформований шляхом проведення _n_-ї кількості операцій додавання точки _G_.

1. Аліса і Боб формують відкриті ключі: *Q<sub>a</sub> = а ∗ G*, *Q<sub>b</sub> = b ∗ G*.
2. Аліса і Боб обмінюються відкритими ключами.
3. Отримавши відкриті ключі один-одного, кожен з них обчислює (*X<sub>s</sub>*, *Y<sub>s</sub>*) = *a ∗ Q<sub>b</sub> = b ∗ Q<sub>a</sub> = a ∗ b ∗ G*, де точка *X<sub>s</sub>* є загальним секретом. Більшість стандартних протоколів, що базуються на ECDH, використовують функції формування ключа для отримання симетричного ключа зі значення *X<sub>s</sub>* (рис. 2.5).

<img align="center" width="50%" src="/resources/img/volume-2/2.2-Key-exchange-protocols/Figure-2.5-Scheme-of-interaction-according-to-ECDH-protocol.png" alt="Рисунок 2.5 – Схема взаємодії по протоколу ECDH"/>                     

З усієї інформації, пов'язаної з секретним ключем, Аліса і Боб розголошують тільки свої відкриті ключі. Щоб Керол дізналася загальний секрет, а також секретні ключі Аліси і Боба, їй знадобиться вирішити задачу дискретного логарифмування на еліптичній кривій, що може зайняти досить тривалий проміжок часу.

### Протокол EKE

Протокол EKE (Encrypted Key Exchange) є протоколом розподілення ключів, який надає можливість захищеного обмінювання даними між користувачами в мережі, використовуючи симетричну і асиметричну криптографію. Протоколом передбачається, що Аліса і Боб володіють загальним секретом _S_ (даний секрет може бути навіть з низькою ентропією, наприклад, пароль) і що, використовуючи цей протокол, вони можуть автентифікувати один одного і сформувати сесійний ключ _K_ (рис. 2.6).

<img align="center" width="50%" src="/resources/img/volume-2/2.2-Key-exchange-protocols/Figure-2.6-Scheme-of-operation-of-the-EKE-protocol-participants.png" alt="Рисунок 2.6 – Схема роботи учасників протоколу EKE"/>    

Давайте опишемо кожен з кроків функціонування протоколу:

1. Аліса генерує ключову пару і шифрує відкритий ключ _A_ з цієї пари загальним секретним ключем _S_. Після цього Аліса посилає зашифроване повідомлення Бобу. Варто зазначити, що відкритий ключ _A_ передається в зашифрованому вигляді для того, щоб тільки Боб мав можливість сформувати зашифроване на цьому ключі повідомлення.
2. Боб, отримавши повідомлення від Аліси, розшифровує його і дізнається _A_, після чого він генерує симетричний ключ _K_, який і буде їхнім спільним з Алісою сесійним ключем. Боб шифрує _K_ отриманим від Аліси ключем _A_, а потім загальним секретним ключем _S_.
3. Аліса, отримавши відповідь від Боба, розшифровує це повідомлення і дізнається з нього сесійний ключ _K_. Після встановлення сесійного ключа починається процес взаємної автентифікації. Аліса генерує випадкове значення *R<sub>a</sub>*, шифрує його з допомогою _K_ і посилає Бобу.
4. Боб розшифровує це повідомлення, дізнається з нього *R<sub>a</sub>* і генерує своє випадкове значення *R<sub>b</sub>*. Далі Боб конкатенує *R<sub>b</sub>* з *R<sub>a</sub>* і шифрує результат ключем _K_. Після чого передає отримане значення Алісі.
5. Аліса розшифровує повідомлення Боба, переконується, що *R<sub>a</sub>* таке ж, яке вона посилала Бобу на кроці 3, і відповідає Бобу зашифрованим за допомогою _K_ повідомленням з його *R<sub>b</sub>*.
6. Боб розшифровує відповідь Аліси і переконується, що *R<sub>b</sub>* таке ж, яке він посилав Алісі на кроці 4. 
7. Протокол закінчений. Обидві сторони надалі для обмінювання інформацією користуються сесійним ключем _K_.

**Найбільш поширені питання**

*— Як виконується атака людини посередині?*

Як ми згадували раніше, кожна сторона передає іншій свій відкритий ключ. Фактично, якщо відсутній механізм забезпечення автентичності повідомлень, що передаються, то сторона, що приймає, не може переконатися, що отриманий відкритий ключ дійсно належить другій стороні. У результаті, зловмисник може відправити свої значення відкритих ключів обом сторонам і сформувати загальний секрет з кожної з них. Після цього він може виконувати роль ретранслятора: отримувати повідомлення від одного боку, ознайомлюватися з його вмістом і передавати другого суб'єкту. Більш того, зловмисник може змінювати ці повідомлення.

*— Чи можна використовувати протокол Діффі–Хеллмана для більш ніж двох учасників?*

Так, цей протокол дозволяє виробити загальний секрет між будь-якою кількістю сторін. Проте для більшої кількості учасників протокол взаємодії складніший і вимагає виконання більшої кількості послідовних етапів.

*— У чому переваги використання інфраструктури відкритих ключів спільно з протоколом Діффі–Хеллмана?*

У разі відсутності механізмів автентифікації при використанні протоколу Діффі–Хеллмана порушник (яким є людина посередині) може видавати себе за цільову сторону, з якої узгоджується ключ. Таким чином, Аліса обмінюється відкритими ключами і формує спільний секрет ні з Бобом, а з порушником. Тому протокол Діффі–Хеллмана часто використовується спільно з інфраструктурою відкритих ключів, яка є джерелом інформації про відкриті ключі та їх власників.

## 2.3 Концепція Merkle tree та її застосування

Концепцію побудування таких дерев опублікував у 1979 році Ральф Меркл, після чого вона набула широкого застосування як для перевіряння цілісності великих обсягів даних, так і в системах контролю версій і криптографічних алгоритмах цифрового підпису.

Ми вже згадували про дерева Меркла в першій частині навчального посібника. В даному розділі ми детально опишемо процес верифікації даних за допомогою дерев Меркла, заглибимося у властивості, які така структура може надати і розглянемо основні галузі застосування даної концепції.

### Структура дерев Меркла

Дерево Меркла – це один із основних способів гешування великих обсягів даних. Структуру дерева Меркла можна розбити на компоненти, як на рисунку 2.7.

>**Компоненти структури Merkle tree**
>> * _Merkle root (корінь)_
>> * _Merkle nodes (вузли)_
>> * _Merkle leaves (листки)_

<img align="center" width="60%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.7-Merkle-tree-structure.png" alt="Рисунок 2.7 – Структура дерева Меркла"/>    

Листки дерева – це геш-значення від довільних даних (Data). Кожен з листів та вузлів одного дерева має однаковий розмір, і цей розмір залежить від геш-функції, що використовується. Кількість листів в дереві Меркла визначається значенням 2<sub>h</sub>, де h – висота дерева Меркла (на рисунку висота дерева Меркла дорівнює 2).

Вузлом дерева Меркла – це геш-значення від конкатенації двох дочірніх листів (або вузлів). Розмір кожного вузла ідентичний розміру листів і також визначається параметрами геш-функції, що використовується.

Корінь дерева – це вузол, який перебуває на вершині дерева. Кореневий вузол зв’язаний з усіма дочірніми вузлами і листками: зміна одного з вузлів або листів дерева спричинить зміну значення його кореня.

Базову ідею побудови дерева Меркла можна описати одним рівнянням:

**Hash<sub>i+1, j</sub> = Hash(Hash<sub>i, 2j</sub> || Hash<sub>i, 2j+1</sub>)**

Рівняння простими словами: для отримання вузлів наступного рівня, вузли (або листки) на поточному рівні попарно конкатенуються і гешуются.

Структура дерева Меркла має низку корисних властивостей.
> * _Зміна хоча б одного біта в будь-якому з блоків даних призведе до істотної (та непередбачуваної) зміни значення Merkle root_
> * _При порушенні цілісності одного з блоків даних можна точно і досить швидко визначити, який із блоків був змінений_
> * _Простота автентифікації і невеликий розмір доказу входження конкретного блоку в структуру дерева Меркла_

### Побудування дерева Меркла

Розберімо на прикладі як саме відбувається побудова дерева Меркла. Припустімо, у нас є 4 блоки даних, що містять цифри: 1, 2, 3 і 4. Для побудови дерева Меркла нам необхідно обчислити геш-значення для кожного з блоку даних, як на рисунку 2.8 (у прикладі була використана геш-функція SHA-256).

<img align="center" width="40%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.8-Hashing-of-data-blocks.png" alt="Рисунок 2.8 – Процес гешування блоків даних"/> 

Отримані геш-значення – листки дерева Меркла. Далі їх необхідно зв’язати у вузли. Для цього пари значень конкатенуються (зчіплюються) і отримане значення також гешується (рис. 2.9).

<img align="center" width="40%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.9-Obtaining-of-Merkle-nodes.png" alt="Рисунок 2.9 – Отримання вузлів дерева Меркла"/> 

У результаті, ми отримуємо два вузла, які тепер таким же чином потрібно зв'язати в одне значення Merkle root. Кореневе значення отримується так само, як і значення окремого вузла (рис. 2.10).

<img align="center" width="40%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.10-Obtaining-of-Merkle-root.png" alt="Рисунок 2.10 – Отримання кореневого значення"/> 

Тепер ми отримуємо одне кореневе значення, яке пов'язує всі блоки вихідних даних. На цьому прикладі можна досить просто пояснити як перевіряється цілісність всіх компонентів дерева Меркла.

Припустимо, зловмисник забажав змінити останній блок даних на число 5. Мотиви зловмисника в цьому випадку не важливі. Важливо те, що в нього не вийде переконати всіх, що дані не були змінені. Така властивість досягається за рахунок використання геш-функцій в дереві Меркла.

Коли зловмисник змінює цільові дані, геш-значення від них змінюється (відповідно, видно зміну значення листа дерева). Оскільки далі відбувається конкатенація цього листа з сусіднім і гешування отриманого значення, значення вузла зміниться. Це спричиняє повну зміну значення Merkle root (рис. 2.11).

<img align="center" width="60%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.11-Merkle-root-value-modification-depending-on-the-input-data-block-modification.png" alt="Рисунок 2.11 – Зміна кореневого значення в залежності від зміни блоку вхідних даних"/> 

Цей приклад можна протестувати і особисто переконається, що кореневе значення дійсно повністю змінюється. Успішно модифікувати  дані у зловмисника вийде тільки при знаходженні колізії (такого набору даних, після гешування якого вийде ідентичне цільовому геш-значення) – фактично тільки за зламу криптографічної геш-функції.

### Автентифікація в дереві Меркла

За допомогоюдерева Меркла можна здійснити швидку та невибагливу до великих обсягів даних перевірку на вміст певного набору даних в структурі дерева. Для цього тому, хто перевіряє, необхідні тільки значення Merkle root і набір значень під назвою Merkle branch.

Що таке Merkle branch? Це набір геш-значень (листків і вузлів), достатній для автентифікації конкретного блоку даних. Як формується цей набір значень? Вузол, який містить необхідні блоки даних перераховує для них дерево Меркла і вибирає тільки ті значення, що знадобляться верифікатору для отримання Merkle root (попарної конкатенації і гешування) для конкретного листа, після чого передає вибрані значення. Той, хто перевіряє, отримавши набір значень і маючи власний блок даних, розраховує значення Merkle root і порівнює його з тим, яке зберігає сам (рис. 2.12).

<img align="center" width="60%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.12-Merkle-branch-calculation.png" alt="Рисунок 2.12 – Обчислення Merkle branch"/> 

На малюнку зображена перевірка  набору даних data 3 (у нашому прикладі це значення 3) на входження у структуру дерева Меркла. Верификатор зберігає геш-значення цього блоку (4E0740…) даних і отримує Merkle branch, що складається з геш-значення сусіднього блоку даних (4B2277…) і одного з вузлів дерева (в даному випадку F5FCA…). Верификатор конкатенує збережене значення з першим значенням Merkle branch і гешує результат. Отримане значення конкатенуюється з другим значенням Merkle branch, і результат конкатенування знову гешується. Отримане значення порівнюється з наявним Merkle root.  Якщо значення збігаються, то такий блок даних дійсно входить в структуру дерева Меркла.

> **Зауваження._** *Є схеми множинної автентифікації, які дозволяють перевірити входження не одного, а відразу декількох блоків даних (у такий спосіб збільшити продуктивність алгоритму). До таких схем належить, наприклад, схема Octopus Authentication.*

### Галузі застосування Merkle tree

Тепер розгляньмо, у яких галузях застосовується концепція Merkle tree.

> * _Алгоритми цифрового підпису_
> * _Децентралізовані файлообмінні системи (BitTorrent, IPFS)_
> * _Blockchain та SPV-вузли_
> * _Системи управління версіями (Git)_

Цифрові підписи на основі геш-функцій можуть потенційно застосовуватися замість поширених на сьогоднішній день, оскільки класичні цифрові підписи уразливі до атак квантового комп'ютера. Особливість цього типу підписів полягає в тому, що вони не вимагають витратних обчислень і ґрунтуються тільки на стійкості геш-функцій, що використовуються.

Інша галузь застосування дерев Меркла – децентралізовані файлообмінні протоколи, як-от BitTorrent і IPFS. Протокол BitTorrent дозволяє перевіряти цілісність фрагментів завантажуваних файлів  через присвоєння кожному блоку даних деякого цифрового відбитка (значення геш-функції SHA-1 від блоку даних). Пов'язана з цим проблема полягає в тому, що розміри деяких блоків даних дуже великі і, відповідно, відбиток цих даних теж має великий розмір.

Щоби розмір торрент-файлу залишався невеликим, використовується схема побудови дерева Меркла. З її допомогою ми можемо зібрати геш-значення від різних фрагментів в єдиний корінь дерева. У результаті, ми отримаємо одне геш-значення, яке дозволить перевірити цілісність всієї сукупності  даних. Так само, за ієрархічную схемою, окремі вузли дерева Меркла дозволяють перевірити цілісність окремих блоків.

У IPFS всі дані представляються у формі мерклізованого орієнтованого ациклічного графу (MDAG), який дозволяє користувачеві отримати весь набір даних (аж до вмісту каталогів), зв'язаних з єдиним унікальним ідентифікатором.

Найбільший рівень уваги схема побудови дерева Меркла отримала в криптовалюті Bitcoin. У статті Сатоші Накамото «Bitcoin: A Peer-to-Peer Electronic Cash System» [18] наведено таку схему (рис. 2.13).

<img align="center" width="50%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.13-Use-of-Merkle-trees-in-Bitcoin.png" alt="Рисунок 2.13 – Використання дерев Меркла в Bitcoin"/> 

На цій схемі зображено будову блоку в Bitcoin. У його заголовку присутнє поле Root Hash. Що ж є це поле?

Кожен блок у Bitcoin може містити до декількох тисяч транзакцій. Ці транзакції гешуються й утворюють листки подальшого дерева Меркла. Далі листки попарно конкатенуються і гешуються, поки не буде отримано єдине кореневе значення. Це і є Root Hash. Ця схема дозволяє перевірити входження будь-якої транзакції до блоку без потреби мати всі транзакції цього блоку.

За цим принципом працює метод SPV (simplified payment verification). Кожен SPV-вузол зберігає всі заголовки блоків (розмір яких дорівнює 80 Б). Заголовки блоків містять значення Merkle root від усіх транзакцій, які в цей блок були додані. Якщо SPV вузол хоче переконатися, що транзакція була підтверджена, він звертається до повного вузлу та запитує Merkle branch для конкретної транзакції (рис. 2.14). Отримавши Merkle branch, той, хто перевіряє, будує шлях автентифікації до кореневого значення (яке він зберігає, позаяк він синхронізується з іншими вузлами мережі).

<img align="center" width="40%" src="/resources/img/volume-2/2.3-Merkle-tree-concept-and-application/Figure-2.14-SPV-node-operation-scheme.png" alt="Рисунок 2.14 – Схема функціонування SPV-вузла"/> 

**Найбільш поширені питання**

*– Навіщо використовувати дерево Меркла, якщо ми просто можемо загешувати всю послідовність?*

Якщо ми гешуватимемо весь набір даних, ми також зможемо забезпечити їх цілісність. Однак у цьому випадку відсутня гнучкість при розкритті частини з цих даних. Якщо ми гешуємо весь набір даних, то верифікатор може перевірити, що дані відповідають геш-значенням, маючи тільки повний набір. Використання дерев Меркла дозволяє забезпечити доказовість того, що один фрагмент даних входить до загальної структури. Такий підхід набагато менш вибагливий до загального обсягу доказів, а також з його допомогою можна забезпечити конфіденційність усього набору даних при доказі цілісності тільки фрагмента.      

*– Чи може кожен вузол мати більше за два дочірні вузли?*

Ми можемо побудувати дерево, у якому кожен вузол буде мати більше двох дочірніх. Однак водночас значно знизиться ефективність цього підходу: збільшиться розмір доказів для автентифікації конкретного набору даних.

## 2.4 Різновиди цифрових підписів

Цифровий підпис є механізмом, який дозволяє забезпечити контроль цілісності й авторства підписаного повідомлення. Однак деякі галузі його застосування вимагають забезпечення додаткових властивостей, які звичайний цифровий підпис забезпечити не може. Тому було запропоновано низку нових підходів, які ми розглянемо в цьому підрозділі.

> * _Одноразовий підпис_
> * _Мультипідпис_
> * _Пороговий підпис_
> * _Груповий підпис_
> * _Кільцевий підпис_
> * _Сліпий підпис_

### Схеми одноразового підпису

Схема одноразового підпису вперше запропонував Леслі Лемпорт (Leslie B. Lamport) у 1979 році. В основі таких схем лежить використання односпрямованих функцій (геш-функцій). Одноразовий підпис передбачає використання однієї ключової пари для підписання тільки одного повідомлення. Під час підписання схеми передбачають публікацію фрагментів особистого ключа. Якщо використовується одна і та сама ключова пара кілька разів, то все більше частин особистого ключа розкриваються, і тоді вони можуть використовуватися зловмисником для відновлення чужого особистого ключа та формування підписів для інших повідомлень від імені цільового користувача.

Щоб зрозуміти основні принципи роботи одноразових підписів, ми розглянемо два базових алгоритми одноразового підпису OTS (One-Time Signature) [19] і WOTS (Winternitz One-Time Signature) [20], особливості обчислення та перевірки підпису в обох алгоритмах, основні їх властивості, а також за рахунок чого зловмисник може підробляти підписи від імені користувача.

### Lamport one-time signature

Насамперед користувачу потрібно згенерувати ключову пару, за допомогою якої формуватимуться та перевірятимуться підписи. Схема підпису Лемпорта [21] передбачає, що особистий ключ користувача складається з парних наборів випадково згенерованих секретних значень. Їхню кількість визначає розмір повідомлення, що підписується (довжина геш-значення). Якщо довжина вихідного значення застосовуваної геш-функції дорівнює _n_ бітів, то для підписання відповідного повідомлення необхідно згенерувати _2n_ секретних значень. Особистий ключ представлений на малюнку 2.15.

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.15-Private-key-formation-scheme.png" alt="Рисунок 2.15 – Схема формування особистого ключа"/> 

Якщо ми, наприклад, будемо генерувати кожне секретне значення (*X<sub>i</sub>* || *Y<sub>i</sub>*) з довжиною 256 біт і використовувати геш-функцію на довжині 256 біт, то довжина нашого особистого ключа в результаті має бути приблизно 8 кБ, що є досить великий обсяг даних порівняно з використовуваними в традиційних схемах ключами з довжиною 256–512 біт.

Відкритий ключ обчислюється як конкантеноване значення від геш-значень згенерованих секретів. Його довжина залежить від використовуваної для його породження геш-функції (якщо вихід геш-функції дорівнює розміру секрету, то в цьому випадку розміри відкритого та особистого ключів будуть збігатися). Процес формування відкритого ключа наведено на рисунку 2.16.

<img align="center" width="70%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.16-Scheme-of-generating-a-public-key-from-a-private-key.png" alt="Рисунок 2.16 – Схема формування відкритого ключа з особистого"/> 

Після того, як відкритий ключ обчислений, він може бути опублікований (переданий перевіряючому, поширений в мережу тощо). Яким чином обчислюється значення підпису в даному випадку? Після того як повідомлення, що підписується, сформоване, від нього обчислюється геш-значення. Щоб підписати повідомлення, ми повинні опублікувати одне з секретних значень в парі (*X<sub>i</sub>* || *Y<sub>i</sub>*) (рис. 2.17), в залежності від конкретного біта геш-значення (0 або 1).

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.17-Digital-signature-calculation-scheme.png" alt="Рисунок 2.17 – Схема обчислення цифрового підпису"/> 

У результаті, ми опублікуємо рівно половину з початково згенерованих секретів. Як перевірити валідність підпису? Той, хто перевіряє, може обчислити геш-значення повідомлення й отримати таку ж саму бітову послідовність. Залежно від цієї послідовності, верифікатор вибирає набір відкритих ключів, відповідно до значення конкретних бітів отриманого геш-значення (рис. 2.18).

<img align="center" width="80%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.18-Public-key-selection-scheme.png" alt="Рисунок 2.18 – Схема вибору відкритих ключів"/> 

Після того, як перевіряючий сформував набір необхідних відкритих ключів, він обчислює геш-значення від частин цифрового підпису. Якщо геш-значення всіх цих значень відповідають сформованому на попередньому етапі відкритому ключу (рис. 2.19), то підпис дійсний.

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.19-Signature-verification-scheme.png" alt="Рисунок 2.19 – Схема перевірки підпису"/> 

### Чому одноразовий підпис «одноразовий»?

Щоби на прикладі розібратися, як працює одноразовий підпис Лемпорта та чому не можна за допомогою одного ключа підписувати кілька повідомлень, розглянемо простий числовий приклад. Як приклад геш-функції, що використовується, приймемо функцію, що повертає чотирьохбітне значення (опустимо алгоритм обчислення: відомо тільки те, що для однакових вхідних даних вихід геш-функції не відрізняється).

Для початку генеруємо особистий ключ. Оскільки довжина геш-функції дорівнює 4 біт, нам необхідно згенерувати вісім секретних значень (рис. 2.20).

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.20-Example-of-generating-a-private-key.png" alt="Рисунок 2.20 – Приклад генерації особистого ключа"/> 

Після цього необхідно обчислити значення відкритого ключа шляхом гешування секретних значень (рис. 2.21) і передати його перевіряючій стороні.

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.21-Example-of-public-key-calculation.png" alt="Рисунок 2.21 – Приклад обчислення відкритого ключа"/> 

Коли користувач формує повідомлення, він обчислює його геш-значення. Далі виконується формування цифрового підпису. Наприклад, отримане у результаті гешування значення дорівнює «0110». У цьому випадку значення підпису буде представляти із себе частини секретного ключа, в залежності від бітів геш-значення (рис. 2.22).

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.22-Example-of-calculating-the-first-digital-signature.png" alt="Рисунок 2.22 – Приклад обчислення першого цифрового підпису"/> 

Після публікації цього значення цифрового підпису разом з повідомленням, фактично всі дізнаються половину зі згенерованих вами секретних значень: *X<sub>0</sub>*, *Y<sub>1</sub>*, *Y<sub>2</sub>*, *X<sub>3</sub>*. Ці значення може зберегти зловмисник, що спростить йому завдання по підбору інших частин особистого ключа жертви.

Якщо той самий користувач використовував ту ж ключову послідовність для підпису іншого повідомлення, то, відповідно, геш-значення цього повідомлення також буде іншим. Отже, позиції необхідних для публікації секретів також змінилися, а значить з публікацією нового значення цифрового підпису буде розголошена ще одна порція складових особистого ключа. Якщо, наприклад, даний користувач за допомогою того ж особистого ключа вдруге підпише повідомлення з геш-значенням «1001» (рис. 2.23), то йому необхідно розкрити секрети, які знаходяться на позиціях *Y<sub>0</sub>*, *X<sub>1</sub>*,  *X<sub>2</sub>*, *Y<sub>3</sub>.

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.23-Example-of-calculating-the-second-digital-signature.png" alt="Рисунок 2.23 – Приклад обчислення другого цифрового підпису"/> 

Якщо зловмисник перехопив обидва повідомлення і значення їх підписів, то він володіє повним набором початково згенерованих секретів, а значить може підписувати будь-які повідомлення від імені цільового користувача. Оскільки власник особистого ключа не зацікавлений у його розголошенні, то він може використовувати один ключ, щоб сформувати не більше одного підпису.

### Winternitz one-time signature

В якості ще одного прикладу одноразового підпису ми розглянемо Winternitz OTS [20]. Даний підхід має дуже велику схожість з підписом Лемпорта, проте передбачає окреме секретне значення не на кожен окремий біт підписаного повідомлення, а на один блок повідомлення. Тому спочатку визначається параметр (ширина) Вінтерніца, який визначає розмір блоків повідомлення. Наприклад, якщо ми встановлюємо ширину Вінтерніца рівною 16 (4 біта) і використаємо геш-функцію SHA-256, то вихідне геш-значення ділиться на 64 блоки довжиною по 4 біта.

Після цього ми генеруємо значення особистих ключів. В даному випадку кількість ключів відповідає кількості блоків (рис. 2.24) і також дорівнює 64.

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.24-Private-key-generation-scheme.png" alt="Рисунок 2.24 – Схема генерації особистого ключа"/> 

Відкритий ключ обчислюється як конкатенація геш-значень від частин особистого ключа. Причому кількість необхідних обчислень геш-функції дорівнює значенню ширини Вінтерніца. Виходячи з цього, фрагменти відкритого ключа дорівнюють фрагментам особистого ключа, від яких 16 раз було обчислено геш-значення (рис. 2.25).

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.25-Public-key-calculation-scheme.png" alt="Рисунок 2.25 – Схема обчислення відкритого ключа"/> 

Відкритий ключ сформований і може бути переданий верифікаторам. У процесі підпису повідомлення, попередньо обчислюється його геш-значення і розбивається на блоки по 4 біти. Після цього, кожен з блоків перетворюється в десяткове значення (рис. 2.26).

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.26-Message-pre-processing-scheme.png" alt="Рисунок 2.26 – Схема попередньої обробки повідомленняя"/> 

Цифровий підпис є значенням особистого ключа для кожного блоку, яке загешовано таку кількість разів, яке отримано при перетворенні блоку в десяткове значення (рис. 2.27).

<img align="center" width="80%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.27-Digital-signature-calculation-scheme.png" alt="Рисунок 2.27 – Схема обчислення цифрового підпису"/> 

Коли верифікатор отримує значення підпису, він попередньо обчислює геш-значення від отриманого повідомлення і так само ділить його на блоки. Після цього він переводить значення кожного блоку в десятковий вигляд, а потім віднімає від значення ширини Вінтерніца отримані десяткові значення і отримує власний набір натуральних чисел. Далі верифікатор гешує значення фрагментів підпису відповідно до отриманого набору натуральних чисел (гешує стільки разів, скільки отримує в результаті віднімання ширини Вінтерніц і десяткових значень блоків). Якщо результат кожного гешування дорівнює відповідній частині відкритого ключа, то значення підпису валідне (рис. 2.28).

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.28-Signature-verification-scheme.png" alt="Рисунок 2.28 – Схема перевірки підпису"/> 

### Мультипідпис

Мультипідпис є схемою цифрового підпису, яка вимагає взаємодії кількох сторін (з застосуванням їхніх особистих ключів) для обчислення підпису. Існує два основних типи мультипідпису. Перший передбачає, що перевірка підпису відбувається відповідно до набору відкритих ключів. В цьому випадку сторони, що взаємодіють, визначають відкриті ключі і необхідну їх кількість для перевірки підпису. Сам же підпис складається з набору значень, кожне з яких перевіряється окремим відкритим ключем (рис. 2.29).

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.29-Multisignature-of-the-first-type.png" alt="Рисунок 2.29 – Перший варіант мультипідпису"/> 

Другий тип мультипідпису дозволяє агрегувати значення відкритих ключів в одне загальне значення, за допомогою якого буде перевірятися єдине агреговане значення підпису. У цьому випадку взаємодіючі сторони спочатку формують загальне значення відкритого ключа та публікують його. В процесі підписання, кожна зі сторін окремо підписує повідомлення, але отримані значення підписів можна «скласти» і перевірити результат за допомогою загального відкритого ключа (рис. 2.30).

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.30-Multisignature-of-the-second-type.png" alt="Рисунок 2.30 – Другий варіант мультипідпису"/> 

У чому ж полягають переваги такого типу підписів? Головна (і така, що має найбільший попит) – це зменшення обсягу пам'яті, необхідної для зберігання мультипідпису. На відміну від стандартних мультипідписів (розмір яких лінійно збільшуються в залежності від кількості підписантів), розмір підпису, обчисленої декількома учасниками за допомогою, наприклад, алгоритму Шнорра [22] не відрізняється розміром від одиночного підпису.

Ще однією перевагою є конфіденційність учасників таких схем. Так як загальний відкритий ключ є агрегованим значенням, то третій стороні досить складно відновити відкриті ключі учасників підпису і зв'язати їх з власниками цих ключів. Всі учасники системи бачать тільки загальний відкритий ключ і загальне значення підпису, а відповідно це візуально не відрізняється від звичайного одиночного підпису.

### Пороговий підпис

Пороговий підпис є різновидом мультипідпису за винятком однієї важливої відмінності: відкриті ключі учасників взаємодії мають різні вагові значення.

Такий підхід часто використовується в облікових системах, а саме шляхом визначення необхідної ваги на проведення конкретної операції і видачу вагових значень відкритим ключам. Таким чином користувач, спочатку маючи одну ключову пару з максимальним ваговим значенням, може створити так званих «підписантів» (набір відкритих ключів) для свого облікового запису, і задати кожному з них власне вагове значення.

Під час верифікування підпису верифікатор перевіряє, що сукупна вага ключів, якими повідомлення було підписано, задовольняє порогу, що вимагається (рис. 2.31). У цьому разі поріг дорівнює 1.

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.31-Threshold-signature-verification-scheme.png" alt="Рисунок 2.31 – Схема перевірки порогового підпису"/> 

### Груповий підпис

Груповий підпис – це механізм, що дозволяє користувачу підписати конкретне повідомлення від імені групи. При цьому груповий підпис має такі властивості:

> * _Тільки члени групи можуть сформувати коректний підпис_
> * _Верифікатор може точно переконатись що конкретний підпис обчислений одним з учасників групи_
> * _Верифікатор не може визначити який саме учасник групи підписав повідомлення_
> * _У разі виникнення суперечки, адміністратор групи може розкрити особистість підписанта_

Перший запропонований варіант групового підпису припускав наявність повністю довіреного адміністратора групи.

Адміністратор групи спочатку генерує велику кількість ключових пар, після чого розподіляє особисті ключі серед учасників групи. Після цього він формує список відкритих ключів учасників групи і перемішує ці ключі в випадковому порядку, після чого публікує цей список.

Коли один з учасників групи хоче підписати документ, він випадковим чином вибирає один зі своїх особистих ключів і обчислює підпис. Коли верифікатор перевіряє значення підпису, він звертається до списку відкритих ключів і перебирає його в пошуках того, який відповідає підпису. Якщо він знаходить відповідний відкритий ключ, це означає, що підпис виробив один із членів групи (рис. 2.32).

<img align="center" width="45%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.32-Group-signature-scheme.png" alt="Рисунок 2.32 – Схема групового підпису"/> 

Це є найпростішою реалізацією схеми групового підпису і вона має ряд недоліків:
* адміністратор може підписувати повідомлення від імені учасників групи;;
* складність додавання нового учасника групи;
* підмножина ключів у кожного з учасників має бути великою для ускладнення аналізу відповідності власника відкритого ключа.

На цю мить є велика кількість алгоритмів групового підпису, які дозволяють усунути перелічені недоліки. Питання довіри учасників групи адміністратору вирішується завдяки тому, що користувачі особисто генерують свої секрети. Водночас адміністратор надає їм тільки набір значень, які необхідні для формування особистих ключів і дозволяють обчислити підпис, що перевіряється відкритим ключем групи.

У цьому випадку верифікатор перевіряє підпис, використовуючи загальний відкритий ключ групи, і не може провести жодної відповідності між ним та конкретним учасником. Така схема підтримує простий механізм додавання нових учасників до групи. При цьому забезпечуються основні властивості групового підпису, які ми розглядали раніше.

### Кільцевий підпис

Кільцевий підпис (ring signature) – вид цифрового підпису, який дозволяє одному з учасників групи (що зветься кільцем) виконати підписання деякого повідомлення від імені всієї групи. Для формування такого підпису, користувач використовує відкриті ключі інших користувачів і свою ключову пару. Верифікатор при перевірці підпису може переконатися, що він була обчислен одним з членів кільця, однак ким саме – невідомо.

Алгоритм кільцевого підпису запропонували Ади Шамір, Яель Тауман, Рон Ривест, і він був анонсований в 2001 році на міжнародній конференції Asiacrypt [22]. Засновники намагалися в назві підкреслити відсутність центральної координуючої структури при формуванні цього підпису: «кільце є геометричною фігурою з однорідною периферією і без центру».

На відміну від групового підпису, у схемі кільцевого підпису немає заздалегідь підготовленої групи учасників, не потрібно проведення будь-яких підготовчих процедур для створення або зміни такої групи. Головна вимога – кожен з учасників повинен бути асоційований з парою ключів. Це дозволяє підписуючому вибрати довільну множину можливих підписуючих (в яку він включає самого себе) і самостійно обчислити підпис, використовуючи відкриті ключі інших учасників зі списку можливих і свій секретний ключ.

Уявімо групу з _n_ користувачів, як на малюнку 2.33. Кожен користувач має свою ключову пару – особистий і відкритий ключі (_sk_, _PK_). Особисті ключі відомі тільки їх власникам, відкриті – усім учасникам системи.

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.33-Scheme-of-forming-a-group-for-a-ring-signature.png" alt="Рисунок 2.33 – Схема формування групи для кільцевого підпису"/> 

Щоб сформувати підпис від імені групи, користувачеві необхідно подати на вхід алгоритму відкриті ключі всіх учасників кільця (включаючи свій), і в якості секрету використовувати власний особистий ключ. Нагадаємо, що відкриті ключі кожного з учасників є загальнодоступними. На рисунку 2.34 схематично показано, як відбувається формування кільцевого підпису користувачем під номером 4.

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.34-Ring-signature-formation-scheme.png" alt="Рисунок 2.34 – Схема формування кільцевого підпису"/> 

Коли верифікатор перевіряє значення підпису, він може переконатися, що підпис був вироблений одним з учасників групи, проте ким саме – невідомо. Тільки з ймовірністю 1/_n_ він може визначити, що підпис обчислив конкретний учасник кільця. При цьому варто зауважити, що достовірно підписуючий може бути розкритий тільки в разі змови всіх інших учасників групи (рис. 2.35).

<img align="center" width="50%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.35-Ring-signature-verification-scheme.png" alt="Рисунок 2.35 – Схема перевірки кільцевого підпису"/> 

Таким чином, схема кільцевого підпису може бути використана, якщо потрібно забезпечити анонімність підписуючого, а також його незалежність від інших учасників, і при цьому забезпечити цілісність і справжність повідомлення що підписується (одержувач буде впевнений, що повідомлення надійшло від учасника певної групи, а не від абикого поза цієї групи).

Варто згадати, що є такий вид кільцевого підпису, який наділений властивістю одноразовості. Такі алгоритми припускають використання значення зображення відкритого ключа, яке дозволяє відстежити (зв'язати) всі підписи сформовані за допомогою одного особистого ключа, навіть якщо при цьому використовувалися різні кільця.

Така властивість має попит у багатьох галузях: електронні вибори (кожен учасник може проголосувати тільки один раз), цифрові гроші (електронні монети можна витратити лише одного разу) тощо.

### Сліпий підпис

Механізм сліпого підпису використовується в тих випадках, коли формує повідомлення одна сторона, а підписує (завіряє) інша і при цьому той, хто створює повідомлення, хоче приховати деякі його частини від підписуючого. Механізм сліпого підпису може застосовуватися в банківських структурах для переказу коштів між користувачами. Фактично можна уявити такого роду взаємодію, як засліплений чек, який передається іншій стороні: власник коштів формує такий чек, а банк, не бачачи унікального ідентифікатора чека, підписує його, після чого цей чек може бути переданий будь-якій стороні і та може отримати гроші без розкриття його відправника.

Механізм сліпого підпису працює наступним чином:

> 1. Відправник формує _n_ різних транзакцій з однаковою сумою переказу, але з різними унікальними ідентифікаторами. Перед відправкою користувач засліплює (шифрує) транзакції, використовуючи випадково згенерований множник. Після цього всі транзакції передаються підписанту.
> 2. Підписант запитує у відправника _n−1_ засліплюючих факторів, які відповідають обраним підписантом транзакціям. Фактично він визначає, які транзакції хоче розкрити.
> 3. Відправник відсилає набір засліплюючих факторів, підписант розкриває з їх допомогою засліплені транзакції і перевіряє, щоб сума переказів дорівнювала та користувач мав достатньо коштів для проведення цієї транзакції. 
> 4. Якщо суми в деяких транзакціях не рівні, то підписант відмовляє користувачеві. В іншому випадку він підписує транзакцію що залишилася, не бачачи її вмісту, і відправляє її назад користувачеві.
> 5. Користувач прибирає осліплення з транзакції. При цьому підпис залишається правильним для транзакції, з якої прибрали осліплення.
> 6. Користувач може відправити цей «чек» будь-кому. Одержувач в будь-який момент часу може передати цей чек стороні, яка підписала його і отримати суму, яка в ньому зазначена. Здійснююча перевірку сторона може тільки переконатися, що підпис коректний, при цьому вона не знає кому був виданий чек з таким ідентифікатором (рис. 2.36).

<img align="center" width="60%" src="/resources/img/volume-2/2.4-Digital-signature-types/Figure-2.36-Blind-signature-generation-and-verification-scheme.png" alt="Рисунок 2.36 – Схема формування та перевіряння сліпого підпис"/> 

**Найбільш поширені питання**

*— У яких системах на даний момент використовуються механізми порогового підпису та мультипідпису?*

Мультипідписи та схеми порогового підпису використовуються в системах для підтримання відмовостійкості та розділення відповідальності за управління процесами. Багато криптовалют дозволяють користувачам заблокувати кошти на multisignature адресах, що дозволяє їм отримати доступ до своїх коштів навіть при втраті одного (або кількох) ключів. Також використання мультипідпису дозволяє побудувати велику кількість протоколів понад деякою вже наявною обліковою системою (atomic swap, payment channels і т. ін.). Механізми порогового підпису використовуються, коли потрібен ще більший рівень розмежування дозволів користувачів. Так можна налаштувати вагу кожного окремого ключа (часто в залежності навіть від окремої операції) і завдяки цьому максимально ефективно налаштувати політику доступу до послуг облікової системи. Такий підхід використовується в багатьох платформах управління активами, наприклад в Stellar.

*— Як співвідносяться рівень анонімності підписувача та розмір кільця за використання кільцевого підпису?*

За використання кільцевого підпису верифікатор тільки з часткою ймовірності може визначити, хто підписав конкретне повідомлення. Що більший розмір кільця, то менша ймовірність того, що конкретне повідомлення підписав конкретний учасник кільця. Наприклад, якщо кільце складається з 10 учасників, то припустити, хто конкретно виробив підпис, можна тільки з імовірністю 10%. Авжеж, особистість підписанта також може бути розкрито, але це можливо, тільки якщо всі інші учасники кільця змовилися між собою.

## 2.5 Розділення секрету за схемою Шаміра

Уявімо ситуацію, коли потрібно захистити будь-які дані, забезпечуючи одночасно й конфіденційність, і доступність. Наприклад, таємний рецепт смачних пиріжків Аліси, яка має свою пекарню. Припустімо, Аліса зашифрувала рецепт і зберігає ключ із собою. За потреби вона надає доступ до рецепту. Але з часом стає зрозуміло, що таке рішення на практиці незручне, тому що щоразу для відкриття сховища потрібна її фізична присутність. А що стосовно відпустки? Або ще гірше: а раптом ключ буде втрачено?

Тоді Аліса могла би зробити копію ключа та довірити його працівнику пекарні, проте в такому разі збільшується й ризик його крадіння.

Є варіант не створювати дублікат, а розділити оригінальний ключ навпіл і віддати частину ключа довіреній людині. Тепер зрозуміло, що вони обидва мають фізично бути присутні, щоби зібрати ключ і відкрити сховище. Отже, щоб украсти рецепт, зловмиснику потрібно отримати обидві частини ключа, що набагато важче за крадіння одного ключа. Однак ця схема не набагато краща, ніж використання одного ключа: якщо один із них утратить половину ключа, повний ключ неможливо буде відновити.

Аліса усвідомлює, що в ідеальному разі потрібно розділити ключ між декількома працівниками, щоби можливість доступу до рецепту  не залежала тільки від однієї людини. Також вона доходить висновку, що має бути певний поріг кількості працівників, щоби за втрати (або недоступності) однієї частини весь ключ могло бути відновлено із решти частин.

Рішення цієї проблеми було подано в роботі Ади Шаміра (Adi Shamir) в 1979 році [78]. Він запропонував порогову схему розділення секрету, яку також називають схемою інтерполяційних поліномів.

### Порогова схема розділення секрету

Порогова схема розділення секрету – це схема, у якій кількість учасників, необхідна для відновлення секрету, може бути меншою, ніж загальна кількість учасників. Припустімо, _n_ – загальна кількість учасників, а _t_ – кількість учасників, необхідна для відновлення секрету. Відновити секрет може будь-яка група з _t_ і більше учасників, тоді як менша кількість учасників нічого не зможе дізнатися про секрет. Порядок виконання схеми Ади Шаміра можна розділити на такі фази.

> * _Підготовча фаза_
> * _Генерування частин секрету_
> * _Відновлення секрету_

Перша фаза – _підготовча_. Припустімо, що є секрет _S_, який потрібно розділити на _n_ частин так, щоби сам секрет можна було отримати тільки за наявності щонайменше _t_ частин. Тоді для початку потрібно вибирати деяке просте число _p_, де _p > S_, _p > n_; воно задаватиме розмір поля. Над цим полем потрібно побудувати поліном, який проходитиме через точку _(0, S)_. Він матиме вигляд  
**F(x)=(a<sub>t-1</sub>x<sup>t-1</sup> + a<sub>t-2</sub>x<sup>t-2</sup> + ... + a<sub>1</sub>x + S)**, де *a<sub>1</sub>, a<sub>2</sub>, ... , a<sub>t-1</sub>*  – випадково вибрані натуральні числа. Згодом секрет можна відновити, якщо обчислити _F(0)_.

Від ступеня полінома також залежатиме кількість точок, яка може знадобитися для відновлення цього полінома. Якщо нам потрібно, щоби секрет можливо було відновити за наявності _t_ частин, то ступінь полінома має бути _t − 1_.

Чим це зумовлено? Уявімо, що в нас є поліном першого ступеня форми _y=S+a<sub>1</sub>x_, наприклад _y=3+2x_. Йому відповідає графік, який ми можемо однозначно ідентифікувати, маючи щонайменше дві точки. Водночас, маючи лише одну точку, ми можемо провести нескінченну кількість прямих через неї (рис. 2.37).

<img align="center" width="50%" src="/resources/img/volume-2/2.5-Shamirs-secret-sharing-scheme/Figure-2.37-A-possible-number-of-straight-lines-that-pass-through-the-necessary-number-of-points-and-through-fewer-points.png" alt="Рисунок 2.37 – Можлива кількість прямих, які проходять через необхідну та через меншу кількість точок"/> 

Аналогічно, якщо ми маємо поліном другого ступеня, нам потрібно щонайменше три точки, позаяк через дві точки можна провести нескінченну кількість кривих другого ступеня (рис. 2.38).

<img align="center" width="50%" src="/resources/img/volume-2/2.5-Shamirs-secret-sharing-scheme/Figure-2.37-A-possible-number-of-straight-lines-that-pass-through-the-necessary-number-of-points-and-through-fewer-points.png" alt="Рисунок 2.38 – Можлива кількість графіків, які проходять через необхідну та через меншу кількість точок
"/> 

З цієї причини нам необхідно побудувати поліном ступеня _t − 1_, якщо ми хочемо, щоби секрет можна було відновити за наявності _t_ частин.

Наступна фаза – _генерування частин секрету_. Кожна частина секрету – це одна точка, що належить графіку, побудованому за допомогою полінома. Для того, щоб отримати чергову точку, потрібно згенерувати натуральне число, а потім підставити його в поліном. У такий спосіб потрібно згенерувати n різних точок. Цю фазу виконує володілець секрету самостійно, щоби не допустити його розголошення.

Після генерування частин секрету кожному учаснику видається його частина
*(x<sub>i</sub>, f(x<sub>i</sub>))*. Відома для всіх учасників інформація – ступінь полінома _t − 1_ і розмір поля _p_.

Остання фаза – _відновлення секрету_. Відновити секрет можна в два способи: розв'язати систему лінійних рівнянь або обчислити інтерполяційний поліном Лагранжа. Другий метод простіший для програмного реалізування, а також за допомогою нього можна обчислити сам секрет, не обчислюючи коефіцієнти полінома. Цю фазу виконує будь-яка група з _t_ учасників, коли з'являється потреба дізнатися секрет.

Формулу інтерполяційного полінома Лагранжа наведено на рис. 2.39. За допомогою цієї формули можна відновити поліном. Потім досить обчислити _F(0)_, щоби відновити секрет.

<img align="center" width="45%" src="/resources/img/volume-2/2.5-Shamirs-secret-sharing-scheme/Figure-2.39-Lagrange-interpolation-equation-Secret-sharing-example.png" alt="Рисунок 2.39 – Формула інтерполяційного полінома Лагранжа"/> 

### Приклад розділення секрету

Розгляньмо роботу схеми на конкретному прикладі. Уявімо, що потрібно розділити секрет _S_ = 7 на 6 учасників так, щоби будь-яка група з 4 учасників мала можливість відновити його.

> Крок 1. Потрібно вибрати просте число _р_, де _р > S_. Наприклад, _p_ = 13. Потім потрібно скласти поліном такого виду (рис. 2.40), де *a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>* – коефіцієнти, випадково вибрані натуральні числа.

<img align="center" width="50%" src="/resources/img/volume-2/2.5-Shamirs-secret-sharing-scheme/Figure-2.40-Making-a-polynomial-with-certain-coefficients.png" alt="Рисунок 2.40 – Складання полінома з визначеними коефіцієнтами"/> 

> Крок 2. У нашому випадку для того, щоб отримати частини секрету, потрібно підставити в поліном 6 різних натуральних чисел, вибраних у випадковий спосіб. Для зручності можна взяти {1, 2, 3, 4, 5, 6}. Ці числа не мають обов'язково йти за порядком; головне – те, щоб усі вони були різні за модулем _p_. У результаті, отримаємо 6 точок, які потім необхідно роздати учасникам (рис. 2.41). Після цього етапу коефіцієнти полінома можна знищити, а секрет можуть відновити будь-які 4 учасники з 6. Залежно від поставлених мет секрет також може бути знищено, тоді використання частин секрету буде єдиний спосіб відновити секрет.

<img align="center" width="50%" src="/resources/img/volume-2/2.5-Shamirs-secret-sharing-scheme/Figure-2.41-Calculation-of-secret-parts.png" alt="Рисунок 2.41 – Розрахування частин секрету"/> 

> Крок 3. Тепер, використовуючи будь-які 4 точки, можна скласти систему рівнянь і розв'язати це завдання або ж можна відновити вихідний поліном, використавши формулу інтерполяційного полінома Лагранжа (рис. 2.42). У прикладі використовуються точки _p_.

<img align="center" width="50%" src="/resources/img/volume-2/2.5-Shamirs-secret-sharing-scheme/Figure-2.42-Reconstruction-of-the-polynomial-and-secret.png" alt="Рисунок 2.42 – Відновлення полінома та секрету"/> 

Потім, знаючи, що _S_ = _F(0)_, можна легко розрахувати секрет: _F(0)_ = 7.

### Переваги схеми Шаміра 

> * _Стійкість_
> * _Динамічність_
> * _Масштабованість_

_Стійкість_. Для відновлення секрету зловмиснику необхідно t частин, тоді як за знання меншої кількості частин він не може відновити навіть частину секретного значення. У цьому разі зловмиснику не допоможе наявність великої обчислювальної потужності, позаяк він не може перевірити коректність підібраних частин.

_Динамічність_. Для того самого секрету можна застосувати схему декілька разів, водночас щоразу отримувати різні набори частин: створювати безліч різних поліномів і відповідних йому точок. Знання частин секрету, базованих на різних поліномах, не допоможе зловмиснику отримати жодного уявлення про сам секрет. Проте створення нового набору частин не скасовує можливість відновити секрет з його старих частин. Уявімо ситуацію: Аліса збирається залишити заповіт на свій таємний рецепт. Для своїх родичів вона може використовувати схему (2, 3), для друзів – (5, 7), а для працівників – (10, 14). Тоді отримати рецепт зможуть або 2 родичі, або 5 друзів, або ж 10 працівників.

_Масштабованість_ забезпечується тим, що кількість володільців секрету можна зробити будь-якою великою через вибирання полінома відповідного ступеня.

### Недоліки схеми Шаміра

> * _Під час розділення та відновлення секрет має перебувати на одному пристрої_
> * _Неможливість перевірити коректність наданої частини секрета_

Щоби розділити секрет за допомогою цієї схеми, секрет має бути на одному пристрої під час розділення. Під час відновлення також необхідна наявність частин секрету на одному пристрої. Наприклад, коли Аліса залишає заповіт на рецепт, їй необхідно зберігати весь рецепт, доки вона не розділить його. Також є ризик крадіння секрету після його відновлення. У ці моменти часу особливо великий ризик того, що конкурент може вкрасти рецепт.

Володілець однієї з частин може надати для відновлення неправильне значення, тоді секрет буде відновлено неправильно й інші про це не дізнаються. У них навіть немає можливості перевірити, чия частина була неправильною.

> **Зауваження._** *Є модифікації схеми Шаміра, у яких використовуються контрольні суми, що мінімізує ймовірність використання некоректних частин. Також є схеми розділення секрету, де кожний учасник може перевірити дійсність частин секрету (наприклад PVSS – публічно перевірюване розділення секрету).*
 
### Застосування схеми Шаміра

Найчастіше порогова криптографія застосовується для зберігання особистого ключа центру сертифікації, а також у хмарних середовищах і схемах електронного голосування.

Крім цього, схема Шаміра може застосовуватися для ієрархічних структур доступу. Такі структури є дерева, де кожний вузол має доступ до меншого об'єму даних, ніж його батьківський вузол. Корінь дерева має доступ до всіх даних. Один варіант реалізації Шамір подав у своїй роботі [78].

Як конкретний приклад можна навести використання схеми Ади Шаміра з боку паризької компанії SatoshiLabs для вирішення проблеми зберігання особистих ключів гаманця. Користувачі можуть «розбивати»  ключі на декілька частин, а потім відновлювати їх через об'єднання деякої заздалегідь визначеної підмножини цих частин. Резервне копіювання з використанням алгоритму від SatoshiLabs дозволяє створювати до 16 частин (які, зі свого боку, можна також додатково розділити). Це резервне копіювання – відкритий стандарт, тому інші компанії згодом зможуть використовувати його у своїх гаманцях.

[ТЕХНОЛОГІЧНІ ДЕТАЛІ ФУНКЦІОНУВАННЯ BITCOIN](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-2/ua/3-technological-details-of-bitcoin-operation.md)
