# МЕТОДИ ДОСЯГНЕННЯ КОНСЕНСУСУ

## 5.1 Proof-of-stake алгоритми досягнення консенсусу

PoS (proof-of-stake) – доказ володіння монетами в деякій цифровий обліковій системі. Алгоритм досягнення консенсусу на базі PoS був створений в якості менш ресурсномісткої альтернативи proof-of-work. У цьому підході до побудови алгоритму досягнення консенсусу ймовірність, з якою вузол отримує право на створення нового блоку, залежить від його балансу. В даному підрозділі ми розглянемо основні концепції, які лягли в основу PoS алгоритмів досягнення консенсусу, а також особливості застосування цього підходу в облікових системах.

### Принцип роботи та структура блоків proof-of-stake

У разі використання proof-of-stake алгоритму досягнення консенсусу, вузол-валідатор вибирається псевдовипадково, на основі комбінації чинників, які можуть включати в себе вік конкретних монет, певне випадкове значення і стан вузла. Також варто відзначити, що в proof-of-stake системах генерація блоків називається _forging_ або _minting_.

В узагальненому вигляді порядок формування нового блоку в PoS наступний. На вхід деякої функції подається заголовок блоку, поточний час, баланс валідатора (його stake) й інші специфічні дані, наприклад, обчислений вік монет або певна випадкова змінна, за рахунок чого забезпечується більш чесний вибір валідатора. Ця функція викликається з певним інтервалом і, при кожній спробі валідатора виконати її, видає певний результат (успішно чи ні).

До цифрових валют, які використовують алгоритм досягнення консенсусу на основі proof-of-stake, належать такі.

> * _Peercoin_
> * _Nxt_
> * _NEM_
> * _Novacoin_
> * _Cardano_

Під час старту системи, в якій застосовується proof-of-stake, монети ніяк не розподілені. Тому творці зазвичай починають з попереднього випуску монет або спочатку запускаються на основі proof-of-work, а потім переходять до повноцінного proof-of-stake. Але за що в такому випадку отримують нагороду валідатори? У першому випадку, оскільки всі монети випускаються заздалегідь, нагородою для валідаторів виступає комісія з проведених транзакцій. У разі поєднання PoW і PoS, валідатори можуть отримувати винагороду як за генерацію нових монет, так і за підтвердження транзакцій.

Для участі в процесі створення нових блоків, потрібно, щоб на балансі учасника були монети – stake (частка). Розмір частки впливає на ймовірність обрання вузла в якості наступного валідатора для forging блоку (рис. 5.1). Відповідно, чим більша частка, тим більший шанс.

<img width="50%" alt="Рисунок 5.1 – Розподіл шансу на додавання нового блоку серед валідаторів в залежності від їх частки" src="/resources/img/volume-2/5.1-Proof-of-stake-consensus-algorithms/Figure-5.1-Distribution-of-the-probability-to-add-a-new-block-among-validators-depending-on-their-stake.png"/> 

Розгляньмо відмінності між структурою блоку в proof-of-stake і proof-of-work системах на прикладі Peercoin (рис. 5.2). Саму систему Peercoin буде детально розглянуто далі.

<img width="50%" alt="Рисунок 5.2 – Порівняння структури PoW і PoS блоків" src="/resources/img/volume-2/5.1-Proof-of-stake-consensus-algorithms/Figure-5.2-Comparison-of-PoW-and-PoS-block-structures.png"/> 

Зліва розташовано схему блоку PoW, у якому є заголовок, подібний до такого в Bitcoin, _coinbase_ – вироджена транзакція, де є тільки один нульовий вхід, що не містить посилань, але з необмеженою кількістю виходів, сума значень на яких має не перевищувати суму винагороди, яка передбачена за створення цього блоку. Після coinbase транзакції йдуть транзакції інших користувачів. І за оригінальними правилами Bitcoin ці транзакції платят комісію, яка додається до винагороди за створення блоку.

Справа разташовано блок proof-of-stake. У його заголовку є вже дві вироджені транзакції: одна з них – coinbase, яка обов'язкова згідно з правилами протоколу, а друга – _coinstake_, яка потрібна тоді, коли блок згенеровано за правилами PoS. У coinstake транзакції свої правила формування. Якщо coinbase транзакція тут містить один вхід й один вихід, і обидва нульові, то coinstake транзакція містить хоча б один вхід, де вказано посилання на невитрачений вихід транзакції, розташованої на певній глибині (для цих монет розраховують параметр coinage), а також два чи більше виходи, перший із яких нульовий, а решта витрачають і перерозподіляють монети. До монет, які творець блоку спрямовує собі у виходах, буде сумуватися й винагорода за створення блоку за proof-of-stake.

Крім того, цей блок містить підпис творця блоку, який має бути перевірений відкритим ключем, указаним у першому вході coinstake транзакції. Підпис доводить, що саме цей учасник створив блок. Після coinstake транзакції йдуть користувацькі транзакції, які теж підписуються, тобто підписується весь блок.

Це зроблено, щоб будь-хто сторонній не міг привласнити новий блок PoS і використати його для підтвердження та розповсюдження своїх транзакцій. Якщо користувач не володіє певним ключем, він не зможе згенерувати потрібний підпис.

### Peercoin

Peercoin [38] – перша криптовалюта, у якій був представлений алгоритм proof-of-stake. При цьому варто відзначити, що у випадку з Peercoin використовується комбінація алгоритмів PoS і PoW. В цьому випадку одні блоки в ланцюжку створені за допомогою PoW, а інші – за допомогою PoS. Обидва варіанти блоків підтверджують транзакції і передбачають винагороду автору як суму комісій і нові (емісійні) монети. Але для блоків, створених за допомогою PoW, кількість нових монет набагато більша, бо ймовірність успішно згенерувати такий доказ не залежить від балансу валідатора. Також варто відзначити, що параметри складності для PoW і PoS розраховуються і змінюються незалежно один від одного. Так само, як і в proof-of-work, складність в proof-of-stake відповідає за вірогідність генерації доказу з першого разу і використовується для регулювання частоти генерації блоків. Таким чином, щоб на великому проміжку часу частота додавання блоків була постійною. Наприклад, якщо за останній час було згенеровано занадто багато або занадто мало блоків, складність збільшиться чи зменшиться відповідно.

Як вже було згадано раніше, шанс вузла на forging блоку в proof-of-stake залежить від кількості монет у нього на балансі. Однак, не можна обмежуватися винятковою цієї метрикою, оскільки тоді перевага віддавалася б найбільш багатим валідаторам, які вирішили зберігати більше монет на своїх гаманцях. Щоб уникнути цієї ситуації, використовуються додаткові методи вибору валідаторів.

У Peercoin для цього реалізований механізм coinage. Вік визначається шляхом множення кількості монет в частці на кількість днів, протягом якого вони знаходяться в частці. При цьому монета має пролежати на гаманці 30 діб, перш ніж вона зможе брати участь в forging. Користувачі, що зберігають в частці більшу кількість монет з великим віком, найімовірніше отримають право на forging наступного блоку.

Після того, як вузол провалідував наступний блок, вік його монет обнуляється і йому знову потрібно чекати 30 діб. При цьому ймовірність знаходження наступного блоку стає максимальною через 90 діб. Це не дозволяє домінувати користувачам з дуже великими і давно лежачими монетами.

> **_Зауваження._** *Вік монети, який витрачається на кинутий блок (orphan block) поновлюється. Через це вартість атаки на Peercoin дуже мала і зловмисник може продовжувати спроби генерації блоків до тих пір, поки йому це не вдасться. Для запобігання ризикам у Peercoin реалізований механізм централізованої трансляції checkpoints, які фіксують стан ланцюжка блоків і повідомляють про небезпеку альтернативних версій історії.*

Якщо власник гаманця хоче, щоб його монети припинили участь у процесі валідації і повернулися на основний баланс, йому доведеться почекати певний час. Це дозволяє впевнитися в тому, що блоки, додані за участю монет, не опиняться невалідними.

### Nxt

Nxt [39] – цифрова валюта, повністю заснована на алгоритмі proof-of-stake, тобто в ній немає можливості майнити нові монети і весь їхній запас (1 мільярд) доступний з самого початку роботи системи. Основна відмінність Nxt полягає в тому, яким чином система забезпечує захист від nothing-at-stake та інших видів атак.

Блок генерується, ґрунтуючись на унікальної інформації з попереднього блоку, яку легко перевірити і практично неможливо передбачити. Шанс вузла на forging нового блоку залежить від його ефективного балансу (у кожного аккаунта він свій), часу, що пройшов з моменту додавання минулого блоку, і певного базового значення. Два останніх параметра відомі всім вузлам системи. Ґрунтуючись на цих даних, легко передбачити, хто з валідаторів отримає право на генерацію наступного блоку.

На ефективний баланс облікового запису нараховуються монети, які не брали участі в транзакціях протягом часу, необхідного на генерацію 1440 блоків. В процесі forging беруть участь тільки монети, що знаходяться на ефективному балансі. Щоб не допустити проведення long-range атак, учасники можуть реорганізувати тільки 720 блоків, що передують поточному. Транзакція при цьому вважається остаточно вірною, якщо вона укладена в блок, який знаходиться на відстані 10 блоків від поточного.

_Цікаво відзначити, що в Nxt замість механізму UTXO, що застосовується в Bitcoin і Peercoin, використовується модель акаунтів і балансів, як, наприклад, в Stellar й Ethereum._

### NEM

Спочатку платформа NEM [40] розроблялася як клон Nxt, однак, згодом була значно перероблена і переросла в самостійну систему. Замість proof-of-stake в NEM використовується його модифікація під назвою proof-of-importance (PoI).

PoI має багато подібностей з PoS, однак при визначенні наступного валідатора використовуються додаткові чинники. Важливість вузла визначається трьома характеристиками: кількість монет, кількість проведених транзакцій і вік самої облікового запису. Таким чином творці NEM заохочують не тільки накопичувати монети, але і активно їх використовувати.

_Так само, як і в Nxt, у NEM відсутній майнінг монет. Валідатори отримують нагороду лише від комісії за підтверджену транзакцію._

У термінології NEM отримання нагороди за генерацію блоку називається harvesting. Щоб мати можливість брати участь в процесі генерації блоків, користувач повинен мати на балансі свого облікового запису не менше 10 000 монет. Важливо відзначити, що монети починають залучатись до процесу не відразу після зарахування на баланс. Кожного дня «повноправними» монетами стають 10% від поточного балансу аккаунту.

Можна помітити, що harvesting багато в чому схожий на forging, присутній в інших PoS-криптовалютах. Однак, у нього є певні відмінності, головна з яких така: пристрій учасника не повинен бути постійно увімкнений для участі в процесі валідації транзакцій.

У NEM присутній механізм delegated harvesting. Принцип його роботи полягає в тому, що учасник може підключити свій аккаунт до існуючого supernode і використовувати його обчислювальні потужності для спільної генерації блоків. Таким чином, можна віддати свій POI-рейтинг в розпорядження іншого вузла, підвищивши шанси на генерацію нового блоку без необхідності нарощувати обчислювальну потужність.

Як тільки в мережі NEM з'являється нова транзакція, перший вузол, який її виявляє, верифікує її і сповіщає інших, тим самим каскадно поширюючи інформацію по мережі.

Для підтримки «системи репутації» серед вузлів, в NEM використовується алгоритм Eigentrust ++. Він розподіляє навантаження по системі і усуває вузли, які не беруть участі в її розвитку.

### Ouroboros

У 2016 році був розроблений протокол Ouroboros [41], покликаний позбутися недоліків систем першого покоління. Ouroboros є першим доказово стійким PoS-протоколом. У ньому право на генерацію наступного блоку також визначається випадковим чином, але цей процес перевірюваний і доказово чесний. Коли в системі є більшість чесних учасників, зловмисник не може вплинути на випадковість алгоритму.

У Ouroboros вводиться поняття епохи (у Cardano, базованої на цьому протоколі, використовуються епохи тривалістю 5 днів). Кожна епоха, зі свого боку, поділяється на слоти тривалістю 30 секунд (рис. 5.3). Для кожного слота обирається лідер, який отримує право на додавання блоку в поточний слот. Лідери винагороджуються незалежно від того, чи випустили вони блок. Модель безпеки передбачає, що зловмисник може продовжувати довільну кількість ланцюжків до свого часового слоту.

<img width="50%" alt="Рисунок 5.3 – Епохи, слоти та лідери" src="/resources/img/volume-2/5.1-Proof-of-stake-consensus-algorithms/Figure-5.3-Epochs,slots-and-leaders.png"/> 

Вибір лідера слота реалізований на основі алгоритму Follow the Satoshi (FTS) [42], суть якого полягає в тому, що з усіх монет, які перебувають в частці, випадковим чином вибирається одна, і її власник стає лідером з усіма наслідками, привілеями та обов'язками, що випливають звідси. Отже, чим більше монет конкретного вузла бере участь в частці, тим більше у нього шансів стати лідером.

Оскільки лідер має значні повноваження, повинен існувати спосіб, який допоможе переконатися в тому, що він був обраний дійсно випадковим чином. Для цього застосовується спеціальний розподілений криптографічний протокол, що гарантує випадкові значення на виході. Так звані виборці (користувачі, які мають певний розмір частки, наприклад, 1% від загальної кількості монет) виконують умовне «підкидання монети» і діляться результатом із іншими виборцями. Ідея полягає в тому, що кожен учасник генерує вхідне значення, і в кінцевому підсумку вони отримують спільне випадкове значення на виході, на яке не може вплинути зловмисник за наявності хоча б одного чесного учасника в системі.

Вибори поділяються на три етапи:

1. Фаза обіцянки. Кожний учасник генерує секрет, після чого формує «обіцянку», у якій містяться зашифровані частки для решти учасників, підписуючи його за допомогою свого секретного ключа, вказує номер епохи, а також прикріплює відкритий ключ, щоб кожен учасник мережі міг перевірити коректність всіх даних із його повідомлення.
2. Фаза розкриття. Учасники розкривають свої обіцянки, сформовані на попередній фазі. Це значення додається виборцями в ланцюжок блоків.
3. Фаза вилучення. Якщо з якихось причин частина обіцянок лишилася нерозкритою (у деяких учасників проблеми з мережею й інше), то решта учасників об'єднує свої частки, отримані на першому етапі, та розкриває всю решту обіцянок. У кінцевому підсумку у кожного учасника повинен бути повний набір обіцянок і відкритих значень із доказами їхньої коректності. Потім на їх основі генерується seed для наступної епохи. Усі виборці отримують однакове значення seed, яке й використовується в алгоритмі FTS.

>**_Зауваження._** *Фундаментальне припущення протоколу Ouroboros полягає в тому, що чесних вузлів повинна бути більшість, а саме як мінімум 50% + 1. У такому випадку можна гарантувати, що зловмисникам не вдасться порушити сталість і живучість системи.*

### Ouroboros Praos

Ouroboros Praos [43] – перший proof-of-stake протокол, націлений на масштабування для широкого використання. Основна відмінність Praos в тому, що він працює в мережах, де є невідома верхня затримка доставки повідомлення. Він забезпечує гарантовану безпеку в ситуації, коли зловмисник вибирає учасників, які працюють за його правилами і генерують вигідні для нього блоки. Однак це можливо тільки якщо чесних учасників більше за 50%.

Для забезпечення випадковості в Ouroboros Praos використовуються випадкові функції, що верифікуються. Отримуючи секретний ключ і вхідні дані, функція видає псевдовипадкове число і доказ. Той, хто має відкритий ключ і доказ, може перевірити, чи дійсно число було отримано із заданих вхідних даних, але не може при цьому отримати його попередньо.

У Praos для для кожної епохи попередньо затверджується значення nonce, яке всі учасники зобов'язані використовувати в якості вхідних даних для своїх верифікованих випадкових функцій. У кожному слоті кожен учасник використовує свою верифіковану випадкову функцію і nonce для генерації випадкового числа. Якщо згенероване число менше, ніж порогове значення, співвідносне з часткою учасника, він стає лідером для заданого слота. Оскільки випадкові значення генеруються незалежно кожним учасником, може виникнути ситуація, коли у слота є кілька лідерів або їх немає взагалі. Nonce для наступної епохи обчислюється за значеннями верифікованих випадкових функцій, вбудованих в заголовки блоків попередньої епохи.

_Якщо вибирається кілька лідерів, відбувається форк, навіть якщо вони всі є чесними. У разі форка чесні сторони повинні вибрати ланцюжок, який вони отримали першим. Це означає, що лідери, які швидше передають свої блоки, мають більший шанс опинитися в найдовшому ланцюжку._

### Ouroboros Genesis

Ouroboros Genesis [44] був розроблений з метою створити PoS протокол, який буде здатний коректно працювати в аналогічних з Bitcoin умовах. Для цього було введено поняття Dynamic Availability. Під цим мається на увазі аналіз блокчейн-протоколу в середовищі з наступними характеристиками.

> * _Сторони приєднуються і відключаються за своїм бажанням_
> * _Кількість онлайн і оффлайн учасників динамічно змінюється_
> * _У будь-який заданий момент часу ми нічого не знаємо апріорі_

Протокол Ouroboros Genesis націлений на захист від далеких атак, суть яких в тому, що зловмисник отримує доступ до особистих ключів користувачів, які давно витратили свої монети, і з їх допомогою створює альтернативну історію, занурюючись в ланцюжок блоків набагато глибше.

Головним удосконаленням Ouroboros Genesis став новий принцип вибору ланцюжків. Лідер вибирає найдовший ланцюжок, який не перевищує задану довжину, або ту, яка має більше блоків на інтервалі розбіжності ланцюжків (рис. 5.4).

<img width="50%" alt="Рисунок 5.4 – Схема вибору головного ланцюжка" src="/resources/img/volume-2/5.1-Proof-of-stake-consensus-algorithms/Figure-5.4-Main-chain-selection-scheme.png"/> 

### Головні переваги та недоліки proof-of-stake

Тепер, коли ми розглянули основні принципи роботи proof-of-stake і конкретні реалізації облікових систем на основі цього протоколу, виокремімо його переваги, які здебільшого проявляються за порівняння його з proof-of-work.

> * _Немає необхідності в значних обчислювальних потужностях_
> * _Право створення блоків залежить не від обчислювальної потужності, а від кількості монет на балансі (і в деяких випадках характеристик цих монет)_
> * _Для створення блоків не потрібне спеціалізоване обладнання_

Головна перевага proof-of-stake-систем полягає в тому, що для участі в процесі валідування транзакцій не потрібно мати значні обчислювальні потужності: брати участь у forging може будь-який персональний комп'ютер із відповідним програмним забезпеченням і достатньою кількістю монет на балансі гаманця. Водночас, як ми згадували раніше, у таких системах, як NEM, можна делегувати свої монети _supernode_; у цьому разі учаснику навіть не треба постійно тримати комп'ютер увімкненим.

Наступна перевага значно підвищує вартість проведення атаки 51% для зловмисника. Проте це буде правдою тільки за розумного вибору характеристик монет, які враховуються під час вибору наступного валідатора, і впровадження деякої випадковості дял захисту від атаки попереднього обчислення. Детальніше про цю й інші атаки ми поговоримо пізніше.

Остання важлива перевага безпосередньо пов'язана з попередніми двома. Для того, щоб стати валідатором у proof-of-stake системі, не потрібно купувати інтегральні схеми спеціального призначення (ASIC), потужну відеокарту чи процесор.
Однак proof-of-stake-системи мають і такі недоліки. 

> * _Одноразова емісія є більш централізований підхід, ніж permissionless видобуток монет, який розтягнуто на певний період часу_
> * _Системи, базовані на proof-of-stake, наражені на більшу кількість атак, а самі атаки провести простіше, ніж, наприклад, за proof-of-work_

### Основні види атак на proof-of-stake-системи

Тепер розгляньмо, які є атаки, націлені на алгоритм proof-of-stake.

> * _Nothing-at-stake_
> * _Атака попереднього обчислення_
> * _Fake stake_
> * _Атака накопиченням віку монет_
> * _Ближні атаки_
> * _Дальні атаки_

### Атака nothing-at-stake

Суть атаки nothing-at-stake полягає в припущенні, що зловмисник може легко побудувати альтернативний ланцюжок блоків, а інші валідатори його підтримають, оскільки це нічого не варто їм в плані обчислювальної потужності на продовження обох ланцюжків. Тобто, може виникнути ситуація, коли всі валідатори одночасно працюють над кількома різними ланцюжками (рис. 5.5, 5.6).

<img width="40%" alt="Рисунок 5.5 – Приклад коректної поведінки вузла в ситуації, коли відбувається форк" src="/resources/img/volume-2/5.1-Proof-of-stake-consensus-algorithms/Figure-5.5-An-example-when-the-node-behaves-correctly-in-the-case-of-a-fork.jpg"/> 

<img width="43%" alt="Рисунок 5.6 – Проблема nothing-at-stake, коли вузол одночасно працює над декількома альтернативними ланцюжками" src="/resources/img/volume-2/5.1-Proof-of-stake-consensus-algorithms/-Figure-5.6-Nothing-at-stake-situation-when-the-node-works.png"/> 

Друга причина, з якої може статися подібна ситуація, полягає в тому, що для валідатора існує фінансова мотивація працювати над декількома ланцюжками одночасно, оскільки тоді вони загалом будуть генерувати більше блоків і отримувати за це більшу винагороду.

Однак, варто зазначити, що для реалізації атаки nothing-at-stake повинні виконуватися наступні припущення:

1. Валідатор буде шукати зиск для себе за будь-якої можливої ситуації, навіть якщо при цьому під удар буде поставлено безпеку і якість роботи мережі
2. Жоден з валідаторів не вестиме себе згідно з правилами системи
3. Валідатори модифікують своє програмне забезпечення, або використовують стороннє, яке свідомо модифіковано для некоректної поведінки.

Основний ризик, пов'язаний з nothing-at-stake, полягає в тому, що зловмисник може провести подвійну витрату, маючи всього 1% загальної частки в системі за умови, що всі вузли підтримають форк ланцюжка. Розгляньмо цю ситуацію докладніше (рис. 5.7).

<img width="55%" alt="Рисунок 5.7 – Подвійна трата на основі атаки nothing-at-stake" src="/resources/img/volume-2/5.1-Proof-of-stake-consensus-algorithms/Figure-5.7-Double-spending-based-on-nothing-at-stake.png"/> 

1. Аліса створює форк ланцюжка і відправляє певну кількість монет на обмінник.
2. В основний ланцюжок Аліса додає транзакцію, в якій переказує кошти на свій альтернативний аккаунт
3. Аліса обмінює свої монети, транзакція з обміном записується в альтернативний ланцюжок, який також виглядає правильно, оскільки його підтримують всі учасники.
4. Якщо обмін буде проведено успішно, Аліса виводить отримані монети на свій гаманець в іншій системі.
5. Аліса припиняє валідувати блоки альтернативного ланцюжка, внаслідок чого він обривається і відкидається.

Насправді така ситуація вкрай малоймовірна, оскільки вона передбачає, що абсолютно всі валідатори будуть підтримувати кожен новий блок. У діючих системах завжди знайдуться чесні вузли, які не стануть підтримувати альтернативні ланцюжки. В такому випадку Аліса змушена буде умовити частину валідаторів працювати над її ланцюжком або підвищити свою частку в системі.

### Атака попереднього обчислення

Якщо вузол-валідатор має значну обчислювальну потужність, він може вплинути на геш поточного блоку, щоб збільшити шанси формування наступного. Якщо обчислення показують, що наступний блок буде належати іншому користувачеві, зловмисник знову змінює параметри транзакції і повторює спробу. Ефективність цієї атаки залежить від розміру частки зловмисника і загальної кількості валідаторів у системі.

Для запобігання подібних атак потрібно додати в процес генерації блоків елемент випадковості.

### Атака fake stake

Дана атака покладається на те, що деякі реалізації алгоритму досягнення консенсусу на основі proof-of-stake не виконують перевірку coinstake-транзакції перед приміщенням блоку в ОЗУ або на жорсткий диск. Coinstake транзакція – це спеціальна транзакція, яку вузол відправляє самому собі під час формування блоку. Внаслідок цього зловмисник з дуже малою кількістю монет (або взагалі без них) може привести вузол-жертву до збою, заповнивши його жорсткий диск або ОЗУ підробленими даними.

Проблема в тому, що в багатьох PoS-системах (наприклад, HTMLCoin, Emercoin, Qtum та ін.) блоки поширюються мережею, розділяючись на два окремих повідомлення: Блок і Заголовок. Вузли запитують Блок тільки після того, як Заголовок проходить валідацію і потрапляє до найдовшого ланцюжка. Оскільки coinstake-транзакція міститься тільки в Блоці, вузол не зможе провалідувати Заголовок без нього. Отже, йому доводиться зберігати Заголовок безпосередньо в оперативній пам'яті, що дає зловмиснику можливість заповнити ОЗУ вузла фіктивними транзакціями.

### Атака накопиченням віку монет

Така атака могла бути здійснена в ранніх версіях монет, в яких використовується механізм віку монети. Зловмисник, що володіє певною часткою, міг почекати протягом тривалого часу і отримати практично повний контроль над мережею.

На даний момент в таких системах, як Peercoin, Novacoin і Blackcoin введено обмеження на максимальний вік монет, що дорівнює 90 добам.

### Short-range атаки

Для виконання ближньої атаки зловмисник створює альтернативний ланцюжок блоків, починаючи з блоку, який розташований недалеко від поточного, і намагається перегнати основний ланцюжок, переконавши учасників переключитися на свою версію. Валідаторам вигідніше працювати над декількома ланцюжками одночасно, оскільки це підвищує їхній дохід і збільшує шанс, що вони будуть працювати над правильною версією.

Однак, як ви пам'ятаєте з минулих розділів, в деяких PoS-системах, наприклад, Nxt, використовуються механізми, які на основі сукупності певних характеристик дозволяють передбачити, хто буде наступним працювати над новим блоком.

Альтернативний підхід захисту від ближніх атак полягає в тому, що валідатори зобов'язані «залишити в заставу» певну кількість монет перш, ніж отримати право брати участь в процесі генерації блоків. Валідатори, які підписують своїм ключем блоки що змагаються, будуть втрачати суму своєї застави.

### Long-range атаки

Суть long-range атаки полягає в тому, що зловмисник намагається переписати історію, починаючи з genesis block, оскільки, на відміну від PoW-систем, не потребує значних обчислювальних ресурсів. Крім того, зловмисник може спробувати отримати доступ до особистих ключів перших учасників системи, щоби використовувати відповідні монети для побудування альтернативного ланцюжка.

Запобігти такій атаці можна, обмеживши глибину, починаючи з якої валідатори можуть створити альтернативний ланцюжок блоків. Саме таким методом користуються активні на цю мить PoS-системи.

**Найбільш поширені питання**

*– Чому власник гаманця, у якого багато монет в системі, не може використовувати їх для шахрайства?*

У разі, коли власник гаманця з великою кількістю монет спробує шахраювати, ціна цих монет впаде, а для нього це вкрай невигідно.

*– Якщо 100 вузлів мережі proof-of-stake раз на секунду згенерують і відправлять до мережі свої пропозиції блоків, залишиться один блок. Хто саме вибере, який із цих блоків буде правильним, і вилучить решту 99?*

В алгоритмі консенсусу буде закладено правило вибору блоку. Щоб усі керувалися цим правилом і вибрали один блок, передбачено певні параметри. Наприклад, у Peercoin це coinage. У разі PoW, якщо хтось згенерував правильний блок, але замість нього прийняли інший, творці блоку змарнували обчислювальну потужність. У класичному же PoS творець блоку не витрачає свої монети. У тому самому Peercoin вони залишаться невитраченими на тій самій глибини ланцюжка і їх можна буде використати для наступної спроби генерування блоку.

*– Чи можна в PoS-системі захиститися від ситуації, коли зловмисні вузли змінять правила блоку?*

Неможливо змінити правила, не змінивши вихідний код уже запущених вузлів. Децентралізовані системи передбачають наявність певних правил обліку та завжди є вузли, які дотримуються цих правил. Авжеж, деякі зловмисні вузли можуть змінити своє програмне забезпечення, але тоді вони не зможуть працювати з чесними вузлами та всякі спроби змінити протокол або його правила будуть невдалими.

## 5.2 Delegated proof-of-stake як алгоритм досягнення консенсусу

DPoS (delegated proof-of-stake) – це алгоритм досягнення консенсусу в децентралізованому середовищі, який є альтернативою таким варіантам, як PoW (Bitcoin proof-of-work) і PoS (Peercoin або NXT proof-of-stake). DPoS був розроблений в 2014 році в рамках проекту Graphene і вперше був задіяний у проекті Bitshares, а пізніше в проектах Steemit і EOS. DPoS вирішує основну проблему PoW, а саме високе споживання енергії даним алгоритмом. DPoS вирішує цю проблему, надаючи право формувати блоки тільки обраним шляхом голосування вузлам-валідаторам мережі з апаратурою, що відповідає певним вимогам щодо обчислювальної потужності.

Також DPoS вирішує основну проблему PoS, а саме потребу запуску користувачем повного вузла мережі для того, щоб його монети брали участь в досягненні консенсусу. У DPoS ж дана проблема вирішена наявністю валідаторів з запущеними повними вузлами мережі, які обробляють транзакції, а користувачеві для того, щоб його монети брали участь в досягненні консенсусу, досить лише відправити спеціальну транзакцію з голосом.

У DPoS-системах, на відміну від proof-of-stake систем, монети, які знаходяться у користувачів, можуть одночасно брати участь в голосуванні і при цьому використовуватися для перекладів. А в результаті зміни балансу вага в голосуванні буде змінюватися відповідно.

Такий тип досягнення консенсусу найкраще підходить для побудови облікової системи, яка передбачає наявність як звичайних користувачів (мобільні клієнти), так і безлічі компаній (повноцінні вузли, які можуть грати роль валідаторів). DPoS спроектований таким чином, що підтримує високу частоту генерації нових блоків і здатний обробляти велику кількість транзакцій за одиницю часу в порівнянні з іншими алгоритмами досягнення консенсусу, які працюють в розподіленому середовищі без довіри. DPoS добре підходить для проектування систем з відкритим доступом, де не потрібна ідентифікація користувачів.

### Алгоритм DPoS

Умови, в яких працює даний алгоритм досягнення консенсусу, відрізняються від умов, в яких працюють PoW і PoS. А саме, валідаторам необхідно розкрити свої особистості і заявити про готовність безперебійно підтримувати роботу повноцінного вузла мережі, своєчасно виконувати верифікацію транзакцій і формувати нові блоки.

Механізм досягнення консенсусу на основі модифікованого proof-of-stake працює за таким правилом, що кожен користувач за бажанням може виставити свою кандидатуру на пост валідатора. Потім серед всіх користувачів проводиться голосування за кандидатів, де вага кожного голосу визначається сумою активів того, хто голосує. Завдяки тому, що користувачі можуть бачити, хто з валідаторів отримав можливість формувати нові блоки, вони можуть скласти строгу послідовність із валідаторів й оптимізувати формування блоків і їх перевіряння. Це дозволяє платформі зменшити час формування блоків і підвищити пропускну здатність. На практиці було перевірено, що за кількості валідаторів кілька десятків можна досягти частоти генерування блоку 1–2 Гц.

Залежно від реалізації DPoS, користувач також може визначити вагу ставки, але ставка у жодному разі не може перевищувати за значенням кількість наявних у користувача активів. Є ще одна особливість, наявність якої теж залежить від реалізації DPoS, – proxy voting, яка полягає в тому, що якщо користувач не знає, за якого члена комітету чи валідатора потрібно голосувати, він може віддати свою вагу голосу іншому звичайному користувачу, якого він вважає більш компетентним у цьому питанні.

За результатами голосування вибирається N (натуральне число, яке вибирає спільнота, зазвичай 20–50) кандидатів, які отримують право формувати нові блоки транзакцій. Цікаво, що члени комітету (якщо такі присутні) та валідатори неанонімні. У системі певної цифрової валюти вони мають акаунти, асоційовані з їхніми identities. Вони мають певну репутацію, беруть участь у розробленні проекту, присутні на форумах, пропонують свої покращення тощо. Їхню діяльність видно. Правила протоколу гарантують коректне прийняття рішень, якщо більша частина активів, які беруть участь в голосуванні, контролюється чесними користувачами. 

Делегати, які стали валідаторами за результатами голосування, псевдовипадково перемішуються, утворюючи чергу, і починають почергово публікувати блоки. Для перемішування можна використовувати деякий спільний для всіх рандомізатор – число, на основі якого буде визначено порядок валідаторів. У ролі рандомізатора може бути використано останній стан ланцюжка блоків – геш-значення останнього блоку. Для всіх, хто переключається на правильну за протоколом версію ланцюжка блоків, геш-значення збігатимуться. Отже, валідатори будуть перемішані в однаковий для всіх спосіб, проте цей порядок неможливо передбачити, оскільки геш-значення від нових блоків неможливо знати заздалегідь. Після того, як останній валідатор в черзі опублікував блок, закінчується цикл роботи групи валідаторів і починається новий в тому самому порядку.

Список валідаторів дійсний протягом епохи, що складається з циклів роботи валідаторів. Після кожної епохи (рис. 5.7) відбувається оновлення списку валідаторів відповідно до результатів голосування, голоси користувачів, які проголосували під час роботи валідаторів, вступають в силу. Пізніше ці дії повторюються.

<img width="50%" alt="Рисунок 5.7 – Етапи досягнення консенсусу" src="/resources/img/volume-2/5.2-Delegated-proof-of-stake-as-a-consensus-algorithm.png/Figure-5.8-Consensus-achievement-stages.png"/> 

Валідатори беруть участь в наступних процесах:
> * _Підтримка повних вузлів в стабільному робочому стані_
> * _Збір та верифікація транзакцій від всіх користувачів_ 
> * _Формування блоків_
> * _Підпис і публікація блоків_
> * _Верифікація блоків інших валідаторів_

Валідатори публікують блоки з геш-значенням останнього блоку, з яким вони згодні. Якщо всі валідатори чесні і згодні один з одним, то ланцюжок блоків виглядає подібним чином (рис. 5.8 (1)). Якщо ж з'являється суперечність, наприклад, валідатор С не згоден з блоком валідатора В, то ланцюжок блоків матиме розгалуження (рис. 5.8 (2)). І вже в залежності від вибору інших валідаторів, буде визначений актуальний ланцюжок.

<img width="42%" alt="Рисунок 5.8 – Структура ланцюжка блоків при: (1) –  згоді валідаторів; (2) –  незгоді валідаторів щодо подальшого блоку" src="/resources/img/volume-2/5.2-Delegated-proof-of-stake-as-a-consensus-algorithm.png/Figure-5.9-Blockchain-structure-(1)-validators-are-in-agreement-(2)-validators-disagree-about-the-next-block.png"/> 

Делегати, що запустили повні вузли мережі і готові надати свої послуги, але не стали валідаторами, залишаються в очікуванні стати такими. Вузол делегата фактично є вузлом-аудитором, але може в будь-який момент стати вузлом-валідатором, якщо підніметься в черзі кандидатів.

Залежно від реалізації DPoS, наприклад BitShares, у користувачів також може бути можливість передати свою вагу голосу якимось довіреним особам, єдиною метою яких є стежити за системою і голосувати. Дана опція називається proxy voting.

При цьому варто зауважити, що в тому ж BitShares користувачі, крім виборів валідаторів, також мають можливість вибирати членів комітету (committee members) і робітників (workers). Члени комітету – користувачі, які мають право змінювати шляхом голосування параметри протоколу, такі, як розмір блоків, інтервали між ними, і визначати комісію за транзакції. Робітники – це користувачі, які надають свої пропозиції щодо виконання ними певної фактичної роботи з оновлення протоколу. Якщо пропозиція робітника набрала достатню кількість голосів членів комітету, то worker починає розробку і отримує винагороду за кожен етап її виконання.

В даному алгоритмі вага кожного делегата безпосередньо залежить від користувачів. Голосуючи, користувачі можуть позбавити їх ваги, перенаправивши або знявши з них свої ставки, якщо ті починають діяти на шкоду системі або перестають виконувати роботу. Варто зауважити, що зміни в голосах вступають в дію після кінця епохи роботи валідаторів. З плином часу склад валідаторів може змінюватися шляхом голосування, за підсумком якого позбавляються прав валідатора бездіяльні учасники і нагороджуються ті, які активно працюють.

### Як запускається облікова система, яка використовує DPoS?

Cпочатку, маючи в системі з DPoS тільки користувачів, які не довіряють один одному, і не маючи серед них валідаторів для створення блоків, а відповідно, не маючи можливості висунутися в валідатори і проголосувати, систему з DPoS запустити не вийде. Тому в основному перед запуском такої системи спільнотою проводиться окреме голосування на окремій платформі. В даному голосуванні вибираються серед майбутніх користувачів перша група валідаторів і інших ролей. Члени community також можуть оголосити перший список валідаторів і інших ролей, що складається зі своїх довірених користувачів.

### Як працює DPoS?

Користувачі, які бажають висунути свою кандидатуру на роль валідатора, запускають повний вузол мережі і заявляють про свою готовність формувати блоки. Для цього вони формують транзакції з операцією створення нового делегата. Після висунення делегата, користувачі, які бажають проголосувати, формують транзакцію з операцією голосування.

Наприклад, Аліса і Боб хочуть стати валідаторами (рис. 5.9), для цього вони формують транзакції з операцією створення нового делегата, які з'являються в ledger з публікацією блоку n. Єва має 115 монет на рахунку, а Керол 564 монет і вони обидві хочуть проголосувати. Для цього вони формують транзакції з операцією голосування, які з'являються в леджері з публікацією одного з наступних блоків. Наприклад, блоку n + 1.

<img width="42%" alt="Рисунок 5.9 – Приклад голосуванняя" src="/resources/img/volume-2/5.2-Delegated-proof-of-stake-as-a-consensus-algorithm.png/Figure-5.10-Voting-example.png"/> 

Розглянемо роботу DPoS на загальному прикладі з трьома валідаторами і трьома циклами їх роботи:

Користувачі: Аліса, Боб, Керол, Єва, Вілл, Джо й Марі.
Баланс коштів: Аліса – 1, Боб – 2, Керол – 3, Єва – 4, Вілл – 5, Джо – 6, Марі – 7.

Можна помітити, що серед всіх користувачів найбільш впливовим на етапі голосування є Марі. Далі відбувається голосування (рис. 5.10):

За Керол проголосували: Єва (4), Аліса (1), Вілл (5), Джо (6).
За Єву проголосували: Керол (3), Боб (2), Марі (7).
За Алісу проголосували: Керол (3), Єва (4), Боб (2), Джо (6).
За Боба проголосували: Вілл (5).

<img width="30%" alt="Рисунок 5.10 – Результат голосування" src="/resources/img/volume-2/5.2-Delegated-proof-of-stake-as-a-consensus-algorithm.png/Figure-5.11-The-voting-results.png"/> 

В результаті голосування Керол, Єва і Аліса, маючи найбільшу кількість голосів, вважаються рівноправними валідаторами, а Боб, маючи менше голосів, залишається делегатом. В цьому випадку консенсус досягається шляхом почергової публікації блоків групою валідаторів. Припустімо, деякий користувач хоче провести конфліктні транзакції ТxА і TxВ. Транзакції перевіряють валідатори: Аліса, Керол і Єва публікують блоки тільки з транзакціями, з якими вони згодні. Тут може бути два випадки.

#### Випадок 1
Валідатори згодні з ТxВ (рис. 5.11). Єва згодна з ТxВ, Аліса згодна з ТxВ, а отже, згодна і з Євою. Керол згодна з ТxВ, а отже, згодна й з Алісою. Ланцюжок блоків не розгалужується.

<img width="50%" alt="Рисунок 5.11 – Формування блоків, якщо кожен з валідаторів згоден з попереднім станом блоку" src="/resources/img/volume-2/5.2-Delegated-proof-of-stake-as-a-consensus-algorithm.png/Figure-5.12-Block-formation-if-every-validator-agrees-with-the-previous-block-state.png"/> 

#### Випадок 2
Керол згодна з ТxА, в той час як Єва і Аліса згодні з ТxВ. Єва формує блок з обраної нею транзакцією, після чого Аліса, якщо згодна з вибором Єви, формує свій блок, грунтуючись на блоці Єви, в іншому ж випадку Аліса формує окремий задовольняючий її блок. Далі Керол формує блок, грунтуючись на одному з блоків Єви або Аліси, з яким вона згодна. Таким чином, ланцюжок блоків розгалужується. Тепер для всіх вузлів мережі є два альтернативні ланцюжки блоків на вибір. Якщо вони обидва відповідають правилам протоколу, то чесні вузли зацікавлені зробити однаковий вибір. Для цього в протоколі існує правило, яке свідчить, що пріоритетним є той ланцюжок, який підтримується великою кількістю валідаторів. У цьому прикладі (рис. 5.12) Аліса та Єва віддали перевагу транзакції TxB. Оскільки це більшість валідаторів, ланцюжок із ТxВ вважається актуальним, а ланцюжок із ТxА вважається відгалуженням.

<img width="50%" alt="Рисунок 5.12 – Формування блоків в разі незгоди одного з валідаторів щодо набору транзакцій" src="/resources/img/volume-2/5.2-Delegated-proof-of-stake-as-a-consensus-algorithm.png/Figure-5.13-Block-formation-while-one-of-the-validators-disagree-with-the-transaction-set.png"/> 

Припустімо, стався випадок №2 й було опубліковано блок із ТxА, а не з ТxВ. Керол дискредитувала себе перед користувачами мережі – і вони вирішили перерозподілити голоси (рис. 5.13):

За Керол проголосували: Боб (2).
За Єву проголосували: Керол (3), Аліса (1), Вілл (5), Джо (6).
За Алісу проголосували: Єва (4), Вілл (5), Джо (6).
За Боба проголосували: Вілл (5), Джо (6), Марі (7).

<img width="30%" alt="Рисунок 5.13 – Результати другого голосування" src="/resources/img/volume-2/5.2-Delegated-proof-of-stake-as-a-consensus-algorithm.png/Figure-5.14-Second-vote-results.png"/> 

У результаті, Боб, Єва і Аліса, маючи найбільшу кількість голосів, вважаються рівноправними валідаторами і Керол, маючи менше голосів, припинила бути валідатором. Список валідаторів оновлюється і весь процес повторюється.

## 5.3 Алгоритми, що належать до BFT-класу

Не всі облікові системи вимагають такого рівня децентралізації, як у Bitcoin, але при цьому мають потребу в набагато більш високій пропускній здатності і малому часу підтвердження транзакцій. Більш того, дуже часто має сенс створення облікової системи permissioned характеру з можливістю призначення валідаторів виключно в ручному режимі. У таких умовах і працюють BFT-протоколи досягнення консенсусу.

У цьому розділі ми розглянемо принципи функціонування найбільш затребуваних протоколів такого класу, проведемо порівняльну характеристику розглянутих протоколів, а також пояснимо, чому забезпечується відмовостійкість систем BFT-типу.

### Practical BFT algorithm

Practical Byzantine Fault Tolerance (pBFT) [45] алгоритм досягнення консенсусу призначений для функціонування в асинхронних децентралізованих системах. Всі вузли в системі пов'язані між собою, причому в кожен момент часу один з вузлів є лідером. Метою протоколу є досягнення згоди між усіма чесними вузлами, коли кількість failed вузлів не більше *(n − 1) / 3*, де *n* – це загальна кількість вузлів-валідаторів в системі. У контексті BFT під failed вузлами маються на увазі не тільки ті, які не діють або поводяться непередбачувано, але ще й ті, які навмисно вступили в загальний змову з метою порушення роботи чесних вузлів.

Алгоритм складається з 5 основних етапів, починаючи від пропозиції додавання транзакцій до кінцевого поновлення стану облікової системи.

> * _Request_
> * _Pre-prepare_
> * _Prepare_
> * _Commit_
> * _Reply_

Далі ми розглянемо особливості кожного з етапів досягнення консенсусу за допомогою pBFT, після чого розберемося, як кількість чесних вузлів впливає на здатність системи досягати згоди щодо поновлення стану облікової системи.

На етапі _request_ відбувається отримання вузлом-лідером транзакцій для підтвердження (рис. 5.14). При отриманні транзакцій, вузол-лідер виконує їх перевірку і об'єднує в блок. Після цього блок підписується і може бути поширений іншим валідатором платформи.

<img width="40%" alt="Рисунок 5.14 – Схема отримання транзакцій лідером" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.15-Leader-receives-transactions.png"/> 

Далі настає _pre-prepare_ етап, під час якого вузол-лідер розсилає всім іншим валідаторам сформований блок (рис. 5.15). Блок підписаний валідатором-лідером і відправлений разом з pre-prepare повідомленням, в результаті чого інші вузли можуть автентифікувати відправника і зрозуміти, до якого етапу досягнення консенсусу відноситься цей блок. Відзначимо, що загальна кількість повідомлень, переданих на цьому етапі, так само *n − 1*, де *n* – загальна кількість валідаторів.

<img width="40%" alt="Рисунок 5.15 – Схема передачі блоку валідаторам" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.16-Block-transmission-scheme.png"/> 

Протягом наступного етапу (_prepare_) інші валідатори обмінюються отриманим блоком один з одним (кожен валідатор відправляє блок всім іншим валідаторам). Блок відправляється разом з повідомленням prepare і підписом валідатора, який його відправив (рис. 5.16). Таким чином кожен валідатор повідомляє, що він верифікував даний блок і готовий його підтвердити. Максимальна кількість повідомлень на цьому етапі дорівнює _(n − 1) * (n − 1)_, де _n_ – загальна кількість валідаторів. Якщо деякі вузли відмовляють в обслуговуванні і не відповідають, мінімальна кількість повідомлень в мережі дорівнює _(n − 1 − f) * (n − 1)_, де _f_ – кількість failed вузлів _(f<sub>max</sub> = (n − 1) / 3)_.

<img width="40%" alt="Рисунок 5.16 – Схема обміну блоками між валідаторами" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.17-Block-exchange-scheme.png"/> 

На цьому етапі важливо відзначити, що мережа є асинхронною, тобто фактично будуть присутні затримки при передачі повідомлень між валідаторами. За таких умов рішення про перехід до наступного етапу приймається незалежно кожним окремим вузлом згідно отримання _2f + 1_ підтверджень від інших валідаторів. Інакше кажучи, як тільки один з вузлів отримав prepare повідомлення (щодо одного і того ж блоку) від _2f + 1_ різних валідаторів, він може переходити до наступного етапу.

Коли необхідну кількість підтверджень отримано, вузол переходить до _commit_ етапу, на якому він заявляє про підтвердження конкретного блоку. На цьому етапі він формує commit повідомлення, підписує і пересилає його всім іншим валідаторам (рис. 5.17). Як тільки окремий вузол отримує commit повідомлення від _2f + 1_ валідаторів, він оновлює локальне стан бази даних відповідно до підтверджених транзакцій. Максимальна кількість повідомлень на цьому етапі дорівнює _n * (n − 1)_, а мінімальне _(n − f) * n_.

<img width="40%" alt="Рисунок 5.17 – Схема обміну commit-повідомленнями" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.18-Commit-messages-exchange-scheme.png"/> 

Після того як локальні копії баз даних валідаторів оновлені, користувачі можуть отримати від них актуальний стан і переконатися в тому, що черговий блок був підтверджений більшістю валідаторів (рис. 5.18). Відзначимо, що pBFT алгоритм досягнення консенсусу гарантує, що якщо валідатори додали черговий блок до ланцюжка блоків, то цей блок не може бути змінений/замінений.

<img width="40%" alt="Рисунок 5.18 – Схема поширення нового стану системи" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.19-New-system-state-distribution-scheme.png"/> 

Деяким обмеженням протоколу practical BFT є велика кількість повідомлень, якими валідатори обмінюються між собою. Відзначимо, що максимально можлива і мінімальна кількість таких повідомлень, коли можливе досягнення консенсусу, дорівнюють відповідно:

$$Messages_{max} = n + (n − 1) * (n − 1) + n * (n − 1),$$

$$Messages_{min} = n + (n − 1 − f) * (n − 1) + (n − f) * (n − 1),$$

де $n$ – кількість всіх валідаторів, $f$ – максимальна кількість failed вузлів (табл. 5.1).

Таблиця 5.1
<img width="50%" alt="Таблица 5.1" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Table-5.1.png"/> 

Розгляньмо детальніше, як вузли досягають консенсусу, і що відбувається в разі, якщо декілька вузлів-валідаторів відмовляють в обслуговуванні або поводяться зловмисно.

### Процес досягнення консенсусу

Уявімо ситуацію, коли в досягненні консенсусу за допомогою pBFT протоколу беруть участь 5 валідаторів, серед яких один є лідером. За таких умов найбільша кількість failed вузлів може дорівнювати 1 (якщо відмовлять 2 або більше вузлів – консенсус досягнутий не буде).

Для початку розглянемо випадок, коли всі вузли є чесними і жоден з них не відмовив в обслуговуванні (рис. 5.19). Процес досягнення консенсусу можна розбити на наступні кроки.

1. _Request_. На першому етапі вузол-лідер отримує транзакції від користувачів системи, перевіряє їх відповідно до правил протоколу і формує блок.
2. _Pre-prepare_. Далі вузол-лідер поширює цей блок іншим валідаторам. Позаяк вузол-лідер поводиться чесно, всі інші валідатори отримують один і той же блок.
3. _Prepare_. Вузли обмінюються між собою отриманим блоком. Оскільки всі вузли чесні і не відмовляють в обслуговуванні, то після закінчення цього етапу кожен валідатор має однакові підтвердження блоку від всіх інших вузлів. Тому вони можуть перейти до етапу commit.
4. _Commit_. Валідатори обмінюються значенням блоку, яке вони готові підтвердити. Після закінчення цього етапу кожен з валідаторів отримує абсолютну більшість підтверджень єдиного блоку і оновлює свій стан реєстру.
5. _Reply_. Користувачі системи звертаються до валідатора за актуальним станом. Оскільки всі валідатори оновили свій стан реєстру на підставі одного і того ж блоку, то інші учасники (аудитори і звичайні користувачі) можуть оновити свій локальний стан.

<img width="50%" alt="Рисунок 5.19 – Схема обміну повідомленнями між чесними валідаторами" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.20-Message-exchange-scheme-for-honest-validators.png"/> 

Тепер розглянемо ситуацію (рис. 5.20), коли один з п'яти валідаторів спробує перешкодити досягненню консенсусу (фактично цей вузол може просто відмовити в обслуговуванні, але ми розглянемо ситуацію коли вузол поводиться зловмисно – обидва випадки на рівні досягнення консенсусу не відрізняються один від одного).

1. _Request_. Лідер отримує транзакції і формує з них блок.
2. _Pre-prepare_. В даному прикладі вузол-лідер є чесним вузлом, відповідно, він відправляє всім іншим вузлам однакове значення блоку.
3. _Prepare_. Вузли обмінюються повідомленнями між собою і кожен чекає _2f + 1_ підтверджень конкретного блоку (від _2f + 1_ чесних валідаторів). Відзначимо, що, незважаючи на зловмисну поведінку одного з валідаторів і те, що він відправляє всім іншим вузлам значення блоку, яке відрізняється від початкового, інші чесні валідатори можуть отримати необхідну кількість підтверджень і перейти до наступного етапу.
4. _Commit_. Валідатори ще раз обмінюються один з одним повідомленнями, які містять блок, що підтверджується. Навіть коли зловмисний валідатор відправляє всім невалідні значення блоку, інші валідатори все одно отримують необхідну кількість підтверджень і оновлюють локальний стан реєстру.
5. _Reply_. При зверненні до валідатора, користувачі орієнтуються на блок, який був підтверджений більшістю, а, відповідно, недійсний блок, відправлений зловмисником, враховуватися при оновленні стану реєстру не буде.

<img width="50%" alt="Рисунок 5.20 – Схема обміну повідомленнями між валідаторами (серед котрих один нечесний" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.21-Message-exchange-scheme-with-one-malicious-validators.png"/> 

Дійсно проблемною для даного прикладу стає ситуація, за якої існує більш, ніж один злочинний вузол (рис. 5.21). В цьому випадку решта вузлів не зможе досягти консенсусу (хоча їх і більше, ніж зловмисників). Тому ми розглянемо функціонування тієї ж системи, але вже за наявності двох злочинних валідаторів.

1. _Request_. Лідер отримує транзакції і формує з них блок.
2. _Pre-prepare_. Вузол-лідер все ще чесний вузол, відповідно, він відправляє всім іншим вузлам однакове значення блоку.
3. _Prepare_. Вузли обмінюються повідомленнями між собою і кожен чекає _2f + 1_ підтверджень. Однак кількість злочинних вузлів перевищує значення _f_, чесні вузли не отримають достатню кількість підтверджень і не зможуть перейти до наступного етапу досягнення консенсусу (етапи commit і reply пропускаються, новий блок не створюється і вузли повторюють спробу заново).

При цьому важливо відзначити, що якби вузол-лідер гарантовано був чесним, то мережа могла б досягти консенсусу (адже кожен з інших чесних вузлів мав би три підтвердження з п'яти). Але оскільки вузли не впевнені, що лідер поводиться чесно (фактично він може змінити своє рішення), то за таких умов консенсус не може бути досягнутий.

<img width="50%" alt="Рисунок 5.21 – Схема обміну повідомленнями між валідаторами (серед котрих два нечесних)" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.22-Message-exchange-scheme-with-two-malicious-nodes.png"/> 

В якості останнього варіанту розвитку подій розглянемо ситуацію, коли зловмисником є ​​лідер (рис. 5.22). У цьому випадку він може передавати всім іншим вузлам різне значення блоків і, відповідно, згоди досягнуто не буде.

1. _Request_. Лідер отримує транзакції і формує 4 різних блоки.
2. _Pre-prepare_. Вузол-лідер передає всім іншим вузлам різні значення блоків. На даному етапі вузли не знають, що отримали різні значення блоків, і тому вони переходять до наступного етапу.
3. _Prepare_. Вузли обмінюються повідомленнями між собою (кожен відправляє кожному) і кожен чекає _2f + 1_ підтверджень. Так як всі з них отримали різне значення блоків, вони і обмінюються різними значеннями, що в підсумку призводить до того, що всі з них не зможуть дочекатися необхідної кількості підтверджень і не зможуть перейти до наступних етапів досягнення консенсусу.

<img width="50%" alt="Рисунок 5.22 – Схема обміну повідомленнями між валідаторами з нечесним лідером" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.23-Message-exchange-scheme-with-a-malicious-leader.png"/> 

### HotStuff як алгоритм досягнення консенсусу

HotStuff [46] також є BFT-подібним алгоритмом досягнення консенсусу, який також передбачає наявність лідера. Однак в цій схемі кожен крок досягнення консенсусу залежить від лідера. Кожен вузол не обмінюється повідомленнями між усіма іншим вузлами, а передає його лідеру, який в подальшому займається його розповсюдженням. На кожному етапі лідер пропонує зміну стану досягнення консенсусу (перехід на новий етап), а інші вузли підтверджують або відхиляють його.

Подібний підхід дозволяє значно знизити навантаження на мережу в цілому шляхом зменшення кількості повідомлень, що передаються вузлами.

Алгоритм складається з 4 етапів, по проходженню яких вузли досягають консенсусу щодо зміни стану реєстру (рис. 5.23).

> * _Prepare_
> * _Pre-commit_
> * _Commit_
> * _Decide_

На кожному з цих етапів вузол-лідер формує так званий quorum certificate який містить підписи інших валідаторів. Тут використовується механізм порогового підпису: вузли переходять до наступного етапу взаємодії, коли сертифікат набирає кількість підписів, що перевищує необхідний поріг _2f + 1_. Перед початком кожного наступного етапу лідер передає всім валідаторам сертифікат попереднього етапу. Вузли перевіряють, що необхідний поріг в сертифікаті досягнутий, і можуть голосувати щодо наступного етапу досягнення консенсусу.

<img width="50%" alt="Рисунок 5.23 – Схема передачі повідомлень між валідаторами" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.24-Message-exchange-scheme.png"/> 

_Prepare_ полягає у отриманні вузлом-лідером набору транзакцій з мережі, формуванні блоку для підтвердження і поширенні цього блоку решті вузлів-валідаторів разом з prepare повідомленням.

На етапі _pre-commit_ вузли перевіряють, що отриманий на попередньому етапі блок задовольняє правилам протоколу, після чого відправляють вузлу-лідеру підтвердження про свою готовність завалідувати цей блок. Лідер отримує prepare голоси валідаторів і об'єднує їх в _pre-commit quorum certificate_, після чого поширює його іншим валідатори для підтвердження разом з _pre-commit_ повідомленням.

На етапі _commit_ валідатори перевіряють pre-commit сертифікат, і якщо вони з ним згодні, то підписують pre-commit повідомлення і повертають його лідеру. Щоб цей pre-commit сертифікат вважався дійсним, він повинен бути підписаний пороговою кількістю валідаторів. Підписом валідатора покриваються всі транзакції, тому фактично лідер збирає голоси валідаторів щодо цілого блоку і не може змінити його в подальшому, оскільки при цьому підписи перестануть бути валідними.

Після отримання достатньої кількості підтверджень лідер знову формує quorum certificate, проте вже для етапу commit, і відправляє його іншим валідаторам, після чого вузли переходять до наступного етапу голосування.

На етапі decide відбувається аналогічний процес. Валідатори отримують commit quorum certificate від лідера, перевіряють що він валідний і містить підписаний необхідною кількістю валідаторів сертифікат попереднього етапу, після чого підписують і його. Після того, як лідер отримує достатню кількість підтверджень commit quorum certificate, він формує _decide certificate_ і передає його всім вузлам валідаторам.

При отриманні такого сертифікату, валідатори вважають що всі етапи досягнення консенсусу пройдені і оновлюють свій стан реєстру в залежності з транзакціями.

Тепер розгляньмо кількість повідомлень, які передаються між валідаторами системи в цьому випадку (табл. 5.2).

Таблиця 5.2
<img width="50%" alt="Таблица 5.2" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Table-5.2.png"/> 

Як видно з графіка, протокол HotStuff дозволяє у багато разів зменшити кількість переданих повідомлень, в порівнянні з pBFT. Для порівняння наведемо графік співвідношення кількості валідаторів і кількість переданих між вузлами повідомлень (рис. 5.24).

<img width="35%" alt="Рисунок 5.24 – Графік залежності кількості переданих повідомлень від використовуваного алгоритму" src="/resources/img/volume-2/5.3-BFT-class-algorithms/Figure-5.25-Relationship-between-the-number-of-transmitted-messages-and-the-algorithm-used.png"/> 

При цьому необхідно розуміти, що в разі, якщо на одному з етапів досягнення консенсусу відмовить в обслуговуванні вузол-лідер, то:

* pBFT протокол передбачає, що консенсус все одно буде досягнутий, якщо кількість чесних вузлів достатня (і якщо відмова лідера не відбувається на найпершому етапі);
* HotStuff має на увазі, що консенсус не може бути досягнутий, так як перехід на кожен наступний етап досягнення консенсуса ініціюється лідером і не може бути ініційований ніким іншим.

**Найбільш поширені питання**

*– Що станеться, якщо вузол-лідер відмовить в обслуговуванні на тривалий час?*

Дуже часто протоколом досягнення консенсусу передбачається, що роль лідера передається кожному новому вузлу на кожному етапі формування нового блоку. Таким чином, якщо валідатор, який є лідером, відмовить в обслуговуванні і консенсус щодо одного з блоку досягнутий не буде, то наступний блок буде ініційований вже наступним вузлом.

*– Чим обмежена максимальна кількість валідаторів для алгоритмів досягнення консенсусу з класу BFT?*

В теорії немає суворого обмеження, однак найбільш ефективним кількістю валідаторів BFT-based алгоритмів досягнення консенсусу є: до декількох десятків валідаторів в разі pBFT подібних алгоритмів; або для декількох сотень в разі використання HotStuff і схожих з ним протоколів. Ці показники є найбільш оптимальними з точки зору безпеки облікової системи, і при цьому дозволяють зберігати невеликою кількість переданих повідомлень і час досягнення консенсусу. 

*– Що зазвичай потрібно, щоб стати валідатором в системі на основі алгоритму досягнення консенсусу, що належить класу BFT?*

Щоб додати або видалити валідатора, необхідна згода на це _2f + 1_ всіх поточних валідаторів. Тому, щоб стати валідатором, необхідно отримати згоду у поточних валідаторів і встановити з'єднання з ними.

## 5.4 FBA як підхід до досягнення консенсусу

FBA (Federated Byzantine Agreement) – це алгоритм досягнення консенсусу, який будується на основі BFT. Головна відмінність FBA – взаємодія вузлів в системі визначається динамічно самими учасниками, тобто вузол стає валідатором для тих, хто йому довіряє. В області фінансових технологій вперше алгоритм FBA був успішно використаний на платформі Stellar.

У FBA власник вузла самостійно повинен вибрати групу вузлів, власникам яких він довіряє (очікуючи, що вони не будуть порушувати правила). При цьому довіра може бути встановлена в один бік, тобто вузол A може довіряти рішенням вузла В, але В не обов'язково буде вірити А.

FBA дозволяє досягати консенсусу серед необмеженої кількості валідаторів, які не знають один одного, а загальна їх кількість може бути невідома.

### Поняття quorum, quorum slice і quorum intersection

Множина, в яку входить конкретний вузол і вузли, яким він довіряє, називається quorum slice. При цьому у одного вузла може бути кілька slices.

Quorum для вузла А – це всі вузли з його slice і вузли, що знаходяться в slices цих вузлів. Іншими словами – всі, кому довіряє А і ті, кому довіряють вони. Більш того, quorum може бути більш глибоким, включаючи тих, кому довіряють вузли, яким довіряє А. Quorum – це замкнута множина вузлів, якої достатньо для досягнення угоди в розподіленій системі.

Quorum intersection – це вузол або декілька вузлів, які належать одночасно декільком slices. Quorum і quorum slice – відносні множини, які визначені для кожного з вузлів окремо. Таким чином, число всіх можливих quorum (або slice) може бути більшою за кількість вузлів у всій мережі.

На рисунку 5.25 наведений приклад мережі з quorum slice і quorum щодо вузла F. Стрілками показано напрям довіри. Якщо між вузлами є дві протилежні стрілки – вони взаємно довіряють один одному. Якщо стрілка одна – другий вузол не довіряє першому.

<img width="42%" alt="Рисунок 5.25 – Quorum slices і quorum" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.26-Quorum-slices-and-quorum.png"/> 

Рисунок 5.26 демонструє quorum intersection, де вузол B є перетином {A, B, C} і {G, D, E, F}, а вузол G – перетином {H, I} і {G, D, E, F}.

<img width="42%" alt="Рисунок 5.26 – Приклад quorum intersection" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.27-An-example-of-quorum-intersection.png"/> 

На практиці вузол може належати кільком quorum slices, а сам quorum slice може містити в собі інший quorum slice. Коли вузли намагаються дійти згоди, вони обмінюються один з одним повідомленнями і погоджуються тільки в тому випадку, якщо кількість тих, хто погодився, перевищує заданий поріг. Поріг при цьому повинен бути не менше, ніж ⅔ від кількості вузлів в quorum slice.

### Blocking set

Також в FBA існує поняття blocking set. Blocking set для певного вузла N є множиною, у якій присутній як мінімум один вузол з кожного quorum slice, в якому він перебуває (рис. 5.27). Blocking set може переконати учасника прийняти певне рішення.

<img width="30%" alt="Рисунок 5.27 – Приклад blocking set, що складається з вузлів B, D, F" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.28-An-example-of-a-blocking-set-consisting-of-nodes-B,D,F.png"/> 

### Disjoint quorums и divergent state

Disjoint quorums – два quorum slices, які не мають вузлів, що прямо або побічно перетинаються, та формують окремі кворуми і в результаті приходять до різних рішень, через що виникає divergent state. Divergent state – це стан, в якому знаходиться система після поділу на кілька незалежних quorums, кожен з яких веде свою історію транзакцій і не впливає на інших.

У PBFT-системах відмовостійкість забезпечується, якщо кількість несправних вузлів не перевищує ⅓ від загальної кількості вузлів в системі. У випадку з FBA ця цифра варіюється від 0 до ⅓ в залежності від структури quorum slices. Відмовостійкість FBA буде прагнути до нуля, коли велика кількість вузлів створює quorum slices з одними і тими ж декількома вузлами. Якщо ці кілька вузлів вийдуть з ладу, система припинить функціонування.

Приклад подібної ситуації наведено на рисунку 5.28. В даному випадку два quorum slices мають всього один загальний вузол. Якщо він потрапить під контроль зацікавленої сторони або з певних причин перестане працювати, інші вузли не зможуть досягти консенсусу.

<img width="42%" alt="Рисунок 5.28 – Приклад disjoint quroums" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.29-An-example-of-disjoin-quorums.png"/> 

### Federated voting

Для досягнення консенсусу в FBA-системах використовується механізм federated voting (рис. 5.29), що складається з трьох етапів: голосування, прийняття та підтвердження [46; 47]. Спочатку кожен вузол може проголосувати за певну заяву, що стосується, наприклад, додавання нового блоку транзакцій. Проголосувавши за заяву, вузол (за умови, що він не є зловмисником) ніколи не буде голосувати за щось, що суперечить йому.

Після етапу голосування вузли переходять до етапу ухвалення. Вузол може прийняти заяву, якщо він не приймав суперечливої заяви раніше і існує кворум, кожен учасник якого проголосував за або приймає цю заяву. Незалежно від рішення кворуму, вузол приймає ту же заяву, що і його blocking set. З цього випливає, що вузол може проголосувати за одну заяву, але прийняти іншу.

Втім, блокуюча множина не є кворумом, оскільки тоді зацікавлена ​​сторона могла б нав'язувати вузлу свої рішення, взявши під контроль вузли з його блокуючої множини. З цієї причини існує ще один етап – підтвердження. Його мета полягає в тому, що вузол повинен виявити quorum, всі вузли якого приймають дане твердження. Вузол підтверджує заяву, якщо всі вузли кворуму, в якому він перебуває, також підтверджують його.

<img width="40%" alt="Рисунок 5.29 – Можливі стани вузла під час федеративного голосування" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.30-Possible-node-stated-in-the-federated-voting-process.png"/> 

### Застосування FBA в Stellar

SCP (Stellar Consensus Protocol) [47] – протокол досягнення консенсусу, побудований на основі FBA. Stellar Consensus Protocol використовує механізм федеративного голосування, щоб забезпечити узгодженість результатів і працездатність системи. В процесі роботи проводиться велика кількість раундів федеративного голосування для різних тверджень доти, поки одне з них не пройде всі етапи.

Перший раунд федеративного голосування проходить в фазі номінації (nomination), коли вузли голосують за прийняття певного блоку транзакцій. На першому етапі вузли виробляють значення-кандидати шляхом проведення федеративного голосування. Значення вважається кандидатом, якщо вузол підтвердив його номінацію. Вузол, у якого немає кандидатів, може номінувати будь-яке значення. Після цього він може тільки приймати і підтверджувати заяви про номінацію від інших вузлів згідно з процедурою федеративного голосування.

Щоб скоротити кількість кандидатів, використовується механізм тимчасових пріоритетів. Спочатку вузол визначає quorum slices, в яких він складається, і вибирає з цього безлічі вузлів найбільш пріоритетний, тобто той, чиє значення він буде номінувати. Вузол може номінувати своє власне значення тільки якщо не знайде більш пріоритетних сусідів. Для розрахунку пріоритету використовується геш-функція, на вхід якої подається номер блоку і відкритий ключ заданого вузла. Чим частіше вузол з'являється в quorum slices сусідів, тим вищим буде його пріоритет.

Під впливом блокуючої множини вузол може проголосувати та прийняти номінацію різних кандидатів, але підтвердить тільки одного. Наочний приклад розглянуто на рисунку 5.30.

<img width="40%" alt="Рисунок 5.30 – Приклад проведення процесу номінації за умови, що вузол спочатку голосував за номінацію А" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.31-An-example-of-the-nomination-process.png"/> 

У процесі номінації може вийти кілька підтверджених кандидатів, які потім об'єднуються в composite. Метод об'єднання залежить від конкретної системи. Наприклад, в Stellar відбувається об'єднання множин транзакцій, а отриманому композиту присвоюється максимальний timestamp з усіх, які є в отриманій безлічі транзакцій.

Коли в результаті номінації був отриманий композит, вузли переходять до балотування (рис. 5.31). Балотування проводиться в три етапи: prepare, commit, externalize. Останній етап, по суті, є виконанням команди, за яку голосують вузли, наприклад, виконання операцій блоку транзакцій. Спочатку вузли повинні проголосувати, підтвердити і прийняти статус prepare для бюлетеня, а потім пройти ці три етапи для статусу commit (тобто для бюлетеня проводиться федеративне голосування, описане вище).

Сам бюлетень являє собою структуру, що складається з двох полів: цілочисельний позитивний лічильник й об'єкт класу Vote, у якому міститься значення-кандидат з минулого етапу.

Якщо з певних причин бюлетень застрягає в невизначеному стані, для нього виконується abort, лічильник інкрементується і вузли переходять до наступного бюлетеню (значення лічильника якого вище). При обміні інформацією про стан бюлетенів вузли можуть прикріплювати до повідомлення діапазон бюлетенів замість одного конкретного.

Бюлетень отримує статус prepared, коли вузол впевнений, що інші не проголосують за commit для бюлетенів з іншими значеннями. При цьому для всіх бюлетенів з меншими значеннями лічильника виконується abort. Коли prepare для бюлетеня буде підтверджений, вузли переходять до голосування щодо статусу commit. Це дозволяє переконатися в тому, що всі згодні з цим бюлетенем і в кінцевому рахунку його директиви будуть виконані.

Після проходження всіх раундів федеративного голосування та підтвердження commit, вузли виконують директиву, зазначену в бюлетені.

<img width="40%" alt="Рисунок 5.31 – Приклад проведення процесу балотування" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.32-The-example-of-the-balloting-process.png"/> 

### Проблема централізації

Кількість вузлів-зловмисників, при якому FBA-система буде здатна досягати консенсусу, варіюється від 0 до ⅓ від загальної кількості учасників в залежності від структури quorum slices. Відмовостійкість буде прагнути до нуля, коли велика кількість вузлів створює quorum slices з одними і тими ж декількома вузлами. Якщо ці кілька вузлів вийдуть з ладу, система не зможе працювати. Приклад подібної ситуації наведено на малюнку 5.32. В даному випадку кілька quorum slices мають всього один загальний вузол і якщо він потрапить під контроль зацікавленої сторони або з певних причин перестане працювати, інші вузли також не зможуть функціонувати.

<img width="30%" alt="Рисунок 5.32 – Приклад мережі з одним загальним вузлом" src="/resources/img/volume-2/5.4-FBA-as-a-consensus-algorithm/Figure-5.33-Example-of-a-network-with-one-common-node.png"/> 

### Рівень децентралізації мережі Stellar

При аналізі взаємодій вузлів Stellar на момент 2019 видно, що присутні близько 35 активних валідаторів, місячний uptime яких вище 90%. При цьому більше половини quorum slices складаються з 10 або менше валідаторів [73]. Перша причина малої кількості валідаторів – відсутність мотивації для участі в системі в цій ролі.

Більшість активних валідаторів належать або безпосередньо Stellar Development Foundation, або компаніям-партнерам. Наприклад, IBM використовує Stellar в платіжній системі на основі blockchain, а Satoshi Pay і tempo.eu.com розробляють додатки на платформі Stellar. Для них мотивацією підтримувати працездатність вузлів є те, що їхні послуги залежать від функціонування системи Stellar. При цьому вони не отримують ніякої фактичної нагороди, як, наприклад, в proof-of-work або proof-of-stake системах.

Друга причина малої кількості валідаторів – залежність системи від довіри до валідатора. Згідно зі структурою поточних quorum slices, учасники системи вибирають з відносно невеликої групи валідаторів, з якими вони пов'язані або яким довіряють, грунтуючись на їх впливовості. Через таку моделі довіри формування quorum slices є необ'єктивним процесом і неминуче схиляється в бік централізації. При цьому у всіх quorum slices присутній як мінімум один валідатор, який належить Stellar Development Foundation (SDF).

Така структура призводить до ризику виходу системи з ладу. У разі, коли один вузол стає недоступним, система продовжує функціонувати. Однак, коли недоступними стануть два будь-яких вузла SDF, відбудеться повний каскадний збій системи, тобто ніхто з валідаторів не зможе досягти консенсусу. Якщо з ладу вийде валідатор eno і один з валідаторів SDF, відмова відбудеться для 90% вузлів.

Одним з потенційних рішень буде наблизити структуру Stellar до тієї, яка використовується в pBFT. Однак, в такому випадку учасникам доведеться постійно моніторити повідомлення від обраних валідаторів і міняти склад quorum slices в залежності від того, які вузли поводяться некоректно. Також учасники можуть знизити порогове значення для досягнення угоди в quorum slice, що підвищить liveness системи, але знизить її безпеку.

На даний момент уразливість, пов'язана з відмовою всієї системи через вихід з ладу двох основних вузлів, усунуто – відмова жодної пари вузлів не призведе до тотального збою системи. Проте, структура все ще досить централізована. Якщо з ладу вийдуть два будь-яких вузла, що належать SDF, і два вузла, якими володіє соціальна мережа Keybase, система також перестане функціонувати. Існують і інші комбінації, здатні вивести з ладу всю систему.

Крім іншого було виявлено, що quorum slices більшості вузлів IBM складаються тільки з SDF1, SDF2, SDF3 і мають threshold, рівний 2. Таким чином, повністю вивести з ладу систему зараз набагато складніше. Проте, варто враховувати ризик того, що впливові вузли SDF потраплять під контроль зацікавленої сторони або вступлять у змову. Хоча останнє твердження малоймовірно, адже вузли, що належать Stellar, зацікавлені в коректній роботі системи.

У випадку зі Stellar загроза безпеки (зокрема можливість провести double-spending) має набагато більше значення, ніж втрата liveness (в звичайних банківських системах затримки по операціях все одно тривають набагато довше). Отже, учасники повинні вибирати і вибирають великі quorum slices, які з набагато більшою часткою ймовірності будуть перебувати в угоді, ніж в робочому стані.

### FBA в порівнянні з іншими алгоритмами досягнення консенсусу

Ми розглянули основні поняття, принципи роботи і обмеження, характерні для Federated Byzantine Agreement. Тепер давайте порівняємо його з іншими поширеними алгоритмами досягнення консенсусу, щоб отримати краще розуміння того, в яких системах він може застосовуватися.

Порівняно з Practical Byzantine Fault Tolerance, іншим протоколом з BFT-сімейства, Federated Byzantine Agreement забезпечує явну перевагу в плані масштабованості, оскільки не вимагає передачі великої кількості повідомлень між вузлами, що дозволяє побудувати мережу з великою кількістю учасників.

Однак за порівняння FBA із proof-of-work останній має перевагу в плані анонімності учасників і забезпечує більший рівень децентралізації, оскільки кожен, хто має відповідне обладнання, може брати участь в процесі генерації блоків. Як було описано раніше в цьому розділі, Stellar, який є найбільш яскравим прикладом використання протоколу FBA на практиці має потенційну схильність до централізованої структури, оскільки валідатори вважають за краще включати до своїх quorum slices вузли, у чесності яких вони точно впевнені.

## 5.5 Hashgraph

Hashgraph – це одночасно й спосіб організації бази даних транзакцій, й алгоритм досягнення консенсусу. Перша версія цього алгоритму передбачає фіксовану кількість валідаторів, які беруть участь у досягненні консенсусу, при цьому для його досягнення необхідно, щоб більш ніж ⅔ з них були чесними. Спосіб організації бази даних hashgraph можна порівняти з ланцюжком блоків, що постійно розгалужується і в якому кожен блок пов'язаний не тільки з попередніми блоками цього ланцюжка, а й із одним із блоків одного з інших ланцюжків блоків.

_Граф гешів (hashgraph)_ – структура даних, яка зберігає історію розповсюдження даних між вузлами (рис. 5.33).

<img width="20%" alt="Рисунок 5.33 – Структура бази даних вузла мережі" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.34-Node's-database-structure.png"/> 

Цей алгоритм розробив Лі́мон Бейрд (Dr. Leemon Baird), співзасновник і технічний директор Swirlds, в 2016 році як альтернативу алгоритмам досягнення консенсусу, що передбачають обмежену кількість відомих валідаторів і наявність лідера. Недолік алгоритмів, що використовують лідерів, полягає в тому, що на вузли-лідери можна зробити DoS-атаку, внаслідок чого вся система відмовляє в обслуговуванні до моменту зміни лідера [49]. Одна з переваг цього алгоритму – досягнення асинхронної візантійської відмовостійкості (asynchronous byzantine fault tolerance). Асинхронна візантійська відмовостійкість полягає в тому, що функціонування алгоритму не залежить від часу, витраченого на доставку повідомлень. Процес валідації в цьому алгоритмі permissioned, тобто для того, щоб стати валідатором, необхідно отримати дозвіл від інших валідаторів.

### Принцип роботи hashgraph

Замість блоків в hashgraph кожен вузол-валідатор створює події. _Подія (event)_ – запис, яку створює і поширює валідатор для підтвердження транзакцій і факту обміну станом графа гешів з іншим валідатором.

Життєвий цикл події виглядає наступним чином:

> * _Створення_
> * _Розповсюдження_
> * _Підтвердження_

### Створення події

Кожен вузол-валідатор може створити підписану ним подію в будь-який момент часу. Він може включити в подію свої або отримані від інших вузлів транзакції, а може взагалі не включати транзакції до події (табл. 5.3). Зазвичай в подію не потрібно включати багато транзакцій, так як в hashgraph кожен вузол-валідатор може створити нову подію в будь-який момент часу.

Таблиця 5.3
<img width="50%" alt="Таблица 5.3" src="/resources/img/volume-2/5.5-Hashgraph/Table-5.3.png"/> 

Як ми бачимо з таблиці 5.3, кожна подія містить посилання на дві попередніх події, а кожна з цих двох попередніх подій містить посилання на ще дві попередніх події тощо. Таким чином, маючи одну подію, можна відстежити всі її події-предки (рис. 5.34).

<img width="42%" alt="Рисунок 5.34 – Формування нової події на основі А і В" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.35-Forming-a-new-event-based-on-A-and-B.png"/> 

### Розповсюдження події

Для розповсюдження подій використовується _Gossip protoco_l [50]. Кожен вузол має з'єднання з іншими вузлами. Згідно з цим протоколом один вузол отримавши повідомлення від іншого вузла починає сам передавати це повідомлення іншим вузлам у випадковому порядку і так далі. Таким чином, спочатку повідомлення передає один вузол, потім два, потім чотири, потім вісім і так далі. Внаслідок цього кількість вузлів, які отримали повідомлення, зростає експоненціально.

Припустімо, Аліса хоче розповсюджувати свою нову подію в мережі за допомогою gossip protocol:

> Крок 1: Аліса створила подію та збирається розповсюдити його рештою вузлів (рис. 5.35).

<img width="36%" alt="Рисунок 5.35" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.36.png"/> 

> Крок 2: Аліса відправляє подію випадково вибраному вузлу мережі, тут це Керол (рис. 5.36).

<img width="36%" alt="Рисунок 5.36" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.37.png"/> 

> Крок 3: Аліса та Керол відправляють цю подію випадково вибраним кожною з них вузлам мережі, тут це Боб і Єва (рис. 5.37).

<img width="36%" alt="Рисунок 5.37" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.38.png"/> 

> Крок 4: Тепер Аліса, Боб, Керол і Єва розповсюджують це повідомлення випадково вибраним кожним із них учасникам мережі. У результаті, усі вузли мережі дізнаються про це повідомлення (рис. 5.38).

<img width="36%" alt="Рисунок 5.38" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.39.png"/> 

_Розповсюдження про розповсюдження (Gossip about gossip)_: вузол-валідатор, отримуючи подію від іншого вузла-валідатора, звіряє, які події йому не відомі, по посиланнях одержуваної їм події. Невідомі події він запитує. Таким чином, обмінюючись подіями, вузли-валідатори синхронізують свої стани графів гешів. Також кожен вузол-валідатор, який отримав подію, верифікує її відповідно до свого графу гешів. Якщо він згоден з цією подією, то також створює нову подію і включає в її значення other-parent hash від одержуваної події. Далі вузол-валідатор, який отримав повідомлення, також поширює свою останню створену подію, other-parent hash якої посилається на подію, отриману раніше. Загальний принцип роботи розповсюдження про розповсюдження можна розглянути на наступному прикладі (рис. 5.39), де показана історія протоколу розповсюдження як граф гешів:

1. Аліса створила подію і повідомила Бобу про неї, а також про всі події, про які знає вона, але не знає Боб. Далі Боб створює свою подію, що пов'язана з подією Аліси, як підтвердження того, що він отримав дані від Аліси.
2. Боб повідомляє Керол про свою подію, а також про всі події, про які знає він, але не знає вона. Після цього Керол створює подію, пов'язану з подією Аліси через подію Боба, як підтвердження того, що вона отримала інформацію від Боба. Практично в той же час Аліса і Дейв проводять аналогічні дії.
3. Керол повідомляє Дейву про свою подію, а також про всі події, про які знає вона, але не знає він. Далі Дейв створює подію, пов'язану з подією Аліси через події Керол і Боба, як факт того, що він отримав інформацію від Керол.
4. Дейв повідомляє Алісі про події, які відомі йому, але не відомі Алісі. Аліса створює свою подію, пов'язану зі своєю подією і подіями Дейва, Керол і Боба. Практично в той же час Керол і Боб проводять аналогічні дії.

<img width="42%" alt="Рисунок 5.39 – Наочний приклад роботи протоколу Gossip about gossip" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.40-An-illustration-of-the-gossip-about-the-gossip-protocol.png"/> 

Кожен вузол мережі зберігає структуру даних графа гешів, отриману під час обміну інформацією про неї з іншими вузлами. Таким чином, структура даних, що зберігається у кожного вузла, постійно оновлюється і синхронізується з іншими. У підсумку, у більшості вузлів зберігається однакова з більшістю інших вузлів структура даних. Кожна подія зберігається в пам'яті як підписана автором послідовність байтів.

### Підтвердження події

Маючи набір подій з транзакціями, важливо знати, яка з них була раніше, а яка – пізніше. Тому події повинні бути впорядковані за часом, причому цей порядок повинен бути однаковий у кожного вузла. Порядок встановлюється шляхом досягнення консенсусу щодо упорядкованості подій через часові мітки (timestamp) для кожної події. Як тільки подія має мітку часу, прийняту більшістю вузлів, її можна вважати підтвердженною.

Для досягнення консенсусу щодо міток часу подій граф гешів ділиться на раунди (рис 5.40).

<img width="20%" alt="Рисунок 5.40 – Наочне представлення розподілу графа на раунди через witness events і сильний зв'язок" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.41-An-illustration-of-a-graph-being-divided.png"/> 

Раунд починається і закінчується як тільки одна з подій (вершина графа на рисунку 5.41) пов'язана з ⅔ перших подій першого раунду (виділені події на нижньому шарі графа) через більшість подій різних авторів (виділені по центру). Ця залежність називається сильним зв'язком (strongly seeing). Перші події кожного вузла-валідатора в раунді називаються witness events; щодо них і проводиться віртуальне голосування.

<img width="65%" alt="Рисунок 5.41 – Приклад сильного зв'язку (strongly seeing)" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.42-An-example-of-strongly-seeing.png"/> 

Перші події в мережі не мають подій-предків, і кожен з них визначається до першого раунду як witness event. Раунд для кожної події визначається як функція від його подій-предків. Простіше кажучи, якщо останні witness events нижче подій по графу належать до раунду _R_, то події до наступного witness event також належать до раунду _R_. Наступне witness event належить до раунду _R + 1_.

Для досягнення консенсусу щодо впорядкованості подій для кожного раунду кожен валідатор локально проводить віртуальне голосування, в якому вибирається медіана з міток часу сусідніх подій події, що перевіряється.

Віртуальне голосування (virtual voting): кожен вузол мережі має копію графа гешів, і кожен граф гешів упорядкований, тобто якщо два різних графа гешів A і B мають однакову подію Х, тоді в кожному з них також знаходяться однакові предки цієї події з однаковими зв'язками між ними. Аліса здатна обчислити голос Боба через граф гешів, так як вона бачить, що якщо подія, що перевіряється, є однією з подій-предків події створеної Бобом, то Боб згоден з цією подією і його голос вважається «за». Значить, Бобу не обов'язково брати участь в голосуванні особисто. Таким чином, кожен вузол може досягти згоди щодо будь-якої кількості рішень, при цьому, фактично, не відправляючи жодного повідомлення з їх голосами, а просто локально обчислюючи результат голосування через наявний у нього граф гешів. При цьому, якщо Боб і Аліса чесні, то Боб, який не знає про подію _Х_, може швидко про неї дізнатися завдяки протоколу розповсюдження. Алгоритм досягнення консенсусу передбачає, що це рано чи пізно станеться, але не висуває ніяких припущень щодо необхідної на це кількості часу.

Для визначення порядку подій і включених в них транзакцій Аліса проводить віртуальне голосування по раундах. Боб і інші вузли мережі проводять таке ж голосування. У кожному голосуванні передбачається, що через деякі witness events в графі гешів Аліси будуть відправлятися голоси валідаторів, а деякі з witness events в тому ж графі гешів Аліси будуть їх отримувати.

Боб може шахраювати і створити два witness events _Х_ і _Y_ з одними тими ж подіями-предками, причому _Х_ і _Y_ не будуть подіями-предками один одного. Тоді далі буде подія W, подіями-предками якої буде і _Х_, і _Y_. Подія W буде бачити, що _Х_ і _Y_ створені одним вузлом валідатора, але жоден з них не є предком іншого, а значить, цей поділ історії на дві альтернативні гілки подій буде розпізнано. В такому випадку _W_ буде бачити або гілку подій з _Х_, або гілку подій з _Y_, або жодну з цих гілок (рис. 5.42).

<img width="30%" alt="Рисунок 5.42 – Приклад того як з'являється подія W" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.43-An-example-of-event-W-creation.png"/> 

Подія _W_ сильно пов'язана з подією _X_, якщо вона пов'язана з нею щонайменше через ⅔ подій різних вузлів. У підсумку виходить, що як Аліса, так і Боб, маючи синхронізовані графи гешів, можуть обчислити віртуальний голос Керол щодо певного рішення і що обидва отримають однаковий результат.

Для досягнення консенсусу щодо послідовності подій для кожного раунду, кожен вузол-валідатор локально проводить віртуальне голосування через _unique famous witness events_ з _famous witness events_.

_Famous witness event_ – witness event подія, яка пов'язана з більшістю witness event в наступному раунді. Для визначення таких подій досить виконати byzantine agreement protocol тільки для кожного witness event, вирішуючи лише одне питання – чи є цей witness event популярним. Як тільки згоду щодо кількох famous witness events досягнуто, легко відтворити з графа гешів достовірний порядок всіх подій.

Witness event вважається famous, якщо вище за графом гешів існує witness event, який пов'язан з перевіряємим witness event мінімум через ⅔ інших witness events.

Маючи граф гешів, можна обчислити голоси всіх валідаторів через віртуальне голосування. Кожен witness event раундом вище голосує «за» на питання, чи є певне witness event популярним, якщо у нього в подіях-предках присутня перевіряєма подія, інакше передбачається, що witness event голосує «ні». У віртуальному голосуванні, коли witness event голосує «так»/«ні», голос обчислюється як функція від його подій-предків. Результат обчислюється через witness event (створений раундом пізніше), у якого в подіях-предків присутні голосуючі witness events. Наприклад, визначимо, чи є famous witness event перша подія Аліси.

1. Кожен валідатор має граф гешів, в якому через віртуальне голосування обчислює, як проголосував би Дейв щодо того, чи є перша подія Аліси famous witness event (рис. 5.43).

<img width="20%" alt="Рисунок 5.43 – Обчислення голосу Дейва щодо певної події" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.44-Calculation-of-Dave’s-vote-regarding-a-certain-event.png"/> 

2. Кожен валідатор через віртуальне голосування обчислює, як проголосувала б Керол щодо того, чи є перша подія Аліси famous witness event (рис. 5.44).

<img width="20%" alt="Рисунок 5.44 – Обчислення голосу Керол щодо певної події" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.45-Calculation-of-Carol’s-vote-regarding-a-certain-event.png"/> 

3. Кожен валідатор через віртуальне голосування обчислює, як проголосував би Боб щодо того, чи є перша подія Аліси famous witness event (рис. 5.45)..

<img width="20%" alt="Рисунок 5.45 – Обчислення голосу Боба щодо певної події" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.46-Calculation-of-Bob’s-vote-regarding-a-certain-event.png"/> 

4. Кожен валідатор через віртуальне голосування обчислює, як проголосувала б Аліса щодо того, чи є перша подія Аліси famous witness event (рис. 5.46).

<img width="20%" alt="Рисунок 5.46 – Обчислення голосу Аліси щодо певної події" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.47-Calculation-of-Alice’s-vote-regarding-a-certain-event.png"/> 

Те, чи є перша подія Боба famous witness event, обчислюється за таким же принципом; точно так же обчислюється famous witness event для всіх witness events.

Тільки-но визначаться всі famous witness events в раунді, прибираються всі famous witness events з однаковим творцем, поки у кожного творця famous witness event не залишиться по одній такій події. Решта famous witness events називаються unique famous witness events. При відсутності розгалужень кожен famous witness event є unique famous witness event. Через дані unique famous witness events визначаються погоджені мітки часу для кожної їх події-наслідника у раунді.

Погоджені мітки часу обчислюються наступним чином. Уявімо, що подія _Х_, що перевіряється, знаходиться в раунді _R_. У тому ж раунді Аліса створила unique famous witness event _A_. Алгоритм знаходить найближчу до famous witness event Аліси подію _Y_, створену Алісою в тому ж раунді, з яким пов'язана подія _X_ як other-parent, або як одна з найближчих подій-предків. Для творця події _Х_ його події _Y_ щодо його famous witness event буде подія _Х_. Мітка часу події _Y_ вважається моментом часу, коли про цю подію дізнався вузол, який створив подію _Y_. Прийнятою більшістю міткою часу для події _Х_ буде медіана міток часу всіх таких подій _Y_ для кожного творця unique famous witness event. Розглянемо наступний приклад:

1. Для unique famous witness event Аліси (_А_) знаходимо найближчу self-parent подія *Y<sub>А</sub>*, яка пов'язана з _Х_, і зберігаємо її мітку часу *t<sub>А</sub>* = 3 (рис. 5.47).

<img width="20%" alt="Рисунок 5.47 – Створення мітки часу для unique famous witness event Аліси" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.48-Creating-the-timestamp-for-Alice’s-unique-famous-witness-event.png"/> 

2. Для unique famous witness event Боба (_В_) знаходимо найближчу self-parent подію *Y<sub>B</sub>*, яка пов'язана з _Х_, і зберігаємо її мітку часу *t<sub>B</sub>* = 1 (рис. 5.48).

<img width="20%" alt="Рисунок 5.48 – Створення мітки часу для unique famous witness event Боба" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.49-Creating-the-timestamp-for-Bob’s-unique-famous-witness-event.png"/> 

3. Для unique famous witness event Керол (_С_) знаходимо найближчу self-parent подію *Y<sub>C</sub>*, яка пов'язана з _Х_, і зберігаємо її мітку часу *t<sub>C</sub>* = 2 (рис. 5.49).

<img width="20%" alt="Рисунок 5.49 – Створення мітки часу для unique famous witness event Керол" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.50-Creating-the-timestamp-for-Carol’s-unique-famous-witness-event.png"/> 

4. Для unique famous witness event Дейва (_D_) знаходимо найближчу self-parent подію *Y<sub>D</sub>*, яка пов'язана з _Х_, і зберігаємо її мітку часу *t<sub>D</sub>* = 4 (рис. 5.50).

<img width="20%" alt="Рисунок 5.50 – Створення мітки часу для unique famous witness event Дейва" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.51-Creating-the-timestamp-for-Dave’s-unique-famous-witness-event.png"/> 

5. Узгодженої міткою часу події _Х_ є медіана від *t<sub>A</sub>* , *t<sub>B</sub>* , *t<sub>C</sub>* , *t<sub>D</sub>* (рис. 5.51).

<img width="40%" alt="Рисунок 5.51 – Обчислення узгодженої мітки часу для події" src="/resources/img/volume-2/5.5-Hashgraph/Figure-5.52-Calculating-the-agreed-timestamp-for-an-event.png"/> 

Безумовно, Аліса і Боб не матимуть однакові графи гешів в будь-який момент часу. Їх графи будуть узгоджені в основному тільки щодо більш ранніх подій. Однак для самих пізніх подій кожен з них може знати про події, про які не знають інші. Як наслідок, у валідаторів буде відрізнятися підмножина підтверджених транзакцій, але помітно більша частина цієї підмножини буде однаковою. Більш того, якщо Аліса не знає про деяку подію з більш ранніх подій, то в майбутньому вона дійде до Аліси. В такому випадку Аліса синхронізується з більшістю інших вузлів.

**Найбільш поширені питання**

*– Чи можна створити правила для заміни валідатора?*

Основна проблема hashgraph полягає в тому, що поточна версія не визначає правила зміни набору валідаторів. Одним з рішень цього вкрай важливого питання може бути включення в повідомлення валідаторів голосів за додавання або усунення учасників. Таким чином, якщо більшість валідаторів підтримають це рішення, буде додано новий вузол або видалений один з поточних. Також, якщо валідатори визначать, що один з них поводиться нечесно, вони зможуть проголосувати за позбавлення його прав валідатора.

*– Для яких випадків найкраще підходить hashgraph?*

Hashgraph добре підходить для випадків, в яких потрібна наявність фіксованої кількості рівноправних валідаторів без будь-якого лідера. Наприклад, кілька компаній співпрацюють, і їм потрібна система для обліку даних про взаємодії між собою, в якій кожна компанія має рівні права і на роботу якої не можуть вплинути сторонні особи.

*– Чи може процес валідації для алгоритму hashgraph бути permissionless?*

Без модифікацій в алгоритмі hashgraph це неможливо, так як кожен аудитор повинен знати повну кількість діючих валідаторів. Отже, список валідаторів повинен бути загальновідомим і захищеним від модифікації, тобто будь-який бажаючий не повинен мати можливості його змінювати.

[МЕТОДИ ЗАБЕЗПЕЧЕННЯ ПРИВАТНОСТІ В СУЧАСНИХ ОБЛІКОВИХ СИСТЕМАХ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-2/ua/6-methods-for-ensuring-privacy-in-modern-accounting-systems.md)
