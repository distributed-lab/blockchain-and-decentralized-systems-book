# [5 РОЛЬ КРИПТОГРАФИЧЕСКИХ ОБЯЗАТЕЛЬСТВ В УЧЕТНЫХ СИСТЕМАХ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ru/5-Role-of-cryptographic-commitments-in-accounting-systems.md)

# 6 ОСНОВЫ ПОСТКВАНТОВОЙ КРИПТОГРАФИИ


## 6.1 Введение в постквантовые криптографические алгоритмы

Хотя еще не существует стабильно работающей версии квантовых компьютеров, уже разработан математический аппарат (квантовые алгоритмы), реализация которого на квантовом компьютере позволит снизить сложность атак на широко используемые криптоалгоритмы.

Квантовые вычисления способны выполнять некоторые алгоритмы решения задач с квадратичным, а то и экспоненциальным ускорением по сравнению с алгоритмами, рассчитанными на выполнение тех же задач на классическом компьютере (табл. 6.1). Например, задачи определенных классов, включая факторизацию чисел и поиск дискретного логарифма, квантовые компьютеры способны решать с эффективностью, гораздо превосходящей возможности классических компьютеров [99–103].

Таблица 6.1 – Сравнение временной сложности выполнения алгоритмов для классического и квантового компьютеров  
| _Тип задачи_ | _Алгоритм для классического компьютера_ | _Алгоритм для квантового компьютера_ |
|---|---|---|
| Факторизация | классический алгоритм Полларда–Штрассена<br>$O(n^{\frac{1}{4}}(\log{n})^{4})$ | квантовый алгоритм Шора<br>$O(\log{n})$ |
| Уравнение Пелла–Ферма | классический алгоритм теста простоты AKS<br>$O((\log{n})^{6})$ | квантовый алгоритм теста простоты<br>$O(n^{2}(\log{\log{n}})(\log{n})^{3})$ |
| Поиск | классический алгоритм бинарного поиска<br>$O(\log{n})$ | квантовый алгоритм Гровера<br>$O(n^{\frac{1}{2}})$ |

> _Замечание. Под временной сложностью подразумевается количество элементарных операций, осуществляемых алгоритмом. К операциям, элементарными для классических компьютеров, принадлежат такие: установка регистра в нулевое значение, битовый сдвиг на один разряд, логическое сложение, логическое умножение. Для квантового компьютера элементарными операциями являются т. н. квантовые гейты._
> 
> _Хотя вычислительная сложность описывается количеством элементарных операций, она не учитывает время выполнения таких операций на классическом либо квантовом процессоре. Именно с этим связано заблуждение, что квантовый компьютер всегда будет работать быстрее._

Наиболее известные квантовые алгоритмы – алгоритм Шора и алгоритм Гровера – используются для быстрой факторизации числа и ускорения поиска соответственно. Эти алгоритмы угрожают многим широко используемым криптопримитивам шифрования и цифровой подписи. Безопасность этих примитивов основывается на предположении, что некоторые вычислительные задачи (например задачу факторизации числа или поиска дискретного логарифма) трудно решить с использованием доступных вычислительных ресурсов. Впрочем, для эффективной реализации таких алгоритмов у квантового компьютера должен быть регистр с достаточным размером (с достаточным количеством кубитов).


### Криптопримитивы, уязвимые к атакам квантового компьютера

Вопрос о том, когда будет построен квантовый компьютер с достаточно большим количеством кубитов для эффективной реализации атак на существующие криптоалгоритмы, сложный и спорный. Однако появление такого компьютера потенциально представляет опасность для современных криптосистем. Стоит также принять во внимание тот факт, что для развертывания современной инфраструктуры с применением классических криптопримитивов, которая включает в себя не только непосредственно математические алгоритмы, но и набор технических средств для их реализации, а также нормативное регулирование данных вопросов, понадобилось практически 20 лет. Исходя из такого опыта, можно сделать вывод, что независимо от скорости развития квантовых вычислений, необходимо уже сейчас готовиться к плавному переводу существующих систем информационной безопасности на стойкие алгоритмы. 

> _Замечание. Ученые из Google AI заметили закономерность (т. н. закон Невена) [104], что квантовые компьютеры наращивают вычислительную мощность с двойной экспоненциальной скоростью._
> 
> _Двойной экспоненциальный темп роста значит, что некоторая величина растет как степень степени 2: $2^{2^{1}}$, $2^{2^{2}}$, $2^{2^{3}}$, $2^{2^{4}}$. Такая скорость – следствие комбинации двух экспоненциальных факторов. Первый состоит в том, что у квантовых компьютеров есть внутреннее экспоненциальное преимущество перед классическими: если в квантовом контуре есть, к примеру, 4 кубита, то его вычислительная мощность сравнима с контуром из 16 обычных битов. Это было бы так даже без улучшения квантовых технологий. Второй экспоненциальный фактор появляется благодаря быстрому улучшению квантовых процессоров. Невен говорит, что квантовые чипы от Google в последнее время улучшаются с экспоненциальной скоростью, которая обусловлена уменьшением количества ошибок. Это позволило инженерам строить более крупные квантовые процессоры. Если классическим компьютерам требуется экспоненциально больше вычислительной мощности для симуляции квантовых процессоров, а мощность этих квантовых процессоров со временем растет экспоненциально, то в итоге получается двойное экспоненциальное взаимоотношение между квантовыми и классическими машинами._

В табл. 6.2 показаны алгоритмы, которые потенциально уязвимы перед атаками с использованием квантовых компьютеров, а также возможные пути устранения уязвимостей для некоторых из них.

Таблица 6.2 – Возможные последствия атак с использованием квантовых компьютеров для наиболее распространенных алгоритмов
| _Криптографический алгоритм_ | _Тип_ | _Применение_ | _Методы противостояния атакам с использованием квантовых компьютеров_ |
|---|---|---|---|
| AES | Симметричная криптография | Шифрование | Увеличение размеров ключевых параметров |
| SHA-2, SHA-3 | — | Хэш-функции | Увеличение размера выхода |
| RSA | Асимметричная криптография | Цифровая подпись, алгоритмы установления ключей  | Не могут оставаться стойкими |
| ECDSA, ECDH | Асимметричная криптография | Цифровая подпись, алгоритмы обмена ключами | Не могут оставаться стойкими |
| DSA | Асимметричная криптография | Цифровая подпись, алгоритмы обмена ключами | Не могут оставаться стойкими |

Как видим, симметричная криптография может оставаться стойкой к квантовым атакам, если увеличить размеры ключевых параметров. Также возможно относительно просто адаптировать механизм хэш-функций и продолжать его безопасно использовать. Однако с частью алгоритмов ассиметричной криптографии такие манипуляции будут неэффективны [105].

Криптоалгоритмы, такие как RSA и DSA, ECDSA, не являются квантово-безопасными, поскольку они не могут быть адаптированы (за счет увеличения размеров ключевых параметров), чтобы опережать темпы развития квантовых вычислений. Например, чтобы атаковать 3072-битный ключ RSA, у квантового компьютера должно быть несколько тысяч логических кубитов. В общем, существует линейная зависимость между длиной ключа RSA (в битах) и необходимым количеством кубитов в квантовом компьютере для реализации эффективной атаки на алгоритм. Когда такой квантовый компьютер станет доступным, переход на больший размер ключа RSA будет препятствовать квантовой атаке, пока не будет изобретен квантовый компьютер с большим количеством кубитов. Однако удвоение размера ключа RSA или ECC увеличивает время работы криптопримитива на обычном компьютере в восемь раз. Если для сохранения стойкости таких алгоритмов перед квантовыми атаками необходимо удваивать размер ключевых параметров каждые два года, то время выполнения алгоритмов на обычном компьютере увеличивается в восемь раз каждые два года. Соответственно, эти алгоритмы быстро становятся непрактичными как с точки зрения скорости, так и с точки зрения ширины полосы пропускания канала, необходимой для передачи ключевой информации.


### Срочность перехода на постквантовые алгоритмы

Чтобы продолжать безопасно использовать криптографию с открытым ключом даже в условиях атак с использованием квантовых компьютеров, необходимо применять принципиально другие алгоритмы, которые будут базироваться на задачах, сложных для квантовых компьютеров. Однако процесс перехода на новые алгоритмы требует времени для проверки и тестирования всех аспектов безопасности новых алгоритмов.

> _Замечание. Алгоритмы, которые будут стойкими к атакам квантового компьютера, будем называть постквантовыми алгоритмами._

До сих пор существует много скептицизма по поводу перспективы создания квантового компьютера, способного выполнять более одной задачи (например, выполнять алгоритм Шора и алгоритм Гровера на одном устройстве без необходимости менять архитектурные компоненты). Соответственно, то, как срочно нужно перейти на алгоритмы, устойчивые к атакам квантового компьютера, зависит от следующих факторов [106]:

1. Как долго необходимо обеспечивать безопасность криптографических ключей? Обозначим эту величину, «срок безопасного использования», как _x_. Есть данные, которые теряют свою ценность в течение короткого промежутка времени (несколько минут для одноразового пароля). А есть данные, которую необходимо хранить в секрете на протяжении десятилетий (например, данные медицинской истории или стратегическая информация, связанная с национальной безопасностью). Для первого типа данных _x_ равен 0 год, тогда как для второго он может достигать 10, 20, 100 год и т. д. Значение _x_, как правило, устанавливает лично владелец каждой системы, требующей защиты, либо его устанавливает регулятор.
2. Сколько времени потребуется для введения постквантовой криптографии? Обозначим эту величину, «время миграции», как _у_. Например, _y_ может быть равным 0 год, если просто развертывается автообновление, которое заменяет AES-128 на AES-256 в системе, полностью контролируемой одним поставщиком. Впрочем, _y_ может быть не менее чем 15 год, если он включает относительно непроверенный метод шифрования с открытым ключом, который должен быть адаптирован для ограниченной среды со многими участниками (заинтересованными сторонами), которые должны согласовать стандарт.
3. Наконец, сколько времени пройдет до того, как квантовый компьютер или какой-либо другой метод взломает используемые ныне инструменты криптографии с открытым ключом? Обозначим эту величину, «время коллапса», как _z_. Если сумма _x_ и _y_ больше, чем _z_, возникает серьезная проблема, поскольку информация, защищенная квантово-уязвимыми инструментами в конце следующих _y_ лет, может быть взломана квантовыми атаками менее чем через x год.


### Возможные пути решения

На сегодня существует два взаимодополняющих семейства возможных решений.

Одно семейство решений называют постквантовой криптографией. К нему относятся  обычные криптопримитивы, основанные на математических задачах, которые по мнению научного сообщества (на основе теоретических вычислений) защищены от атак с применением квантового компьютера. Эти решения удобны тем, что соответствующие алгоритмы могут работать и на классическом компьютере. В свою очередь, это упрощает процессы исследования даже до момента появления достаточно мощных квантовых компьютеров. Применяя такие решения, мы все еще находимся в ситуации «вычислительной безопасности», т. е. мы предполагаем, что сложность атаки грубой силы с применением квантового компьютера будет достаточно высокой, чтобы обеспечить стойкость систем с применением таких алгоритмов (подробнее рассмотрим далее).

> _Замечание. Согласно классическому определению считается, что алгоритм стойкий, если не существует более эффективной атаки, чем прямой перебор ключевых параметров (атака грубой силы). Однако для постквантовых алгоритмов необходимо также выполнение еще одного условия, а именно стойкости к атакам с применением алгоритмов Шора [107] и Гровера [108]_

Другое семейство решений известно как квантовая криптография [109] – метод защиты коммуникаций, основанный на принципах квантовой физики. В отличие от традиционной криптографии, которая использует математические методы, чтобы обеспечить секретность информации, квантовая криптография рассматривает случаи, когда информация переносится с помощью объектов квантовой механики, например электронов в электрическом токе или фотонов в линиях волоконно-оптической связи. Процесс отправки и приема информации всегда выполняется физическими средствами.

Атакой на такие системы (в терминах квантовой криптографии атакой называется «подслушивание») может быть изменение определенных параметров физических объектов (носителей информации).

Технология квантовой криптографии опирается на принцип неопределенности Гейзенберга [110]: невозможно одновременно получить координаты и импульс частицы; невозможно измерить один параметр фотона, не исказив другой.

Используя квантовые явления, можно спроектировать и создать такую систему связи, которая всегда может обнаруживать подслушивание. Это обеспечивается тем, что попытка измерения взаимосвязанных параметров в квантовой системе вносит в нее нарушения, разрушая исходные сигналы. Значит, по уровню шума в канале честные пользователи могут распознать присутствие перехватчика.
Недостаток таких решений – необходимость организовать квантовый канал (рис. 6.1). Чтобы отправлять кубиты, необходимо наличие соответствующего оборудования у обеих сторон взаимодействия. Такое оборудование очень дорогостоящее и на сегодня недоступно для широкого использования.

![Рисунок 6.1 – Организация квантового канала](/resources/img/volume-3/6.1-Introduction-to-post-quantum-cryptographic-algorithms/F-6.1-quantum-channel-setup.png "Рисунок 6.1 – Организация квантового канала")

В краткосрочной перспективе такие квантовые каналы доступны от точки к точке на относительно коротких расстояниях, но возможно в среднесрочной и долгосрочной перспективе квантовая связь и квантовые повторители позволят организовать безопасные каналы на больших расстояниях.

Далее мы рассмотрим, какие задачи являются вычислительно сложными для квантовых компьютеров. На сегодня выделяют четыре основные задачи в разных математических аппаратах, которые легли в основу семейств постквантовых примитивов.


### Lattice-based cryptography (LB-криптография)

LB-криптография – это подход к построению алгоритмов асимметричного шифрования и цифровой подписи с использованием задач теории алгебраических решеток.

Алгебраическая решетка – это дискретное подмножество векторов в эвклидовом пространстве $\mathbb{R}^{n}$, замкнутое относительно операций сложения и вычитания векторов. Мы говорим, что размерность решетки – _n_, если она не размещается в любом подпространстве пространства $\mathbb{R}^{n}$. Геометрически решетка – это множество равновероятно размещенных в пространстве точек, через которые проходят векторы. Алгебраическая решетка может рассматриваться как абелева группа.

Базис решетки _L_ – это множество векторов В таких, что любой другой вектор в решетке может быть представлен в виде линейной комбинации (с целочисленными коэффициентами) элементов множества _В_. Если размерность решетки равна по меньшей мере 2, то существует бесконечно большое множество различных базисов решетки (рис. 6.2).

![Рисунок 6.2 – Множество базисов в решетке](/resources/img/volume-3/6.1-Introduction-to-post-quantum-cryptographic-algorithms/F-6.2-many-bases-in-lattice.png "Рисунок 6.2 – Множество базисов в решетке")

Алгебраические решетки как математическую конструкцию впервые изучили Лагранж и Гаусс. В криптографии они использовались, например, для криптоанализа конгруэнтных генераторов. В 1996 году M. Aitai показал, как решетки могут быть использованы в качестве нового криптопреобразования. В 2009 году Gentry использовал решетки для построения новой гомоморфной криптосистемы.

Устойчивость LB-криптосистем базируется на сложности решения двух комбинаторных задач:

1. Задача о кратчайшем векторе (shortest vector problem, SVP): поиск кратчайшего вектора в решетке _L_, представленной в базисе _В_. На ней построены алгоритмы шифрования с использованием решеток. Личный ключ в такой системе – базис решетки _В_ и специально выбранная унимодулярная матрица _U_ (квадратная матрица с целыми коэффициентами, определитель которой равен +1 или −1). Открытый ключ – базис $B'=BU$. Зная базис, можно сгенерировать вектор, близкий к заданной точке, но зная близкий вектор, нам необходим исходный базис, чтобы найти исходную точку. Пример такой системы – NTRUEncrypt [111].
2. Задача о ближайшем векторе (closest vector problem, CVP): для заданного базиса _В_ решетки _L_ и некоторого вектора $v \in L$ необходимо найти вектор $v' \in L$, который является ближайшим к вектору _v_. На этой задаче построены алгоритмы цифровой подписи на решетках. Идея заключается в использовании решеток, для которых «плохой» базис (длинные и почти параллельные векторы) – открытый ключ, а «хороший» базис (короткие и почти ортогональные векторы) – личный ключ. Пример – алгоритм цифровой подписи NTRUSign [112].

Преимущества LB-алгоритмов заключаются в их относительной простоте и легкости распараллеливания предварительных вычислений, необходимых для операций зашифрования/расшифрования и генерации/верификации цифровой подписи. С другой стороны, оказалось трудно дать точные оценки безопасности «решетчатых схем» по сравнению даже с известными методами криптоанализа.


### Code-based cryptography (CB-криптография)

CB-криптография включает в себя системы, основанные на кодах с исправлением ошибок, такие как алгоритмы шифрования McEliece [113] и Niederreiter, и соответствующие схемы подписи Courtois, Finiasz и Sendrier. Основной прием – добавление к записываемым (передаваемым) полезным данным специальным образом структурированной избыточной информации (например контрольной суммы). При чтении (приеме) данных такая избыточная информация используется для обнаружения и исправления ошибок. Количество ошибок, которое можно исправить, ограничено и зависит от конкретного применяемого кода.

CB-криптография базируется на сложности декодирования линейных кодов. Открытый ключ в такой системе – матрица _K_ с размерностью $dt \times n$ с коэффициентами в поле $\mathrm{GF}(2)$. Сообщение (_m_) представляет собой _n_-битную строку с весом _t_, то есть _n_-битная строка содержит ровно _t_ битов, которые равны 1; его необходимо предварительно отформатировать. Чтобы зашифровать сообщение _m_, отправитель формирует $dt$-битный ($d= \lg{n}$) шифротекст $C=Km$.

Главная задача для злоумышленника – поиск синдрома декодирования матрицы _К_. То есть она состоит в том, чтобы получить результат умножения _К_, зная, что на входе – вектор с весом _t_. Это можно сделать методами линейной алгебры: выполнить обратную операцию восстановления _C_ к _n_-битному вектору _v_ такому, что $Kv=C$. Однако существует очень много таких векторов _v_, и поиск среди них _t_-вектора крайне тяжелый. Самая известная на сегодня атака на эту задачу имеет экспоненциальную сложность для большинства матриц _К_.

Впервые криптосистема McEliece была представлена в 1978 году; с тех пор эффективные атаки на нее не появлялись. Позже были предложены другие системы, основанные на кодах с исправлением ошибок. Хотя примитивы, основанные на кодах, довольно быстрые, они используют ключи со слишком большим размером. В большинстве случаев применение аппарата кодов оказалось удобнее для реализации схем шифрования, чем для алгоритмов цифровой подписи.


### Multivariate polynomial cryptography (MQ-криптография)

Безопасное применение криптопримитивов этой группы в условиях атак с использованием квантовых компьютеров основано на предположении, что решение систем многомерных полиномов над конечными полями находить сложно.

Открытый ключ в такой системе – последовательность $(P_{1} P_{2}, \ldots ,P_{2b})$ из $2b$ полиномов с $4b$ переменными $(ω_{1},ω_{2}, \ldots ,ω_{4b})$ с коэффициентами в поле $\mathrm{GF}(2)$. Каждый полином представлен как последовательность $(1,ω_{1},ω_{2}, \ldots ,ω_{4b},ω_{1}ω_{2},ω_{1}ω_{3}, \ldots ,ω_{4b-1}ω_{4b})$. Открытый ключ состоит из $16b^{3}+4b^{2}+2b$ битов. Например, для $b=128$ размер ключа будет составлять 4 МБ.

Преимущество MQ-криптографии – именно размеры подписей и открытых ключей.

Главная задача для злоумышленника – поиск последовательности $(ω_{1},ω_{2}, \ldots ,ω_{4b})$ из $4b$ битов, которая порождает исходную последовательность $(P_{1} P_{2}, \ldots ,P_{2b})$ из $2b$ битов. Вероятность угадать последовательность из 4b битов можно оценить как $2^{-2b}$.


### Hash-based cryptography (HB-криптография)

HB-криптография (криптография, основанная на использовании хэш-функций) использует схемы одноразовой подписи, такие как Lamport–Diffie или Winternitz. Устойчивость таких схем основывается исключительно на устойчивости хэш-функции, которая используется. Особенность схем Lamport–Diffie и Winternitz – невозможность их безопасного использования более одного раза. Для устранения указанных недостатков используются двоичные деревья. Основная идея заключается в том, что каждый узел дерева рассчитывается как хэш-значение от конкатенации дочерних узлов дерева. Корневой узел дерева – открытый ключ, который рассчитывается последовательно (рис. 6.3). Листья дерева хранят значения одноразовых ключей.

![Рисунок 6.3 – Архитектура hash-based алгоритмов подписи](/resources/img/volume-3/6.1-Introduction-to-post-quantum-cryptographic-algorithms/F-6.3-architecture-of-hash-based-signature-algorithms.png "Рисунок 6.3 – Архитектура hash-based алгоритмов подписи")

Идею использования дерева предложил в 1979 году Ральф Меркл (Ralph C. Merkle). У нее есть ряд недостатков, таких как большой размер ключей и долгое время генерации подписи. На сегодня известны модификации алгоритма Merkle, такие как алгоритм Leighton–Micali, алгоритм XMSS и алгоритм SPHINCS.


### Альтернативные группы

Было предложено множество систем, которые не входят в вышеуказанные группы. Одно из таких предложений основано на оценке изогений суперсингулярных эллиптических кривых.

> _Замечание. Теорема Хассе утверждает, что при количестве точек N кривой, которая определена над полем $\mathrm{GF}(q)$, справедливо равенство: $|N-(q+1)| \leq 2 \sqrt{q}$. Для кривой, определенной над двоичным конечным полем $\mathrm{GF}(2^{n})$, можно утверждать, что $N=2^{n}+1-t$, где $|t| \leq \sqrt{2^{n}}$._
> 
> _Если t делится без остатка на характеристику поля, эллиптическая кривая над двоичным конечным полем называется суперсингулярной [114]._

Задача дискретного логарифмирования на эллиптических кривых может быть эффективно решена с помощью алгоритма Шора на квантовом компьютере, но для задачи нахождения изогении (то есть рационального отображения, которое переводит точки одной кривой в точки изогенной кривой, оставляя «незатронутой» точку на бесконечности) на суперсингулярных кривых нет аналогичной квантовой атаки.

### \*\*\*Распространенные мифы\*\*\*

_Как только будет создан квантовый компьютер, который эффективно решает задачу дискретного логарифмирования в группе точек эллиптической кривой, ECDSA сразу же станет бесполезным._

Не всегда такое утверждение будет верным. В некоторых случаях ECDSA может оставаться достаточно надежным, например, если период жизни открытого ключа меньше времени выполнения атаки, а также если ключи используются только один раз и открытый ключ публикуется одновременно с цифровой подписью или позже нее. Кстати, именно поэтому в Биткоине могут продолжать использоваться ECDSA и хэш-значения открытых ключей в качестве адресов.

### \*\*\*Часто задаваемые вопросы\*\*\*

_– Можно ли уже сейчас использовать постквантовые алгоритмы на практике, не дожидаясь фактического появления квантовых компьютеров?_

Постквантовая криптография может использоваться уже сегодня, однако современная инфраструктура пока не готова для ее применения. Например, чтобы в существующую ИОК внедрить использование hash-based подписей, необходимо решить ряд вопросов: как минимум изменить форматы сертификатов открытых ключей и определить политику их обновления. Ведь существует принципиальное различие: при текущем подходе ключевая пара выдается на фиксированный промежуток времени, а при использовании hash-based подписей срок действия открытого ключа зависит от количества наложенных подписей.


## 6.2 Алгоритмы подписи на основе хэш-функций

Во второй части учебного пособия мы рассматривали алгоритмы одноразовой подписи, такие как OTS Лэмпорта и WOTS. Использование этих алгоритмов в совокупности с деревьями Меркла легло в основу постквантовых hash-based алгоритмов цифровой подписи. В этом разделе идет речь о таких алгоритмах, свойствах, которые они обеспечивают, и особенностях их архитектуры.

На сегодня наиболее известные и перспективные алгоритмы цифровой подписи, которые строятся на основе хэш-функций, – алгоритмы семейства SPHINCS [115–118]. Более того, SPHINCS+ прошел во второй тур Процесса стандартизации постквантовой криптографии NIST [119]; он соревнуется с восемью другими проектами за звание нового стандарта цифровой подписи. В этом разделе мы и постараемся описать, как из строительных блоков, таких как OTS (WOTS), HORS (опишем далее) и деревья Меркла, получилось разработать алгоритм цифровой подписи, который будет обеспечивать достаточный уровень безопасности даже в условиях работы квантового компьютера.


### Конструкция HORS

Прежде чем приступить к рассмотрению устройства SPHINCS, опишем, как работает один из компонентов этого алгоритма – HORS (Hash to Obtain Random Subset) [120]. Эта схема few-time подписи была описана в 2002 году и расширяет схему OTS Лэмпорта, позволяя достичь меньшего размера подписи. Безопасность алгоритма основывается только на используемых хэш-функциях [121].

Для начала рассмотрим, как пользователь генерирует ключи. Предположим, что в алгоритме используются две хэш-функции с длиной выхода 160 бит (в действительности HORS не определяет, какие конкретно хэш-функции должны быть использованы; для нашего примера будет достаточно просто обозначить длину выходного хэш-значения). Также установим длину частей личного ключа 160 бит.

Кроме этих параметров, нас интересуют еще два: _t_ и _k_. Параметр _t_ определяет количество частей личного и открытого ключей, а параметр _k_ – количество блоков, на которые будет разделено хэш-значение подписываемого сообщения. При этом между параметрами существует следующая зависимость: $t=2^{\frac{l}{k}}$, где _l_ – длина хэш-значения от подписываемого сообщения. Сразу отметим, насколько важен выбор этих параметров. Если мы определим $k=160$, то $t=2$. Это значит, что личный ключ будет состоять только из двух значений, каждым из которых будем подписывать либо «0», либо «1». При этом размер подписи будет превышать 3 килобайта (как и если бы мы использовали OTS Лэмпорта), а значение открытого ключа будет занимать 40 байт. Если же выбрать k=1, необходимо будет сгенерировать $2^{160}$ частей личного ключа, что на практике довольно проблематично.

Для нашего примера постараемся выбрать оптимальные значения этих параметров: $k=16$, $t=1024$. Итак, когда параметры выбраны и согласованы между участниками системы, пользователь, которому необходимо подписать сообщение, генерирует личный ключ, количество частей которого равно 1024 (рис. 6.4).

![Рисунок 6.4 – Структура личного ключа](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.4-private-key-structure.png "Рисунок 6.4 – Структура личного ключа")

После того как личный ключ сформирован, пользователь вычисляет открытый ключ, количество частей которого также равно 1024. Для получения открытого ключа из личного используется хэш-функция с длиной выхода (в контексте примера) 160 бит (рис. 6.5).

![Рисунок 6.5 – Процесс вычисления открытого ключа](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.5-public-key-computation.png "Рисунок 6.5 – Процесс вычисления открытого ключа")

Открытый ключ распространяется среди проверяющих – с его помощью они могут верифицировать подпись, вычисленную пользователем.

> _Замечание. В приведенном примере значение открытого ключа (набора его частей) достаточно велико (около 20 килобайт) и его не очень удобно хранить верификаторам. Существует способ сжать открытый ключ (для нашего примера – до 160 бит), немного модифицировав алгоритм подписи. Для этого используется дерево Меркла, которое собирает части ключа в одно корневое значение. Здесь мы опускаем детали сжатия ключей, однако далее обязательно рассмотрим их._

Рассмотрим, каким образом проходит сам процесс подписи. Пользователь вычисляет хэш-значение сообщения. После этого полученное хэш-значение он разделяет на _k_ одинаковых по размеру блоков. В нашем примере это будет 16 10-битных блоков (рис. 6.6).

![Рисунок 6.6 – Разбиение хэш-значения сообщения на блоки](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.6-dividing-message-hash-value-into-blocks.png "Рисунок 6.6 – Разбиение хэш-значения сообщения на блоки")

Каждый из этих блоков будет обрабатываться по отдельности, а значение подписи будет содержать в себе _k_ одинаковых по размеру личных ключей. Далее каждый из блоков рассматривается как натуральное число (рис. 6.7).

![Рисунок 6.7 – Преобразование блоков в целочисленные значения](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.7-conversion-of-blocks-to-integer-values.png "Рисунок 6.7 – Преобразование блоков в целочисленные значения")

При использовании схемы HORS части подписи являются частями личного ключа, у которых есть полученные ранее индексы (целочисленные значения блоков). То есть в нашем примере подпись представляет собой набор значений, как на рис. 6.8.

![Рисунок 6.8 – Структура подписи](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.8-signature-structure.png "Рисунок 6.8 – Структура подписи")

Теперь рассмотрим, как полученное значение подписи может быть проверено при помощи открытого ключа. Для этого проверяющий повторяет точно такие же операции над сообщением: вычисляет его хэш-значение, разбивает на блоки и рассматривает каждый блок как натуральное число (рис. 6.7, 6.8). Исходя из полученных индексов, проверяющий выбирает части открытого ключа, которые нужно использовать для верификации. Набор этих частей для нашего примера изображен на рис. 6.9.

![Рисунок 6.9 – Значение открытого ключа для проверки подписи](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.9-public-key-for-signature-verification.png "Рисунок 6.9 – Значение открытого ключа для проверки подписи")

Проверка подписи здесь очень похожа на проверку одноразовой подписи Лэмпорта: каждая часть подписи хэшируется и сравнивается с соответствующей частью открытого ключа (рис. 6.10). Если все соответствующие части равны между собой, то подпись считается верной.

![Рисунок 6.10 – Процесс проверки подписи](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.10-signature-verification.png "Рисунок 6.10 – Процесс проверки подписи")


### Схема подписи Меркла

Теперь мы рассмотрим схему подписи Меркла (MSS), так как SPHINCS – расширение этого алгоритма. Схема подписи Меркла создает многоразовую подпись. Это значит, что она, в отличие от рассмотренных ранее алгоритмов, позволяет подписать несколько различных сообщений и использовать для их проверки одно и то же значение открытого ключа.

Этот алгоритм подписи использует ключи и механизм одноразовой подписи (OTS Лэмпорта, WOTS или любой другой алгоритм), которые, в свою очередь, связаны в древовидную структуру с единым корневым значением.

Начнем с того, как пользователь генерирует ключи. Выбирается параметр, который определяет количество сообщений, которые могут быть проверены одним открытым ключом. Допустим, этот параметр равен 4 (мы сможем подписать 4 различных сообщения, которые будут верифицироваться одним и тем же открытым ключом). Поэтому следующим шагом является создание 4 пар ключей OTS (рис. 6.11).

![Рисунок 6.11 – Генерация ключей для подписи](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.11-generation-of-keys-for-signature.png "Рисунок 6.11 – Генерация ключей для подписи")

> _Замечание. Напомним, что схема OTS Лэмпорта подразумевает генерацию 2n частей личного ключа, где n – длина выходного значения используемой хэш-функции. Значением подписи являются значения частей личного ключа, которые соответствуют каждому биту выхода хэш-функции (в зависимости от значения бита выхода). В ходе верификации проверяющий вычисляет хэш-значения от частей подписи и сопоставляет их с частями открытого ключа. Использование OTS Лэмпорта необязательное; альтернативно может использоваться WOTS (оба алгоритма описаны во второй части учебного пособия)._

При помощи каждого личного ключа одноразовой подписи пользователь и будет подписывать сообщение. Однако использование дерева Меркла позволяет передавать проверяющим не 4 различных открытых ключа, а одно значение. Каким образом? Вычисленные открытые ключи – это листья дерева Меркла, которые далее хэшируются, а хэш-значения от них конкатенируются друг с другом для дальнейшего хэширования и образования узлов дерева. В итоге, получается единое корневое значение (Merkle root), которое и является «глобальным» открытым ключом для всех открытых ключей OTS (рис. 6.12).

Глобальный открытый ключ передается проверяющим и используется для верификации подписей сообщений, которые были подписаны любым из дочерних личных ключей одноразовой подписи.

![Рисунок 6.12 – Процедура формирования открытого ключа](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.12-public-key-formation.png "Рисунок 6.12 – Процедура формирования открытого ключа")

Как же выполняется подписание? Пользователь вычисляет хэш-значение сообщения и для этого хэш-значения вычисляет одноразовую подпись (OTS). К этому значению пользователь прикрепляет значение соответствующего открытого ключа и Merkle branch для аутентификации его в дереве Меркла. Весь этот набор данных прикрепляется к сообщению в качестве цифровой подписи (рис. 6.13).

![Рисунок 6.13 – Структура подписи](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.13-signature-structure.png "Рисунок 6.13 – Структура подписи")

Если мы подписываем сообщение при помощи _private\_key<sub>1</sub>_, то к значению подписи OTS прикрепляется значение _public\_key<sub>1</sub>_, а также _H<sub>1</sub>_ и _H<sub>11</sub>_, которые являются Merkle branches для _public\_key<sub>1</sub>_.

Верификация подписи состоит из двух этапов: проверка одноразовой подписи и проверка того, что указанный открытый ключ относится к глобальному открытому ключу (аутентификация в дереве Меркла). То есть проверяющий подает на вход функции проверки OTS само значение подписи и значение указанного открытого ключа (рис. 6.14).

![Рисунок 6.14 – Схема верификации подписи](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.14-signature-verification.png "Рисунок 6.14 – Схема верификации подписи")

Если значение одноразовой подписи верно, проверяется входимость открытого ключа в дерево Меркла, корень которого содержит значение глобального открытого ключа. То есть, имея значения Merkle branch, проверяющий выполняет верификацию определенного открытого ключа в дереве (рис. 6.15).

![Рисунок 6.15 – Проверка вхождения открытого ключа в дерево Меркла](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.15-verification-of-existence-of-public-key-in-tree.png "Рисунок 6.15 – Проверка вхождения открытого ключа в дерево Меркла")

> _Замечание. В 2011 году была предложена схема XMSS (расширенная версия подписи Меркла) (рис. 6.16). Ее основное отличие – использование алгоритма WOTS+ [122]. Кроме того, она использует дополнительные маски для узлов дерева Меркла перед их конкатенацией и дальнейшим хэшированием. Эта особенность должна обеспечивать безопасность на тот случай, если используемая хэш-функция окажется неустойчивой к коллизиям второго рода [123; 124]._
> 
> _Поскольку далее перейдем к рассмотрению алгоритма SPHINCS, отметим, что он, как и XMSS, использует битовые маски перед хэшированием узлов дерева Меркла._

![Рисунок 6.16 – Схема подписи XMSS](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.16-XMSS-signature-scheme.png "Рисунок 6.16 – Схема подписи XMSS")


### Семейство алгоритмов SPHINCS

Теперь рассмотрим устройство алгоритмов SPHINCS, которые используют описанные ранее схемы. Важная особенность этих алгоритмов: они состоят из большого количества деревьев, которые совместно составляют _hypertree_. Предлагаемая высота hypertree в различных алгоритмах семейства находится в диапазоне 50–70 (например, предлагаемая высота для SPHINCS-256 [118] равна 60). Однако в качестве примера возьмем hypertree с высотой 9.

Hypertree, в свою очередь, делится на слои (обычно около 10), каждый из которых хранит экземпляры поддеревьев Меркла. Для примера возьмем количество слоев 3.

Что представляют собой поддеревья Меркла, которые мы используем для примера? Каждое такое дерево имеет высоту 3. Это значение равно общей высоте hypertree, разделенной на количество слоев в нем. Такие поддеревья хранят в своих листьях сжатые открытые ключи WOTS (WOTS+).

В листьях _hypertree_ находятся открытые ключи HORST – сжатые при помощи дерева Меркла открытые ключи HORS. В вершине _hypertree_ находится значение глобального открытого ключа. Полная схема hypertree SPHINCS изображена на рис. 6.17.

![Рисунок 6.17 – Архитектура hypertree](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.17-hypertree-architecture.png "Рисунок 6.17 – Архитектура hypertree")

Итак, детальнее разберем компоненты схемы. На вершине дерева находится значение глобального открытого ключа, которое передается проверяющему. Это значение получается путем конкатенации и хэширования листьев поддерева верхнего слоя hypertree (слоя 2 на рис. 6.17).

Что представляют собой листья поддерева? Листья поддерева – это сжатые открытые ключи WOTS. Что такое сжатый открытый ключ? Вспомним: обычный ключ WOTS – это набор частей ключа, который имеет большой размер (около 2–8 кБ). Однако части ключа можно сложить в структуру дерева Меркла и получить сжатое значение с размером 128–256 бит. При этом в подпись добавляется значение Merkle branch, которое позволяет доказать факт соответствия частей ключа сжатому значению. 

Эти сжатые открытые ключи используются для проверки подписи открытых ключей, которые находятся на более низком слое hypertree. Нижние слои hypertree работают таким же образом вплоть до экземпляров открытых ключей HORST, которым соответствуют личные ключи, которыми подписываются конечные сообщения.

Рассмотрим процесс генерации ключей для алгоритма SPHINCS. Изначально пользователь генерирует два секретных значения (чаще всего 256-битных) – _S<sub>1</sub>_ и _S<sub>2</sub>_. Первое значение в дальнейшем будет использоваться для генерации вспомогательных ключей (для подписей WOTS и HORS), второе – для выбора листа hypertree, который будет использоваться для подписи, и для добавления случайности при хэшировании сообщения. Вслед за этим генерируется набор масок _Q_, которые будут использоваться для получения подписей WOTS и HORS и для построения деревьев Меркла. Из полученных компонентов и состоит личный ключ (рис. 6.18).

![Рисунок 6.18 – Компоненты личного ключа](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.18-private-key-components.png "Рисунок 6.18 – Компоненты личного ключа")

Для получения открытого ключа необходимо построить поддерево, которое находится на вершине hypertree. Для этого мы генерируем секретные ключи WOTS для листьев этого поддерева. Отметим, что такие ключи порождаются детерминистически в зависимости от индекса экземпляра WOTS и секретного значения _S<sub>1</sub>_. Для нашего примера мы порождаем 8 секретных ключей для одноразовой подписи WOTS, а затем из них вычисляем значения открытых ключей (сжатых), которые будут листьями поддерева верхнего уровня. Далее эти ключи складываются в древовидную структуру, в корне которой оказывается значение открытого ключа SPHINCS (рис. 6.19).

![Рисунок 6.19 – Открытый ключ SPHINCS](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.19-public-key-in-SPHINCS.png "Рисунок 6.19 – Открытый ключ SPHINCS")

К значению открытого ключа добавляется список масок _Q_, который необходим для проверки подписи. В итоге, открытый ключ состоит из значений _global\_public\_key_ и _Q_.

Теперь перейдем к вычислению подписи. Важная особенность алгоритма SPHINCS – направление вычисления подписи снизу hypertree (с листьев) к поддереву, которое находится на вершине hypertree. Согласно нашему примеру (hypertree с высотой 9 и количеством слоев 3) в сумме получается 512 листьев, которые являются сжатыми открытыми ключами HORS. Поэтому сначала необходимо при помощи открытого ключа выбрать, из какого листа будет подписано сообщение.

Необходимый лист выбирается на основании хэш-значения самого подписанного сообщения и секретного значения _S<sub>2</sub>_. Для этого мы используем функцию, которая генерирует псевдослучайную последовательность (в основном – хэш-функцию), которая принимает на вход сообщение и _S<sub>2</sub>_ и возвращает значение индекса листа дерева (index) и дополнительное значение _R_ (рис. 6.20).

![Рисунок 6.20 – Получение индекса листа дерева для подписи](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.20-obtaining-index-of-tree-leaf.png "Рисунок 6.20 – Получение индекса листа дерева для подписи")

Для чего используется _R_? Это значение – своего рода salt, которое мы прикрепляем к подписываемому сообщению перед вычислением его хэш-значения для добавления энтропии (_R_ также прикрепляется к значению подписи). Ввиду этого index – полностью детерминированное значение и оно одинаковое для нескольких подписей одного и того же сообщения. В свою очередь, прикрепляемое к подписи _R_ позволяет правильно вычислить подписанное хэш-значение стороне, которая будет верифицировать подпись.

После того как выбран индекс экземпляра HORS для подписи сообщения, должна быть сгенерирована соответствующая пара ключей этого экземпляра. Эта пара также детерминистически генерируется из секрета  _S<sub>1</sub>_. При помощи сгенерированной ключевой пары подписывается хэш-значение сообщения (рис. 6.21). _Index_, _R_, а также полученное на этом этапе значение подписи HORS – части итоговой подписи SPHINCS.

![Рисунок 6.21 – Добавление значений подписи](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.21-addition-of-signature-values.png "Рисунок 6.21 – Добавление значений подписи")

Далее мы вычисляем сжатый открытый ключ экземпляра HORS. Этот открытый ключ мы подпишем при помощи экземпляра WOTS, который находится выше по иерархии. Для этого мы генерируем новую пару ключей для этого экземпляра WOTS и рассчитываем значение подписи для ключа HORS. Значение этой подписи также добавляется к глобальной подписи SPHINCS.

Однако это еще не все. Открытый ключ WOTS-подписи должен быть аутентифицирован в собственном поддереве (рис. 6.22). Поэтому мы вычисляем Merkle branch, который ведет от этого ключа к корневому значению поддерева. Для этого нужно сгенерировать ключевые пары для каждого листа WOTS и построить соответствующее дерево.

![Рисунок 6.22 – Аутентификация ключа в дереве](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.22-key-authentication.png "Рисунок 6.22 – Аутентификация ключа в дереве")

К глобальному значению подписи SPHINCS добавляется еще и соответствующий конкретному поддереву Merkle branch. Таким же образом происходит подпись на каждом следующем уровне hypertree: каждый следующий экземпляр WOTS подписывает значение открытого ключа на нижнем уровне. В итоге, для нашего примера значение подписи будет выглядеть так, как на рис. 6.23.

![Рисунок 6.23 – Значение подписи SPHINCS](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.23-SPHINCS-signature-value.png "Рисунок 6.23 – Значение подписи SPHINCS")

На каждом слое hypertree в глобальное значение подписи добавляется значение подписи WOTS и путь аутентификации – набор значений, которые доказывают принадлежность конкретного ключа к корневому значению.

Процедура проверки подписи состоит из меньшего количества шагов, так как не требует генерации ключей для всех листьев конкретного дерева. Входные параметры при верификации – глобальный открытый ключ и подпись для конкретного сообщения.

На первом шаге проверяющий вычисляет хэш-значение сообщения. Для этого он использует само сообщение и значение _R_, которое находится в подписи. Далее выполняется проверка подписи HORS для полученного значения. Отметим, что в значении подписи отсутствует значение открытого ключа HORS. Однако ввиду того, что открытый ключ HORS – это хэш-значение от значения подписи в сжатом виде, имея значение подписи, мы можем легко вычислить необходимый открытый ключ.

После этого необходимо проверить подпись полученного ключа экземпляром WOTS верхнего уровня (вычислить соответствующий открытый ключ из подписи). Далее – проверить, что полученное значение входит в структуру поддерева, используя Merkle branch. Поскольку Merkle branch находится в подписи, мы можем вычислить значение корневого узла поддерева. Это значение открытого ключа аналогично подписано экземпляром WOTS более высокого уровня.

Мы поднимаемся вверх по hypertree, используя пути аутентификации и значения подписей нижних слоев. В итоге, мы получим корневое значение, которое мы и сравниваем со значением глобального открытого ключа пользователя. Если значения равны между собой, подпись считается верной.

# [7 STABLECOINS И ДЕЦЕНТРАЛИЗОВАННЫЕ ФИНАНСЫ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ru/7-Stablecoins-and-decentralized-finance.md)
