# [1 ПРИМЕНЕНИЕ ДЕЦЕНТРАЛИЗОВАННЫХ ПОДХОДОВ ДЛЯ ОРГАНИЗАЦИИ РАЗЛИЧНЫХ СИСТЕМ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ru/1-Applying-decentralized-approaches-to-different-system-designs.md)

# 2 ПОДПИСИ ШНОРРА И СВЯЗАННЫЕ С НИМИ ОБНОВЛЕНИЯ


## 2.1 Особенности и применение подписей Шнорра

Еще с 2014 года сообщество Bitcoin рассматривает возможность и необходимость добавления подписей Шнорра в протокол учетной системы. Основная причина добавления такого типа подписей заключается в текущем размере доказательств владения монетами. Дело в том, что более 40% обычной транзакции занимают доказательства владения монетами: значения открытого ключа и цифровой подписи. В случае реализации механизма мультиподписи такая ситуация усугубляется еще сильнее, так как подпись предоставляется для каждого открытого ключа по отдельности, что приводит к пропорциональному увеличению размера доказательств.

А что значат большие объемы доказательств для Bitcoin? Это огромные транзакции, за которые пользователям необходимо платить. Это малое количество транзакций в блоках и, в результате, низкая пропускная способность системы. Это большой размер mempool и увеличение комиссии при использовании мультиподписи.

Алгоритм подписи Шнорра был разработан еще в 1980 году и теоретически может избавить пользователей от перечисленных выше недостатков [49]. Но почему же он сразу не был реализован в протоколе Bitcoin? Дело в том, что на момент создания первой версии ПО он был запатентован и не мог использоваться в программном обеспечении с открытым исходным кодом. В то же время ECDSA был действующим, проверенным стандартом, поэтому именно он и был реализован в протоколе Bitcoin. В этом разделе мы рассмотрим принципы функционирования подписей Шнорра, особенности их применения в протокол Bitcoin и причины для их применения, а также то, каким образом эти подписи уже были внедрены в другие учетные системы и то, к чему привело их добавление.


### Преимущества подписей Шнорра

Во второй части учебного пособия мы рассматривали особенности функционирования двух типов мультиподписи: тип, который подразумевает агрегирование открытых ключей и значений подписи, и тип, который не позволяет этого (отдельное значение подписи проверяется отдельным открытым ключом). Подписи Шнорра, в отличие от ECDSA, относятся к первому типу подписей, а именно позволяют агрегирование открытых ключей в единое общее значение, а также агрегирование значений подписи. То есть, в отличие от используемых ECDSA-мультиподписей (размер которых линейно увеличивается в зависимости от количества подписантов), мультиподпись, сформированная при помощи алгоритма Шнорра, не отличается по размеру от одиночной подписи (рис. 2.1).

![Рисунок 2.1 – Размер мультиподписи вычисленной по ECDSA и алгоритму Шнорра](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.1-size-comparison-for-multisignatures.png "Рисунок 2.1 – Размер мультиподписи вычисленной по ECDSA и алгоритму Шнорра")

В этом и состоит основное и наиболее востребованное свойство подписей Шнорра: уменьшение размера доказательств владения монетами при использовании мультиподписи. Уменьшение итогового размера подписи на входе транзакции приводит к увеличению пропускной способности системы (соответственно, к уменьшению размера комиссии, которую необходимо заплатить за место в блоке).

Впрочем, эта концепция может быть расширена еще больше. Что если мы будем использовать такие подписи одновременно для всех входов транзакции? Процедура подписи чаще всего состоит в представлении всех полей транзакции в байтовую строку и подписи этой строки (вернее, ее хэш-значения). Соответственно, чаще всего (когда используется signature hash type SIGHASH_ALL) каждый вход одной транзакции содержит подпись одних и тех же данных – всех полей этой транзакции – при помощи конкретного ключа. Из этого следует, что мы можем применить принципы агрегирования не только для отдельного входа транзакции, но и для транзакции в целом (рис. 2.2).

![Рисунок 2.2 – Использование единого значения подписи для всех вдохов транзакции](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.2-single-signature-value-for-all-transaction-inputs.png "Рисунок 2.2 – Использование единого значения подписи для всех вдохов транзакции")

> _Замечание. В истории Bitcoin были периоды, когда количество транзакций в mempool достигало 140 тысяч, хотя при нормальной нагрузке на систему их количество не превышает 10 тысяч (рис. 2.3). Это были периоды, когда проводились намеренные flood-атаки на Bitcoin. Для этого публиковалось много транзакций с большим количеством входов, в результате чего в блок помещалось всего несколько десятков транзакций вместо нескольких тысяч [50]._
> 
> _Подпись Шнорра позволит избежать непреднамеренного возникновения таких ситуаций и повысить пропускную способность системы, так как можно реализовать схему, при которой каждой транзакции будет соответствовать всего одна подпись (общее доказательство владения монетами для всех входов)._

![Рисунок 2.3 – График загруженности mempool в Bitcoin](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.3-Bitcoin-mempool-load-chart.png "Рисунок 2.3 – График загруженности mempool в Bitcoin")

Также важно рассмотреть необходимость внедрения подписей Шнорра с точки зрения конфиденциальности транзакций. Как мы упоминали ранее, основным преимуществом подписей Шнорра является возможность создания транзакции с мультиподписью, которая не отличима от обычной транзакции. При этом ни один из участников сети не может видеть, какие открытые ключи относятся к конкретной транзакции – фигурировать может только общее агрегированное значение [51].

На сегодняшний день мультиподпись в Bitcoin реализуется при помощи механизма P2SH. Данный подход позволяет переложить часть оплаты комиссии (переплату за использование больших условий траты монет) на принимающую сторону, однако, при этом условие траты монет все равно известно третьим лицам (так как оно должно быть опубликовано для доказательства владения монетами). В качестве альтернативы был предложен механизм MAST, который мы рассмотрим в следующем разделе.

Концепция MAST позволяет обеспечить конфиденциальность неиспользованных условий, но при этом условие, которое было выполнено, доступно всем участникам сети. Также размер доказательств владения монетами может выдать присутствие других условий.

Внедрение подписей Шнорра открывает дорогу для таких предложений, как Taproot и Graftroot (где требуется возможность агрегирования ключей) [52]. Taproot предлагает все преимущества MAST-структур, но при этом никто не будет знать, что за простой транзакцией скрывался сложный смарт-контракт (в случае если будет выполнено условие, находящееся на вершине дерева Меркла, иначе третья сторона также может узнать о наличии дополнительных условий). Graftroot же позволяет полностью скрыть существование сложных условий (другие пользователи никогда не узнают о наличии альтернативных сценариев). Подробнее мы рассмотрим эти подходы в подразделах 2.3 и 2.4.


### Устройство подписей Шнорра

Для того чтобы показать, какими свойствами обладает мультиподпись, выработанная по алгоритму Шнорра, рассмотрим принципы функционирования одиночной подписи. Изначально пользователь имеет ключевую пару: личный и открытый криптографические ключи. При этом процесс получения открытого ключа из личного ничем не отличается от ECDSA: открытый ключ равен личному, умноженному на значение базовой точки. Важно отметить, что реализация подписей Шнорра не требует изменения используемых параметров эллиптической кривой (соответственно, порядок формирования ключевой пары и итогового адреса не изменится для пользователя).

Сам процесс подписи сообщения довольно прост и состоит из двух шагов: генерация рандомизатора и использование личного ключа и рандомизатора для формирования подписи (рис. 2.4).

![Рисунок 2.4 – Алгоритм подписи Шнорра](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.4-Schnorr-signature-algorithm.png "Рисунок 2.4 – Алгоритм подписи Шнорра")

Значение подписи представляет собой пару значений $(R,s)$, где _R_ – точка на кривой, _s_ – натуральное число. При верификации подписи проверяется выполнение условия, как на рисунке 2.5. В случае, если равенство выполняется, то подпись считается верной.

![Рисунок 2.5 – Алгоритм проверки подписи](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.5-signature-verification-algorithm.png "Рисунок 2.5 – Алгоритм проверки подписи")

> _Замечание. Суммарный размер значения такой подписи равен 96 Б. Однако его можно сжать до 65 Б. Для этого нужно представить значение точки R как координату х и знак координаты у. Этот способ рассмотрен во 2-й части книги в контексте сжатого формата открытого ключа в Bitcoin._


### Мультиподпись при помощи алгоритма Шнорра

Механизм мультиподписи фактически не отличается от обычной подписи, за исключением того, что значения подписи и открытого ключа равны их агрегированному значению всех участников (рис. 2.6). Агрегированный открытый ключ равен сумме открытых ключей всех участников подписи и также представляет собой точку на кривой. Значение подписи, в свою очередь, является суммой подписей всех участников, приведенной по модулю порядка базовой точки.

![Рисунок 2.6 – Сравнение алгоритмов одиночной подписи и мультиподписи Шнорра](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.6-comparison-of-single-signature-and-multisignature-algorithms.png "Рисунок 2.6 – Сравнение алгоритмов одиночной подписи и мультиподписи Шнорра")

Можно заметить, что размер мультиподписи ничем не отличается от одиночной подписи, и алгоритмы верификации обеих подписей полностью идентичны. Это значит, что стороннему наблюдателю неизвестно, была ли это одиночная подпись или мультиподпись.


### Принцип проведения rogue key attack

Механизм мультиподписи, который мы описали ранее, может использоваться в случае, если каждый участник системы гарантировано знает открытые ключи остальных участников, с которыми совершает взаимодействие. Однако, на практике такой подход использоваться не будет, по крайней мере в Bitcoin и других подобных системах, так как он позволяет одной из сторон смошенничать на этапе формирования агрегированного открытого ключа [53].

Для того, чтобы объяснить такого рода атаку, предлагаем сразу рассмотреть пример: Алиса и Боб хотят отправить свои средства на адрес, доступ к которому они могут получить только совместно (то есть multisig адрес).

Для этого им нужно сформировать агрегированный открытый ключ, за которым и будут закреплены монеты. В процессе формирования такового Алиса с Бобом обмениваются открытыми ключами и вычисляют агрегированное значение как сумму их открытых ключей. Затем Алиса с Бобом формируют транзакции (либо одну общую транзакцию), которые тратят монеты на указанное агрегированное значение (рис. 2.7).

![Рисунок 2.7 – Отправка монет на агрегированное значение открытого ключа](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.7-sending-coins-to-aggregated-public-key-value.png "Рисунок 2.7 – Отправка монет на агрегированное значение открытого ключа")

После подтверждения такой транзакции в сети, Алиса с Бобом только совместно могут потратить заблокированные монеты. Для этого каждый из них формирует собственное значение подписи, которые впоследствие агрегируются и добавляются в доказательство владения монетами. Процесс траты средств при помощи мультиподписи изображен на рис. 2.8.

![Рисунок 2.8 – Трата средств с multisignature адреса](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.8-spending-funds-with-multisignature-addresses.png "Рисунок 2.8 – Трата средств с multisignature адреса")

Как мы уже упоминали ранее, верификатор может проверить правильность подписи, проверив равенство на рисунке 2.9.

![Рисунок 2.9 – Процедура проверки подписи](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.9-signature-verification-procedure.png "Рисунок 2.9 – Процедура проверки подписи")

Давайте теперь рассмотрим ситуацию, в которой Боб хочет обмануть Алису и забрать ее монеты себе. Для этого на шаге обмена открытыми ключами ему нужно просто отправить Алисе поддельное, специальным образом подобранное значение открытого ключа. В отличие от схемы на рис. 2.9, пусть Боб отправляет не собственное значение _X<sub>B</sub>_, а значение $X_{\text{B}}-X_{\text{A}}$ (рис. 2.10).

![Рисунок 2.10 – Боб подменяет значение открытого ключа](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.10-spoofing-public-key-value.png "Рисунок 2.10 – Боб подменяет значение открытого ключа")

Мы видим, что в этом случае значение агрегированного ключа равно значению открытого ключа Боба. Соответственно, Боб знает личный ключ, при помощи которого он может вычислить подпись, которая будет проверяться при помощи указанного открытого ключа. Таким образом, Бобу не требуется подтверждение Алисы для разблокировки монет, которые привязаны к такому адресу.

> _Замечание. При проведении этой атаки Боб не знает значение секретного ключа, который бы соответствовал открытому ключу  X<sub>B</sub>-X<sub>A</sub>, благодаря свойствам эллиптических кривых. Однако, эта атака может быть проведена в базовом случае, поскольку Алиса не проверяет, знает ли фактически Боб секрет_

В качестве одного из решений такого рода проблемы можно использовать дополнительную итерацию после обмена ключами, во время которой участники должны доказать, что они знают соответствующие личные ключи. Для этого каждый из них может сгенерировать случайное значение nonce и попросить контрагента подписать его, после чего проверить подпись полученным ранее открытым ключом (рис. 2.11). При этом, данный способ требует дополнительные 4 итерации и не является самым оптимальным решением (в отличие от способа, который мы рассмотрим далее).

![Рисунок 2.11 – Проверка факта, что Боб владеет указанным открытым ключом](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.11-verifying-ownership-of-public-key.png "Рисунок 2.11 – Проверка факта, что Боб владеет указанным открытым ключом")


### Схема Bellare–Neven

Другим предложением для защиты от атаки подмены ключа является использования подписи Bellare–Neven [54]. Давайте рассмотрим особенности функционирования данной схемы (рис. 2.12).

![Рисунок 2.12 – Схема подписи Bellare–Neven](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.12-Bellare--Neven-signature-scheme.png "Рисунок 2.12 – Схема подписи Bellare–Neven")

Как можно заметить, в схеме отсутствует агрегированное значение открытого ключа и для верификации подписи используются все открытые ключи участников по отдельности. Такая схема действительно не позволяет одной из сторон подделать открытый ключ, так как соответствующее секретное значение необходимо будет для вычисления подписи. При этом также значение подписи по размеру не отличается от подписи, вычисленной одним участником.

Однако очевидным недостатком этой схемы является то, что алгоритм ее верификации полностью отличается от стандартной подписи и требует использование открытых ключей всех сторон, что, в свою очередь, деанонимизирует участников взаимодействия.


### Схема MuSig

15 января 2018 года было опубликовано предложение новой схемы, которая использует Bellare–Neven подход, но при этом позволяет сделать множественную подпись неотличимой от стандартной (при этом сохраняя защиту от атаки с подменой открытого ключа) [55]. Давайте рассмотрим алгоритм формирования такой подписи (рис. 2.13).

![Рисунок 2.13 – Схема подписи MuSig](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.13-MuSig-signature-scheme.png "Рисунок 2.13 – Схема подписи MuSig")

Значение агрегированного ключа в этом случае равно не просто сумме открытых ключей, а сумме открытых ключей, каждый из которых умножен на дополнительное значение (хэш-значение, которое включает хэш от всех открытых ключей подписантов, а также частный открытый ключ).

MuSig фактически и является той схемой, которая способна решить задачи, связанные с уменьшением размера доказательства траты монет (путем уменьшения итогового размера подписи) и конфиденциальностью участников сделки (агрегированный открытый ключ и общее значение подписи). Более того, за счет того, что алгоритм верификации одиночной подписи не отличается от алгоритма верификации мультиподписи, валидаторы могут даже не догадываться об участии в сделке нескольких сторон (а в случае использования дополнительных методик, таких как taproot и graftroot, – и о наличии дополнительных условий).


### Ограничения использования подписей Шнорра

Несмотря на описанные ранее преимущества подписей Шнорра, возникает ряд задач, которые необходимо решить для их применения. 

Ранее мы упоминали о том, что транзакция может содержать одну подпись для всех своих входов. Такая возможность действительно существует, однако, при этом стоит учесть, что при подписи каждого из входов должны учитываться открытые ключи всех входов. В качестве примера: у нас есть транзакция с тремя входами на 2, 3 и 5 монет. Каждый из этих входов (предварительных непотраченных выходов) закреплен за отдельным открытым ключом, доказательство владение которым определяет доказательство владения монетами.

Для агрегации подписей в одну, каждый из входов должен фактически содержать подписи следующего типа (рис. 2.14).

![Рисунок 2.14 – Значения подписей на входах транзакции](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.14-signature-values-for-transaction-inputs.png "Рисунок 2.14 – Значения подписей на входах транзакции")

Эти значения могут быть агрегированы только в случае, если каждый из подписывающих имеет одинаковое значение агрегированного открытого ключа (_Х_), то есть знает открытые ключи всех остальных входов. Таким образом, пользователь не может подписать свои входы и использовать входы других пользователей для формирования общей транзакции без предварительного согласия всех сторон на это. Эта особенность очень усложняет реализацию таких подходов как CoinJoin (и его модификации), CoinShuffle и др.

Второе ограничение состоит в том, что подход с агрегированием подписей в транзакции может использоваться только в том случае, если подпись покрывает всю транзакцию (SIGHASH_ALL). Signature Hash Types позволяют пользователю подписать только определенные входы и выходы транзакции, сохранив при этом гибкость взаимодействия другим участникам транзакции (например, возможность добавления дополнительных входов и выходов, и т. д.). Однако, такие типы подписи подразумевают подпись разных данных, и, соответственно, различных хэш-значений. Из этого следует, что значения подписи входов с различными типами подписываемых данных не могут быть агрегированы.


### Особенности реализации подписей Шнорра

По состоянию на январь 2020 года ничто не препятствует реализовать подписи Шнорра в протоколе Bitcoin (за исключением необходимости убедить сообщество, что это целесообразно).

В июне 2018 года был обнародован проект, в котором излагается техническая реализация подписей Шнорра [56]. Питер Вейлле (Pieter Wuille), который, собственно, и обнародовал проект, заявил, что подпись Шнорра – это «строительный блок для различных дальнейших улучшений». Он выразил надежду, что изменения в конечном счете будут приняты, хотя полностью это зависит от решения пользователей. Также вышло математическое объяснение принципов работы подписи Шнорра в соавторстве таких ведущих разработчиков, как Грегори Максвелл (Gregory Maxwell) и Джонсон Лау (Johnson Lau) [55].

Предшествием введения подписей Шнорра стало обновление протокола под названием Segregated Witness, позволяющее вынести подписи транзакции в структуру вне основного блока. И хотя сам SegWit для реализации подписи Шнорра не является непременным условием, его активация позволяет сделать весь процесс более простым. Использование мультиподписи алгоритмом Шнорра в объединении с SegWit позволяет еще больше уменьшить размер транзакции и увеличить уровень конфиденциальности каждого пользователя за счет возможности объединения всех подписей транзакции в одну.

### \*\*\*Часто задаваемые вопросы\*\*\*

_– Можно ли развить идею еще дальше и разрешить валидаторам агрегировать значения подписей всех транзакций в блоке?_

Агрегация подписей возможна только если подписи покрывают один набор данных. Но так как пользователи подписывают только свои транзакции (различные данные), нельзя агрегировать их значение в границах блока.

_– Можно ли с использованием MuSig организовать схему, когда один пользователь создал транзакцию, подписал ее своим ключом и положил в сейф, а через время ее взял другой пользователь, доподписал своим ключом и опубликовал?_

Теоретически такая возможность существует, однако, такой подход не будет удобным для пользователей. Все дело в том, что для генерации подписи стороны должны предварительно обменяться значениями _R<sub>i</sub>_ и сформировать общее _R<sub>aggr</sub>_, которое необходимо для вычислений. Поэтому единственный способ это сделать для данной схемы – предварительно сгенерировать _R<sub>i</sub>_, обменяться ими и разойтись. Тогда, может быть реализован вариант, когда транзакция подписывается сначала одним, а потом другим пользователем. Но при этом каждый из них должен дополнительно хранить собственное _R<sub>i</sub>_ и общее _R<sub>aggr</sub>_.


## 2.2 Концепция MAST в Bitcoin 

Протокол Bitcoin позволяет описывать условия траты монет при помощи специального скриптового языка (Bitcoin Script). Он не является полным по Тьюрингу, однако определенный в нем набор операций позволяет реализовывать наиболее часто используемые сценарии и, более того, обеспечивать функционирование протоколов верхнего уровня (atomic swaps, payment channels, и т. д.).

Текущий протокол Bitcoin предусматривает, что все условия траты монет (даже если скрипт содержит несколько альтернативных условий) должны быть опубликованы: либо явно в выходе транзакции, либо во входе следующей транзакции с доказательствами удовлетворения этих условий (подход P2SH). Такой подход позволяет гарантированно проверить выполнение условий, однако его нельзя назвать наиболее эффективным ввиду следующих причин.

> * _Большое количество неиспользуемых данных_
> * _Низкий уровень конфиденциальности_
> * _Ограничение размера контрактов_

Первый недостаток состоит в том, что транзакция должна содержать весь контракт (все условия), вне зависимости от того, какое конкретно условие было удовлетворено. Таким образом, если мы имеем сценарий, как на рисунке 2.15, то все данные этого скрипта должны быть помещены в транзакцию, хотя фактически монеты будут разблокированы только при выполнении одного условия из всех возможных.

![Рисунок 2.15 – Скрипт, помещаемый в условие траты монет](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.15-script-placed-in-coin-spending-condition.png "Рисунок 2.15 – Скрипт, помещаемый в условие траты монет")

По этой же причине есть некоторые проблемы с конфиденциальностью условий: каждый участник сети видит все альтернативные условия, вне зависимости от того, какое из них действительно было выполнено.

Протокол Bitcoin ограничивает максимальный размер транзакции, как 1/4 от максимального размера блока, и максимальный размер скрипта в 520 байт. Но кроме этого, ограничением является цена записи данных в цепочку блоков Bitcoin. В отличие от платформ смарт-контрактов (таких как Ethereum), где комиссия рассчитывается на основании потраченных на выполнение контракта ресурсов, контракт в Bitcoin оплачивается строго в зависимости от его размера и, соответственно, экономически невыгодно создавать контракты с большим количеством условий, из которых использовано будет только одно.

В данном подразделе мы поговорим об одном из способов решения данных проблем – о концепции MAST и ее применении в протоколе Bitcoin. Концепция MAST подразумевает использование деревьев Меркла и абстрактных синтаксических деревьев, чтобы задавать условия траты монет на выходах транзакций. Рассмотрим по порядку, как это устроено.


### Абстрактные синтаксические деревья

Для начала ознакомимся с понятием абстрактное _синтаксическое дерево_ (abstract syntax tree, AST) [57]. Это дерево, которое представляет некоторый алгоритм. _Листьями_ таких деревьев являются операнды (переменные либо константные значения), а узлами – соответствующие операторы (инструкции либо функции). Синтаксические деревья в основном используются для упрощения оптимизации и анализа программного кода.

В качестве примера давайте приведем простую подпрограмму, целью которой является нахождение числа ближайшего к заданному, которое делится на 32 без остатка (для упрощения примера, предположим, что поиск осуществляется только в верхнюю сторону). Приведем псевдокод такой подпрограммы на рисунке 2.16.

![Рисунок 2.16 – Псевдокод программы нахождения числа, которое делится на 32](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.16-pseudocode-for-finding-number-divisible-by-32.png "Рисунок 2.16 – Псевдокод программы нахождения числа, которое делится на 32")

На рисунке 2.17 изображено синтаксическое дерево, которое описывает эту же подпрограмму. В дереве ромбом обозначены узлы, которые задают инструкции, овалом – переменные, а прямоугольником – константные значения. Ребра дерева определяют переходы между операциями.

![Рисунок 2.17 – Абстрактное синтаксическое дерево для программы](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.17-abstract-syntax-tree-for-program.png "Рисунок 2.17 – Абстрактное синтаксическое дерево для программы")

На вершине дерева находится инструкция "while". Это инструкция создания цикла, которая проверяет некоторые условия и, в зависимости от них, выполняет тело цикла (либо не выполняет). Условие в данном случае расположено в левой части дерева. Давайте рассмотрим его детальнее (рис. 2.18).

![Рисунок 2.18 – Представление условия программы](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.18-representation-of-program-conditions.png "Рисунок 2.18 – Представление условия программы")

Изначально переменная _А_ делится на константное значение 32. Инструкция "mod" возвращает нам остаток от деления. После этого выполняется инструкция "no equal", которая сравнивает два операнда и возвращает "true" в случае их неравенства. Операнды инструкции в этом случае – константное значение 0 и значение, которое возвращает оператор "mod".

Таким образом, после выполнений всех инструкций в этом поддереве, оператор "while" получает либо значение "false" – если _А_ делится на 32 без остатка, – либо значение "true" – если 32 не является делителем _A_. Если "while" получает "false", то цикл завершается. Если возвращается значение "true", то начинают выполняться инструкции в правом поддереве (рис. 2.19).

![Рисунок 2.19 – Представление инструкций программы](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.19-representation-of-program-instructions.png "Рисунок 2.19 – Представление инструкций программы")

В этом поддереве фактически происходит инкрементирование входного значения _А_. Сначала операция "add" слагает _А_ и 1, после чего операция "assign" выполняет присвоение результата переменной _А_. После того, как тело цикла выполняется, снова проверяется выполнение условия, как мы рассматривали ранее.

Итак, использование AST позволяет разбить программу на различные части и увидеть как эти части будут выполняться (и будут ли выполнены вообще) в зависимости от других условий. Эту особенность абстрактных синтаксических деревьев мы и будем использовать для построения MAST.


### Что же такое MAST?

Вторая составляющая концепции MAST – это использование деревьев Меркла. Так как мы уже рассматривали устройство деревьев Меркла, то не будем углубляться и объяснять детали повторно, просто еще раз напомним их ключевые преимущества: обеспечение возможности проверки целостности входящих в дерево данных и обеспечение аутентификации отдельного листа по Merkle branch, не разглашая содержимого остальных листьев дерева.

Теперь определим, что такое MAST и как эта концепция может применяться. MAST – это merklized abstract syntax tree, где применяются идеи дерева Меркла и абстрактного синтаксического дерева для задания взаимоисключающих условий траты монет [58]. При этом в качестве языка описания условий выступает, как обычно, Bitcoin Script.

Схематично merklized abstract syntax tree будет выглядеть так, как это представлено на рисунке 2.20.

![Figure 2.20 – Merklized abstract syntax tree (MAST)](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.20-merklized-abstract-syntax-tree.png "Figure 2.20 – Merklized abstract syntax tree (MAST)")

MAST Root является корневым хэш-значением, которое будет помещаться в выход транзакции. Овалом обозначены хэш-значения узлов дерева, которые ведут к условиям траты монет. Таким образом, поддеревья содержат взаимоисключающие условия, по которым монеты могут быть потрачены. Следовательно, тот, кто тратит монеты, будет использовать либо одно поддерево, либо другое.

Прямоугольником обозначены условия, которые задаются с помощью Bitcoin Script. Причем условия, по которым монеты будут потрачены вероятнее всего, рекомендуется помещать как можно ближе к корню дерева – это уменьшит размер доказательства владения монетами.

Чтобы доказать владение монетами по условиям конкретного поддерева, доказывающей стороне необходимо опубликовать скрипт используемого поддерева (как в случае P2SH), а также набор значений Merkle branch, которые необходимы для проверки факта, что используемое условие действительно находится среди альтернативных.


### Упрощенная схема MAST

Чтобы понять принцип функционирования MAST, давайте приведем следующий пример. Допустим, в общем сценарии задано два взаимоисключающих условия траты монет. В первом случае монеты можно потратить, предоставив одну подпись и дождавшись наступления определенного времени, а во втором – нужно предоставить несколько подписей (например 2-из-2) (рис. 2.21).

![Рисунок 2.21 – Альтернативные условия траты монет](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.21-alternative-coin-spending-conditions.png "Рисунок 2.21 – Альтернативные условия траты монет")

Пользователи могут прибегнуть к одному из вариантов, при этом MAST позволяет добиться того, что условия второго не будут разглашены. Мы можем преобразовать эти альтернативные условия в единое merklized abstract syntax tree, как на рисунке 2.22. То есть, фактически мы вычисляем хэш-значение каждого условия, после чего конкатенируем их и получаем MAST Root путем повторного хэширования полученного значения.

![Рисунок 2.22 – Представление условий в виде MAST-дерева](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.22-representation-of-conditions-in-MAST.png "Рисунок 2.22 – Представление условий в виде MAST-дерева")

Теперь мы можем доказать, что конкретное условие находилось в MAST дереве. Для этого доказывающей стороне нужно просто предоставить хэш-значение альтернативного условия в качестве Merkle branch (для условия с мультиподписью – это значение _H<sub>1</sub>_). Верификатор вычисляет хэш-значение от опубликованного условия, после чего, используя Merkle branch, вычисляет значение Merkle root и сравнивает его с имеющимся в выходе предыдущей транзакции.

Как мы упоминали ранее, MAST Root представляет собой 32-байтное значение, которое помещается в выход транзакции (рис. 2.23). Это гораздо меньше, по сравнению с размещением полного скрипта (167 байт).

![Рисунок 2.23 – Помещение в условия траты монет значения MAST Root вместо скрипта](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.23-putting-MAST-Root-values-instead-of-script.png "Рисунок 2.23 – Помещение в условия траты монет значения MAST Root вместо скрипта")

Теперь рассмотрим, как происходит трата монет, которые заблокированы на таком адресе. В случае стандартной (_pay to contract_) транзакции, нам необходимо было бы просто предоставить доказательства владения монетами: это либо значение открытого ключа и подписи (первое условие) – 129 байт, либо два значения подписи – 128 байт.

В случае использования P2SH подхода (в выходе предыдущей транзакции находится 32-байтное хэш-значение всего скрипта), доказательства содержат весь скрипт (167 байт), а также данные для его удовлетворения, что в сумме достигает около 300 байт.

MAST позволяет подать на вход транзакции условие, которое было выполнено (либо 30 байт, либо 134 байта), данные, которые удовлетворяют этим условиям, а также доказательство того, что условие является одним из альтернативных. Для этого к доказательствам добавляется Merkle branch (в нашем случае 32 байта – хэш-значение альтернативного условия).

Сравнительная характеристика использования стандартного, P2SH и MAST подходов представлена на рисунке 2.24.

![Рисунок 2.24 – Сравнительная характеристика подходов к заданию условий траты](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.24-comparison-of-approaches.png "Рисунок 2.24 – Сравнительная характеристика подходов к заданию условий траты")

Мы видим, что MAST значительно позволяет сократить объем данных, помещаемых в транзакцию в случае выполнения первого условия. Отличия при выполнении второго условия не выглядят так значительно, однако давайте рассмотрим, как увеличение контракта (увеличение альтернативных условий) влияют на размер скрипта.


### Преимущества и особенности MAST

В примере выше было представлено только два условия выполнения скрипта. Но давайте рассмотрим ситуацию, когда таких условий гораздо больше. В случае использования стандартного либо P2SH подхода объем данных скрипта будет сильно возрастать в зависимости от количества условий. Однако, при использовании MAST размер скрипта и размер Merkle branch будут возрастать не намного (максимум на 32 байта с каждым дополнительным условием). Более того, если правильно располагать условия в дереве, то можно очень сильно сэкономить и на значении Merkle branch. Давайте представим, что у нас есть 7 альтернативных условий, но при этом мы знаем, с какой вероятностью может быть использовано каждое из них (рис. 2.25).

![Рисунок 2.25 – Набор альтернативных условий траты с различными вероятностями выполнения](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.25-set-of-alternative-spending-conditions.png "Рисунок 2.25 – Набор альтернативных условий траты с различными вероятностями выполнения")

Соответственно, используя концепцию MAST, можно таким образом расположить эти условия в дереве, чтобы с высокой вероятностью заплатить как можно меньшую комиссию. Для этого необходимо условие А (которое может выполниться с большей вероятностью) поместить ближе к вершине дерева, а условия F и G – подальше (рис. 2.26).

![Рисунок 2.26 – MAST из альтернативных условий](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.26-MAST-with-many-alternative-conditions.png "Рисунок 2.26 – MAST из альтернативных условий")

В этом случае, если будет использовано условие А, то в доказательствах траты монет будет располагаться само условие А, доказательства, которые ему удовлетворяют, а также одно хэш-значение в качестве Merkle branch – _H<sub>BCDEFG</sub>_, размером в 32 байта. В наихудшем случае, то есть если будет использовано условие G (или F), доказательство владения монетами будет содержать соответствующий скрипт, удовлетворяющие ему данные и значение Merkle branch, которое включает в себя _H<sub>F</sub>_, _H<sub>E</sub>_, _H<sub>CD</sub>_, _H<sub>B</sub>_, и _H<sub>A</sub>_. Если мы предоставим сравнительную характеристику для этого сложного условия, то получим следующую картину (рис. 2.27, за средний размер одного условия бралось 100 байт, в качестве доказательств – 150 байт).

![Рисунок 2.27 – Сравнительная характеристика размеров условий в зависимости от способа их задания](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.27-comparison-of-size-of-conditions.png "Рисунок 2.27 – Сравнительная характеристика размеров условий в зависимости от способа их задания")

Давайте обратим внимание на оптимизацию объема данных, которые в итоге попадают в цепочку блоков. Внимательно посмотрите на график ниже. На вертикальной оси обозначен объем данных в байтах, при этом сама шкала логарифмическая. На горизонтальной оси отмечается количество альтернативных условий траты монет (рис. 2.28) [59].

![Рисунок 2.28 – График зависимости общего размера условия от количества альтернативных составных частей](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.28-graph-of-total-size-of-data-volume.png "Рисунок 2.28 – График зависимости общего размера условия от количества альтернативных составных частей")

Синей линией обозначена зависимость объема данных от количества условий без использования MAST. Красной линией обозначена зависимость объема данных от количества условий с использованием MAST. Голубая линия – это лимит размера Bitcoin Script для P2SH. Зеленая линия – это лимит размера Bitcoin Script в структуре witness.


### Применение MAST на практике

MAST можно применить для более оптимизированной реализации HTLC (Hashed Time-Lock Contracts), которые применяются в протоколе Lightning Network и для реализации Atomic Swap. Также концепция может быть применена для более оптимизированной реализации Escrow. MAST дает возможность реализовать очень большие конструкции с использованием multisignature.

Благодаря MAST во многих случаях можно отказаться от операции OP_RETURN для добавления хэш-значений данных в цепочку блоков. Вместо этого можно включать эти данные в дерево и при необходимости доказывать, что конкретные данные были зафиксированы в цепочке блоков Bitcoin. При чем такое добавление не повлияет на размер транзакции.


### Развитие концепции и текущее состояние

Развивать и продвигать идею MAST в сообществе Биткоина начали Рассел О’Коннор (Russell O'Connor), Питер Вейлле (Pieter Wuille), Питер Тодд (Peter Todd) и Джонсон Лау (Johnson Lau). В начале 2016-го года было опубликовано предложение по улучшению протокола Биткоин под номером 114 (BIP114), где была описана спецификация одного из вариантов реализации данного подхода с использованием witness programs, которые, в свою очередь, были введены с обновлением SegWit. BIP114 также предлагает программную реализацию, которая добавляет новые правила достижения консенсуса в протокол Биткоина.

Позже, в 2017-м году, предложили альтернативный вариант реализации концепции MAST, который описан в BIP117. Он основан на BIP114 и вносит некоторые модификации. По состоянию на 2018-й год оба предложения остаются на стадии рассмотрения.

Отметим, что MAST может быть интегрирован в Bitcoin с помощью softfork обновления протокола. И это тоже очень важная особенность данной концепции.


### \*\*\*Часто задаваемые вопросы\*\*\*

_– Будет ли MAST root задаваться в структуре witness или где он будет указан?_

MAST root вместе с данными, которые его определяют, будет указываться в ScriptPubKey на выходе транзакции. Эти данные будут занимать 25–35 Б и, скорее всего, будут легко кодироваться в привычный bitcoin-адрес. А в структуре witness, где доказывается владение монетами, будет указан Merkle branch, условия и данные, которые удовлетворяют этим условиям.

_– Будет ли расширено множество доступных OP_CODEs в языке Bitcoin Script?_

На данный момент еще не ясно, потому что предложение – на стадии рассмотрения и могут быть внесены дополнительные правки и улучшения. Вероятно, будет добавлен OP_CODE, такой как OP_MERKLEBRANCHVERIFY, для гибкости использования MAST. 

_– Вероятно ли внедрение MAST в Bitcoin в ближайшее время?_

Маловероятно. Это обновление важное, но не срочное, поэтому оно может подождать, пока разработчики работают над другими улучшениями протокола. Позже они смогут интегрировать сразу несколько улучшений в одном обновлении, как это было в случае SegWit.


## 2.3 Принципы функционирования Taproot

Подписи Шнорра предоставляют очень важную особенность – возможность агрегирования открытых ключей и значений подписи. Это, в свою очередь, приводит к повышению пропускной способности сети и повышению уровня приватности пользователей. Увеличение пропускной способности обеспечивается путем экономии места в транзакции за счет агрегации доказательств траты монет). Повышенный уровень приватности состоит в том, что для стороннего наблюдателя транзакция с одиночной подписью неотличима от транзакции, использующей мультиподпись.

Еще одна концепция, направленная на улучшение данных свойств, – MAST. Она позволяет избежать добавления неиспользованных условий траты монет в транзакцию, что также экономит место в цепочке блоков и не раскрывает альтернативных условий. Однако особенность концепции MAST – то, что остальные участники сети могут видеть, есть ли альтернативные условия траты монет (так как доказательство владения монетами содержат соответствующий Merkle branch). Сами условия не раскрываются, но раскрывается факт их наличия. Поэтому целью Taproot является создание и добавление в Bitcoin улучшения, которое позволит «маскировать» сложные контракты под обычные транзакции.

В этом подразделе мы рассмотрим, как подписи Шнорра могут использоваться для решения такой проблемы. Мы рассмотрим, что из себя представляет концепция с названием Taproot, как она улучшает свойство конфиденциальности условий контрактов и какие есть возможности для ее реализации в протоколе Bitcoin.


### Порядок применения альтернативных условий

В повседневной жизни третьи стороны (и договора) для решения конфликтов между субъектами нужны только если такие конфликты возникают [60]. Если же стороны договариваются между собой, то отсутствует необходимость в задействовании дополнительных инструментов. В этом смысле большинство условий траты монет ничем не отличается от повседневных решений разногласий. Наиболее интересные и используемые смарт-контракты построены таким образом, что один из альтернативных сценариев подразумевает распределение монет, если все стороны подпишут транзакцию (рис. 2.29).

![Рисунок 2.29 – Контракт, в котором одно условие подразумевает распределение монет в случае согласия всех сторон](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.29-contract-in-which-one-condition-involves-distribution-of-coins.png "Рисунок 2.29 – Контракт, в котором одно условие подразумевает распределение монет в случае согласия всех сторон")

На рисунке мы видим, что если будет использовано первое условие, то проверка оставшихся не нужна; об их существовании могут и не знать другие участники системы. MAST показал, каким образом мы можем экономить на размерах транзакции, публикуя только используемые условия (и сохраняя конфиденциальность остальных). Однако, повторим, что MAST скрывает условия, но не факт их наличия.

Попробуем еще сильнее расширить данную концепцию и разбить контракт на две составляющие: условие с мультиподписью и набор альтернативных условий, которые собраны в MAST (рис. 2.30).

![Рисунок 2.30 – Разбитие контракта на составляющие](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.30-contract-component-separation.png "Рисунок 2.30 – Разбитие контракта на составляющие")

Целью Taproot фактически является комбинирование этих двух альтернативных сценариев в однообразное условие траты монет, помещение в транзакцию которого не приведет к разглашению этих сценариев. Давайте рассмотрим, как для этого могут применяться подписи Шнорра.


### Подписи Шнорра как базовый элемент Taproot

Для того, чтобы разобраться, как работает отдельная технология, нужно разобрать простой и понятный пример, который ее использует. Поэтому представьте ситуацию, когда Алиса с Бобом хотят создать некоторый контракт с большим количеством сложных условий.

Каждый из участников владеет личным и открытым ключом. У Алисы есть личный ключ _a_ и открытый $A=aG$, у Боба личный ключ _b_ и открытый $B=bG$. Они решают заблокировать свои монеты на контракте со следующими условиями распределения: либо монеты могут быть потрачены по соглашению Алисы и Боба (мультиподпись), либо Евой по наступлению ее совершеннолетия (через 2 года). Альтернативные условия представлены на рисунке 2.31.

![Рисунок 2.31 – Наличие альтернативных условий в контракте](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.31-alternative-conditions-in-contract.png "Рисунок 2.31 – Наличие альтернативных условий в контракте")

Предположим, что Алиса и Боб способны использовать Taproot. Вместо публикации указанного выше условия, они делают следующее. Для начала Алиса с Бобом агрегируют значения своих открытых ключей. После этого они конкатенируют агрегированный открытый ключ с альтернативным условием и вычисляют хэш-значение результата. Полученное хэш-значение они умножают на базовую точку _G_, после чего полученный результат складывают с агрегированным ключом (рис. 2.32).

![Рисунок 2.32 – Создание Taproot сторонами](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.32-creating-Taproot-by-contracting-parties.png "Рисунок 2.32 – Создание Taproot сторонами")

Полученное в результате значение _P_ будет использоваться в качестве открытого ключа, за которым и будут заблокированы монеты. 

Представим, что в первом случае Алиса и Боб совместно решают потратить эти монеты. Для этого им нужно предоставить значение подписи, которое удовлетворит открытому ключу _P_. Каким образом они могут это сделать? Представим значение _P_ в следующем виде (рис. 2.33-А).

![Рисунок 2.33-А – Детальное представление открытого ключа](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.33-A-detailed-presentation-of-public-key.png "Рисунок 2.33-А – Детальное представление открытого ключа")

Чтобы соответствовать открытому ключу _P_, транзакция должна быть подписана при помощи подходящего личного ключа [60] (рис. 2.33-Б).

![Рисунок 2.33-Б – Соответствующее значение личного ключа](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.33-B-corresponding-value-of-private-key.png "Рисунок 2.33-Б – Соответствующее значение личного ключа")

Так как Алиса с Бобом знают собственные личные ключи, а также им известны альтернативные условия, то соответствующая подпись может быть вычислена следующим образом. Боб подписывает транзакцию при помощи собственного личного ключа, а Алиса добавляет к своему личному ключу хэш-значение альтернативного условия, после чего также подписывает транзакцию уже полученным значением. Далее стороны обмениваются полученными значениями подписей. Так как подписи Шнорра позволяют агрегировать значения подписи, то в доказательства владения монетами будет помещено единое значение подписи, которое соответствует единому значению агрегированного открытого ключа.

Однако что произойдет, если Алиса с Бобом совместно не тратят монеты? В этом случае, по истечении двух лет, Ева может получить доступ к монетам. Рассмотрим, каким образом это происходит.

Для доказательства владения монетами, Ева должна доказать, что знает корректное значение _AggKey_ и альтернативного условия, а также, предоставить данные, удовлетворяющие этому условию. Фактически ситуация схожа с P2SH подходом, за исключением того, что при верификации транзакции проверяется не соответствие условия заданному хэш-значению, а выполнение следующего равенства (рис. 2.33-В).

![Рисунок 2.33-В – Равенство, которое проверяется во время верификации транзакции](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.33-C-equation-inspected-during-transaction-verification.png "Рисунок 2.33-В – Равенство, которое проверяется во время верификации транзакции")

Если равенство выполняется, верификатор проверяет _Condition_. В нашем случае это проверка того, что прошло необходимое количество времени (2 года), и проверка подписи открытым ключом Евы.

> _Замечание. Важно, чтобы хэш-значение получалось из конкатенированных значений агрегированого ключа и условия траты   монет. Если бы использовалось хэш-значение только от альтернативного условия траты монет (рис. 2.34), то монеты могли бы быть похищены._
> 
> _Для этого злоумышленнику нужно было бы создать любое условие, которому он может выполнить, рассчитать хэш-значение от этого условия и умножить на базовую точку, после чего рассчитать значение агрегированного ключа как разницу P и полученного значения. Тогда бы для верификаторов данные агрегированного ключа и альтернативного условия были бы валидны._

![Рисунок 2.34 – Вычисление хэш-значения только от условий траты](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.34-calculation-of-hash-value-based-exclusively-on-spending-conditions.png "Рисунок 2.34 – Вычисление хэш-значения только от условий траты")

Таким образом, мы видим, что отсутствуют дополнительные расходы при задании условия траты монет при помощи Taproot. В случае, когда Алиса с Бобом договорились между собой и провели транзакцию, она ничем не отличается от обычной (P2PK либо же P2PKH). Однако, если монеты разблокированы Евой, то раскрывается альтернативное условие и соответственно сам факт использования Taproot.

Отметим, что альтернативное условие может являться не скриптом в явном виде (как это было в вышеописанном примере), а составлять большой набор альтернативных условий, которые сложены в MAST структуру. То есть давайте возьмем дерево с прошлого подраздела (с 7 альтернативными условиями) и посмотрим на него же, но уже с учетом использования Taproot (рис. 2.35).

![Рисунок 2.35 – Условие, которое задано при помощи Taproot и MAST](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.35-condition-defined-using-Taproot-and-MAST.png "Рисунок 2.35 – Условие, которое задано при помощи Taproot и MAST")

При использовании Taproot, мы можем добиться того, что выход транзакции, который это условие содержит, не будет отличаться от обычного выхода, который платит на одиночный ключ/адрес. Однако, это будет работать только при условии, что стороны договорятся между собой. Если же будет использоваться наименее вероятное условие, то необходимо будет предоставить Merkle branch, это альтернативное условие и данные, удовлетворяющие ему (рис. 2.36).

![Рисунок 2.36 – Сравнительная характеристика зависимости размера условий от способа их задания](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.36-comparison-of-dependence-of-conditions-size.png "Рисунок 2.36 – Сравнительная характеристика зависимости размера условий от способа их задания")


### Каскады Taproot-сценариев

Для построения деревьев сценариев могут быть использованы каскады с использованием Taproot. То есть альтернативная ветвь может содержать не MAST root, а другое значение открытого ключа, как при использовании классического Taproot [60]. В этом случае мы будем иметь дерево, изображенное на рисунке 2.37.

![Рисунок 2.37 – Каскад Taproot-сценариев](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.37-cascade-of-Taproot-scripts.png "Рисунок 2.37 – Каскад Taproot-сценариев")

В этом случае доказательство владения монетами ничем не отличается от подхода, использующего MAST. Если все стороны договариваются между собой и формируют подходящую подпись для уровня 0, то в этом случае альтернативные условия не раскрываются. Если же пользователи формируют подходящую подпись для уровня 1 или ниже, то в этом случае не раскрываются условия, которые находятся ниже в дереве, но при этом нужно доказать, что значение открытого ключа для данного уровня входит в общее дерево условий.

При использовании каскадов Taproot нельзя добиться гораздо большей эффективности и конфиденциальности по сравнению с MAST, но в следующем разделе мы опишем схему, которая позволяет использовать различные ветви (сценарии) и при этом не разглашать даже факт наличия альтернативных ветвей.

### \*\*\*Часто задаваемые вопросы\*\*\*

_– Когда Taproot может быть внедрен в Bitcoin?_

Криптографам и разработчикам потребуется несколько месяцев на представление отзывов на предложение. После этого период тестирования в Bitcoin testnet продлится 2–3 месяца. При благоприятных обстоятельствах softfork с добавлением Taproot может случиться в конце 2021 года.


## 2.4 Устройство Graftroot

В предыдущем подразделе мы рассмотрели, каким образом Taproot позволяет замаскировать сложный смарт-контракт под обычную транзакцию, и при этом не раскрывать его, если стороны договорились и потратили монеты с помощью мультиподписи. Однако у Taproot есть одно серьезное ограничение: он позволяет задавать только одно условие, использование которого не раскроет факт использования Taproot и присутствие альтернативных условий.

В этом подразделе мы рассмотрим концепцию под названием Graftroot, которую предложил Грегори Максвелл (Gregory Maxwell), а также то, какие проблемы она решает и какие требования необходимо учитывать для ее реализации.


### Отдельная подпись каждого альтернативного условия

Graftroot, также как и Taproot, строится на предположении о том, что каждый контракт (насколько бы он не был сложным), предполагает распределение монет в случае, если стороны договорятся между собой (совместно подпишут транзакцию). Однако, в отличие от Taproot, Graftroot позволяет скрывать количество альтернативных условий, а также добавлять новые после создания транзакции [60].

В концепции Taproot все альтернативные условия учитываются при вычислении открытого ключа, за которым закреплены монеты. Отличием же Graftroot является то, что при помощи агрегированного ключа будут отдельно подписаны все альтернативные условия траты монет.

Рассмотрим пример из предыдущего подраздела, в котором Алиса с Бобом решили заблокировать монеты на совместном адресе и предоставить к ним доступ либо при помощи мультиподписи, либо Евой по истечении двух лет (рис. 2.38).

![Рисунок 2.38 – Альтернативные условия траты монет](/resources/img/volume-3/2.4-Graftroot-design/F-2.38-alternative-conditions-for-spending.png "Рисунок 2.38 – Альтернативные условия траты монет")

Как и в предыдущем примере, стороны формируют общий открытый ключ, агрегируя значения собственных открытых ключей. Также они создают альтернативное условие (в котором монеты могут быть потрачены Евой), после чего совместно подписывают его и отдают самой Еве. Вслед за этим, Алиса и Боб формируют транзакцию, в которой просто блокируют монеты за агрегированным значением открытого ключа (рис. 2.39).

![Рисунок 2.39 – Формирование транзакции с блокировкой монет за конкретным ключом](/resources/img/volume-3/2.4-Graftroot-design/F-2.39-locking-coins.png "Рисунок 2.39 – Формирование транзакции с блокировкой монет за конкретным ключом")

Как в этом случае монеты могут быть потрачены? В первом случае Алиса и Боб совместно договариваются потратить монеты. Все, что им нужно для этого сделать, это совместно подписать следующую транзакцию. Верификатор проверяет, что значение подписи соответствует агрегированному значению открытого ключа, и, если значение подписи валидно, – монеты могут быть потрачены (рис. 2.40).

![Рисунок 2.40 – Трата монет с использованием мультиподписи](/resources/img/volume-3/2.4-Graftroot-design/F-2.40-spending-with-multisignature.png "Рисунок 2.40 – Трата монет с использованием мультиподписи")

Однако, давайте представим, что за 2 года Алиса и Боб не потратили монеты и их хочет потратить Ева. В этом случае она предоставляет подписанное значение скрипта (альтернативного условия), а также доказательства владения монетами (подпись Евы). Верификатор сначала проверяет подпись скрипта. Напоминаем, что данный скрипт был подписан Алисой и Бобом при помощи мультиподписи, а значит, открытый ключ для проверки подписи – агрегированное значение их открытых ключей (оно находится в условиях траты монет). Если подпись правильная, то верификатор убеждается, что альтернативное условие было действительно подписано Алисой и Бобом, и что они согласны с его содержимым (рис. 2.41).

![Рисунок 2.41 – Предоставление Евой скрипта для разблокировки монет](/resources/img/volume-3/2.4-Graftroot-design/F-2.41-script-to-unlock-coins.png "Рисунок 2.41 – Предоставление Евой скрипта для разблокировки монет")

После этого уже проверяется выполнение условия скрипта. В данном случае верификатор проверяет, что время разблокировки было достигнуто, а также, что транзакция подписана действительно Евой. Если все проверки прошли – монеты могут быть потрачены.

В результате мы видим, что в случае, если все стороны договариваются между собой, то они могут сформировать транзакцию, которая ничем не отличается от обычной (платит на один ключ/адрес). Однако, в случае, если используется альтернативное условие, то раскрываются детали только этого условия, а все остальные остаются конфиденциальными. Важной особенность Graftroot является независимость размера доказательств от количества альтернативных условий (рис. 2.42) [60].

![Рисунок 2.42 – Формирование альтернативных условий для разблокировки](/resources/img/volume-3/2.4-Graftroot-design/F-2.42-alternative-conditions-for-unlocking.png "Рисунок 2.42 – Формирование альтернативных условий для разблокировки")


### Возможность добавление новых условий

Еще одной очень важной особенностью Graftroot является отсутствие необходимости изначально определять все возможные сценарии для траты монет. Пользователи, которые участвовали в формировании агрегированного значения открытого ключа, могут в любой момент времени создать и подписать новый сценарий траты монет. Требованием при этом является только необходимость подписи скрипта всеми участниками транзакции [60].

Например, представьте ситуацию, что Алиса и Боб заблокировали свои монеты на MultiSig-адресе без каких-либо изначальных альтернативных условий. Через некоторое время они поссорились и ни одна из сторон не согласилась уступать даже часть монет с этого адреса другой стороне. Ева предлагает им решить ситуацию мирным путем и отдать все средства ей, чтобы они не достались ни Алисе, ни Бобу. Они соглашаются с этим и совместно формируют новое условие, согласно которому монеты могут быть потрачены Евой. Для этого им не нужно формировать новую транзакцию, а просто нужно совместно подписать необходимый скрипт и передать его Еве (рис. 2.43).

![Рисунок 2.43 – Формирование нового альтернативного условия](/resources/img/volume-3/2.4-Graftroot-design/F-2.43-new-alternative-condition-after-transaction-confirmation.png "Рисунок 2.43 – Формирование нового альтернативного условия")

После получения этого скрипта и подписи, Ева в любой момент может сформировать транзакцию, которая тратит эти монеты.

Преимущества Graftroot в следующем. В случае, если все стороны договорятся, то такая транзакция ничем не будет отличаться от обычной P2PK транзакции. В случае же, если необходимо исполнить другое условие для получения монет, то в итоге будет видно что исполнилось условие, но будет отсутствовать информация о других условиях и их количестве, так как размер доказательств не зависит от количества альтернативных сценариев (в отличие от использования MAST и Taproot).

Важным моментом при использовании Graftroot отметим необходимость хранения подписей альтернативных условий заинтересованными сторонами. В случае потери такой подписи, альтернативное условие не может быть выполнено (подпись может быть восстановлена только сторонами, открытые ключи которых использовались для получения агрегированного значения).

При этом стоит отметить особенности удаления альтернативных условий (которые схожи с изменением условий траты монет в случае использовании обычной multisig транзакции). После того, как альтернативные скрипты подписаны и отправлены, они могут быть отменены только за счет изменения агрегированного значения.

То есть, если Алиса и Боб уже отправили подписанный скрипт Еве, но после этого передумали, то единственный способ спасти монеты – первыми сформировать и подтвердить транзакцию, которая платит на новое агрегированное значение ключа (Алиса и Боб генерируют новые ключевые пары, формируют новый агрегированный открытый ключ и на него отправляют монеты) (рис. 2.44).

![Рисунок 2.44 – Изменение значения открытого ключа, за которым закреплены монеты](/resources/img/volume-3/2.4-Graftroot-design/F-2.44-changing-value-of-public-key.png "Рисунок 2.44 – Изменение значения открытого ключа, за которым закреплены монеты")

В этом случае Ева уже не сможет потратить монеты, так как созданная ею транзакция будет являться конфликтующей и не будет подтверждена валидаторами.

### \*\*\*Часто задаваемые вопросы\*\*\*

_– Есть ли смысл добавлять в Биткоин одновременно механизмы MAST, Taproot и Graftroot или лучше реализовать только один из них?_

На самом деле имеет смысл добавлять все эти механизмы, так как они имеют различную архитектуру и свойства. Но при этом не все из них могут использоваться в совокупности. Например, использование Taproot вместе с MAST является очень удобным решением (в разделе 2.3 мы рассмотрели, как это работает). Однако, не имеет смысла использовать MAST в совокупности с Graftroot, так как последний позволяет устанавливать неограниченное количество различных условий, причем даже после подписания транзакции. Это и является некоторым ограничением протокола – сторона, которой делегировали скрипт, не может быть уверена, что не будет создан новый скрипт траты монет.

Поэтому если необходима гибкость при задании условий – хорошей идеей является использование Graftroot. Если же важно обеспечить необратимость условий – стоит использовать Taproot (возможно, в совокупности с MAST, если существует несколько альтернатив).

# [3 ПРИМЕНЕНИЕ КОНЦЕПЦИЙ ШАРДИНГА, OFF-CHAIN, И DAG](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ru/3-Applying-the-concepts-of-sharding-off-chain-and-DAG.md)
