# [2 ПОДПИСИ ШНОРРА И СВЯЗАННЫЕ С НИМИ ОБНОВЛЕНИЯ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ru/2-Schnorr-signatures-and-their-application.md)

# 3 ПРИМЕНЕНИЕ КОНЦЕПЦИЙ ШАРДИНГА, OFF-CHAIN, И DAG

Одной из самых сложных задач при построении учетной системы является обеспечение возможности ее масштабирования. Под масштабируемостью системы следует понимать способность системы обрабатывать больший объем данных (запросов, транзакций, состояний аккаунтов) при увеличении количества ее серверов (узлов-аудиторов, валидаторов). В контексте учетной системы, использующей технологию blockchain, ее масштабируемость можно оценить тремя метриками: пропускная способность, время подтверждения блока и требования к аппаратному и программному обеспечению узлов.

В зависимости от архитектуры системы, увеличение нагрузки и количества валидаторов может привести к ряду следующих проблем.

> * _Неспособность системы обрабатывать весь поток транзакций_
> * _Увеличение объемов памяти, необходимых для хранения истории_
> * _Увеличение времени подтверждения транзакций_
> * _Повышение комиссий_

Итак, первая проблема связана с пропускной способностью системы. Пропускная способность любой учетной системы ограничена (не верьте, если владелец системы утверждает обратное ‒ у любой системы есть пороговая нагрузка, которую она преодолеть не сможет). В случае децентрализованной учетной системы пропускная способность зависит от времени достижения консенсуса между валидаторами и количества событий (например транзакций), относительно которых консенсус будет достигнут.

Разные системы имеют различную максимальную пропускную способность: Bitcoin – 3-7 транзакций в секунду, EOS и Bitshares – до нескольких тысяч. Однако в любом случае, если нагрузка будет превышать допустимое значение, то часть транзакций система просто не сможет обработать.

Учетным системам, использующим технологию блокчейн, необходимо хранить всю историю транзакций для обеспечения целостности конечного состояния реестра. Следовательно, история транзакций может только возрастать в своем объеме. И чем больше транзакций система способна обработать за единицу времени, тем быстрее будет увеличиваться база данных и требования к оборудованию для поддержания системы. Это означает, что со временем в системе уменьшается количество узлов, которые могут хранить полную историю транзакций, что, в свою очередь, влияет на степень децентрализации и отказоустойчивости системы в целом.

От количества валидаторов зависит уровень децентрализации системы. В случае использования PoW и PoS в качестве алгоритмов достижения консенсуса, увеличение количества валидаторов не влияет на время достижения консенсуса (но за счет специфики протоколов не обеспечивается неизменяемость истории). Однако, при использовании алгоритмов, построенных на основе BFT (которые подразумевают неотменяемость конечного состояния системы), увеличение количества валидаторов влияет на время достижения консенсуса и, в свою очередь, на пропускную способность сети.


## 3.1 Использование off-chain протоколов

Оff-chain протоколы масштабируемости учетных систем начали развиваться с появлением платежных каналов и Lightning Network [62]. Напомним, что off-chain протоколы являются протоколами второго уровня, работающими поверх конкретной учетной системы (нескольких систем). Фактически такие предложения не подразумевают изменения базового протокола учетной системы, но при этом позволяют перенести взаимодействие пользователей за границы основной цепочки блоков, сохраняя свойства основного протокола.

Основная суть off-chain протоколов состоит в блокировании пользователями монет в основной цепочке и обмене между собой транзакциями, которые могут изменить выходное распределение монет. В некотором смысле меняется подход к достижению консенсуса: после блокировки средств в канале, достигается уже не глобальный консенсус относительно обновления состояния всей учетной системы, а только между участниками канала непосредственно (рис. 3.1). Причем математика, которая лежит в основе off-chain взаимодействия, не позволяет мошенничать обоим контрагентам.

![Рисунок 3.1 – Процесс достижения консенсуса в основной сети и в платежных каналах](/resources/img/volume-3/3.1-Using-off-chain-protocols/F-3.1-reaching-consensus-in-accounting-system-and-in-payment-channels.png "Рисунок 3.1 – Процесс достижения консенсуса в основной сети и в платежных каналах")

К протоколам, которые используют схожие идеи, можно отнести следующие:

> * _Lightning Network_
> * _Plasma_
> * _Celer Network_
> * _Raiden Network_
> * _Trinity_
> * _Interledger_
> * _GEO Protocol_

Напомним, что Lightning Network является протоколом, который уже функционирует поверх Bitcoin, и может функционировать поверх схожих с Bitcoin протоколов. Lightning Network использует механизм коммутации двунаправленных каналов и позволяет сформировать trustless систему для быстрых переводов в рамках этих каналов (время обработки транзакций зависит только от задержек на обработку и передачу данных между участниками). Детальный принцип работы LN и его свойства мы рассматривали во 2-й части учебного пособия.

Основная идея Plasma состоит в использовании сайдчейнов для повышения пропускной способности сети Ethereum [63]. Фактически Plasma использует структуру из большого количества цепочек блоков, связанных в деревья, и состояние каждой дочерней цепочки зафиксировано в состоянии родительской, вплоть до основной цепочки блоков (рис. 3.2). Каждая из дочерних цепочек может иметь собственный механизм достижения консенсуса и метод связи с родительской цепочкой. 

![Рисунок 3.2 – Архитектура протокола Plasma](/resources/img/volume-3/3.1-Using-off-chain-protocols/F-3.2-Plasma-protocol-architecture.png "Рисунок 3.2 – Архитектура протокола Plasma")

> _Замечание. Еще одним из представителей off-chain протоколов является GEO protocol [64]. GEO представляет собой децентрализованную одноранговую сеть, которая позволяет ее участникам учитывать активы между собой, включая обмен активов из различных учетных систем. Протокол использует только платежные каналы и каналы доверия между узлами (вес доверия определяется независимо от пользователей друг к другу). В GEO protocol консенсус достигается только между вовлеченными в конкретную транзакцию сторонами. В то же время у них нет никакой информации о состоянии остальной сети. Также отсутствует глобальный реестр для активов, которые представлены в сети, и нет единого источника информации про сеть._


## 3.2 Концепция шардинга

Изначально концепция _шардинг (sharding)_, либо _сегментирование_, применялась по отношению к базам данных [65]. Этот процесс подразумевал под собой разделение большой базы данных на непересекающиеся _шарды (shards)_, или _сегменты_, с обеспечением более быстрого доступа к каждому отдельному сегменту и простотой управления им. Важной особенностью является непересекаемость наборов данных сегментов (отсутствие в шардах повторений).

Различают вертикальный и горизонтальный типы шардинга. _Вертикальный шардинг_ состоит в выделении некоторых таблиц из базы данных и перенос их на другие сервера (рис. 3.3) [66]. В этом случае запросы к разным таблицам будут обрабатываться разными серверами базы данных, что может увеличить пропускную способность системы в целом. Но при этом очень важно обеспечить резервирование (репликацию) отдельных шардов для повышения отказоустойчивости системы, так как ограничение доступа к одному из шардов может критически повлиять на работу с остальными шардами.

![Рисунок 3.3 – Процесс вертикального шардирования](/resources/img/volume-3/3.2-Sharding-concept/F-3.3-vertical-sharding.png "Рисунок 3.3 – Процесс вертикального шардирования")

_Горизонтальный шардинг_ подразумевает разбиение единой таблицы на составляющие, согласно общим признакам (причем заранее определенным) (рис. 3.4) [67]. При этом деление совершается по следующему принципу:

> * _Каждый шард имеет такую же структуру, что и изначальная таблица_
> * _Разделение выполняется на основании определенных атрибутов элементов_
> * _При обращении к системе она определяет к какому шарду следует обратиться_

![Рисунок 3.4 – Процесс горизонтального шардирования](/resources/img/volume-3/3.2-Sharding-concept/F-3.4-horizontal-sharding.png "Рисунок 3.4 – Процесс горизонтального шардирования")

Преимущество горизонтального шардинга также состоит в возможности распределения обработки различных частей базы данных отдельными серверами (или группами серверов), что влияет на увеличение пропускной способности системы. Однако наряду с преимуществами, которые данный подход предоставляет, в классическом варианте он имеет набор ограничений [66]:

> * _Сложность при составлении выборок элементов, их поиске и фильтрации_
> * _Перебалансировка (перераспределение) данных в таблицах_
> * _Повышенные требования к репликации шардов_

Первое ограничение состоит в сложности составления общей выборки элементов по шардам. Например, если мы хотим получить несколько записей, которые были добавлены последними, то это достаточно сложно сделать, так как записи добавляются в различные шарды, каждый из которых ведет собственный учет. Также усложняются процедуры поиска и фильтрации данных по шардам (если речь конечно идет не о тех признаках, по которым эти шарды были разбиты).

> _Замечание. Представим пример, когда таблица разбита на 5 шардов и мы хотим сделать выборку из последних 100 элементов, которые были добавлены в общую базу. В этом случае очень просто определить 100 последних элементов для каждого шарда по отдельности, но так как каждый шард ведет собственный учет, то выбрать 100 общих элементов достаточно сложно (нужно проводить поэлементное сравнение). Более того, элементы распределяются по шардам не совсем равномерно, поэтому мы не можем выбрать 20 последних элементов из каждого шарда для получения описанной выборки._

Вторым важным моментом является перебалансировка данных в случае появления дополнительных шардов. Правила шардинга должны быть заданы еще до процесса разделения таблицы как такового. Если архитектура шардинга не продумана, то это может привести к потере некоторых данных либо повреждению таблиц. В лучшем случае может возникнуть ситуация, когда необходимо будет анализировать все имеющиеся шарды для добавления нового.

При увеличении шардов также увеличивается вероятность отказа одного из них. Если они расположены на различных серверах/узлах, то каждый из хранителей сегментов должен обеспечить репликацию (резервирование) отдельного шарда.


### Шардинг в системах на основе blockchain

В системах на основе blockchain шардинг состоит в разбиении системы на более мелкие компоненты, каждый из которых занимается обработкой отдельного (непересекающегося с остальными) набора транзакций и хранит информацию относящуюся к его шарду (транзакции и состояния аккаунтов).

Каждый такой сегмент состоит из относительно небольшого подмножества валидаторов, которые достигают консенсуса относительно своего шарда. За счет того, что количество шардов растет пропорционально увеличению нагрузки на учетную систему, это позволяет справляться с потоком транзакций и поддерживать время их подтверждения в допустимых пределах.

То есть, вместо одной единой цепочки блоков, мы разделяем историю на несколько цепочек, каждая из которых является шардом (рис. 3.5) [68].

![Рисунок 3.5 – Разбиение учетной системы на шарды](/resources/img/volume-3/3.2-Sharding-concept/F-3.5-dividing-into-shards.png "Рисунок 3.5 – Разбиение учетной системы на шарды")

Каждый шард, в свою очередь, имеет свой собственный набор валидаторов, которые достигают консенсуса относительно обновления его состояния. Однако, при этом возникает ряд задач, которые необходимо решить при использовании шардинга в учетной системе.

> * _Обеспечение высокого уровня защищенности отдельного шарда_
> * _Распределение валидаторов между шардами_
> * _Обеспечение доступности данных_
> * _Подтверждение транзакций, относящихся к нескольким шардам_

Здесь мы видим первое ограничение, которое связано с меньшей степенью защищенности шардов по сравнению с единой цепочкой, над которой работают все валидаторы. Например, если мы представим ситуацию, когда консенсус в сети достигается при помощи PoW, то разбиение на шарды повлечет за собой пропорциональное уменьшение вычислительной мощности в отдельных шардах (рис. 3.6). Это сильно упрощает проведение атаки 51% [69].

![Рисунок 3.6 – Снижение защищенности отдельного шарда по сравнению с единой цепочкой](/resources/img/volume-3/3.2-Sharding-concept/F-3.6-reduced-security-of-individual-shard.png "Рисунок 3.6 – Снижение защищенности отдельного шарда по сравнению с единой цепочкой")

Вторая задача связана с решением вопроса, кто из валидаторов и над каким шардом работает. Абзацем ранее мы упоминали атаку 51%, предполагая, что мощности валидаторов распределяются равномерно между шардами. Если же валидаторы сами выбирают, над каким сегментом системы им работать, это может привести к ухудшению ситуации и большему количеству атак. Следовательно, в системе должен присутствовать механизм распределения валидаторов среди шардов, относительно которых они будут достигать согласия.

Третья задача связана с доступом к данным между шардами. Фактически, узлы-валидаторы отдельного шарда создают собственную цепочку блоков, которая содержит транзакции, влияющие на изменение локального состояния шарда. Однако существует ряд случаев, когда для принятия решений валидаторам необходимо получить информацию из другого шарда.

Если транзакция с платежом затрагивает аккаунты, находящиеся внутри одного шарда, то в этом случае не возникает никаких проблем: эта транзакция обрабатывается валидаторами данного шарда. Однако необходимо обеспечивать совместимость на этапе, когда транзакция касается аккаунтов, учет которых ведется в различных шардах: ведь если шарды не могут «общаться между собой», то они ничем не отличаются от двух независимых учетных систем, каждая из которых ведет собственную историю событий.


### Архитектура TON

Одним из самых ярких представителей платформ, использующих в своей архитектуре технологию шардинга, является TON (telegram open network) [70]. Технология подразумевает возможность разделения единой системы на 2<sup>92</sup> подсистем, которые функционируют независимо и тем не менее умеют общаться между собой. В данном разделе мы рассмотрим основные механизмы, которые легли в построение сети TON, а также разберемся, действительно ли использование шардинга может решить проблемы масштабируемости, которым подвержено большинство современных учетных систем.

Telegram open network содержит большое количество компонентов.

> * _Учетная система_
> * _Распределенное файловое хранилище_
> * _Инструменты анонимизации сети_
> * _DHT_ 
> * _DNS_
> * _Набор инструментов для функционирования платежных каналов и связи с другими учетными системами_

Основным компонентом (ядром) TON является учетная система. Остальные компоненты являются вспомогательными и позволяют расширить функциональность платформы.


### _Устройство цепочки блоков в TON_

В отличие от традиционной цепочки блоков, которая используется во многих системах, TON предлагает использование многоуровневой архитектуры. Для этого предусмотрено несколько типов цепочек блоков:

> * _Masterchain_
> * _Workchain_
> * _Shardchain_

_Masterchain_ является единой корневой цепочкой, которая используется для хранения состояния всех дочерних цепочек. Masterchain хранит информацию о текущей версии и параметрах протокола TON, о текущем наборе валидаторов и размере их стейка, о наборе текущих активных workchains и shardchains, а также хэш-значения актуальных блоков этих цепочек. Для достижения консенсуса в masterchain используется алгоритм PoS [70].

Masterchain разбивается на _workchains_ – дочерние системы, максимальное количество которых может равняться 2<sup>32</sup> (рис. 3.7). Каждый workchain является подсистемой, которая имеет собственный протокол учета, собственный формат аккаунтов, транзакций, собственную виртуальную машину для выполнения контрактов, собственную внутреннюю валюту, и т. д. В каждом workchain выполняется учет только относящихся к нему аккаунтов, поэтому его можно представить как отдельную учетную систему. При этом к каждой такой системе выдвигается ряд требований для возможности коммуникации с другими workchains и masterchain (подробнее эти требования мы рассмотрим далее).

![Рисунок 3.7 – Разбиение masterchain на workchains](/resources/img/volume-3/3.2-Sharding-concept/F-3.7-dividing-into-workchains.png "Рисунок 3.7 – Разбиение masterchain на workchains")

Workchains, в свою очередь, могут разделяться на _shardchains_. Каждый shardchain имеет такую же архитектуру, как и родительский workchain, но при этом он обрабатывает только определенное подмножество аккаунтов. Максимальное количество shardchains в одном workchain может достигать 2<sup>60</sup>.

> _Замечание. На самом деле workchain является абстрактным понятием – это просто набор shardchains, которые единообразно функционируют по заранее заданным правилам. Если объяснить это на более простом примере, представьте таблицу, разделенную на шарды. Каждый отдельный шард является независимой таблицей, а глобальное состояние – это набор таких таблиц-шардов. Единственный случай, при котором workchain можно представить в виде единой структуры данных – когда этот workchain состоит из одного единственного shardchain._

У каждого workchain есть собственный 32-битный идентификатор (_workchain_id_). Для создания workchain создается соответствующая транзакция, которая должна быть подтверждена в masterchain. По умолчанию с момента инициализации TON поддерживает Workchain Zero (_workchain_id_ = 0). Этот workchain предназначен для работы с TON-контрактами, а также для передачи базовой валюты (gram).

Shardchain, в свою очередь, идентифицируется с использованием пары значений: _workchain_id_ – идентификатор родительского workchain и _shard_prefix_ – значение от 1 до 2<sup>60</sup>, которое определяет пространство аккаунтов, которые будут обрабатываться данным shardchain.


### Разделение и объединение shardchains

Существует два типа разделения workchain на shardchains: _статическое_ и _динамическое_. _Статическое разделение_ предусматривает изначальное определение количества возможных shardchains по определенным признакам. Например, мы хотим разделить систему на 8 шардов – для каждого из них задаем подмножество аккаунтов, которые будут обрабатываться (рис. 3.8).

![Рисунок 3.8 – Статическое разделение на shardchains](/resources/img/volume-3/3.2-Sharding-concept/F-3.8-static-splitting-into-shardchains.png "Рисунок 3.8 – Статическое разделение на shardchains")

Это самый простой способ шардинга, однако он не самый эффективный. Неэффективность такого подхода заключается в том, что нужно заранее сделать предположения касательно нагрузки на систему. Если пользователь создаст небольшое количество shardchains, то при большой нагрузке на систему не все из них смогут обрабатывать относящиеся к ним транзакции. Если же наоборот, задано слишком большое количество shardchains, то в каждом из них по отдельности транзакции будут появляться очень редко, что приведет к дополнительным тратам на поддержание системы.

Динамическое сегментирование позволяет заранее не определять необходимое количество шардов, а разделять/объединять shardchains в режиме реального времени. Эта особенность подразумевает, что каждый отдельный шард может в любой момент времени быть автоматически разделен, если его пропускной способности недостаточно (рис. 3.9). При создании нового workchain TON предполагает изначальное создание одного shardchain, который в дальнейшем может делиться в зависимости от нагрузки.

![Рисунок 3.9 – Принципы динамического шардирования](/resources/img/volume-3/3.2-Sharding-concept/F-3.9-principles-of-dynamic-sharding.png "Рисунок 3.9 – Принципы динамического шардирования")


### Принятие решений относительно состояния системы

Ранее мы упоминали, что каждый блок masterchain хранит в себе актуальные, на момент его формирования, хэш-значения блоков всех shardchains сети. Как только хэш-значение блока shardchain будет включено в блок masterchain, то этот блок считается подтвержденным в системе и на него могут ссылаться последующие блоки.

Каждый новый блок в shardchain также в свою очередь содержит последнее значение блока в masterchain, которые подтверждает все ранее созданные shardchain блоки. Такая связь между masterchain и shardchains нужна для того, чтобы shardchains могли ориентироваться на состояния друг друга (рис. 3.10). Фактически, masterchain необходим для синхронизации всех дочерних shardchains (и, соответственно, workchains) и определения глобального состояния системы.

![Рисунок 3.10 – Связь между masterchain и shardchains](/resources/img/volume-3/3.2-Sharding-concept/F-3.10-relation-between-masterchain-and-shardchains.png "Рисунок 3.10 – Связь между masterchain и shardchains")

> _Замечание. Предполагается, что валидаторами платформы TON будут несколько сотен участников, обладающих наибольшими stakes. Все валидаторы псевдослучайным образом разбиваются на подмножества, каждое их которых на протяжении некоторого времени выполняет валидацию блоков в границах отдельного shardchain (каждый валидатор может быть выбран в несколько подмножеств). Достижение консенсуса выполняется при помощи алгоритма BFT. Если один из валидаторов подписывает невалидный блок, то он может быть оштрафован – потерять свой стейк (или часть его), а также быть исключен из набора валидаторов._

После того как все новые блоки в шардах были сгенерированы (либо прошло время выделенное для их генерации), генерируется новый masterchain блок, который содержит в себе хэш-значение блоков shardchains. Консенсус относительно добавления нового блока в masterchain достигается за счет использования BFT протокола среди всех валидаторов.


### Обмен сообщениями между shardchains

Повторим, что обязательным требованием к учетной системе, которая поддерживает шардинг, является возможность шардов отправлять сообщения друг другу. Существует два подхода к построению такого взаимодействия: _асинхронные_ транзакции и _атомарные_ [68].

Давайте разберемся, в чем суть асинхронных транзакций между шардами на примере перевода монет между аккаунтами. Представим, что Алиса хочет передать Бобу 100 монет, причем их аккаунты находятся в различных шардах. В этом случае, в шарде, отвечающем за начисление средств Бобу, валидаторы подтвердят транзакцию только после того, как у них будет достаточно доказательств того, что подтверждена связанная транзакция в шарде Алисы, отвечающем за вычитание средств у нее. Рассмотрим детальнее взаимодействие пользователей на рисунке 3.11.

![Рисунок 3.11 – Проведение асинхронных транзакций](/resources/img/volume-3/3.2-Sharding-concept/F-3.11-conducting-asynchronous-transactions.png "Рисунок 3.11 – Проведение асинхронных транзакций")

1. Алиса отправляет транзакцию в шард А, которая вычитает с ее аккаунта 100 монет.
2. Валидаторы шарда А подтверждают транзакцию. Алиса получает соответствующее доказательство (например, путь аутентификации в дереве Меркла для этой транзакции).
3. Алиса отправляет другую транзакцию в шард B, которая содержит доказательство подтверждения предыдущей транзакции.
4. Валидаторы проверяют доказательства и подтверждают транзакцию в шарде B.

Однако, такой подход не является совершенным и не может применяться в любых учетных системах. Одной из причин является то, что пользователь не может быть уверен в том, что после подтверждения транзакции в одном из шардов, соответствующее подтверждение выполнится и в другом. Более того, если шарды могут ветвиться (по правилам протокола), то ситуация, при которой подтверждение выполнится только в одном из шардов гораздо более вероятна.

> _Замечание. В TON общая форма отправляемого сообщения зависит от шарда-получателя и от аккаунта (или контракта) получателя, однако сообщение обязательно должно поддерживать общие поля, которые позволят совершать такую отправку между workchains._
> 
> _Каждое сообщение содержит идентификаторы аккаунтов отправителя и получателя. Идентификатор аккаунта в этом случае представляется двумя значениями: workchain_id (для определения какому workchain принадлежит аккаунт) и account_id (в базовом случае 256-битовое значение, которое идентифицирует аккаунт внутри workchain)._
> 
> _Идентификаторы аккаунтов могут отличаться в различных workchain. Единственное требование, которое выдвигается – длина идентификатора не должна быть короче 64 бит (необходимо для шардинга)_
> 
> _Некоторые сообщения могут не иметь отправителя либо получателя (обязательным является присутствие как минимум одного). Такие сообщения используются для коммуникации с внешними системами и приложениями. Сообщение, которое не содержит отправителя, напрямую включается в соответствующий shardchain (в случае если оно корректно). Комиссия за добавление этого сообщения будет взиматься с аккаунта-получателя. Сообщение, которое не содержит получателя, добавляется в shardchain его отправителя. Но при этом нельзя гарантировать, что это сообщение было получено внешней системой._


## 3.3 Конструкция и применение DAG

С развитием технологии blockchain многие пытались усовершенствовать различные аспекты учетных систем, построенных на ее основе, но суть оставалась неизменной – в основе системы всегда лежит единая цепочка блоков, а сами блоки добавляются по одному за раз.

Во многом DAG-based системы очень похожи на blockchain-based. Транзакции точно так же связываются между собой при помощи хэш-значений, а в учетной системе присутствуют валидаторы, которые добавляют и подтверждают новые транзакции. Однако, из-за отличительных особенностей разветвленной структуры данных нужно обеспечить подходящий алгоритм достижения консенсуса. Для этого используются, прежде всего, методы обхода графа, на основе которых и построены алгоритмы достижения консенсуса.

Одной из первых попыток внедрить ориентированные ациклические графы в учетной системе стала учетная система IOTA, направленная на нужды IoT-индустрии. В такой сфере крайне важно обеспечить высокую масштабируемость, низкое потребление ресурсов и возможность устойчивой работы при перебоях связи, в то же время не жертвуя безопасностью системы. Но удалось ли разработчикам IOTA и других учетных систем обеспечить те преимущества, к которым они стремились?


### Происхождение понятия граф

Само понятие графов возникло достаточно давно. Математик Леонард Эйлер ввел его еще в XVIII веке, работая над решением известной задачи о кенигсбергских мостах [71–72], суть которой заключалась в прохождении по семи мостам города и возвращении в начальный пункт, побывав на каждом мосту только однажды. Как оказалось позже, это невозможно. Давайте же разберемся почему и как графы помогли Эйлеру в решении задачи.

> _Замечание. Если изобразить мосты Кенигсберга как дуги, а части города, откуда можно начать свое путешествие как вершины, получится следующий граф (рис. 3.12). В ходе рассуждений Эйлер пришел к обоснованию невозможности обойти все мосты не пересекая их дважды – любой граф, имеющий более двух вершин, к которым ведет нечетное количество ребер, невозможно нарисовать, не отрывая карандаш от бумаги. В нашем случае ко всем вершинам ведет нечетное количество ребер, следовательно, обойти их не получится._

![Рисунок 3.12 – Схема кенигсбергских мостов](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.12-Königsberg-bridges-scheme.png "Рисунок 3.12 – Схема кенигсбергских мостов")

С тех пор теория графов прошла долгий путь и сейчас используется в различных сферах, от экономики до компьютерных наук. Например, в сфере компьютерных наук графы являются основой многих древовидных структур данных. В физике и схемотехнике при помощи графов изображают принципиальные схемы, а в экономике графы используются для принятия локально оптимальных решений на каждом этапе решения задачи. Также графы нашли свое применение в сфере маршрутизации данных и навигации.


### Что такое DAG?

_Ориентированный ациклический граф (directed acyclic graph, DAG) – это ориентированный граф, для которого невозможны замкнутые обходы._ Это определение может звучать довольно запутанно, поэтому давайте сначала вспомним основные определения из теории графов.

Прежде всего, графом называют абстрактную структуру, состоящую из множества вершин и ребер, которые связывают вершины между собой (рис. 3.13). Сами вершины имеют произвольную структуру и могут представлять различные объекты (города, состояния автомата, сетевые коммутаторы и т. п.).

![Рисунок 3.13 – Неориентированный граф](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.13-undirected-graph.png "Рисунок 3.13 – Неориентированный граф")

Графы делятся на следующие категории:

* _Неориентированный граф_ – граф, в котором ребра связывают две вершины симметрично (рис. 3.13)
* _Ориентированный граф_ – граф с асимметрично связанными вершинами

При этом в ориентированном графе может присутствовать _цикл (замкнутый обход)_ – обход по последовательности ребер, при котором мы возвращаемся к исходной вершине. Следовательно, ациклическим графом называют тот, в котором замкнутые обходы отсутствуют. Для лучшего понимания изображаем ориентированный циклический граф на рис. 3.14 и ориентированный ациклический граф на рис. 3.15.

![Рисунок 3.14 – Пример ориентированного циклического графа](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.14-directed-cyclic-graph.png "Рисунок 3.14 – Пример ориентированного циклического графа")

![Рисунок 3.15 – Пример ориентированного ациклического графа](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.15-directed-acyclic-graph.png "Рисунок 3.15 – Пример ориентированного ациклического графа")


### Архитектура децентрализованных учетных систем на основе DAG

Учетные системы на основе DAG, в отличии от blockchain-based систем, позволяют подтверждать транзакции параллельно (в несколько независимых потоков одновременно). Объекты в учетных системах на основе DAG связываются при помощи хэш-значений, т. е. новые транзакции ссылаются на те, которые уже включены в структуру.

Каждый новый объект должен сослаться на несколько предыдущих, что позволяет графу, увеличиваясь, оставаться достаточно связным.

Для описания взаимосвязей между транзакциями вводятся понятия _прямого_ и _косвенного_ подтверждения. Если представить транзакции в виде вершин графа, а ссылки в виде ребер, одна транзакция будет _прямо подтверждать_ другую, если между ними существует ребро. _Косвенное подтверждение_ появляется, когда две транзакции не имеют связывающего их ребра, но существует путь, по которому можно проследовать от одной транзакции к другой. Наглядный пример продемонстрирован на рис. 3.16.

![Рисунок 3.16 – Связь транзакций в графе](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.16-relation-of-transactions-in-graph.png "Рисунок 3.16 – Связь транзакций в графе")

Как видно из рисунка, транзакция А _прямо_ подтверждает транзакции B и C, а также _косвенно_ подтверждает транзакции D и E. Таким образом, генезис-транзакция (G) подтверждается всеми последующими либо прямо, либо косвенно.

Транзакция, которая только добавлена в граф и еще не имеет подтверждений, называется _tip_. В нашем случае транзакции A и I являются tips. После того, как транзакция добавлена, информация о ней ретранслируется по сети. 

При получении новой транзакции валидатор проверяет ее структуру и другие параметры, которые непосредственно зависят от конкретной учетной системы (например, присутствует ли в ней доказательство выполненной работы и все ли подписи действительны) [73–74].


### Достижение консенсуса и решение разногласий

При добавлении новой транзакции в граф сослаться можно на любые предыдущие транзакции, но имеет ли это смысл? Конечно же нет, поскольку это не приносит никакой пользы для системы. Логичнее всего подтверждать и ссылаться на tips. Однако, зачастую количество tips в заданный момент времени будет намного больше 1, поэтому должен существовать алгоритм их выбора.

Самым очевидным вариантом будет случайный обход по графу в поисках неподтвержденных транзакций, на которые можно сослаться. Однако в таком случае нет способа уберечься от tips, которые ссылаются на давно подтвержденные транзакции, поскольку невозможно абсолютно точно сказать когда пришла конкретная транзакция, заставив тем самым валидаторов выбирать только самые последние. Решением подобной проблемы будет применение механизмов cumulative weight и weighted random walks.

Cumulative weight – это «совокупный вес» конкретной транзакции, то есть количество транзакций, которые прямо или косвенно на нее ссылаются (с учетом этой самой транзакции). 

Weighted random walks – это механизм рандомизированного прохода по графу, в котором проходящий вероятнее пройдет по пути к транзакции с наибольшим совокупным весом.

Основная идея такого подхода заключается в том, что честные валидаторы не будут ссылаться на некорректные транзакции, из-за чего вес этих транзакций будет гораздо меньше и в конечном счете они будут отброшены. Такой подход не только заставляет валидаторов выбирать транзакции, которые скорее всего являются корректными, но и предотвращает ситуации, когда валидатор решает сослаться на уже давно подтвержденную транзакцию, не принося пользы для системы.

Давайте рассмотрим пример работы этих механизмов на рис. 3.17.

![Рисунок 3.17 – Пример ситуации с транзакцией, ссылающейся на давно подтвержденную](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.17-transaction-referring-to-already-confirmed-transaction.png "Рисунок 3.17 – Пример ситуации с транзакцией, ссылающейся на давно подтвержденную")

Валидатор, создавший транзакцию 16, решил сослаться на уже подтвержденную транзакцию 7 вместо того, чтобы подтвердить и сослаться на 15 или 8. Когда следующий валидатор будет выбирать tips, на которые ему сослаться и дойдет до транзакции 7, вероятность того, что он перейдет в 16 крайне мала, поскольку ее суммарный вес равен 1. Вместо этого он перейдет к 9 и продолжит обход.

Такой подход не только мотивирует валидаторов подтверждать новые транзакции, но и обеспечивает защиту от невалидных транзакций. Представим, что транзакция 16 на самом деле невалидна и даже если кто-то из честных валидаторов перейдет к ней (ведь данный метод обхода предусматривает некоторую степень случайности), он не станет на нее ссылаться.

Однако, если транзакция попала в граф и на нее кто-то сослался, это не делает ее подтвержденной. Для предотвращения атак двойной траты применяется механизм _confirmation confidence_. Confirmation confidence – это значение, которое вычисляется для каждой конкретной транзакции и обозначает степень принятия транзакции участниками сети. Значение confirmation confidence варьируется от 0 до 100% и вычисляется следующим образом: определенное количество раз выполняется алгоритм обхода графа, после чего выполняется подсчет количества транзакций, которые ссылаются на текущую и на их основе выполняется расчет confirmation confidence.

Вероятность того, что транзакции с высоким значением confirmation confidence (более 95%) будет отброшена, крайне мала. Единственная возможность выполнить атаку двойной траты в такой ситуации – подтвердить этой транзакцией две давно подтвержденные, после чего начать генерировать большое количество новых транзакций, повышая совокупный вес новой ветки. Однако, такой сценарий возможен только в случае, когда заинтересованная в двойной трате сторона способна сгенерировать больше транзакций, чем все остальные участники системы.

> _Замечание. В некоторых системах, например, IOTA, используется более централизованный подход, основанный на публикации в сети специальных транзакций (специально назначенным участником), которые фиксируют состояние системы._

Разобравшись с основами архитектуры и функционирования учетных систем на основе ориентированных ациклических графов, давайте рассмотрим несколько примеров представителей такого класса систем.


### IOTA

IOTA – это асинхронная permissionless учетная система, изначально разработанная с учетом нужд индустрии IoT, которые требуют масштабируемости, низкого потребления ресурсов, отсутствия комиссий, возможности устойчивой работы при перебоях связи и высокого уровня безопасности. IOTA работает на основе tangle – такое название дали распределенному DAG-реестру разработчики [75].


### Transactions in IOTA

Прежде чем двигаться дальше, давайте более подробно рассмотрим структуру и жизненный цикл транзакции, а также этапы, которые она должна пройти прежде, чем считаться подтвержденной. Общая структура транзакции приведена на рис. 3.18.

![Рисунок 3.18 – Структура транзакции в IOTA](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.18-IOTA-transaction-structure.png "Рисунок 3.18 – Структура транзакции в IOTA")

В поле hash помещается хэш-значение, которое покрывает все поля транзакции.

> _Note. В качестве алгоритма хэширования IOTA использует Curl-P-R. Curl-P-R – алгоритм хэширования, разработанный специально для работы с троичной системой счисления. По своей сути Curl-P-R – это модифицированная функция губки (класс криптографических алгоритмов). Числом R в данном случае обозначается количество раундов хэширования._
> 
> _В 2019 году исследователи из Boston University, MIT Media Lab и Harvard University представили публикацию, в которой была доказана уязвимость алгоритма Curl-P-27 к коллизиям [76]. По заявлениями самих разработчиков, в реальных условиях практически невозможно реализовать подобную атаку из-за методов защиты, реализованных в централизованном механизме подтверждения транзакций._
> 
> _Однако, на данный момент для вычисления хэш-значения транзакций и доказательств выполненной работы вместо Curl-P-27 применяется Curl-P-81 [77]._

Поле _signatureMessageFragment_ содержит в себе значение подписи (WOTS) или произвольное информационное сообщение. Подпись покрывает хэш-значение связки транзакций и в зависимости от длины относится к одному из трех уровней безопасности: первый (2187 трайтов), второй (4374 трайта) или третий (6561 трайт). При этом размер поля signatureMessageFragment ограничен 2187 трайтами и в случае превышения этого размера подпись нужно будет делить на несколько частей.

Поле _address_ указывает на адрес получателя или отправителя в зависимости от типа транзакции. Типы транзакций мы рассмотрим дальше в этом подразделе.

В поле _value_ задается количество отправляемых или получаемых монет. Если же нужно просто передать по сети определенное сообщение, не прикрепляя к нему монеты, можно указать нулевое значение этого поля.

В _timestamp_ содержится временная метка создания транзакции, но она не верифицируется и фактически может содержать произвольное значение.

Поля _currentIndex_ и _lastIndex_, соответственно, содержат в себе индексы текущей и крайней транзакции в связке (bundle).

В поле _trunkTransaction_ содержится хэш-значение следующей по счету транзакции в связке, либо хэш-значение другой транзакции в tangle (только для крайней транзакции). Более подробно формирование этого поля мы рассмотрим далее.

Поле _branchTransaction_ используется, чтобы сослаться на одну из опубликованных транзакций в графе. Далее мы подробно опишем что такое bundle, а также рассмотрим каким образом транзакции ссылаются друг на друга.

В поле _bundle_ указывается хэш-значение, необходимое для определения, к какой связке принадлежит данная транзакция. Для этого хэш-значением покрываются поля _address_, _value_, _currentIndex_, _lastIndex_ и _timestamp_ для всех транзакций в одной связке [79].

Поле _attachmentTag_ позволяет установить произвольную служебную метку сообщения. Прежде всего это используется для идентификации сообщений при обмене информацией между IoT-устройствами.

В поле _attachmentTimestamp_ указывается время формирования транзакции.

Значение в поле _nonce_ инкрементируется после каждой попытки решения задачи PoW [73]. На текущий момент сложность – константная величина, однако разработчики IOTA работают над внедрением протокола Coordicide, который, в частности, введет механизм адаптивной сложности [74].

Сами транзакции бывают трех типов: _input_, _output_ и _zero-value_ (рис. 3.19). Тип транзакции зависит от ее предназначения. Однако, для перевода средств каждой input-транзакции должна соответствовать output-транзакция.

![Рисунок 3.19 – Типы транзакций в IOTA и их обязательные поля](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.19-transaction-types-in-IOTA-and-their-required-fields.png "Рисунок 3.19 – Типы транзакций в IOTA и их обязательные поля")

Input-транзакция имеет негативное значение в поле value, указывая тем самым, что монеты списываются с определенного адреса. Также в ней обязательно указывается адрес, на котором содержится достаточное количество монет, подпись или ее фрагмент и корректное значение nonce.

Output-транзакция, в свою очередь, должна содержать положительное значение в поле value, корректный адрес и nonce. Zero-value-транзакции содержат 0 в поле value, а в поле address не обязательно указывать корректный адрес. Этот тип транзакций используется для обмена сообщениями между участниками сети.


### Структура и назначение bundle

Ранее в разделе мы упоминали термин bundle. Bundle – это связка взаимозависимых транзакций [81]. Например, транзакция, перечисляющая монеты на адрес Алисы прямо зависит от транзакции, которая списывает эти монеты с баланса Боба. Следовательно, они обе будут помещены в одну связку.

Bundle состоит из трех частей: _head_, _body_ и _tail_. В tail помещается первая транзакция в связке (с нулевым значением currentIndex), а в head, соответственно, крайняя транзакция (currentIndex которой равен lastIndex).

Все транзакции в bundle, кроме head, связываются через поле trunkTransaction. Эта связь позволяет узлам определить принадлежность транзакций к одной связке и провалидировать их. Поле branchTransaction используется, чтобы ссылаться на одну из ранее добавленных в граф транзакций. Для лучшего понимания, давайте детально рассмотрим пример bundle на рис. 3.20.

![Рисунок 3.20 – Структура bundle](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.20-bundle-structure.png "Рисунок 3.20 – Структура bundle")

Как можно увидеть из рисунка, все четыре транзакции связаны между собой – в поле _trunkTransaction_ указывается хэш-значение транзакции со следующим по порядку индексом. В поле _branchTransaction_ указывается хэш-значение _trunk tip_ – уже добавленной в реестр tail-транзакции из другого bundle. Поскольку TX(3, 3) является крайней, в поле _trunkTransaction_ она также ссылается на _trunk tip_, а в _branchTransaction_ указано хэш-значение _branch tip_ – второй транзакции, которая была добавлена в реестр ранее.

Bundle также делятся на типы: _transfer bundles_ и _zero-value bundles_. В первом случае в связке содержится как минимум одну входящую и одну исходящую транзакции. В свою очередь, zero-value bundles содержат в себе zero-value транзакции с информационными сообщениями. Рассмотрим краткий пример.

Алиса хочет отправить Бобу одну монету, используя при этом подпись 2 уровня. В bundle будет три транзакции: первая зачисляет монету на баланс Боба, вторая списывает ее с баланса Алисы и содержит фрагмент подписи, при помощи которой Алиса доказывает владение своим личным ключом. Третья транзакция содержит оставшийся фрагмент подписи (рис. 3.21), поскольку подпись имеет слишком большую длину и не поместится в одну транзакцию. При этом отметим, что транзакция зачисления монет на баланс Боба не требует подписи, поэтому поле _signatureMessageFragment_ остается пустым.

![Рисунок 3.21 – Пример bundle из трех транзакций, которые обеспечивают перевод одной монеты с адреса Алисы на адрес Боба](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.21-bundle-with-three-transactions-transferring-one-coin.png "Рисунок 3.21 – Пример bundle из трех транзакций, которые обеспечивают перевод одной монеты с адреса Алисы на адрес Боба")

### \*\*\*Часто задаваемые вопросы\*\*\*

_– Почему в IOTA используется троичная система счисления?_

Троичная система счисления обеспечивает не только большую эффективность вычислений, но также позволяет работать с отрицательными числами без необходимости прибегать к дополнительному коду, как в случае с двоичной системой счисления.

_– Кто такой координатор и какова его роль в IOTA?_

Поскольку сеть IOTA еще находится на раннем этапе своего развития, она не может позволить себе быть полностью децентрализованной, из-за чего разработчикам пришлось прибегнуть к внедрению механизма координатора. Координатор – это узел-валидатор в сети IOTA, который принадлежит IOTA Foundation. Все транзакции, на которые ссылаются транзакции, созданные координатором (они называются milestones), считаются окончательно подтвержденными.

# [4 МЕХАНИЗМЫ ОБЕСПЕЧЕНИЯ КОНФИДЕНЦИАЛЬНОСТИ В ИНТЕРНЕТЕ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ru/4-Privacy-and-anonymity-on-the-Internet.md)
