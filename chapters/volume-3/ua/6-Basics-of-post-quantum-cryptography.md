# [5 РОЛЬ КРИПТОГРАФІЧНИХ ЗОБОВ'ЯЗАНЬ В ОБЛІКОВИХ СИСТЕМАХ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ua/5-Role-of-cryptographic-commitments-in-accounting-systems.md)

# 6 ОСНОВИ ПОСТКВАНТОВОЇ КРИПТОГРАФІЇ


## 6.1 Вступ до постквантових криптографічних алгоритмів

Хоча ще немає версії квантових комп'ютерів, що стабільно працює, уже розроблено математичний апарат (квантові алгоритми), реалізування якого на квантовому комп'ютері дозволить знизити складність атак на широко використовувані криптоалгоритми. Вони здатні виконувати алгоритми розв’язання задач з квадратичним, а то й експоненціальним прискоренням порівняно з алгоритмами, розрахованими на виконання тих самих завдань на класичному комп'ютері (табл. 6.1). Наприклад, задачі певних класів, зокрема факторизування чисел і знаходження дискретного логарифма, квантові комп'ютери здатні розв’язувати з ефективністю, яка набагато перевершує можливості класичних комп'ютерів [99–103].

Таблиця 6.1 – Порівняння часової складності виконання алгоритмів для класичного та квантового комп'ютерів  
| _Тип задачі_ | _Алгоритм для класичного комп'ютера_ | _Алгоритм для квантового комп'ютера_ |
|---|---|---|
| Факторизування | класичний алгоритм Полларда–Штрассена <br>$O(n^{\frac{1}{4}}(\log{n})^{4})$ | квантовий алгоритм Шора <br>$O(\log{n})$ |
| Рівняння Пелла | класичний алгоритм тесту простоти AKS <br>$O((\log{n})^{6})$ | квантовий алгоритм тесту простоти <br>$O(n^{2}(\log{\log{n}})(\log{n})^{3})$ |
| Пошук | класичний алгоритм бінарного пошуку <br>$O(\log{n})$ | квантовий алгоритм Ґровера <br>$O(n^{\frac{1}{2}})$ |

> _Зауваження. Під часовою складністю мається на увазі кількість елементарних операцій, які здійснює алгоритм. До операцій, елементарних для класичних комп'ютерів, належать такі: установлення регістра в нульове значення, бітове зсування на один розряд, логічне додавання, логічне множення. Для квантового комп'ютеру елементарні операції є квантові гейти (див. 6.3)._
> 
> _Хоча обчислювальна складність описується кількістю елементарних операцій, вона не враховує час виконання таких операцій на класичному або квантовому процесорі. Саме з цим пов'язані хибна думка, що квантовий комп'ютер завжди працюватиме швидше_

Найвідоміші квантові алгоритми – алгоритм Шора й алгоритм Ґровера – використовуються для швидкого факторизування числа та прискорення пошуку відповідно. Ці алгоритми загрожують багатьом широко використовуваним криптопримітивам шифрування та цифрового підпису. Безпечність цих примітивів ґрунтується на припущенні, що деякі обчислювальні задачі (наприклад задачу факторизування числа чи знаходження дискретного логарифма) важко розв'язати з використанням доступних обчислювальних ресурсів. Утім, для ефективного реалізування таких алгоритмів квантовий комп'ютер повинен мати регістр із достатнім розміром (з достатньою кількістю кубітів).


### Криптографічні примітиви, уразливі до атак квантового комп'ютера

Питання про те, коли буде побудовано квантовий комп'ютер із достатньо великою кількістю кубітів для ефективного реалізування атак на наявні криптоалгоритми, складне та суперечливе.

Однак поява такого комп'ютера потенційно небезпечна для сучасних криптосистем. Також варто взяти до уваги той факт, що для розвернення сучасної інфраструктури з застосуванням класичних криптопримітивів, яка включає не тільки безпосередньо математичні алгоритми, але й набір технічних засобів для їх реалізування, а також нормативне регулювання цих питань, знадобилося майже 20 років. Виходячи з такого досвіду, можна зробити висновок, що незалежно від швидкості розвитку квантових обчислень, потрібно вже зараз готуватися до плавного переведення наявних систем інформаційної безпеки на стійкі алгоритми. 

> _Зауваження. Учені з Google AI помітили закономірність (т. зв. закон Невена) [104], що темп зростання можливостей квантових комп'ютерів має подвійну експоненціальну швидкість._
> 
> _Подвійне експоненціальне зростання означає, що деяка величина зростає, як ступінь ступеня 2: 2<sup>2<sup>1</sup></sup>, 2<sup>2<sup>2</sup></sup>, 2<sup>2<sup>3</sup></sup>, 2<sup>2<sup>4</sup></sup>. Така швидкість – наслідок комбінування двох експоненціальних факторів. Перший полягає в тому, що квантові комп'ютери мають внутрішню експоненціальну перевагу перед класичними. Якщо квантовий контур має, наприклад, 4 кубіти, то його обчислювальну потужність можна порівняти з контуром із 16 звичайних бітів. Це було би так навіть без покращення квантових технологій. Другий експоненціальний фактор з'являється завдяки швидкому покращенню квантових процесорів. Невен каже, що найкращі квантові чіпи від Google останнім часом покращуються з експоненціальної швидкістю, яка обумовлена зменшенням кількості помилок. Це дозволило інженерам будувати більш великі квантові процесори. Якщо класичним комп'ютерам потрібно експоненціально більша обчислювальна потужність для симулювання квантових процесорів, а потужність цих квантових процесорів згодом зростає експоненціально, то в підсумку виходить подвійне експоненціальне відношення між квантовими та класичними машинами._

У табл. 6.2 показано алгоритми, потенційно вразливі перед атаками з використанням квантових комп'ютерів, а також можливі шляхи усунення вразливостей для деяких із них.

Таблиця 6.2 – Можливі наслідки атак із використанням квантових комп'ютерів для найбільш поширених алгоритмів
| _Криптографічний алгоритм_ | _Тип_ | _Застосування_ | _Методи протистояння атакам з використанням квантових комп'ютерів_ |
|---|---|---|---|
| AES | Симетрична криптографія | Шифрування | Збільшення розмірів ключових параметрів |
| SHA-2, SHA-3 | — | Геш-функції | Збільшення розміру виходу |
| RSA | Асиметрична криптографія | Цифровий підпис, алгоритми встановлення ключів  | Не можуть залишатися стійкими |
| ECDSA, ECDH | Асиметрична криптографія | Цифровий підпис, алгоритми обмінювання ключами | Не можуть залишатися стійкими |
| DSA | Асиметрична криптографія | Цифровий підпис, алгоритми обмінювання ключами | Не можуть залишатися стійкими |

Як бачимо, симетрична криптографія може залишатися стійкою до квантових атак, якщо збільшити розміри ключових параметрів. Також можливо відносно просто адаптувати механізм геш-функцій і надалі його безпечно використовувати. Проте з частиною алгоритмів асиметричної криптографії такі маніпуляції будуть неефективні [105].

Криптоалгоритми, як-от RSA, DSA й ECDSA, не квантово безпечні, оскільки вони не може бути адаптовано (через збільшення розміру ключових параметрів), щоб випереджати темпи розвитку квантових обчислень. Наприклад, щоб атакувати 3072-бітний ключ RSA, квантовий комп'ютер повинен мати кілька тисяч логічних кубітів. Загалом, є лінійна залежність між довжиною ключа RSA (в бітах) і необхідною кількістю кубітів у квантовому комп'ютері для реалізування ефективної атаки на алгоритм. Коли такий квантовий комп'ютер стане доступним, перехід на більший розмір ключа RSA перешкоджатиме квантовій атаці, поки не буде винайдено квантовий комп'ютер з більшою кількістю кубітів. Однак подвоєння розміру ключа RSA або ECC збільшує час роботи криптопримітива на звичайному комп'ютері увосьмеро. Якщо для збереження стійкості таких алгоритмів перед квантовими атаками необхідно подвоювати розмір ключових параметрів що два роки, то час виконання алгоритмів на звичайному комп'ютері збільшується увосьмеро що два роки. Відповідно, ці алгоритми швидко стають не практичними як з погляду швидкості, так і з погляду ширини смуги пропускання каналу, необхідної для передавання ключової інформації.


### Терміновість переходу на постквантові алгоритми

Щоби надалі безпечно використовувати криптографію з відкритим ключем навіть за умови атак із використанням квантових комп'ютерів, потрібно застосовувати принципово інші алгоритми, які базуватимуться на задачах, складних для квантових комп'ютерів. Однак процес переходження на нові алгоритми вимагає часу для перевіряння та тестування всіх аспектів безпеки нових алгоритмів.

> _Зауваження. Алгоритми, які будуть стійкі до атак квантового комп'ютера, називатимемо постквантовими алгоритмами.._

Досі є багато скептицизму стосовно перспективи створення квантового комп'ютера, здатного виконувати більш ніж одне завдання (наприклад, виконувати алгоритм Шора й алгоритм Ґровера на одному пристрої без потреби змінювати архітектурні компоненти). Відповідно, те, як терміново потрібно перейти на алгоритми, стійкі до атак квантового комп'ютера, залежить від таких факторів [106]:

1. Як довго потрібно організовувати безпеку криптографічних ключів? Позначмо цю величину, «термін безпечного використання», як _x_. Є дані, які втрачають свою цінність протягом короткого проміжку часу (кілька хвилин для одноразового пароля), а є інформація, яку потрібно зберігати в секреті протягом десятиріч (наприклад, дані медичної історії або стратегічна інформація, пов'язана з національною безпекою). Для першого типу даних параметр $x = 0$ рік, тоді як для другого – може досягати 10, 20, 100 рік тощо. Зазвичай значення _x_ зазвичай встановлює особисто володілець кожної системи, яка потребує захисту, або його встановлює регулятор.
2. Скільки часу буде потрібно для впровадження постквантової криптографії? Позначмо цю величину, «час мігрування», як _у_. Наприклад, може бути $y = 0$ рік, якщо просто розгортається  автооновлення, яке замінює AES-128 на AES-256 в системі, яку повністю контролює один постачальник. Утім, може бути $y ≥ 15$ рік, якщо він включає відносно неперевірений метод шифрування з відкритим ключем, який має бути адаптовано для обмеженого середовища з багатьма учасниками (зацікавленими сторонами), які повинні узгодити стандарт.
3. Нарешті, скільки часу спливе доти, як квантовий комп'ютер або будь-який інший метод зламає використовувані нині інструменти криптографії з відкритим ключем? Позначмо цю величину, «час колапсу», як _z_. Якщо $x + y > z$, виникає серйозна проблема, оскільки інформація, захищена квантово вразливими інструментами наприкінці наступних _y_ рік, може бути зламано квантовими атаками менш ніж через _x_ рік.


### Можливі шляхи вирішення

На сьогодні є два взаємодоповнювальні сімейства можливих рішень. 

Одне сімейство рішень називають постквантовою криптографією. До нього належать звичайні криптопримітиви, що ґрунтуються на математичних задачах, які, на думку наукової спільноти (на основі теоретичних обчислень), захищені від атак із застосуванням квантового комп'ютера. Ці рішення зручні тимі, що відповідні алгоритми можуть також працювати на класичному комп'ютері. Зі свого боку, це спрощує процеси дослідження навіть до моменту появи доволі потужних квантових комп'ютерів. Застосовуючи такі рішення, ми досі перебуваємо в ситуації «обчислювальної безпечності», тобто ми припускаємо, що складність атаки грубої сили з застосуванням квантового комп'ютера буде достатньо високою, щоби забезпечити стійкість систем із застосуванням таких алгоритмів (детальніше розглянемо далі).

> _Зауваження. Згідно з класичним визначенням вважається, що алгоритм стійкий, якщо немає більш ефективної атаки, ніж пряме перебирання ключових параметрів (атака грубої сили). Однак для постквантових алгоритмів потрібне також виконання ще однієї умови, а саме стійкості до атак із застосуванням алгоритмів Шора [107] та Ґровера [108]._

Інше сімейство рішень відоме як квантова криптографія [109] – метод захисту комунікацій, базований на принципах квантової фізики. На відміну від традиційної криптографії, яка використовує математичні методи, щоби забезпечити секретність інформації, квантова криптографія розглядає випадки, коли інформація переноситься за допомогою об'єктів квантової механіки, наприклад електронів ув електричному струмі чи фотонів у лініях волоконно-оптичного зв'язку. Процес відправлення та приймання інформації завжди виконується фізичними засобами.

Атакою на такі системи (у термінах квантової криптографії атакою називають «підслуховування») може бути змінювання певних параметрів фізичних об'єктів (носіїв інформації).

Технологія квантової криптографії спирається на принцип невизначеності Гейзенберґа [110]: неможливо одночасно отримати координати й імпульс частки; неможливо виміряти один параметр фотона, не викрививши інший.

Використовуючи квантові явища, можна спроектувати та створити таку систему зв'язку, яка завжди може виявляти підслуховування. Це забезпечує те, що спроба вимірювання взаємопов'язаних параметрів у квантовій системі вносить до неї порушення, руйнуючи вихідні сигнали. Отже, за рівнем шуму в каналі чесні користувачі можуть розпізнати присутність перехоплювача.

Недолік таких рішень – необхідність організувати квантовий канал (рис. 6.1). Щоб відправляти кубіти, потрібна наявність відповідного обладнання в обох сторін взаємодії. Таке обладнання дуже дороге та на сьогодні недоступне для широкого використання.

![Рисунок 6.1 – Організування квантового каналу](/resources/img/volume-3/6.1-Introduction-to-post-quantum-cryptographic-algorithms/F-6.1-quantum-channel-setup.png "Рисунок 6.1 – Організування квантового каналу")

У короткостроковій перспективі такі квантові канали доступні від точки до точки на відносно коротких відстанях, але, можливо, у середньостроковій і довгостроковій перспективі квантовий зв'язок і квантові повторювачі дозволять організувати безпечні канали на великих відстанях.

Далі ми розглянемо, які задачі обчислювально складні для квантових комп'ютерів. На сьогодні виокремлюють чотири основні задачі в різних математичних апаратах, на яких ґрунтуються сімейства постквантових примітивів.


### Lattice-based cryptography (LB-криптографія)

LB-криптографія – це підхід до побудування алгоритмів асиметричного шифрування та цифрового підпису з використанням завдань теорії алгебраїчних решіток.

Алгебраїчна решетка – це дискретна підмножина векторів ув евклідовому просторі $\mathbb{R}^{n}$, замкнена відносно операцій додавання та віднімання векторів. Ми говоримо, що розмірність решітки – _n_, якщо вона не розміщується в будь-якому підпросторі простору $\mathbb{R}^{n}$. Геометрично решітка – це множина рівноймовірно розміщених у просторі точок, через які проходять вектори. Алгебраїчна решітка може розглядатися як абелева група.

Базис решітки _L_ – це множина таких векторів _В_, що будь-який інший вектор у решітці може бути подано у формі лінійної комбінації (з цілочисельними коефіцієнтами) елементів множини _B_. Якщо розмірність решітки принаймні дорівнює 2, то є безліч різних базисів решітки (рис. 6.2).

![Рисунок 6.2 – Множина базисів у решітці](/resources/img/volume-3/6.1-Introduction-to-post-quantum-cryptographic-algorithms/F-6.2-many-bases-in-lattice.png "Рисунок 6.2 – Множина базисів у решітці")

Алгебраїчні решітки як математичну конструкцію вперше вивчали Лагранж і Ґаусс. У криптографії вони використовувалися, наприклад, для криптоаналізування конгруентних генераторів. У 1996 році M. Aitai показав, як решітки може бути використано в ролі нового криптоперетворення. У 2009 році Gentry використав решітки для побудування нової гомоморфної криптосистеми.

Стійкість LB-криптосистем ґрунтується на складності розв'язання двох комбінаторних задач:

1. Задача про найкоротший вектор (shortest vector problem, SVP): пошук найкоротшого вектора в решітці _L_, поданій у базисі _В_. На ній побудовані алгоритми шифрування з використанням решіток. Особистий ключ у такій системі – базис решітки _В_ та спеціально вибрана унімодулярна матриця _U_ (квадратна матриця з цілими коефіцієнтами, визначник якої дорівнює +1 або −1). Відкритий ключ – базис $B'=BU$. Знаючи базис, можна згенерувати вектор, близький до заданої точки, але знаючи близький вектор, нам потрібний вихідний базис, щоб знайти вихідну точку. Приклад такої системи – NTRUEncrypt [111].
2. Задача про найближчий вектор (closest vector problem, CVP): для заданого базису _В_ решітки _L_ і деякого вектора $v \in L$ потрібно знайти вектор $v' \in L$, найближчий до вектору _v_. На цій задачі побудовані алгоритми цифрового підпису на решітках. Ідея полягає у використанні решіток, для яких «поганий» базис (довгі та майже паралельні вектори) – відкритий ключ, а «хороший» базис (короткі та майже ортогональні вектори) – особистий ключ. Приклад – алгоритм цифрового підпису NTRUSign [112].

Переваги LB-алгоритмів полягають у їхній відносній простоті та легкості розпаралелювання попередніх обчислень, потрібних для операцій зашифрування/розшифрування та генерування/верифікування цифрового підпису. З іншого боку, виявилося важко дати точні оцінки безпечності «решіткових схем» навіть порівняно з відомими методами криптоаналізування.


### Code-based cryptography (CB-криптографія)

CB-криптографія включає системи, базовані на кодах із виправленням помилок, як-от алгоритми шифрування McEliece [113] і Niederreiter, і відповідні схеми формування підпису Courtois, Finiasz і Sendrier. Основний прийом – додання до корисних даних, що записуються (передаються), у спеціальний спосіб структурованої надлишкової інформації (наприклад, контрольного числа). Під час зчитування (приймання) даних така надлишкова інформація використовується для виявлення та виправлення помилок. Кількість помилок, яку можна виправити, обмежена та залежить від конкретного застосовуваного коду.

CB-криптографія базується на складності декодування лінійних кодів. Відкритий ключ у такій системі – матриця _K_ з розмірністю $dt \times n$ із коефіцієнтами в полі $\mathrm{GF}(2)$. Повідомлення (_m_) – це _n_-бітний рядок із вагою _t_, тобто _n_-бітний рядок містить рівно _t_ бітів, які дорівнюють 1; його потрібно попередньо відформатувати. Щоби зашифрувати повідомлення _m_, відправник формує $dt$-бітний ($d= \lg{n}$) шифротекст $C = Km$.

Головна задача для зловмисника – пошук синдрому декодування матриці _К_. Тобто вона полягає в тому, щоби отримати результат множення _К_, знаючи, що на вході – вектор із вагою _t_. Це можна зробити методами лінійної алгебри: виконати обернену операцію відновлення _Кm_ до _n_-бітного вектору _v_ такого, що $Kv = Km$.

Проте є дуже багато таких векторів _v_, і пошук серед них _t_-вектора вкрай важкий. Найвідоміша на сьогодні атака на цю задачу має здебільшого експоненційну складність для матриць _К_.

Уперше криптосистему McEliece була подано в 1978 році; відтоді ефективні атаки на неї не з'являлися. Пізніше було запропоновано інші системи, базовані на кодах із виправленням помилок. Хоча примітиви,що ґрунтуються на кодах, достатньо швидкі, вони використовують ключі з надто великим розміром. Здебільшого застосування апарату кодів виявилося зручнішим для реалізування схем шифрування, ніж для алгоритмів цифрового підпису.


### Multivariate polynomial cryptography (MQ-криптографія)

Безпечне застосування криптопримітивів цієї групи за умови атак із використанням квантових комп'ютерів ґрунтується на припущенні, що розв'язання систем багатовимірних поліномів над кінцевими полями знаходити складно.

Відкритий ключ у такій системі – послідовність 

$(P_{1} P_{2}, \ldots ,P_{2b})$ 

з $2b$ поліномів із $4b$ змінними $(ω_{1},ω_{2}, \ldots ,ω_{4b})$ з коефіцієнтами в полі $\mathrm{GF}(2)$ ∈ {0,1}. Кожний поліном подано як послідовність

$(1,ω_{1},ω_{2}, \ldots ,ω_{4b},ω_{1}ω_{2},ω_{1}ω_{3}, \ldots ,ω_{4b-1}ω_{4b})$
 
Відкритий ключ складається з $16b^{3}+4b^{2}+2b$ біт. Наприклад, для $b = 128$ розмір ключа становитиме 4 МБ.

Перевага MQ-криптографії – саме розміри підписів і відкритих ключів.

Головна задача для зловмисника – пошук послідовності з $4b$ $(ω_{1},ω_{2}, \ldots ,ω_{4b})$ бітів, яка породжує $2b$ вихідних бітів

$(P_{1} P_{2}, \ldots ,P_{2b})$ 

Імовірність угадати послідовність з $4b$ бітів можна оцінити як $2^{-2b}$.


### Hash-based cryptography (HB-криптографія)

HB-криптографія (криптографія, базована на використанні геш-функцій) використовує схеми формування одноразового підпису, як-от Lamport–Diffie чи Winternitz. Стійкість таких схем ґрунтується виключно на стійкості використовуваної геш-функції. Особливість схем Lamport–Diffie та Winternitz – неможливість їх безпечного використання більш ніж одного разу. Для усунення зазначених недоліків використовуються двійкоів дерева. Основна ідея полягає в тому, що кожен вузол дерева розраховується як геш-значення від конкатенації дочірніх вузлів дерева. Кореневий вузол дерева, – відкритий ключ, який розраховується послідовно (рис. 6.3). Листки дерева зберігають значення одноразових ключів.

![Рисунок 6.3 – Архітектура hash-based алгоритмів формування підпису](/resources/img/volume-3/6.1-Introduction-to-post-quantum-cryptographic-algorithms/F-6.3-architecture-of-hash-based-signature-algorithms.png "Рисунок 6.3 – Архітектура hash-based алгоритмів формування підпису")

Ідею використання дерева запропонував в 1979 році Ральф Меркл (Ralph C. Merkle). Вона має низку недоліків, як-от великий розмір ключів і довгий час генерування підпису. На сьогодні відомі модифікації алгоритму Меркла, як-от алгоритм Leighton–Micali, алгоритм XMSS, алгоритм SPHINCS.


### Альтернативні групи

Було запропоновано багато систем, які не належать до зазначених вище груп. Одна з таких пропозицій базована на оцінюванні ізогеній суперсингулярних еліптичних кривих.

> _Зауваження. Теорема Гассе стверджує, що за кількості точок N кривої, яка визначена над полем_ $\mathrm{Z}(q)$ _з q елементами, правильна така рівність:_ $|N-(q+1)| \leq 2 \sqrt{q}$. Ураховуючи, що двійкове кінцеве поле $\mathrm{GF}(2^{n})$ складається з $2^{n}$ _елементів, можна стверджувати, що порядок кривої_ $E(a, b)$ _в цьому полі дорівнює_ $2^{n}+1-t$_, де_ $|t| \leq \sqrt{2^{n}}$.
> 
> _Якщо t ділиться на характеристику поля без залишку, еліптичну криву над двійковим кінцевим полем називають суперсингулярною [114]._

Задачу дискретного логарифмування на еліптичних кривих може бути ефективно розвя'зано за допомогою алгоритму Шора на квантовому комп'ютері, але для задачі знаходження ізогенії (тобто раціонального відображення, що переводить точки однієї кривої в точки ізогенної кривої, залишаючи нерухомою нескінченно віддалену точку) на суперсингулярних кривих немає аналогічної квантової атаки.

### \*\*\*Поширені міфи\*\*\*

_Щойно буде створено квантовий комп'ютер, який ефективно розв'язує задачу дискретного логарифмування в групі точок еліптичної кривої, ECDSA відразу ж стане непотрібним._

Не завжди таке твердження буде правильне. У деяких випадках ECDSA може залишатися достатньо надійним, наприклад, якщо період життя відкритого ключа менший за час виконання атаки, а також якщо ключі використовуються тільки одного разу та відкритий ключ публікується одночасно з цифровим підписом або пізніше за нього. До речі, саме тому в Біткоїні може надалі бути використано ECDSA та геш-значення відкритих ключів як адреси.

### \*\*\*Часті запитання\*\*\*

_– Чи можна вже зараз використовувати постквантові алгоритми на практиці, не чекаючи на фактичну появу квантових комп'ютерів?_

Постквантову криптографію можна використовувати вже сьогодні, проте сучасна інфраструктура поки не готова до її використання. Наприклад, для того, щоби до наявної ІВК впровадити використання hash-based підписів потрібно вирішити низку питань: щонайменше змінити формати сертифікатів відкритих ключів і визначити політику їх оновлення. Адже є принципова відмінність у тому, що за наявного підходу ключова пара видається на фіксований проміжок часу, а за використання hash-based підписів термін дії відкритого ключа залежить від кількості накладених підписів.


## 6.2 Алгоритми підпису на основі геш-функцій

У другій частині навчального посібника ми розглядали алгоритми одноразового підпису, як-от OTS Лемпорта та WOTS. На використанні цих алгоритмів разом із деревами Меркла ґрунтується постквантові hash-based алгоритми цифрового підпису. У цьому розділі йдеться про такі алгоритми, властивості, які вони забезпечують, й особливості їхньої архітектури.

На сьогодні найбільш відомі та перспективні алгоритми цифрового підпису, побудовані на основі геш-функцій, – алгоритми сімейства SPHINCS [115–118]. До того ж, SPHINCS+ пройшов до другого туру Процесу стандартизації постквантової криптографії NIST [119]; він змагається з вісьмома іншими проектами за звання нового стандарту цифрового підпису. У цьому розділі ми й намагатимемося описати, як із будівельних блоків, як-от OTS (WOTS), HORS (опишемо далі) і дерев Меркла, вийшло розробити алгоритм формуання цифрового підпису, який забезпечуватиме достатній рівень безпеки навіть за умови роботи квантового комп'ютера.


### Конструкція HORS

Перш ніж узятися за розгляд будови SPHINCS, опишемо, як працює один із компонентів цього алгоритму – HORS (Hash to Obtain Random Subset) [120]. Цю схему few-time підпису було описано в 2002 році, і вона розширює схему OTS Лемпорта, дозволяючи досягти меншого розміру підпису. Безпека алгоритму ґрунтується тільки на використовуваних геш-функціях [121].

Для початку розгляньмо, як користувач генерує ключі. Припустімо, що в алгоритмі використано дві хеш-функції з довжиною виходу 160 біт (насправді HORS не визначає, які конкретно геш-функції має бути використана; для нашого прикладу буде достатньо просто позначити довжину вихідного геш-значення). Також установімо довжину частин особистого ключа, що дорівнює 160 біт.

Крім цих параметрів, нас цікавлять ще 2 параметри: _t_ та _k_. Параметр _t_ визначає кількість частин особистого та відкритого ключів, а параметр _k_ – кількість блоків, на які буде розділено геш-значення підписуваного повідомлення. Між параметрами є така залежність:

$t=2^{\frac{l}{k}}$

де _Hash.length_ – довжина геш-значення підписуваного повідомлення. Відразу відзначмо, наскільки важливий вибір цих параметрів. Якщо ми виберемо $k = 160$, то $t = 2$. Це означає, що особистий ключ складатиметься тільки з двох значень, кожним із яких підписуватимемо чи то «0», чи то «1». Водночас розмір підпису буде більш за 3 кбайт (як і якби ми використовували OTS Лемпорта), а значення відкритого ключа займатиме 40 байт. Якщо ж вибрати _k_, що дорівнює 1, потрібно буде згенерувати 2160 частин особистого ключа, що на практиці доволі проблематично.

Для нашого прикладу намагатимемося вибрати оптимальні значення цих параметрів: $k = 16$, $t = 1024$. Отже, коли параметри вибрано й узгоджено між учасниками системи, користувач, якому потрібно підписати повідомлення, генерує особистий ключ, кількість частин якого дорівнює 1024 (рис. 6.4).

![Рисунок 6.4 – Структура особистого ключа](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.4-private-key-structure.png "Рисунок 6.4 – Структура особистого ключа")

Після того як особистий ключ сформовано, користувач обчислює відкритий ключ, кількість частин якого також дорівнює 1024. Для отримання відкритого ключа з особистого використовується геш-функція з довжиною виходу (у контексті прикладу) 160 біт (рис. 6.5).

![Рисунок 6.5 – Процес обчислення відкритого ключа](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.5-public-key-computation.png "Рисунок 6.5 – Процес обчислення відкритого ключа")

Відкритий ключ розповсюджується серед перевірячів, і з його допомогою вони можуть верифікувати підпис, який обчислив користувач.

> _Зауваження. У наведеному прикладі значення відкритого ключа (набору його частин) доволі велике (близько 20 кбайт) і його не дуже зручно зберігати верифікаторам. Є спосіб стиснути відкритий ключ (для нашого прикладу – до 160 біт), трохи модифікувавши алгоритм підпису. Для цього використовується дерево Меркла, яке збирає підключі до одного кореневого значення. Тут ми пропускаємо деталі стиснення ключів, проте далі обов'язково розглянемо їх._

Розгляньмо, у який спосіб проходить сам процес підписання. Користувач обчислює геш-значення повідомлення. Після цього отримане геш-значення він розділяє на k однакових за розміром блоків. У нашому прикладі це буде 16 10-бітних блоків (рис. 6.6).

![Рисунок 6.6 – Розбиття геш-значення повідомлення на блоки](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.6-dividing-message-hash-value-into-blocks.png "Рисунок 6.6 – Розбиття геш-значення повідомлення на блоки")

Кожний із цих блоків оброблятиметься окремо, а значення підпису міститиме _k_ однакових за розміром особистих ключів. Далі кожний із блоків розглядається як натуральне число (рис. 6.7).

![Рисунок 6.7 – Перетворення блоків у цілочисельні значення](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.7-conversion-of-blocks-to-integer-values.png "Рисунок 6.7 – Перетворення блоків у цілочисельні значення")

За використання схеми HORS частини підпису – це частини особистого ключа, які мають отримані раніше індекси (цілочисельні значення блоків). Тобто в нашому прикладі підпис – це набір значень, як на рис. 6.8.

![Рисунок 6.8 – Структура підпису](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.8-signature-structure.png "Рисунок 6.8 – Структура підпису")

Тепер розгляньмо, як отримане значення підпису може бути перевірено за допомогою відкритого ключа. Для цього той, хто перевіряє, повторює точно такі самі операції над повідомленням: обчислює геш-значення від нього, розбиває на блоки та розглядає кожний блок як натуральне число (рис. 6.7, 6.8). З огляду на отримані індекси перевіряч вибирає частини відкритого ключа, які потрібно використовувати для верифікування. Набір цих частин для нашого прикладу зображено на рис. 6.9.

![Рисунок 6.9 – Значення відкритого ключа для перевіряння підпису](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.9-public-key-for-signature-verification.png "Рисунок 6.9 – Значення відкритого ключа для перевіряння підпису")

Перевіряння підпису тут дуже схоже на перевіряння одноразового підпису Лемпорта: кожна частина підпису гешується та порівнюється з відповідною частиною відкритого ключа (рис. 6.10). Якщо всі відповідні частини дорівнюють одна одній, то підпис вважається правильним.

![Рисунок 6.10 – Процес перевіряння підпису](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.10-signature-verification.png "Рисунок 6.10 – Процес перевіряння підпису")


### Схема підпису Меркла

Тепер ми розглянемо схему підпису Меркла (MSS), позаяк SPHINCS – розширення цього алгоритму. Схема Меркла створює багаторазовий підпис. Це означає, що вона, на відміну від розглянутих раніше алгоритмів, дозволяє підписати кілька різних повідомлень, та використати для їх перевіряння те саме значення відкритого ключа.

Цей алгоритм підпису використовує ключі та механізм одноразового підпису (OTS Лемпорта, WOTS або будь-який інший алгоритм), які, зі свого боку, пов'язані в деревоподібній структурі з єдиним кореневим значенням.

Почнімо з того, як користувач генерує ключі. Вибирається параметр, який визначає кількість повідомлень, які може бути перевірено одним відкритим ключем. Припустімо, цей параметр дорівнює 4 (ми зможемо підписати 4 різних повідомлення, які верифікуватимуться тим самим відкритим ключем). Тому наступний крок – створення 4 пар ключів OTS (рис. 6.11).

![Рисунок 6.11 – Генерування ключів для підпису](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.11-generation-of-keys-for-signature.png "Рисунок 6.11 – Генерування ключів для підпису")

> _Зауваження. Нагадаємо, що схема OTS Лемпорта передбачає генерування_ $2n$ _частин особистого ключа, де n – довжина вихідного значення використовуваної геш-функції. Значення підпису – це значення елементів особистого ключа, які відповідають кожному біту виходу геш-функції (залежно від значення біта виходу). Під час перевіряння той, хто перевіряє, обчислює геш-значення від частин підпису та впевнюється в їхній відповідності частинам відкритого ключа. Використання OTS Лемпорта необов'язкове; альтернативно може використовуватися WOTS (обидва алгоритми описано в другій частині навчального посібника)._

За допомогою кожного особистого ключа одноразового підпису користувач і підписуватиме повідомлення, однак використання дерева Меркла дозволяє передавати тим, хто перевіряє, не 4 різні відкриті ключі, а одне значення. У який спосіб? Обчислені відкриті ключі – це листки дерева Меркла, які далі гешуються, а геш-значення від них конкатенуються одне з одним для подальшого гешування й утворення вузлів дерева. У підсумку, виходить єдине кореневе значення (Merkle root), яке і є «глобальний» відкритий ключ для всіх відкритих ключів OTS (рис. 6.12).

Глобальний відкритий ключ передається перевірячам і використовується для верифікування підписів повідомлень, які було підписано будь-яким із дочірніх особистих ключів одноразового підпису.

![Рисунок 6.12 – Процедура формування відкритого ключа](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.12-public-key-formation.png "Рисунок 6.12 – Процедура формування відкритого ключа")

Як же виконується підписання? Користувач обчислює геш-значення повідомлення, і для цього геш-значення він обчислює одноразовий підпис (OTS). До цього значення користувач прикріплює значення відповідного відкритого ключа та Merkle branch для його автентифікації в дереві Меркла. Весь цей набір даних буде прикріплено до повідомлення як цифровий підпис (рис. 6.13).

![Рисунок 6.13 – Структура підпису](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.13-signature-structure.png "Рисунок 6.13 – Структура підпису")

Якщо ми підписуємо повідомлення за допомогою _private\_key<sub>1</sub>_, то до значення підпису OTS прикріплюється значення _public\_key<sub>1</sub>_, а також _H<sub>1</sub>_ й _H<sub>11</sub>_, які є Merkle branches для _public\_key<sub>1</sub>_.

Верифікування підпису складається з двох етапів: перевіряння одноразового підпису та перевіряння того, що зазначений відкритий ключ належить до глобального відкритого ключа (автентифікація в дереві Меркла). Тобто той, хто перевіряє, подає на вхід функції перевіряння OTS саме значення підпису та значення зазначеного відкритого ключа (рис. 6.14).

![Рисунок 6.14 – Схема верифікування підпису](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.14-signature-verification.png "Рисунок 6.14 – Схема верифікування підпису")

Якщо значення одноразового підпису правильне, перевіряється входження відкритого ключа до кореня дерева Меркла, який містить глобальне значення відкритого ключа користувача. Тобто, маючи значення Merkle branch, перевіряч виконує верифікацію визначеного відкритого ключа в дереві (рис. 6.15).

![Рисунок 6.15 – Перевіряння входження відкритого ключа до дерева Меркла](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.15-verification-of-existence-of-public-key-in-tree.png "Рисунок 6.15 – Перевіряння входження відкритого ключа до дерева Меркла")

> _Зауваження. У 2011 році було запропоновано XMSS (розширену схему підпису Меркла) (рис. 6.16). Її основна відмінність – використання алгоритму WOTS+ [122]. Крім того, вона використовує додаткові маски для вузлів дерева Меркла перед їх конкатенуванням і подальшим їх гешуванням. Ця особливість має організувати безпеку про той випадок, якщо використовувана геш-функція виявиться нестійкою до колізій другого роду [123; 124]._
> 
> _Оскільки далі перейдемо до розгляду алгоритму SPHINCS, відзначмо, що він, як і XMSS, використовує бітові маски перед гешуванням вузлів дерева Меркла._

![Рисунок 6.16 – Розширена схема підпису Меркла](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.16-XMSS-signature-scheme.png "Рисунок 6.16 – Розширена схема підпису Меркла")


### Сімейство алгоритмів SPHINCS

Тепер розгляньмо будову алгоритмів SPHINCS, які використовують описані раніше схеми. Важлива особливість цих алгоритмів: вони складаються з великої кількості дерев, які спільно утворюють _hypertree_. Пропонована висота hypertree в різних алгоритмах сімейства перебуває в діапазоні 50–70 (наприклад, пропонована висота для SPHINCS-256 [118] дорівнює 60). Однак як приклад візьмімо hypertree з висотою, що дорівнює 9.

Hypertree, зі свого боку, поділяється на шари (зазвичай близько 10), кожний із яких зберігає екземпляри піддерев Меркла. Для прикладу візьмімо кількість шарів 3.

Що є піддерева Меркла, які ми використовуємо для прикладу? Кожне таке дерево має висоту, що дорівнює 3. Це значення дорівнює загальній висоті hypertree, поділеній на кількість шарів у ньому. Такі піддерева зберігають у своїх листках стиснені відкриті ключі WOTS (WOTS+).

У листках hypertree розташовано відкриті ключі HORST – стиснені за допомогою дерева Меркла значення глобального відкритого ключа. У вершині hypertree розташовано значення глобального відкритого ключа. Повну схему hypertree SPHINCS зображено на рис. 6.17.

![Рисунок 6.17 – Архітектура hypertree](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.17-hypertree-architecture.png "Рисунок 6.17 – Архітектура hypertree")

Отже, детальніше розберімо компоненти схеми. На вершині дерева розташовано значення глобального відкритого ключа, яке передається перевірячу. Це значення отримується через конкатенування та гешування листків піддерева верхнього шару hypertree (шару 2 на рис. 6.17).

Що є листки піддерева? Листки піддерева – це стиснені відкриті ключі WOTS. Що таке стиснений відкритий ключ? Пригадаймо: звичайний ключ WOTS – це набір частин ключа, який має великий розмір (приблизно 2–8 кБ). Однак можна поєднати частини ключа в структурі дерева Меркла й отримати стиснене значення з розміром 128–256 біт. Водночас до підпису додається значення Merkle branch, яке дозволяє довести факт відповідності частин ключа стисненому значенню.

Ці стиснені відкриті ключі використовуються для перевіряння підпису відкритих ключів, які розташовано на більш низькому шарі hypertree. Нижні шари hypertree працюють у такий самий спосіб аж до екземплярів відкритих ключів HORST, яким відповідають особисті ключі, якими підписуються кінцеві повідомлення.

Розгляньмо процес генерування ключів для алгоритму SPHINCS. Спочатку користувач генерує два секретні значення (найчастіше 256-бітні) – _S<sub>1</sub>_ і _S<sub>2</sub>_. Перше значення в подальшому використовуватиметься для генерування допоміжних ключів (для підписів WOTS і HORS). Друге – для вибирання листка hypertree, який буде використано для підписування, та для додання випадковості під час гешування повідомлення. Услід за цим генерується набір масок Q, які використовуватимуться для отримання підписів WOTS і HORS і для побудування дерев Меркла. З отриманих компонентів і складається особистий ключ (рис. 6.18).

![Рисунок 6.18 – Компоненти особистого ключа](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.18-private-key-components.png "Рисунок 6.18 – Компоненти особистого ключа")

Для отримання відкритого ключа необхідно побудувати піддерево, яке розташоване на вершині hypertree. Для цього ми генеруємо секретні ключі WOTS для листків цього піддерева. Відзначмо, що такі ключі породжуються детерміністично залежно від індексу екземпляру WOTS і секретного значення _S<sub>1</sub>_. Для нашого прикладу ми породжуємо 8 секретних ключів для одноразового підпису WOTS, а потім із них обчислюємо значення відкритих ключів (стиснених), які будуть листками піддерева верхнього рівня. Далі ці ключі поєднуються в деревоподібній структурі, у корені якої опиняється значення відкритого ключа SPHINCS (рис. 6.19).

![Рисунок 6.19 – Відкритий ключ SPHINCS](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.19-public-key-in-SPHINCS.png "Рисунок 6.19 – Відкритий ключ SPHINCS")

До значення відкритого ключа додається список масок _Q_, який потрібен для перевіряння підпису. У результаті, відкритий ключ – це набір значень {_global\_public\_key_, _Q_}.

Тепер перейдімо до обчислення підпису. Важлива особливість алгоритму SPHINCS – напрямок обчислення підпису знизу hypertree (з листків) до піддерева, яке розташоване на його вершині. Згідно з нашим прикладом (hypertree з висотою 9 і з 3 шарами) загалом виходить 512 листів, які є стиснені відкриті ключі HORS. Тому спочатку потрібно вибрати за допомогою відкритого ключа, з якого листка буде підписано повідомлення.

Потрібний листок вибирається за геш-значенням самого підписаного повідомлення та секретним значенням _S<sub>2</sub>_. Для цього ми використовуємо функцію, яка генерує псевдовипадкову послідовність (переважно – геш-функцію), яка приймає на вхід повідомлення й _S<sub>2</sub>_ і повертає значення індексу листка дерева (index) та додаткове значення _R_ (рис. 6.20).

![Рисунок 6.20 – Отримання індексу листка дерева для підпису](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.20-obtaining-index-of-tree-leaf.png "Рисунок 6.20 – Отримання індексу листка дерева для підпису")

Для чого використовується _R_? Це значення – таке собі salt, яке ми прикріплюємо до підписуваного повідомленням перед обчисленням його геш-значення для додання ентропії (_R_ також прикріплюється до значення підпису). З огляду на це індекс – повністю детерміноване значення і воно однакове для декількох підписів. Зі свого боку, прикріплюване до підпису _R_ дозволяє правильно обчислити підписане геш-значення стороні, яка верифікуватиме підпис.

Після того як вибрано індекс екземпляру HORS для підпису повідомлення, має бути згенеровано відповідну пару ключів цього екземпляру. Ця пара також детерміністично генерується з секрету _S<sub>1</sub>_. За допомогою згенерованої ключової пари підписується геш-значення повідомлення (рис. 6.21). _Index_, _R_, а також отримане на цьому етапі значення підпису HORS – частини кінцевого підпису SPHINCS.

![Рисунок 6.21 – Додання значень підпису](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.21-addition-of-signature-values.png "Рисунок 6.21 – Додання значень підпису")

Далі ми обчислюємо стиснений відкритий ключ екземпляру HORS. Цей відкритий ключ ми підпишемо за допомогою екземпляру WOTS, який розташований зверху за ієрархією. Для цього ми генеруємо нову пару ключів для цього екземпляру WOTS та розраховуємо значення підпису для ключа HORS. Значення цього підпису також додається до глобального підпису SPHINCS. 

Однак це ще не все. Відкритий ключ підпису WOTS має бути автентифіковано в його піддереві (рис. 6.22). Тому ми обчислюємо Merkle branch, який веде від цього ключа до кореневого значення піддерева. Для цього потрібно згенерувати ключові пари для кожного листка WOTS і побудувати відповідне дерево.

![Рисунок 6.22 – Автентифікування ключа в дереві](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.22-key-authentication.png "Рисунок 6.22 – Автентифікування ключа в дереві")

До глобального значення підпису SPHINCS додається ще й відповідне до конкретного піддерева Merkle branch. У такий самий спосіб відбувається підпису на кожному наступному рівні hypertree: кожний наступний екземпляр WOTS підписує значення відкритого ключа на нижньому рівні. У підсумку, для нашого прикладу значення підпису матиме вигляд, як на рис. 6.23.

![Рисунок 6.23 – Значення підпису SPHINCS](/resources/img/volume-3/6.2-Hash-based-signature-algorithms/F-6.23-SPHINCS-signature-value.png "Рисунок 6.23 – Значення підпису SPHINCS")

На кожному шарі hypertree до глобального значення підпису додається значення підпису WOTS і шлях автентифікації – набір значень, які доводять належність конкретного ключа до кореневого значення.

Процедура перевіряння підпису складається з меншої кількості кроків, тому що не вимагає генерування ключів для всіх листків конкретного дерева. Вхідні параметри під час верифікування – глобальний відкритий ключ та підпис для конкретного повідомлення.

На першому кроці той, хто перевіряє обчислює геш-значення від повідомлення. Для цього він використовує саме повідомлення та значення _R_, яке розташоване в підписі. Далі виконується перевіряння підпису HORS для отриманого значення. Відзначмо, що в значенні підпису не вказано значення відкритого ключа HORS. Проте через те, що відкритий ключ HORS – це геш-значення від значення підпису в стисненій формі, маючи значення підпису, ми можемо легко обчислити потрібний відкритий ключ.

Після цього потрібно перевірити підпис отриманого ключа екземпляром підпису WOTS верхнього рівня (обчислити відповідний відкритий ключ із підпису). Далі – перевірити, що отримане значення входить до структури піддерева, використовуючи Merkle branch. Оскільки Merkle branch є в підписі, ми можемо обчислити значення кореневого вузла піддерева. Це значення відкритого ключа аналогічно підписано екземпляром WOTS більш високого рівня.

Ми піднімаємося вгору в hypertree, використовуючи шляхи автентифікації та значення підписів нижніх шарів. У підсумку, ми отримаємо кореневе значення, яке ми й порівнюємо зі значенням глобального відкритого ключа користувача. Якщо значення дорівнюють один одному, підпис вважається правильним.

# [7 STABLECOINS ТА ДЕЦЕНТРАЛІЗОВАНІ ФІНАНСИ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ua/7-Stablecoins-and-decentralized-finance.md)
