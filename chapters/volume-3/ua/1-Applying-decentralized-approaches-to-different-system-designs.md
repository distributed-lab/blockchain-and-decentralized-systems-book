# [ПРО DISTRIBUTED LAB](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ua/0.2-About-Distributed-Lab.md)

# 1 ЗАСТОСУВАННЯ ДЕЦЕНТРАЛІЗОВАНИХ ПІДХОДІВ ДЛЯ ОРГАНІЗУВАННЯ РІЗНИХ СИСТЕМ

З плином часу принципи децентралізації дедалі більше використовуються під час проєктування інформаційних систем різного призначення. Децентралізовані технології використовуються за побудування мережних протоколів і протоколів оверлейних мереж, у системах обмінювання даними та повідомленнями, у пошукових і фінансових системах тощо.

У першому розділі навчального посібника розглядається, як децентралізація впливає на архітектурні зміни у звичних для користувача системах. Які складнощі організування mesh-мереж і чим вони кращі за традиційний Інтернет? Чи необхідна ідентифікація користувачу та як розподілити процес ідентифікації між незалежними сторонами? Які процеси може бути розподілено в системі аукціонів? Чи є сенс у наявності децентралізованих бірж і які є протоколи їх реалізування? Якщо ви хоча б одного разу ставили собі одне з цих запитань або під час читання вони викликали у вас цікавість, то цей розділ – для вас


## 1.1 Принципи функціонування та розвиток mesh networks

Mesh network (mesh-мережа) – фізична топологія мережі передачі даних, яка передбачає, що кожна робоча станція (комп'ютер, смартфон, телевізор тощо) має прямі з'єднання із іншими робочими станціями та виконує роль незалежного комутатора, беручи участь у передаванні їхнього трафіку.

> **_Відмінні властивості використання mesh network_**  
> * _Підвищений рівень відмовостійкості_
> * _Неможливість блокувань і фільтрації_
> * _Відсутність абонентської плати_
> * _Вільне використання (permissionless)_

Топологія mesh-мережі передбачає, що вузол (пристрій користувача) має кілька фізичних з'єднань із іншими вузлами, тобто підключений у дротовий або бездротовий спосіб без посередників. Саме через таку надлишковість та низьку ймовірність одночасного розриву декількох з'єднань підвищується рівень відмовостійкості всієї мережі [1].

Вузол mesh-мережі отримує та відправляє дані через своїх «сусідів» замість підключення до централізованого провайдера (рис. 1.1). Таким чином, частина трафіку вузла проходить через одного з його сусідів, але сусід замість того, щоб вимагати оплату за послугу, спрямовує частину свого трафіку через цей вузол. На практиці отримати послуги такої мережі може будь-хто без абонентської плати, витратившись тільки на придбання мережного пристрою і підтримання його роботи.

![Рисунок 1.1 – Передавання даних між користувачами mesh-мережі](/resources/img/volume-3/1.1-Operation-principles-and-development-of-mesh-networks/F-1.1-data-transmission.png "Рисунок 1.1 – Передавання даних між користувачами mesh-мережі")

Оскільки всю мережу підтримують виключно приватні та незалежні особи, здійснити блокування конкретних вузлів або фільтрування трафіку доволі складно. Тут може виникнути питання, чи буде законна мережа, організована в такий спосіб у межах житлового району чи цілого міста? Звісно, все залежить від ситуації та чинного на певній території законодавства, але здебільшого відповідь доволі проста: доки учасники такої мережі, розміщуючи своє обладнання, не порушують правила приватної та громадської власності, а також передбачені обмеження щодо частоти та потужності електромагнітного випромінювання, претензій із боку закону до учасників не має бути.

У мережах спеціального призначення, наприклад, між військовими або космічними об'єктами, адреси вузлів призначаються у централізований спосіб, а щоби приєднатися до мережі, потрібно пройти спеціальну процедуру реєстрації й отримати дозвіл. Водночас протоколи mesh-мереж загального призначення намагаються забезпечити властивість permissionlessness. Тому в таких мережах адреси або призначаються автоматично, або вузол самостійно генерує собі адресу. Щоб стати рівноправним вузлом mеsh-мережі, жодних додаткових дозволів отримувати не потрібно.


### Глобальна мета mesh-мереж

Є кілька протоколів для організації mesh-мереж, кожний із них спрямований на забезпечення певних властивостей і функцій під час вирішення локальних завдань забезпечення зв'язку, де не справляється традиційна топологія та централізовані провайдери. 

Однак глобальна ідея впровадження mesh-мереж – створення альтернативного і самодостатнього Інтернету, де кожний пакет даних під час передавання від вузла відправника до вузла отримувача криптографічно захищений і в якому кожний кожному є провайдер інтернет-з'єднання, отримати IP-адресу так само просто, як згенерувати випадкове число, є багато альтернативних маршрутів між будь-якими двома вузлами, а терміни, на кшталт «відмова в обслуговуванні» та «мережа недоступна», користувачам навіть не знайомі. Використання такого Інтернету буде для користувачів набагато більш приватне для користувачів і захищене від фільтрування контенту, що передається [2].

Концептуальна складність створення глобальної mesh-мережі полягає в тому, що для її старту потрібно покрити більшість планети пристроями, які в будь-який момент готові працювати за єдиним протоколом. Поки критичну масу таких пристроїв не досягнуто, порівняльна користь від них украй мала. Це значить, що для створення альтернативної глобальної мережі за принципом mesh network людям спочатку потрібно повірити в цю ідею, увімкнути підтримку таких мереж на своїх пристроях і чекати. А коли критичну масу незалежних користувачів буде досягнуто та покриття буде стабільне, таку мережу можна вважати альтернативним Інтернетом і можна відмовитися від послуг централізованих інтернет-провайдерів.

Схематичну різницю між традиційним Інтернетом і альтернативним можна побачити на рис. 1.2. У традиційному Інтернеті є провайдери мережного з'єднання, через які проходить трафік локальних груп користувачів. Крім цього, є компанії, які забезпечують канали зв'язку та маршрутизацію пакетів між локальними групами та континентами. Така централізація управління трафіком веде до двох основних проблем традиційного Інтернету. Перша пов'язана з можливістю блокування конкретних користувачів або конкретного контенту. Друга – з можливою відмовою в обслуговуванні.

![Рисунок 1.2 – Підключення користувачів у традиційному й альтернативному Інтернеті](/resources/img/volume-3/1.1-Operation-principles-and-development-of-mesh-networks/F-1.2-connection-of-users.png "Рисунок 1.2 – Підключення користувачів у традиційному й альтернативному Інтернеті")

На практиці є такі міста та навіть країни, які підключені до решти мережі тільки одним фізичним каналом. В історії відомі випадки, коли такий канал зв'язку переривав нормальне функціонування на добу чи навіть довше. У результаті, порушувалася робота багатьох бізнес-процесів, а також нормальне життя приватних осіб, і ситуація загострювалася аж до громадських заворушень.

Зі свого боку, альтернативний Інтернет передбачає, що всі канали зв'язку підтримують самі користувачі. У цьому разі рівень децентралізації управління трафіком максимальний, а ймовірності блокувань – мінімальні.

> **_Популярні протоколи для організування mesh-мереж_**  
> * _DTN_
> * _NETSUKUKU_
> * _B.A.T.M.A.N._
> * _OSPF_
> * _CJDNS_
> * _Yggdrasil_

DTN (Delay-Tolerant Networking) – одна з найбільш ранніх альтернатив традиційним мережам передачі даних [3]. Спочатку її завданням було забезпечення надійного доставлення даних у мережі з великим часом розповсюдження сигналу, тривалим очікуванням у черзі на відправлення чи тимчасовим розривом зв'язку між вузлами. Розвиток DTN почалося в 1970-х роках, коли почали з'являтися портативні комп'ютери, і дослідники зацікавилися питанням забезпечення надійності мереж, учасники яких не мають постійного підключення.

Вузли такої мережі повинні були зберігати отримані пакети даних, доки вони не будуть передані наступному вузлу. Порівняно з традиційними мережами вузли такої мережі припускають набагато триваліше зберігання пакетів і можуть їх записувати на диск для очікування в черзі на відправлення. Ця технологія – найбільш перспективна для застосування в космічному зв'язку. Тому під затримками в DTN розуміють не тільки затримки, які породжують транзитні вузли або обмеження пропускної здатності каналу зв'язку, а й додаткові затримки під час передавання сигналу, які не залежать від обсягу даних, що передаються (рис. 1.3). Такі затримки можуть залежати від швидкості розповсюдження сигналу в середовищі передачі та пройденого шляху, а також якості каналу зв'язку (якщо канал поганий, то відбуватимуться втрати даних, що потребуватиме додаткового часу на їх повторне передавання).

![Рисунок 1.3 – Приклад збереження даних з боку вузлів DTN](/resources/img/volume-3/1.1-Operation-principles-and-development-of-mesh-networks/F-1.3-data-saving-by-DTN-nodes.png "Рисунок 1.3 – Приклад збереження даних з боку вузлів DTN")

У DTN-мережах пакети, які вже пройшли частину свого шляху, зберігаються не тільки незважаючи на великі затримки, а й незважаючи на розриви каналів передачі даних (за рахунок зберігання їх на проміжних вузлах). Такий розрив може статися через обмеження дальності бездротового зв'язку, розрідженість мобільних вузлів, брак енергетичних ресурсів або завади. А за відновлення каналу між вузлами пакети, що збереглися, просто продовжують свій шлях замість повторної відправлення.

Протокол CJDNS – більш молодий проект, його перші реалізації з'явилися в 2012 році [4]. CJDNS підтримує відкрита спільнота, і він передусім слугує потребам користувачів. Порівняно з іншими протоколами він реалізує шифрування пакетів даних між відправником й отримувачем, а також шифрування даних під час передавання між усіма транзитними вузлами. Крім того, є можливість об'єднання кількох приватних mesh-мереж в одну велику, а також з'єднання вузлів через традиційний Інтернет.

Протокол CJDNS передбачає, що кожен вузол сам собі генерує криптографічні ключі для асиметричного шифрування та пов'язану з відкритим ключем мережну адресу з діапазону приватних адрес IPv6. Для фізичного з'єднання з «сусідами» може використовуватися Wi-Fi (у режимі точки доступу та клієнта одночасно) або дротовий Ethernet. Кількість вузлів у такій мережі може сягати десятків мільярдів, тому таблиця маршрутизації організована за принципами DHT (distributed hash table). Таким чином, вузол мережі зберігає тільки частину таблиці та може ефективно будувати маршрут для будь-якого пакету, звертаючись до сусідніх вузлів.

Цікавий і той факт, що в 2017 році спільнота CJDNS розкололася і частина розробників почала роботу над схожим проектом – Yggdrasil [6]. Мети проекту та принципи їх досягнення збігаються, але розробники Yggdrasil пропонують більш децентралізований спосіб маршрутизування пакетів, який дозволяє повністю уникнути централізованих вузлів-довідників.

На відміну від більшості інших, протокол B.A.T.M.A.N. (Better Approach To Mobile Adhoc Networking) у ролі ідентифікаторів вузлів використовує MAC-адреси їхніх мережних інтерфейсів. У мережі, що працює за цим протоколом, кожен вузол зберігає дві таблиці маршрутизації: локальну та глобальну. У локальній таблиці зберігається інформація про вузли, з якими є безпосереднє фізичне з'єднання, а в глобальній таблиці – найактуальніша інформація, отримана з локальних таблиць сусідів. Під час роботи кожен вузол регулярно відправляє широкомовні повідомлення з даними про свою адресу та свою локальну таблицю маршрутизації. Відзначмо, що протокол B.A.T.M.A.N. підтримує відкрита спільнота, на момент 2019 року він активно вдосконалюється та має інтеграцію до ядра Linux.

Розроблення протоколу Netsukuku було зупинено, однак він теж має деякі цікаві особливості. Наприклад, усі вузли мережі, що працюють за цим протоколом, розглядаються ієрархічно. Кожні 256 вузлів утворюють так званий груповий вузол (gnode), а 256 групових вузлів, зі свого боку, складають групу вищого порядку (ggnode) тощо. Протокол Netsukuku логічно розглядає будь-який груповий вузол як фізичний, тому маршрутизація може працювати однаково на всіх рівнях ієрархії. Перевага такого підходу полягає в тому, що за кожного пошуку маршруту необхідно оперувати щонайбільше 256 вузлами, що значно полегшує процес. Для обміну даними про стан мережі вузли використовують TP-пакет (trace path package), де не вказаний отримувач, однак є дані про всіх посередників, через яких він пройшов аж до відправника. Згідно з протоколом один із вузлів виступає ініціатором і відправляє такий пакет усім своїм сусідам, сусіди додають до отриманого пакету дані про себе та передають доповнений пакет далі, але ніхто не передає той самий пакет двічі. Виходить, що кожен вузол, який прийняв TP-пакет, отримує повний маршрут до вузла відправника, а також до кожного з вузлів-посередників.

Протокол OSPF (open shortest path first) також використовує динамічну маршрутизацію, але засновану на технології відстежування стану каналу (link-state technology). Відповідно до цієї технології кожний маршрутизатор прагне знати не тільки найкращі маршрути до кожного вузла, а й мати повну карту мережі з усіма наявними зв'язками між іншими маршрутизаторами. А для знаходження найкоротшого шляху протокол OSPF використовує алгоритм Дейкстри. У таблиці 1.1 наведено порівняння згаданих протоколів організації mesh-мереж [5].

![Таблиця 1.1 – Порівняльна характеристика наявних протоколів організування mesh-мереж](/resources/img/volume-3/1.1-Operation-principles-and-development-of-mesh-networks/T-1.1-en-characteristics-of-existing-protocols.png "Таблиця 1.1 – Порівняльна характеристика наявних протоколів організування mesh-мереж")


### Застосування mesh-мереж на практиці

Найбільш поширений і попитний варіант mesh-мереж використовує бездротові технології. У цьому разі робочі станції можуть змінювати розташування щодо інших і створювати нові фізичні з'єднання на льоту. Тоді як дротові з'єднання не дозволяють так само легко підключити одну робочу станцію до кількох інших і перепідключити за потреби.

Спочатку потреба в побудові mesh-мереж виникла у військовій справі, де в польових умовах часто необхідний автономний зв'язок. Тому мережі, що самоорганізуються, стали гарним рішенням для створення зон великої площі з суцільним і надійним покриттям. Така мережа легко масштабується за додавання нових вузлів і відмовостійка за втрати окремих елементів мережі.

Завдяки численним позитивним властивостям mesh-мережі з часом набули поширення й в інших сферах.

> **_Сфери застосування mesh-мереж_**  
> * _Військова справа (з'єднання між комп'ютерами в умовах польових операцій)_
> * _Супутниковий зв'язок (66 супутників сузір'я Ірідіум функціонують як єдина mesh-мережа)_ [7]
> * _Зв'язок у великих корпоративних середовищах_
> * _Зв'язок на територіях із нерозвиненою інфраструктурою_

У світі досі є такі міста та райони, куди не дісталися централізовані провайдери мережного підключення і де місцеві жителі вирішують забезпечити себе мережним з'єднанням, об'єднавшись у mesh-мережу. Гарний приклад – проект Guifi, який започаткувався на початку нульових, коли місцеві жителі втомилися чекати на появу в регіоні нормального інтернет-провайдера. Нині це одна з найбільших mesh-мереж у світі: вона складається з більш ніж 35 тисяч активних вузлів. Мережа розвивається на громадських засадах, і підключення до Guifi доступне цілком безкоштовно [8].

У мережі Guifi є так звані «острови» – групи вузлів, що розташовані близько один до одного та мають високу ступінь зв'язності (рис. 1.4). Кожний «острів» – це мережа, яка об'єднує користувачів району, муніципалітету чи міста. Для підключення користувачів зазвичай використовуються Wi-Fi-маршрутизатори зі спеціальною прошивкою. Зв'язок між островами може забезпечуватися зокрема через традиційний Інтернет (VPN або проксі-сервери). Крім того, вузли, підключені до традиційного Інтернету, надають й іншим користувачам Guifi доступ до нього.

![Рисунок 1.4 – Карта mesh-мережі Guifi в містах Іспанії](/resources/img/volume-3/1.1-Operation-principles-and-development-of-mesh-networks/F-1.4-map-of-mesh-network.png "Рисунок 1.4 – Карта mesh-мережі Guifi в містах Іспанії")

Пропускна здатність у кожного конкретного вузла мережі в кожному випадку різна: у деяких вона не перевищує й 1 Мбіт/с, але в багатьох районах (особливо в горах) це досі найкращий спосіб підключення до Інтернету.


### Особливості маршрутизації пакетів у мережі

Усю безліч алгоритмів маршрутизування можна розділити на два класи: реактивні (reactive) та проактивні (proactive). Реактивні алгоритми маршрутизування прокладають маршрут для пакету від вузла-відправника до вузла-отримувача тільки в момент самої потреби, що створює певну затримку під час передавання першого пакету. Основна перевага цього класу алгоритмів – відсутність фонового навантаження на мережу.

За проактивного підходу підтримання таблиць актуальних маршрутів здійснюється завдяки постійному фоновому обмінюванню між вузлами даними про зміни топології мережі, а також періодичному розсиланню спеціальних службових пакетів. Оскільки проактивний алгоритм завжди має готовий маршрут до будь-якого потенційно досяжного вузла, то додаткові затримки під час відправлення пакетів даних виключені. Але досягається ця перевага завдяки фоновому трафіку, що призводить до зниження підсумкової продуктивності мережі порівняно з використанням реактивних алгоритмів.

Ефективність роботи й проактивних, і реактивних алгоритмів різко знижується за збільшення частоти змін у топології мережі. Зниження ефективності роботи реактивних алгоритмів пояснюється тим, що кешовані маршрути транспортування пакетів швидко застарівають через руйнування зв'язків, які їх складають. У граничному разі застосування реактивного алгоритму стає неможливим через те, що маршрути доставлення пакетів старішатимуть за час їх побудування.

Використання проактивних алгоритмів в мережі з частими змінами топології призведе до різкого підвищення обсягу службового трафіку для підтримання актуальності таблиц маршрутизування, що в граничному разі призводить до ситуації, коли вся пропускна здатність мережі використовується тільки для передавання службових даних. Тому для організування процесу маршрутизування пакетів даних у мережі з топологією, що часто змінюється, ні проактивні, ні реактивні алгоритми в чистій формі не можуть застосовуватися. Вони намагаються побудувати повний шлях від вузла-відправника до вузла-отримувача, але у великій мережі з постійними змінами довгі маршрути мають надто короткий час життя. Це змушує базуватися на локальних властивостях мережі під час побудування ефективних алгоритмів маршрутизування. Локальний підхід дає дві переваги: економію ресурсів під час реагування на зміну топології мережі та простоту отримання стану решти вузів мережі.

Інший важливий принцип побудування ефективного алгоритму маршрутизування для мереж із топологією, що часто змінюється, – мінімізування реакції на зміну топології. Це досягається завдяки тому, що службові повідомлення відправляються лише малій кількості вузлів, розташованих безпосередньо близько до точки, у якій відбулася зміна топології. Водночас не потрібне змінювання всього характера маршрутизування в мережі. Таким чином, у кожного пакету даних, що передається, є повний маршрут, але повністю його дотримуватися необов'язково. Тому за виникнення розривів зв'язку чи відключенні вузла-посередника проблему вирішує локальна група з найближчих вузлів.


### Недоліки mesh-мереж

> * _Початковий запуск mesh-мережі порівняно складний_
> * _Мережа ефективно працює тільки за великої кількості вузлів_
> * _Непередбачувана пропускна здатність мережі та затримки доставлення пакетів_
> * _Проблеми побудови оптимальних маршрутів_
> * _Мережа малоефективна для отримання доступу до централізованих сервісів, розташованим у глобальній мережі_

Mesh-мережа працює ефективно тільки за достатньої зв'язності вузлів. Кожний повинен мати фізичне з'єднання з кількома іншими вузлами, і між «островами» мережі має бути достатня кількість з'єднань. Тому для початкового запуску мережі необхідно набрати критичну масу готових пристроїв.

У динамічних mesh-мережах (де вузли непередбачувано переміщуються в просторі та відключаються) неможливо прогнозувати пропускну здатність і час передавання пакету між двома вузлами мережі. Це значить, що під час скачування чи вивантаження файлу користувач не може отримати оцінку залишку часу, а під час аудіодзвінку або потокового передавання відео можуть виникати паузи, навіть якщо використовуються адаптивні протоколи передавання медіапотоку, оскільки вони не можуть вибрати оптимальні параметри для з'єднання, характеристики якого неможливо передбачити.

Проблема маршрутизації також залишається актуальною. Є кілька підходів до побудови маршрутів у динамічних мережах, але в кожного є свої недоліки: високі вимоги до обсягу пам'яті, тривалість роботи, залежність від єдиного вузла-довідника, вибір оптимального маршруту тільки за одним критерієм тощо. Оскільки ідеального рішення бути не може, дослідники надалі шукають оптимальний баланс між наявними перевагами та недоліками.

Варто також розуміти, що mesh-мережа найбільш ефективна для незалежного зв'язку приватних вузлів між собою. Наприклад, для організації корпоративної IP-телефонії mesh-мережа добре підійде, а якщо кожен член деякої групи користувачів звертатиметься тільки до «facebook.com», сенсу в такому об'єднанні буде мало.


### \*\*\*Поширені міфи\*\*\*

_Mesh-мережа не має доступу до Інтернету._

Іноді це так, тому що деякі протоколи для організування mesh-мереж не підтримують можливість транслювання пакетів до глобальної мережі та зворотньо. Проте це не означає, що такі mesh-мережі не можуть мати доступу до Інтернету. Для підключення до глобальної мережі використовуються спеціальні прокси- чи VPN-сервери, які mesh-мережі підтримують і які дозволяють використовувати Інтернет усередині mesh-мереж.


### \*\*\*Часті запитання\*\*\*

_– Як об'єднати дві mesh-мережі_

Тут може бути кілька принципово різних ситуацій. Якщо мережі використовують один протокол, який початково підтримує об'єднання мереж, тоді достатньо наявності одного спільного вузла. Якщо мережі використовують один протокол, але він не підтримує об'єднання мереж, тоді необхідне ручне налаштування бодай одного спільного маршрутизатора та транслятора мережних адрес. Якщо мережі використовують різні протоколи, то об'єднання мереж може виявитися взагалі неможливим з огляду на використання різних форматів адрес, форматів пакетів даних, наявності наскрізного (end-to-end) шифрування й інших особливостей взаємодії.

_– Чи можуть mesh-мережі та відповідні технології опинитися під забороною регулятора?_

Забороняти використовувати саму технологію дуже неправильно, позаяк вона може використовуватися для різних мет. Одні можуть використовувати mesh-мережі для передавання забороненого контенту чи приховування слідів злочинної діяльності, а інші – для досягнення цілком благородних мет. Наприклад, інтернет-провайдерам й операторам мобільного зв'язку зручно використовувати mesh-мережі для спрощення налаштування свого обладнання через самоорганізацію. Мережним адміністраторам зручно використовувати mesh-мережі для створення бездротової мережі з великою зоною покриття (торгові центри, офісні будівлі і т. ін.). У сфері інтернету речей використання mesh-мереж також дуже актуальне для виявлення найближчих пристроїв і взаємодії з ними.


## 1.2 Децентралізовані системи цифрової ідентифікації

Для кожного з нас можна скласти набір із певних атрибутів (даних), який однозначно виокремлює нашу особу з-поміж інших, причому це можуть бути як фізичні характеристики (відбитки пальців, рисунок сітківки ока), так і їхні цифрові аналоги (адреса електронної пошти, відкритий ключ цифрового підпису) (рис. 1.5). Усе це – ідентифікаційні дані, або personal identifiable information (PII) [9].

![Рисунок 1.5 – Ідентифікаційні дані користувача](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.5-user-identity-data.png "Рисунок 1.5 – Ідентифікаційні дані користувача")

Коли користувач хоче вперше скористатися послугою сервісу (наприклад, відкрити рахунок у банку, завести електронну пошту, отримати біометричний паспорт тощо), причому не важливо, чи в цифровій формі чи ні, система, найімовірніше, попросить його надати набір ідентифікаційних даних і на підставі них створить у своїй локальній базі обліковий запис, до якого запише відповідність між ідентифікаційними даними користувача та _локальним ідентифікатором_. Так у людини з'явиться _digital identity_ [10].

Процес збирання унікальних даних має назву ідентифікація. Процедура ідентифікації здебільшого необхідна, щоби сервіс розумів, з ким він взаємодіє, оскільки часто до акаунту, який закріплений за конкретним користувачем, прив'язаний набір дозволів або прав, доступних тільки конкретному користувачу [11].

> _Зауваження. Тут і далі сервіси, що надають послуги ідентифікації, ми називатимемо провайдерами ідентифікації (identity provider)._

Після проходження ідентифікації користувач отримує ідентифікатор у межах системи (рис. 1.6). За подальшої взаємодії з поточною системою користувачу не потрібно буде повторно надавати свої ідентифікаційні дані, а «впізнаватимуть» його за виданим раніше локальним ідентифікатором, у ролі якого може виступати номер рахунку в деякому банку, адреса електронної пошти, яку було використано для реєстрації в системі, або біометричний паспорт. Процедура перевіряння, що користувач – той, за кого себе видає, має назву _автентифікація_ [12].

![Рисунок 1.6 – Проходження з боку користувача процедури ідентифікації в різних провайдерів](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.6-user-identification-procedure.png "Рисунок 1.6 – Проходження з боку користувача процедури ідентифікації в різних провайдерів")

На цьому етапі важливо виокремити одне з обмежень такого підходу: бази даних провайдерів ідентифікації ніяк не пов'язані та не синхронізовані одна з одною. Це призводить до того, що конкретний ідентифікатор може використовуватися тільки в системі, у якій він був виданий. Отже, ми маємо ситуацію, коли одній фізичній особі (physical identity) відповідає багато digital identities (рис. 1.7).

![Рисунок 1.7 – Ідентифікатори користувача в різних облікових системах](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.7-user-identifiers.png "Рисунок 1.7 – Ідентифікатори користувача в різних облікових системах")

Хоча така парадигма зараз застосовується повсюдно, вона спричиняє певні незручності як для користувачів, так і для провайдерів.

> **_Недоліки наявних систем ідентифікації_**  
> * _Нераціональне використання ресурсів_
> * _Недотримання політики оброблення персональних даних_
> * _Ризик викрадення персональних даних користувача_
> * _Недотримання парольної політики_

Перший недолік полягає в тому, що користувач змушений витрачати час для реєстрації на кожному новому сервісі, заповнювати ідентичні (або майже ідентичні) реєстраційні форми, вигадувати нові лоґіни та паролі, проходити капчу, підтверджувати реєстрацію за допомогою email тощо. Погодьтеся, такий процес завдає багато незручностей, особливо якщо зрештою сервісом необхідно скористатися лише одного разу (наприклад, форматування картинки) або виявиться, що це не зовсім той сервіс, який потрібний користувачу.

Як ми згадували раніше, ідентифікаційна інформація включає персональні дані користувача, які повинні збиратися, оброблятися і зберігатися з дотриманням вимог GDPR [13] (або інших схожих нормативних документів). Абсолютно всі подібні регуляції включають один із головних принципів: необхідність контролювання володільцем власних персональних даних. Однак на практиці ситуація абсолютна не така: користувачі здебільшого навіть не уявляють, що відбувається з їхніми персональними даними після того, як вони підписали папір (або поставили галочку) про згоду на їх оброблення (рис. 1.8).

![Рисунок 1.8 – Приклад згоди на оброблення персональних даних](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.8-personal-data-processing-agreement.png "Рисунок 1.8 – Приклад згоди на оброблення персональних даних")

Найчастіше під час проходження процедури ідентифікації персональні дані передаються у відкритій формі. У такій самій формі їх й обробляє провайдер ідентифікації. Це спричиняє підвищення ймовірності перехоплення персональних даних з боку зловмисника.

Крім того, у користувача збирається велика кількість ідентифікаторів і відповідних їм паролів, необхідних для автентифікації в різних системах. Уявіть, що ви стоїте перед зачиненими дверима з великою в'язкою ключів і не можете згадати, який саме ключ підходить до цих дверей (рис. 1.9). У таких умовах користувачі намагаються спростити собі життя та використовують один пароль для доступу до різних сервісів. У цьому разі компрометація пароля на одній зі сторін призведе до отримання доступу в багатьох незалежних системах.

Слід зважати й на той факт, що парольна політика в кожного провайдера своя, і крім того, що користувачу необхідно стежити за збереженістю своїх паролів, йому потрібно ще й вчасно їх оновлювати [14].

![Рисунок 1.9 – Традиційний процес отримання доступу до системи](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.9-traditional-access-gaining.png "Рисунок 1.9 – Традиційний процес отримання доступу до системи")

Логічним рішенням може бути можливість використання раніше зібраних ідентифікаційних даних повторно. Наприклад, користувач, який уже має акаунт Google, хоче скористатися сервісом draw.io та створити діаграму. Замість того, щоби заново заповнювати реєстраційну форму та проходити процедуру ідентифікації, він може попросити Google надати сервісу потрібну інформацію. Нижче ми розглянемо, у який спосіб можливо організувати таку взаємодію.


### Будова та принципи функціонування протоколу OAuth

Протокол OAuth [15] надає рішення, яке дозволяє стороннім застосункам отримати обмежений контрольований доступ до контрольованих ресурсів (наприклад, до персональних даних користувача).

> **_Ролі в протоколі OAuth_** 
> * _Володілець ресурсу_
> * _Зберігач ресурсу_
> * _Клієнт_
> * _Сервер авторизації_

_Володілець ресурсу_ – фактично сам користувач. Він може надати дозвіл іншим сторонам (_клієнтам_) на отримання доступу до ресурсу.

_Клієнт_ – застосунок/сервіс, який може формувати запити від імені володільця ресурсу для отримання даних, які належать володільцю ресурсу.

_Зберігач ресурсу (resource server)_ – сервер, на якому зберігається захищений ресурс (наприклад, сервер Google, який зберігає дані користувача).

_Сервер авторизації (authorization server)_ – сервер, який випускає токени доступу для клієнта після його успішної автентифікації (підтвердження прав на доступ до ресурсу).

Основна ідея протоколу OAuth полягає в тому, щоби замість облікових даних користувача (його лоґіна та пароля) для доступу до захищеного ресурсу використовувати токен спеціального призначення – цифровий рядок, який містить атрибути доступу. За такими атрибутами легко визначити, до якої саме інформації було надано доступ, на який час і кому.

Токени доступу видає сервер авторизації зі схвалення володільця ресурсу. Сервіс використовує токен для отримання доступу до захищених ресурсів, розміщених на боці зберігача ресурсів (рис. 1.10).

> _Зауваження. Взаємодія між сервером авторизації та сервером ресурсів виходить за межі цього протоколу. Сервер авторизації може бути тим самим сервером, що й сервер ресурсів, чи окремим об'єктом. Один сервер авторизації може видавати токени доступу, які приймають кілька серверів ресурсів._

![Рисунок 1.10 – Функціонування протоколу OAuth](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.10-OAuth-protocol.png "Рисунок 1.10 – Функціонування протоколу OAuth")

Згідно з протоколом OAuth 2.0 передбачено такий порядок взаємодії:

1. Сервіс формує авторизаційний запит і спрямовує його володільцю ресурсу. Запит на авторизацію може бути відправлено користувачу безпосередньо (як показано на рисунку 1.10) або побічно, через сервер авторизації.

2. Володілець ресурсу передає сервісу Authorization Grant, який містить підтвердження того, що користувач насправді має права на отримання доступу до ресурсу.

3. Сервіс запитує токен доступу на сервері авторизації. Для підтвердження того, що сервіс діє від імені власника ресурсу, до запиту включається Authorization Grant, отриманий на попередньому кроці. Тут Authorization Grant виступає підтвердженням успішної автентифікації користувача на боці сервера авторизації. Зверніть увагу, що сервер, який видає токени доступу на цьому етапі, не знає, якому застосунку (клієнту) вони видаються, але точно знає, що клієнт отримав необхідний дозвіл від володільця ресурсу.

4. Сервер авторизації перевіряє дозволи сервісу (тобто розуміє, що саме власник ресурсу надає права цьому клієнту) та Authorization Grant. Якщо Authorization Grant дійсний, видає токен доступу.

5. Сервіс запитує захищений ресурс у зберігача ресурсу після автентифікації та використовує токен доступу.

6. Зберігач ресурсу перевіряє токен доступу та, якщо токен доступу дійсний, обробляє запит. На цьому етапі зберігач ресурсу точно знає, якому застосунку видається токен доступу, і точно впевнений, що це відбувається зі згоди володільця даних.

Таким чином, користувачу достатньо одного разу ввести набір персональних даних на одному сервісі, після чого, можливо, видаватиме токени доступу до різних частин такого набору різним клієнтам. Наприклад, точно за таким самим принципом, як описано вище, користувач може дозволити програмі на своєму смартфоні зберігати зроблені фото на Google Drive автоматично.


### Протоколи OpenID й OpenID Connect

OpenID пропонує концепцію створення єдиної облікової системи для різних інтернет-ресурсів, яка позбавила би користувачів від потреби постійно заповнювати реєстраційні форми (проходити процедуру ідентифікації) і, відповідно, накопичувати нові пари лоґін–пароль.

Ідея полягає в тому, щоб зберігати єдиний обліковий запис на одному сервісі (в одного з OpenID-провайдерів) і користуватися ним для реєстрації на інших сервісах, які підтримують протокол OpenID.

> _Зауваження. До списку OpenID-провайдерів належать Google, Microsoft, Symantec, Verizon, Oracle, VMware._

Протокол передбачає участь трьох сторін:

* Користувача, який хоче використовувати свій ідентифікатор OpenID
* інтернет-сервісу, доступ до якого хоче отримати користувач
* OpenID-провайдера, який раніше провів процедуру ідентифікації користувача

Протоколи OpenID першого та другого покоління [16] були націлені виключно на автентифікацію користувача на боці одного з провайдерів OpenID, результат якої передавався безпосередньо стороні, що перевіряє, – сервісу, з яким хотів взаємодіяти користувач (рис. 1.11).

![Рисунок 1.11 – Функціонування протоколу OpenID](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.11-OpenID-protocol.png "Рисунок 1.11 – Функціонування протоколу OpenID")

Процедура встановлення каналу зв'язку між інтернет-сервісом і провайдером OpenID (на кроці 3) здійснюється за внутрішнім алгоритмом check_Id, який є протокол двохпрохідної автентифікації, та дозволяє сторонам, що взаємодіють, переконатися в справжності одна одної. Опціонально між інтернет-сервісом і провайдером можливе встановлення загального секрету за протоколом Діффі–Хеллмана (у цьому разі за допомогою MAC-коду інтернет-сервіс може надійно автентифікувати провайдера без додаткових запитів щодо отримання інформації про його сертифікат). Функціонування протоколу Діффі–Хеллмана було розглянуто в 2-й частині цього навчального посібника.

Унаслідок роботи протоколу інтернет-сервіс засвідчується в тому, що користувач – той, за кого себе видає, тому що це підтвердив один із довірених провайдерів ідентифікації. Водночас жодна інша інформація про користувача не розкривається. Відзначмо, що ні OpenID 1.0, ні OpenID 2.0 не були сумісні з протоколом OAuth.

Протокол третього покоління, який отримав назву OpenID Connect [17], є надбудова над протоколом авторизації OAuth 2.0. OpenID Connect дозволяє інтернет-сервісам перевірити особу користувача на основі автентифікації, виконаної авторизаційним сервером (рис. 1.12).

У межах протоколу OpenID Connect розглядатимемо такі ролі протоколу:

* Кінцевого користувача – об'єкт, який отримує доступ до ресурсу клієнта
* Сторону-перевіряча (клієнт, RP) – сервіс, який згідно з протоколом OAuth 2.0 вимагає автентифікації кінцевого користувача та доступу до частини інформації про нього від провайдера OpenID
* OpenID-провайдера (OP) – сервер авторизації, здатний автентифікувати кінцевого користувача та надати стороні-перевірячу інформацію про подію автентифікації та про кінцевого користувача

![Рисунок 1.12 – Функціонування протоколу OpenID Connect](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.12-OpenID-Connect-protocol.png "Рисунок 1.12 – Функціонування протоколу OpenID Connect")

В узагальненій формі взаємодія в межах протоколу OpenID Connect відбувається в такий спосіб:

1. Сервіс направляє запит автентифікації до провайдера OpenID.
2. Користувач проходить процедуру автентифікації на боці провайдера OpenID, після якої користувач повідомляє, якому саме сервісу потрібно надати доступ до персональної інформації.
3. У результаті, видаються два токени (ID Token й Access Token), які включаються до AuthResponse. ID Token містить інформацію про Authentication event – набір інформації про те, який користувач ініціював видавання токенів і для якої клієнтської сторони на сервері. Access Token – це точно такий самий токен, як було описано вище в протоколі OAuth.
4. Використовуючи отриманий Access Token, перевіряльна сторона спрямовує запит на отримання інформації про користувача, яка зберігається на боці провайдера OpenID.
Провайдер OpenID перевіряє токен доступу та, якщо він дійсний, обробляє запит.


### Обмеження описаних протоколів

Запропоновані протоколи, звісно, спрощують взаємодію користувачів і провайдерів ідентифікації, проте залишається кілька ключових проблемних питань.

> * _Відсутність прямого контролю з боку користувача своїх персональних даних_
> * _Проблема довіри до централізованих провайдерів_
> * _Уразливості, пов'язані з автентифікацією за парою лоґін–пароль_
> * _Ризики, що виникають за використання сесій_
> * _Відсутність синхронізації ідентифікаційних подій_

Обидва описаних вище підходи передбачають зберігання критичної інформації (зокрема PII) користувача на одному ресурсі. Відповідно, забезпечення її збереженості повністю залежить від політики безпеки цього ресурсу, і сам ресурс цими даними фактично володіє. У підсумку, користувач досі не може повністю контролювати свої персональні дані.

Друге обмеження пов'язане з необхідністю довіри до централізованих провайдерів ідентифікації. Сервіс отримує інформацію від конкретного провайдера та вважає її правильною. Фактично, відсутня об'єктивність під час вирішення питання про довіру до окремої identity.

Метод автентифікації за парою лоґін–пароль недостатньо надійний. Компрометація пароля (а користувачі не завжди використовують дійсно сильні паролі) призводить до компрометації всіх персональних даних користувача. До того ж, якщо згадати про те, наскільки користувачі не люблять вигадувати нові паролі, то компрометація одного пароля відчиняє відразу багато «дверей».

Уразливості протоколу OAuth також пов'язані з сесійною природою протоколу. Якщо зловмиснику вдасться перехопити Authorization Grant під час такої сесії, то в нього з'явиться можливість реалізації атаки людини посередині (man-in-the-middle).

Користувач може мати кілька OpenID-ідентифікаторів, які не будуть пов'язані один із одним. Таким чином, питання наявності багатьох digital identity остаточно не вирішене.


### Принципи побудування глобальної системи ідентифікації

Нижче розглянемо, у який спосіб можливо побудувати глобальну децентралізовану систему ідентифікації. Основні принципи такої системи:

> * _Прямий контроль з боку користувача власних ідентифікаційних даних_
> * _Identity користувача містить digital digest персональних даних із метою забезпечення перевірюваності їхньої цілісності_
> * _Зв'язок ідентифікаційних даних із ключами, які належать користувачу_
> * _Розподілене зберігання ідентифікаційних даних із боку провайдерів, які ці дані підтвердили_
> * _Синхронізація ідентифікаційних подій між незалежними провайдерами_

Основна роль глобальної цифрової системи ідентифікації – зв'язування глобального ідентифікатора користувача з його відкритим ключем і персональними даними, які цьому користувачу належать, за допомогою перевіряння цього зв'язку з боку декількох identity providers (рис. 1.13).

![Рисунок 1.13 – Концепція глобальної системи цифрової ідентифікації](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.13-global-digital-identity-system.png "Рисунок 1.13 – Концепція глобальної системи цифрової ідентифікації")

Найбезпечніший підхід до автентифікації (і авторизації) полягає в тому, що для кожної облікової системи, з якою взаємодіє користувач, право проведення дозволених для ідентифікатора операцій (і доступу до дозволених даних) перевіряється за допомогою володіння відкритим ключем, до якого прив'язаний ідентифікатор. Володіння відкритим ключем перевіряється за допомогою обчислення (і подальшого перевіряння) цифрового підпису.

Облікова система, з якою в цю мить хоче взаємодіяти користувач, отримавши запит від нього, може звернутися до глобальної цифрової системи ідентифікації й отримати актуальний відкритий ключ, відповідний конкретному ідентифікатору, після чого перевірити підпис запиту (рис. 1.14).

![Рисунок 1.14 – Перевіряння зв'язку ідентифікаційних даних із відкритим ключем за отримання запиту](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.14-verification-of-link-of-identification-data.png "Рисунок 1.14 – Перевіряння зв'язку ідентифікаційних даних із відкритим ключем за отримання запиту")

Зберігання критичної (sensitive) інформації у відкритій формі вимагає дорогих методів захисту, проте можливо зберігати не саму інформацію, а її цифровий відбиток (геш-значення), за яким буде легко визначити, що користувач дійсно володіє доступом до своїх персональних даних.

Користувач повинен мати можливість зберігати різні набори ідентифікаційних даних у різних облікових системах і за потреби надавати інформацію, яку запитує третя сторона, не створюючи нового набору.

Уявімо собі користувача, у якого є акаунти в декількох облікових системах, які зберігають потрібні їм набори персональних даних (рис. 1.15).

![Рисунок 1.15 – Дані, які зберігають різні провайдери ідентифікації](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.15-data-stored-by-different-identity-providers.png "Рисунок 1.15 – Дані, які зберігають різні провайдери ідентифікації")

Наприклад, користувач хоче оформити електронний страховий поліс на новий автомобіль. Для цього страхова компанія вимагає надати такий набір даних: адреса електронної пошти, на яку потрібно надіслати поліс, паспортні дані, підтвердження наявності достатньої кількості коштів для внесення щомісячних платежів, дані водійського посвідчення.

На сьогодні навіть із використанням описаних вище протоколів немає зручного для користувача способу дистанційно надати страховій компанії необхідний набір даних. Навіть якщо страхова компанія приймає OpenID-ідентифікатори, користувачу після проходження процедури автентифікації потрібно буде «вручну» надавати необхідний пакет документів. Протокол OAuth також не дає помітного виграшу, позаяк для його застосування користувачу буде потрібно авторизувати всі свої клієнтські програми (якщо вони є взагалі) в обліковій системі страхової компанії.

У концепції глобальної системи ідентифікації користувачу, за суттю, потрібно буде сформувати та надати страховій компанії набір дозволів із зазначенням, у яких із наявних облікових систем зберігаються частини необхідного набору даних (рис. 1.16). Такий набір дозволів може підписуватися особистим ключем користувача, так що кожний із провайдерів ідентифікації зможе надійно перевірити, що запит виконується з дозволу володільця даних (користувача).

![Рисунок 1.16 – Отримання інформації від різних провайдерів ідентифікаці](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.16-retrieving-information.png "Рисунок 1.16 – Отримання інформації від різних провайдерів ідентифікаці")

Водночас можна побачити, що запити від страхової компанії надходять тільки до тих облікових систем, які вказав користувач. Таким чином, йому не довелося самому формувати та надавати необхідний набір інформації, як і не довелося заводити додатковий акаунт у новій обліковій системі.


### Розширення можливостей глобальної системи ідентифікації за допомогою технології blockchain

Організація мережі між провайдерами ідентифікації з використанням технології blockchain дозволить створити розподілену базу даних із мітками часу для кожної проведеної транзакції. Транзакцією в такій системі може бути подія проходження з боку користувача процедури ідентифікації в одного з провайдерів. Це робить транзакції легко відстежуваними, незворотними, а також запобігає шахрайству, зловживанням і будь-яким іншим видам маніпуляцій.

Після проведення процедури ідентифікації користувача провайдер додає відповідний запис до ланцюжка блоків. Якщо користувачу потрібно отримати доступ до іншого сервісу, користувач звертається до нього, використовуючи власний ідентифікатор.

Система, зі свого боку, запитує дані про те, хто з інших провайдерів уже ідентифікував користувача. Володілець кожної системи самостійно визначає, наскільки довіряти подіям ідентифікації (а відповідно, і результатам цих подій), які випускає інша система. Якщо рівень довіри максимальний, то система надає користувачу послугу на підставі його ідентифікатора. Якщо довіра до системи (або набору систем) нижча, то клієнт може запитати дані користувача та переконатися, що вони відповідають тим, які зберігаються в розподіленому реєстрі.

Варто зазначити, що доступ до персональних даних здійснюється тільки після схвалення користувача. Якщо наданих даних достатньо, система дає користувачу доступ; якщо ні (наприклад, необхідні додаткові дані), то система окремо проводить ідентифікацію користувача з відповідним записом у реєстрі.

Розгляньмо, як можна в такій системі організувати процедуру ідентифікації (також відому як «Know Your Customer», KYC) (рис. 1.17).

![Рисунок 1.17 – Проходження з боку користувача ідентифікації з доданням відповідної події до системи](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.17-passing-identification-procedure.png "Рисунок 1.17 – Проходження з боку користувача ідентифікації з доданням відповідної події до системи")

1. Аліса відправляє свій відкритий ключ і дані, необхідні для проходження процедури KYC, банку, який є провайдером ідентифікації.
2. Банк поміщає отримані персональні дані користувача до надійного сховища KYC, дотримуючись вимог GDPR. Зверніть увагу, що дані KYC повинен зашифрувати банк і тільки він може безпосередньо отримати доступ до даних сховища. Якщо дані KYC хоче отримати стороння організація, їй необхідно зв'язатися з банком, який, перш ніж надати ці дані, запитає схвалення користувача.
3. Провайдер KYC отримує доступ до даних користувача та проводить процедуру KYC (таким провайдером може бути як сам банк, так і сторона, якій банк довіряє проведення цієї процедури).
4. Після цього провайдер KYC передає банку результати проходження процедури KYC. Якщо процедура не вдалася, банк інформує користувача про це, а користувач додає відсутні дані і повторює крок 1.
5. Якщо процедура KYC була успішно завершена, банк створює транзакцію, яка містить відкритий ключ користувача (який підписаний ключем банку) і значення геш-функції від усіх користувацьких даних (як доказ зберігання цих даних). Також він додає до транзакції інформацію про те, що він ці дані підтвердив. Вузли-валідатори обробляють транзакцію та додають її до ланцюжка блоків.
6. Банк повертає Алісі підписану транзакцію. Аліса може перевірити, що відповідний запис було додано до ланцюжка блоків і що дані в транзакції відповідають даним, які вона відправила.
7. Якщо Боб хоче змінити свій відкритий ключ, він інформує про це свій орган ідентифікації (у нашому прикладі це центр сертифікації пенсійного фонду).
8. Пенсійний фонд створює транзакцію, яка містить інформацію про анулювання раніше дійсного сертифіката, і додає її до ланцюжка блоків. Валідатори обробляють транзакцію та додають її до ланцюжка блоків, унаслідок чого раніше встановлений відкритий ключ стає недійсним для всіх учасників системи.

Тепер розгляньмо, як можна організувати використання ідентифікатора для доступу до сервісів інших організацій (рис. 1.18).

![Рисунок 1.18 – Процес отримання доступу до сервісів за використання отриманого ідентифікатора](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.18-gaining-access-to-services.png "Рисунок 1.18 – Процес отримання доступу до сервісів за використання отриманого ідентифікатора")

1. Попередньо банк додає подію ідентифікації Аліси до розподіленої бази даних, як ми описали вище.
2. Аліса хоче взаємодіяти з пенсійним фондом. Вона не зареєстрована в ньому, але пенсійний фонд також є вузол у системі ідентифікації. Вона формує запит до пенсійного фонду, до якого включає свій ідентифікатор (відкритий ключ), і підписує запит особистим ключем, який підтверджує право власності на ідентифікатор.
3. Пенсійний фонд перевіряє підтвердження ідентифікатора Аліси в розподіленої базі. Якщо пенсійний фонд довіряє банку щодо ідентифікації та сертифікації користувачів, він надає відповідну послугу Алісі.
4. Якщо пенсійний фонд недостатньо довіряє банку (наприклад, банк – молода компанія), він може запитати ідентифікаційні дані Аліси в банку (якщо Аліса дає на це свою згоду).
5. У цьому разі банк отримує дані зі сховища та передає їх пенсійному фонду. Зверніть увагу, що Аліса має надати дозвіл на доступ до її персональних даних під час формування запиту до пенсійного фонду.
6. Пенсійний фонд отримує дані та може перевірити їхню достовірність (геш від даних, що зберігаються в розподіленій базі), після чого фонд надає Алісі доступ до його послуг.
7. Пенсійний фонд зобов'язаний зберігати цю інформацію, тому він має відразу отримати її та зберегти у своєму сховищі.


### Digital identity для IoT

Є дев'ять основних застосувань IoT (рис. 1.19) [78].

![Рисунок 1.19 – Сфери використання Internet of things](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.19-IoT-application-areas.png "Рисунок 1.19 – Сфери використання Internet of things")

За допомогою технології блокчейн можливо організувати систему ідентифікації, яка підходить усім: у сфері електронної охорони здоров'я для надійного обміну інформацією про елементи медичного обладнання, у промисловості – для автентифікації даних, її компонентів і виробників тощо. Як приклад розгляньмо можливий спосіб організації системи ідентифікації, що містить інформацію про датчики автомобіля (рис. 1.20).

![Рисунок 1.20 – Використання системи ідентифікації для організування інфраструктури для IoT](/resources/img/volume-3/1.2-Decentralized-digital-identity-systems/F-1.20-identification-system-with-IoT-infrastructure.png "Рисунок 1.20 – Використання системи ідентифікації для організування інфраструктури для IoT")

1. Виробники датчиків розміщують ідентифікатори та відкриті ключі своєї продукції в системі ідентифікації.
2. Датчики передають інформацію з бортового комп'ютера автомобіля (водночас підписуючи всі повідомлення, що передаються).
3. Бортовий комп'ютер звертається до розподіленого реєстру та перевіряє дійсність відкритих ключів датчиків.
4. На підставі отриманої інформації бортовий комп'ютер подає команди на механізми автомобіля.
5. Припустімо, Єва хоче відправити хибну інформацію від імені одного з датчиків.
6. Комп'ютер запитує відкритий ключ, який відповідає отриманому ідентифікатору. Оскільки в системі відсутня identity Єви (а якщо й присутня, то до неї прив'язане інше значення відкритого ключа), бортовий комп'ютер не оброблятиме отриманий запит.


### \*\*\*Часті запитання\*\*\*

_– Чи може децентралізована система підтримувати багатофакторну автентифікацію? Як це працюватиме, якщо в ролі першого фактору я хочу використовувати знання, а в ролі другого фактору – свої біометричні дані?_

Децентралізована система ідентифікації може підтримувати багатофакторну автентифікацію, водночас процес буде розділено на кілька етапів. На першому ви, наприклад, проходите автентифікацію в першого провайдера (вводите секретний PIN-код). Однак для децентралізованої системи не буде достатньо підтвердження тільки від одного провайдера для того, тому вам необхідно буде додатково пройти біометричну автентифікацію з участю другого провайдера (який зберігає ваші біометричні дані). Таким чином, тільки після проходження декількох підтверджень децентралізована система буде впевнена в тому, що ви – той користувач, за якого себе видаєте.

_– Які алгоритми досягнення консенсусу застосовні для систем ідентифікації, що використовують технологію blockchain?_

Оскільки користувачі цих систем проходять ідентифікацію, це permissioned середовище. Для досягнення консенсусу в такому середовищі зазвичай використовуються такі алгоритми: BFT, FBA, DPoS, PoA.


## 1.3 Децентралізовані платформи електронного голосування

У найпростішому випадку голосування можна визначити як спосіб прийняття колективного рішення, який передбачає формування спільної думки на основі підрахунку голосів членів певної групи. У цьому підрозділі ми розглянемо кілька способів організації електронного голосування, переваги та недоліки описаних підходів, а також використання цих підходів на практиці.


### Проблеми традиційних підходів до проведення голосування

Традиційні підходи до голосування можна вважати достатньо ефективними та безпечними, тільки коли справа стосується опитування серед мешканців одного будинку щодо кольору вхідних дверей або вибирання капітана команди під час займання спортом. У контексті більш масштабних і вимогливих заходів, як-от загальнонаціональні вибори чи референдуми, вони ніколи не були такими; просто до певного часу не було кращих альтернативних способів організувати голосування в перерахованих сферах.

Таким підходам властиві такі недоліки й обмеження:

> * _Непрозорість процедури підрахунку голосів_
> * _Можливість наявності підроблених виборців_
> * _Псевдоанонімність тих, хто голосує_
> * _Можливість спотворення голосів у бюлетенях_

Перше обмеження полягає в тому, що підрахунок голосів на платформі голосування виконується в довіреному закритому середовищі. Виборець змушений довіряти тим, хто формує й оголошує результати голосування, і не може самостійно переконатися в тому, що його голос ураховано правильно (рис. 1.21).

![Рисунок 1.21 – Непрозорість процедури підрахунку голосів](/resources/img/volume-3/1.3-Decentralized-e-voting-platforms/F-1.21-non-transparency-of-vote-counting-procedure.png "Рисунок 1.21 – Непрозорість процедури підрахунку голосів")

У контексті другого обмеження напрошується аналогія з «мертвими душами»: база даних виборців може бути в неактуальному стані на момент проведення голосування і, до того ж, є ризик, що голосувати можуть користувачі, які не існують. Тобто необхідне надійне джерело даних про тих, хто голосує, роль якого, фактично, може виконувати окремий орган (як це реалізовано зараз) або система ідентифікації (як це має бути реалізовано в підсумку).

З огляду на наявність третього обмеження в традиційних підходах особа того, хто голосує, може бути розкрита і, крім того, на того, хто голосує, може чинитися тиск, щоби він віддав голос за «правильного» кандидата (рис. 1.22). Цей тиск також може бути виражений у підкупі виборця, загрозі фізичного насильства, псуванні професійної репутації й т. ін.

![Рисунок 1.22 – Псевдоанонімність того, хто голосує](/resources/img/volume-3/1.3-Decentralized-e-voting-platforms/F-1.22-pseudo-anonymity-of-voter.png "Рисунок 1.22 – Псевдоанонімність того, хто голосує")

Четверте обмеження пов'язане з тим, що після голосування частина бюлетенів залишаються порожніми, адже деякі виборці за власним бажанням не беруть участі в голосуванні; заповнивши їх, можна створити голоси з нізвідки. Тут само варто враховувати, що, зіпсувавши валідні бюлетені, можна позбутися від справжніх голосів. До того ж, відомі випадки, коли на виборчій дільниці були використані ручки з чорнилом, що зникає [18].

Відзначимо, що багато голосувань нині досі проходить у нецифровій (ручній) формі. Окрім їхньої неефективності та небезпечності, вони вимагають великих фінансових витрат. Однак є й системи електронного голосування; кілька прикладів таких систем ми розглядаємо далі.


### Електронне голосування в Естонії

У 2005 році Естонія стала першою державою в світі, яка провела загальнонаціональні вибори з використанням електронного голосування, а в 2007 році вона використовувала його під час парламентських виборів [19]. Можливість проголосувати в електронній формі було впроваджено додатково до традиційного способу голосування (на виборчій дільниці з паперовим бюлетенем).

I-Voting (Internet-voting, інтернет-голосування) – це система, яка дозволяє виборцям голосувати в будь-якій точці світу, використовуючи необхідне ПЗ. Фактично, вирішувалася проблема, яка полягала в тому, що під час використання будь-якого методу дистанційного голосування, зокрема традиційні поштові бюлетені, є можливість примусового або купленого голосування. Рішення Естонії полягає в тому, щоб дозволити виборцям входити до системи та голосувати декілька разів у період попереднього голосування. Оскільки кожний голос скасовує попередній, виборець має можливість змінити свій голос; але за кожної спроби проголосувати повторно система запитує в користувача підтвердження цієї дії [19].

Інфраструктура системи I-Voting показана на рис. 1.23. Вона включає такі компоненти:

* Клієнт голосування (Voting Client)
* Застосунок перевіряння голосу (Verification App)
* Сервер пересилання голосів (Vote Forwarding Server)
* Сервер журналювання (Log Server)
* Сервер зберігання голосів (Vote Storage Server)
* Сервер підрахування голосів (Vote Counting Server)
* Апаратний модуль безпеки (HSM)

![Рисунок 1.23 – Інфраструктура системи I-Voting](/resources/img/volume-3/1.3-Decentralized-e-voting-platforms/F-1.23-I-Voting-system-infrastructure.png "Рисунок 1.23 – Інфраструктура системи I-Voting")

Для участі в процедурі голосування I-Voting необхідно завантажити на комп'ютер клієнтський застосунок; він містить призначений для виборів відкритий ключ для шифрування голосу ((PK<sub>elect</sub>)) і сертифікат TLS для сервера пересилання. Протягом періоду попереднього голосування виборець входить до системи, використовуючи ID-картку чи Mobile-ID.

Клієнтське ПЗ перевіряє identity сервера за допомогою раніше згаданого сертифіката, а сервер, виходячи з відкритого ключа виборця, підтверджує його право голосувати та відображає для нього відповідний список кандидатів (_C_).

Виборець робить вибір _c_. Після цього клієнт здійснює доповнення голосу _c_ за алгоритмом RSA-OAEP [20] і зашифровує його конкретним відкритим ключем виборів ((PK<sub>elect</sub>)). Для зашифрованого голосу (_b_) користувач обчислює підпис (_σ_) за допомогою свого особистого ключа (SK<sub>voter</sub>).

Сервер отримує зашифрований і підписаний голос _v_, пов'язує його з унікальним ідентифікатором _x_ і повертає _x_ клієнту (рис. 1.24) [21].

![Рисунок 1.24 – Процес передавання голосу](/resources/img/volume-3/1.3-Decentralized-e-voting-platforms/F-1.24-vote-casting.png "Рисунок 1.24 – Процес передавання голосу")

Виборець може перевірити, чи було його голос правильно записана на сервері голосування, за допомогою окремого застосунка. Відсканувавши код QR, який показує клієнт для голосування, він отримує _r_ й _x_. Застосунок відправляє _x_ на сервер пересилання й отримує від нього _b_ та _C_. Для кожного варіанту голосу _c_' він обчислює зашифровану форму та порівнює її з отриманим раніше b; якщо збіг знайдено, тоді застосунок показує виборцю _c_', інакше повідомляє про помилку. Сервер дозволяє провести таку перевірку тричі для голосу протягом тридцяти хвилин після здійснення голосу (рис. 1.25) [21].

![Рисунок 1.25 – Процес перевіряння голосу](/resources/img/volume-3/1.3-Decentralized-e-voting-platforms/F-1.25-vote-verification.png "Рисунок 1.25 – Процес перевіряння голосу")

> _Зауваження. Під час виконання процедури, описаної вище, виборець може перевірити, що він не припустився помилки під час вибирання варіанту голосу. Утім, він не може переконатися, що його голос згодом буде правильно підраховано._

Після закінчення онлайн-голосування сервер зберігання перевіряє ще раз підписи зашифрованих голосів й анулює невалідні та застарілі голоси. Цифровий підпис виборця (_σ_) відокремлюється від голосу (_b_) до того, як він надходить на сервер підрахування голосів, що забезпечує анонімність виборця (тобто сервер зберігання не передає цифрові підписи на сервер підрахування). Набір анонімних зашифрованих голосів (_B_) переносять на сервер підрахування. Сервер підрахування використовує апаратний модуль безпеки, який містить особистий ключ виборів (SK<sub>elect</sub>) для розшифрування голосів і підраховує голоси за кожного кандидата (_counts[c]_). Підсумок підрахування електронних голосів (_counts_) об'єднується з підсумком ручного голосування та публікується як загальний результат виборів [21]. Ці дії виконує виборча комісія (рис. 1.26).

![Рисунок 1.26 – Процес підрахування голосів](/resources/img/volume-3/1.3-Decentralized-e-voting-platforms/F-1.26-vote-counting.png "Рисунок 1.26 – Процесс подсчета голосов")

Результати електронного голосування не публікуються до кінця голосування в день виборів (день ручного голосування). Після підрахунку голосів (зазвичай наступного дня) голоси повторно перераховують для перевірки їхньої цілісності. Щоби підсумок підрахунку можна було перевірити публічно, електронні голоси змішуються і перевпорядковуються. Під час аудиту даних аудитор також перевіряє цілісність скриньки для бюлетенів, правильність анулювання повторних голосів й анонімізації голосів. Як й аудитор, сторонні спостерігачі також можуть проводити аналогічні процедури перевіряння [22].


### Електронне голосування у Швейцарії

У Швейцарії з 2003 року було проведено понад 200 спроб упровадження електронного голосування в різних кантонах. Утім, електронне голосування досі не стало постійним явищем; у листопаді 2018 року право голосувати в електронній формі було менше, ніж у 4% зареєстрованого населення. Для порівняння: в Естонії в 2017 році 31% всіх голосів було віддано в електронній формі [23].

За минулі роки було випробувано дві системи. Перша з них була власною розробкою кантону Женева. Кілька інших кантонів її також намагалися впровадити, однак у 2018 році було оголошено, що ця система передчасно припинить свою роботу через високі витрати на її підтримання [23].

Друга система – Swiss Post – це розробка іспанської групи Scytl. У двох кантонах систему використовують із 2016 та 2017 року відповідно й для федеральних голосувань, і для місцевих виборів [24].

Електронне голосування з використанням системи Swiss Post задумано як додатковий канал голосування, який пропонується поряд із голосуванням поштою та ручним голосуванням. Процес голосування проілюстровано на рис. 1.27; він складається з таких етапів:

1. Формування бюлетенів (визначення предмета голосування та списку варіантів голосу).
2. Генерування кодів доступу та підтвердження.
3. Підготування та доставлення матеріалів для голосування.
4. Зашифрування урни для бюлетенів і розподілення ключів.
5. Голосування (заповнення та відправлення бюлетенів).
6. Доставлення запечатаної урни для бюлетенів.
7. Розшифрування урни та підрахування електронних голосів.
8. Опублікування результатів і статистики.

Система Swiss Post (у центрі) безпосередньо взаємодіє з тим, хто голосує, на кроках 3 та 5. З органом влади – на кроках 1, 4 та 6.

![Рисунок 1.27 – Цикл голосування з використанням системи Swiss Post](/resources/img/volume-3/1.3-Decentralized-e-voting-platforms/F-1.27-voting-with-Swiss-Post-system.png "Рисунок 1.27 – Цикл голосування з використанням системи Swiss Post")

Станом на жовтень 2019 року в Швейцарії не впроваджено систему електронного голосування, яка діє постійно. До цього моменту уряд лише планував, щоби щонайменше 18 із 26 кантонів надавали можливість проголосувати в електронній формі на парламентських виборах [23].

### Децентралізований підхід до проведення електронного голосування

Децентралізований підхід може покращити процес голосування, підвищуючи надійність, безпечність і стійкість системи голосування. Розгляньмо кілька важливих властивостей, які може привнести цей підхід:

> * _Можливість перевіряння правильності підрахування голосу_
> * _Відмовостійкість системи_
> * _Анонімність тих, хто голосує_
> * _Можливість перевіряння справжності голосів_
> * _Захист від підроблення голосів_

Далі ми розглянемо один із прикладів децентралізованого голосування.


### Приклад схеми голосування без центрального органу

Ми розглянемо протокол, який не використовує центральний орган, який створив М. Меррітт у 1982 році [25]. Припустімо, що Аліса, Боб, Керол і Дейв голосують щодо чого-небудь. Нехай у кожного виборця є пара ключів (відкритий і особистий), а також їхні відкриті ключі відомі один одному (рис. 1.28). 

![Рисунок 1.28 – Учасники голосування](/resources/img/volume-3/1.3-Decentralized-e-voting-platforms/F-1.28-voting-participants.png "Рисунок 1.28 – Учасники голосування")

Нехай _E_ – це функція зашифрування, _R_ – випадковий рядок, а _V_ – рядок, що містить голос (наприклад, номер варіанту відповіді). Для зручності виокремімо в цьому протоколі такі етапи: формування голосів, відправлення голосів, підтвердження та підрахування голосів.
На етапі формування голосів кожний виборець робить такі дії (рис. 1.29):

1. Додає випадковий рядок _R<sub>0</sub>_ (salt) до свого голосу.
2. Шифрує результат кроку 1 відкритим ключем Дейва.
3. Шифрує результат кроку 2 відкритим ключем Керол.
4. Шифрує результат кроку 3 відкритим ключем Боба.
5. Шифрує результат кроку 4 відкритим ключем Аліси.
6. Додає новий випадковий рядок до результату кроку 5 і шифрує отримане відкритим ключем Дейва.
7. Додає новий випадковий рядок до результату кроку 6 і шифрує отримане відкритим ключем Керол.
8. Додає новий випадковий рядок до результату кроку 7 і шифрує отримане відкритим ключем Боба.
9. Додає новий випадковий рядок до результату кроку 8 і шифрує отримане відкритим ключем Аліси.

![Рисунок 1.29 – Схема формування голосу](/resources/img/volume-3/1.3-Decentralized-e-voting-platforms/F-1.29-vote-configuration.png "Рисунок 1.29 – Схема формування голосу")

Кінцеве повідомлення виборця матиме такий вигляд: $E_{\text{A}}(R_{4} \Vert E_{\text{B}}(R_{3} \Vert E_{\text{C}}(R_{2} \Vert E_{\text{D}}(R_{1} \Vert E_{\text{A}}(E_{\text{B}}(E_{\text{C}}(E_{\text{D}}(V \Vert R_{0}))))))))$. Кожний, хто голосує, зберігає всі проміжні результати на кожному кроці обчислень. Ці результати використовуватимуться в подальших кроках протоколу для підтвердження, що голос конкретного виборця буде підраховано.

Етап відправлення голосів передбачає таку послідовність дій (рис. 1.30):

1. Кожний, хто голосує, відправляє зашифрований голос Алісі.
Аліса розшифровує всі голоси, використовуючи свій особистий ключ, видаляє всі випадкові рядки на цьому рівні, перетасовує всі голоси та надсилає результат Бобу. Тепер кожний голос матиме такий вигляд: $E_{\text{B}}(R_{3} \Vert E_{\text{C}}(R_{2} \Vert E_{\text{D}}(R_{1} \Vert E_{\text{A}}(E_{\text{B}}(E_{\text{C}}(E_{\text{D}}(V \Vert R_{0})))))))$.
2. Боб розшифровує всі голоси, використовуючи свій особистий ключ, перевіряє, чи є його голос серед надісланих голосів, видаляє всі випадкові рядки на цьому рівні, тасує голоси та надсилає результат Керол. Тепер кожний голос матиме такий вигляд: $E_{\text{C}}(R_{2} \Vert E_{\text{D}}(R_{1} \Vert E_{\text{A}}(E_{\text{B}}(E_{\text{C}}(E_{\text{D}}(V \Vert R_{0}))))))$.
3. Керол розшифровує всі голоси, використовуючи свій особистий ключ, перевіряє, чи є її голос серед надісланих голосів, видаляє всі випадкові рядки на цьому рівні, тасує голоси та надсилає результат Дейву. Тепер кожний голос матиме такий вигляд: $E_{\text{D}}(R_{1} \Vert E_{\text{A}}(E_{\text{B}}(E_{\text{C}}(E_{\text{D}}(V \Vert R_{0})))))$.
4. Дейв розшифровує всі голоси, використовуючи свій особистий ключ, перевіряє, чи є його голос серед надісланих голосів, видаляє всі випадкові рядки на цьому рівні, тасує голоси та надсилає результат Алісі. Тепер кожний голос матиме такий вигляд: $E_{\text{A}}(E_{\text{B}}(E_{\text{C}}(E_{\text{D}}(V \Vert R_{0}))))$.

![Рисунок 1.30 – Схема передавання голосу](/resources/img/volume-3/1.3-Decentralized-e-voting-platforms/F-1.30-vote-submission.png "Рисунок 1.30 – Схема передавання голосу")

Подальші дії належать до етапу підтвердження та підрахування голосів (рис. 1.31):

1. Аліса розшифровує всі голоси, використовуючи свій особистий ключ, перевіряє, чи є її голос серед надісланих голосів, підписує всі голоси та надсилає результат Бобу, Керол і Дейву. Тепер кожний голос матиме такий вигляд: $S_{\text{A}}(E_{\text{B}}(E_{\text{C}}(E_{\text{D}}(V \Vert R_{0}))))$.
2. Боб перевіряє та видаляє підписи Аліси. Він розшифровує всі голоси, використовуючи свій особистий ключ, перевіряє, чи є його голос серед надісланих голосів, підписує всі голоси та надсилає результат Алісі, Керол і Дейву. Тепер кожний голос матиме такий вигляд: $S_{\text{B}}(E_{\text{C}}(E_{\text{D}}(V \Vert R_{0})))$.
3. Керол перевіряє та видаляє підписи Боба. Вона розшифровує всі голоси, використовуючи свій особистий ключ, перевіряє, чи є її голос серед надісланих голосів, підписує всі голоси та надсилає результат Алісі, Бобу та Дейву. Тепер кожний голос матиме такий вигляд: $S_{\text{C}}(E_{\text{D}}(V \Vert R_{0}))$.
4. Дейв перевіряє та видаляє підписи Керол. Він розшифровує всі голоси, використовуючи свій особистий ключ, перевіряє, чи є його голос серед надісланих голосів, підписує всі голоси та надсилає результат Алісі, Бобу та Керол. Тепер кожний голос матиме такий вигляд: $S_{\text{D}}(V \Vert R_{0})$.
5. Усі перевіряють підпис Дейва. Вони переконуються, що їхні голоси перебувають серед отриманих (знаходячи свій випадковий рядок).
6. Усі видаляють випадкові рядки з кожного голосу та підраховують голоси. У такий спосіб кожний учасник отримує власний результат голосування.

![Рисунок 1.31 – Схема підтвердження та підрахування голосів](/resources/img/volume-3/1.3-Decentralized-e-voting-platforms/F-1.31-vote-confirmation-and-tallying.png "Рисунок 1.31 – Схема підтвердження та підрахування голосів")

Аліса, Боб, Керол і Дейв негайно дізнаються, якщо хто-небудь із них спробує шахраювати. Щоби виявити шахрайство, тут не потрібно жодних центральних органів. Наведімо приклад зі спробою шахрайства, щоби побачити, як це працює.

Якщо хто-небудь намагається додати голос, Аліса виявить цю спробу на другому етапі голосування, коли вона отримає більше голосів, ніж кількість користувачів, що беруть участь у голосуванні. Якщо Аліса спробує додати голос, Боб також виявить це на другому етапі голосування.

Спритніша є підміна одного голосу іншим. Позаяк голоси шифруються різними відкритими ключами, кожний може створити стільки правильних голосів, скільки потрібно. На кожному етапі (2 і 3) підміна голосу на різних етапах виявляється по-різному.

Якщо хто-небудь замінить один голос іншим на третьому етапі голосування, його дії будуть виявлені відразу. На кожному кроці голоси підписуються та надсилаються всім виборцям. Якщо виборець виявляє, що його голосу більше немає з-поміж набору голосів, він негайно припиняє виконання протоколу. Оскільки голоси підписуються на кожному кроці та кожний може повернутися в третій частині протоколу на кілька кроків назад, то виявити шахрая, що підміняє голоси, легко.

Заміна одного голосу іншим у другій частині протоколу більш тонка. Аліса не може зробити підміну, тому що Боб, Керол і Дейв виявлять це на наступних кроках. Якщо Боб замінить голоси Керол і Дейва (пам'ятайте, він не знає, кому який голос належить), Керол або Дейв помітять це далі (на своїх кроках). Вони не знатимуть, хто підмінив їхні голоси (хоча це має бути хтось, що вже обробив голоси), але вони знатимуть, що їхні голоси підмінено. Якщо Бобу пощастило і йому вдалося підмінити голос Аліси, вона не помітить цього до третьої частини протоколу. Тоді вона виявить зникнення свого голосу, але не зможе дізнатися, хто підмінив його. На другому етапі голосу перемішуються та не підписуються на кожному кроці, тому ніхто не зможе виконати протокол у зворотному напрямку та визначити, хто підмінив голоси.

Інша форма шахрайства – спроба дізнатися, хто за кого проголосував. Через перетасування голосів у другій частині ніхто не зможе виконати протокол у зворотному напрямку та зв'язати голоси та тих, хто голосує. Видалення випадкових рядків у другій частині також вирішальне для збереження анонімності: якби рядки не видалялися, перемішування голосів могло б бути інвертоване за допомогою повторного зашифрування отримуваних голосів відкритим ключем того, хто їх тасував. Коли протокол зупиниться, конфіденційність голосів збережеться.

До того ж, через початковий випадковий рядок (_R<sub>0</sub>_) навіть однакові голоси шифруються по-різному на кожному кроці протоколу. Ніхто не може дізнатися значення голосу на останньому кроці третього етапу.

Які проблеми цього протоколу? По-перше, для виконання протоколу потрібно здійснювати громіздкі обчислення. У наведеному прикладі в голосуванні беруть участь тільки четверо, але й він уже складний. Такий протокол не зможе працювати під час реальних виборів із десятками тисяч тих, хто голосує.

По-друге, Дейв дізнається результати виборів раніше за інших. Хоча він і не може вплинути на результат, він отримує певну перевагу.

По-третє, деякий учасник може скопіювати голос іншого учасника, навіть не знаючи його змісту заздалегідь. Щоб зрозуміти, чому це може стати проблемою, розгляньмо приклад голосування для трьох тих, хто голосує, – Аліси, Боба та Єви. Припустимо, що Єві не важливі результати голосування, але вона хоче знати, як голосувала Аліса, і для цього копіює її голос. У результатах більшість голосів гарантовано буде у варіанту відповіді, за який голосувала Аліса: або 3 з 3, якщо Боб голосував за той самий варіант відповіді, або 2 з 3, якщо інакше.


### Використання технології blockchain для системи електронного голосування

Для застосування децентралізованого електронного голосування до звичайних виборів необхідний протокол, який одночасно дозволяє забезпечити прозорість голосування й анонімність користувачів. Блокчейн як технологія, на якій може (але не зобов'язана) бути базована децентралізована система, може забезпечити такі особливості:

> * _Виборець може будь-коли переконатися, що його голос було підраховано правильно_
> * _Наявність доказу права голосувати та перевіряння цілісності голосу завдяки використанню цифрових ключів і підписів_
> * _Підроблення голосу неможливе, позаяк його відразу буде виявлено в історії відправлення голосів_

Перша та найважливіша перевага використання blockchain для організування платформи голосування полягає в тому, що користувач дійсно може переконатися в тому, що його голос було пораховано правильно та що результати голосування спираються на проведені транзакції. Водночас можуть використовуватися методи забезпечення анонімності тих, хто голосує (наприклад, кільцеві підписи) зі збереженням перевірюваності результатів голосування.

Використання криптографічних підписів і ланцюжка блоків дозволяє забезпечити перевірку справжності та цілісності всіх відправлених транзакцій. Водночас важливо забезпечити надійне джерело інформації про відкриті ключі тих, хто голосує. Маючи надійну інфраструктуру відкритих ключів, кожний користувач зможе перевірити, що голоси виходили від осіб, які існують, водночас інформація щодо відправника голосу може бути прихована.

Голоси в цьому разі також не може бути змінено заднім числом, оскільки таку зміну буде видно всім учасникам мережі, які зберігають історію транзакцій (можливо, навіть полегшеним вузлам). Якщо системі голосування необхідно надавати можливість переголосування, то це може здійснюватися тільки за допомогою відправлення нової транзакції.

Варто відзначити, що ті платформи електроного голосування, які можна назвати децентралізованими, передусім націлені на забезпечення можливості перевіряння результатів і того, чи було враховано голос конкретного учасника. Це саме ті властивості, які не забезпечують традиційні системи голосування.

### \*\*\*Часті запитання\*\*\*

_– Які ще є методи забезпечення приватності користувачів у системах електронного голосування?_

Як один із альтернативних варіантів забезпечення приватності можна використовувати механізм кільцевих підписів. Якщо набір відкритих ключів користувачів заздалегідь відомий, то той, хто голосує, може використовувати відкриті ключі з цього набору та свій особистий ключ для формування кільцевого підпису голосу. Нагадаємо, що під час перевіряння підпису такого типу верифікатор може переконатися, що підпис обчислив один із учасників групи, але водночас не може визначити, хто саме.

_– Чи децентралізовані системи електронного голосування в Естонії та Швейцарії? Якщо ні, то чому їх розглядають поза контекстом традиційних підходів до голосування_

Обидві розглянуті системи не децентралізовані; обидві передбачають наявність центрального органу, який приймає та підраховує голоси (виборчої комісії). Вони поєднують традиційні способи організування голосування з можливістю проголосувати без паперових бюлетенів і фізичної присутності на виборчій дільниці (з голосуванням в електронній формі).


## 1.4 Технології децентралізованих бірж

Біржа – це майданчик, де покупці та продавці можуть укладати угоди між собою. Біржа може займатися торгівлею товарами (товарна біржа), цінними паперами (фондова біржа), валютою (валютна біржа), найманням працівників (біржа праці) й іншою діяльністю. З появою криптовалют й інших цифрових активів виникла потреба функціонування відповідних бірж, які підтримують обмін таких активів на фіатні валюти та взаємний обмін.

Першими виникли централізовані біржі. Вони виступають посередниками та відповідають за зберігання й управління всіма коштами, які торгуються на платформі. Перша біржа, що підтримувала bitcoin, – Bitcoinmarket.com – з'явилася 17 березня 2010 року [26].

> **_Проблеми централізованих бірж_**  
> * _Ризики зламу майданчиків_
> * _Ключі від монет контролює біржа_
> * _Ризик заборон_
> * _Необхідність повної довіри до біржі з боку користувачів_

Основний недолік – ризик зламу платформи. Централізовані біржі вразливіші перед шахраями та хакерами, тому що вони є гарна ціль: усі кошти зберігаються централізовано (до того ж, відправлення монет криптовалюти незворотне та доволі складно відстежуване без спеціальних засобів), що спрощує завдання зловмиснику (замість того, щоб проводити дорогі атаки з невеликою вигодою на кінцевих користувачів, він атакує біржу). На рис. 1.32 можна оцінити наслідки найвідоміших зламів централізованих бірж [27–40].

![Рисунок 1.32 – Злами централізованих бірж і фінансові втрати від них](/resources/img/volume-3/1.4-Decentralized-exchange-technologies/F-1.32-attacks-on-centralized-exchanges.png "Рисунок 1.32 – Злами централізованих бірж і фінансові втрати від них")

Другий недолік полягає в тому, що ключі від монет контролює біржа, а значить, користувач має повністю довіряти самій біржі. Саме тому біржа може обмежити користувачів за спроби виведення коштів із платформи. Дуже часто користувачі витрачають багато сил і коштів для відновлення доступу до монет після отримання повідомлення «Виведення коштів тимчасово відключено для цього рахунку» [41].

Окрім цього, є ризик державних (і не тільки) заборон й обмежень. У біржі можуть вилучити сервери, та й сама біржа може заблокувати рахунки жителів якоїсь країни через політичну ситуацію. Найгучніші заборони та репресії відбулися в Китаї та Кореї [42]. Наприклад, китайська влада закрила біржу криптовалют BISS (у зв'язку з порушенням законодавства країни) і заарештували десять осіб, підозрюваних у причетності до її операцій у листопаді 2019 року [43].

Також централізована біржа працює тільки з верифікованими користувачами, тому на цьому етапі властивість анонімності здебільшого буде втрачено. Користувачі мають дотримуватися вимог KYC, які передбачають надання документів, що посвідчують їхню особу.

Звідси виникає інший ризик – витікання персонально ідентифікованої інформації (PII) через централізовані біржі. У 2018 році було опубліковано інформацію про продаж даних користувачів таких бірж: Bittrex, Poloniex, Bitfinex і Binance [44].


### Принципи функціонування децентралізованих бірж

Альтернативою, яка вирішує перераховані проблеми, можуть стати децентралізовані біржі (рис. 1.33). Такі платформи дозволяють користувачам зберігати контроль над коштами та займаються тільки зіставленням ордерів користувачів, що бажають обмінятися (й іноді гарантуванням безпеки цих обмінів).

![Рисунок 1.33 – Відмінність функціонування централізованих та децентралізованих бірж](/resources/img/volume-3/1.4-Decentralized-exchange-technologies/F-1.33-difference-in-operation-of-exchanges.png "Рисунок 1.33 – Відмінність функціонування централізованих та децентралізованих бірж")

На відміну від централізованої, децентралізована біржа не зберігає ключі від коштів користувачів, а є лише платформа для проведення транзакцій без посередників, тобто відсутня будь-яка централізована сторона, яка контролює та забезпечує функціонування децентралізованої біржі. Є декілька підходів до організування децентралізованих бірж:

> * _Escrow_
> * _Atomic swap_
> * _Smart contracts_
> * _Internal exchanges_

Слід розуміти, що децентралізовані біржі – це не одна конкретна технологія. Є багато бірж і багато відповідних технологій. Насамперед їх варто відрізняти за способом організації процесів, як-от створення order book, зберігання order book, керування доступом до order book, а також _order matching_. Є такі децентралізовані біржі, де частину процесів виконують вручну самі користувачі. Наприклад, такими процесами можуть бути обмінювання відкритими ключами для створення проміжних адрес або аудитування смарт-контрактів, які гарантують здійснення чи скасування обміну. З огляду на це DEX можна поділити щонайменше на дві групи:

* З on-chain order book
* З off-chain order book

В ідеальному разі децентралізована біржа могла би працювати з необмеженою кількістю цифрових валют, з необмеженою кількістю користувачів (торговців) та дозволяла би здійснювати trustless обміни. Така децентралізована біржа була б одна, тому що більша кількість була би не потрібна. У цьому контексті найбільш пригожа технологія – atomic swap у поєднанні з відкритою системою створення order book. Утім, це лише ідеальний варіант децентралізованої біржі; практично люди лише намагаються досягти чогось схожого.


### Escrow

Рахунок escrow – це спеціальний рахунок для безпечного проведення розрахунків між покупцем і продавцем. Його ще називають умовним рахунком, тому що кошти з нього можна перевести лише після виконання певних умов. За такої взаємодії покупець кладе гроші на рахунок escrow, а продавець може їх забрати, коли виконає умови, заздалегідь прописані в договорі. Безпечність функціонування цього підходу лежить на незалежному посереднику, який стежить за виконанням умов.

Подібні рахунки найчастіше використовуються під час обмінювань криптовалюти на фіатні валюти, однак вони ж можуть використовуватися під час обмінювання однієї криптовалюти на іншу. Обмін відбувається за таким принципом: криптовалюта утримується, доки не буде здійснено платіж. Наприклад, дві людини, які хочуть обмінятися доларами та біткоїнами знаходять один одного. У такому разі вибирається посередник, який стежитиме за тим, щоб угода відбувалася чесно для обох сторін. Разом вони створюють MultiSig-адресу 2-з-3 (рахунок escrow). Один ключ належатиме тому, хто хоче отримати долари, другий – тому, хто хоче отримати біткоїни, а третій – посереднику. Для здійснення транзакції достатньо 2 підписів: або сторони домовляються між собою, або в разі виникнення сперечання посередник приймає позицію однієї зі сторін і допомагає вирішити розбіжності (за відповідну винагороду). Одна з бірж, які реалізують цю технологію, – BitSquare.


### Atomic swap

Atomic swap – це технологія, яка дозволяє здійснити обмін одного цифрового активу на інший без централізованих посередників. Обов'язкові умови для здійснення atomic swap: обмінювані валюти повинні мати однаковий алгоритм гешування та підтримувати контракти з блокуванням за гешем та часом (HTLC). Ми вже детально розглядали функціонування atomic swap у другій частині навчального посібника.

Не всі криптовалюти підтримують atomic swap, що є певний недолік цієї технології. До тих, які на цю мить підтримують цю технологію, належать Bitcoin, Ethereum й інші подібні до них проекти. Варто відзначити, що досі немає єдиного стандарту для atomic swap. Усі, хто зараз використовує atomic swap, використовують криптографію та смарт-контракти без єдиного стандарту.

> _Зауваження. Перші згадки про цю технологію були в 2013 році. Однак тільки 20 вересня 2017 року розробники Decred створили перший смарт-контракт, використовуючи SCRIPT, щоби дозволити атомарний обмін між Decred і Litecoin [45]._

Приклад біржі, яка використовує ці технології, – BarterDEX [46]. BarterDEX – це децентралізована біржа, побудована на платформі Komodo, яка використовує технології atomic swap.

> _Зауваження. Komodo використовує алгоритм досягнення консенсусу delayed proof-of-work (dPoW). dPoW включає механізм, який нотаріально засвідчує блоки в ланцюжку. Цей алгоритм передбачає зберігання резервних копій транзакцій у вибраному ланцюжку блоків, щоб у разі атаки на Komodo усю історію можна було відновити. Ця можливість досягається через додання в блок «знімка» поточного стану системи._

Біржа BarterDEX підтримує понад 100 різних монет і токенів, серед яких – Bitcoin-based валюти, Ethereum-based валюти, токени, випущені на платформі Ethereum. Обмеження цієї платформи – неможливість проведення обмінів між цифровими та фіатними валютами.

Важлива особливість платформи полягає в тому, що _order book_ також децентралізована. Для функціонування order book, BarterDEX підтримує користувацьку peer-to-peer мережу, яка використовує два типи вузлів: _full-relay node_ і _non-relay node_.

Основна відмінність між типами вузлів полягає в тому, що full-relay node – зазвичай користувач із великим обсягом продажів, який забезпечує ліквідність ув обмін на те, щоби бути _trading hub_ в мережі. Це дозволяє йому здійснювати операції швидше, ніж його торговельні конкуренти. Non-relay nodes – вузли кінцевих користувачів, які використовують BarterDЕХ під час обмінювання одного цифрового активу на інший.


### 0x protocol

Проект був заснований у жовтні 2016 року [47]. _0x_ – це не платформа, що реалізує децентралізовану біржу. Це відкритий permissionless протокол (контракт) для децентралізованого обмінювання, який функціонує в Ethereum.

Усі обміни проходять _off-chain_. У самому ланцюжку записується тільки результат взаємодії у формі транзакції. Записи в ланцюжку містять тільки дані про зміни прав власності (інші дані до ланцюжка не потрапляють).

Обмінювання відбувається згідно з такими кроками:

1. Користувач створює order, описує бажаний обмінний курс та термін його дії (після якого order не може бути виконано), після чого підписує його особистим ключем.
2. Далі йому потрібно знайти іншого користувача, з яким він може обмінятися. Якщо такий користувач заздалегідь визначений, то можна просто відправити ордер _0x_ безпосередньо (тобто електронною поштою, через чат або позабіржову платформу). Якщо ж контрагент іще не знайдений, то замовлення відправляється до relayer. Relayer веде книгу замовлень поза ланцюжком блоків. За допомогою їх користувачі можуть знаходити, створювати, виконувати чи скасовувати ордери. Relayer також може спілкуватися з іншими relayer-вузлами та створювати набір замовлень для збільшення ліквідності (рис. 1.34).

![Рисунок 1.34 – Відправлення orders relayer-вузлам](/resources/img/volume-3/1.4-Decentralized-exchange-technologies/F-1.34-sending-orders-to-relayer-nodes.png "Рисунок 1.34 – Відправлення orders relayer-вузлам")

3. Щойно хтось знаходить ордер і бажає здійснити за ним обмін, він відправляє до ланцюжка блоків ордер разом із сумою, яку він бажає заповнити. На відміну від біржі, relayer не проводить операцію. Він може тільки полегшити торги, подаючи ордери користувачів, що транслюються в мережі.
4. Покупець відправляє смарт-контракту децентралізованої біржі свій підпис разом із підписом автора ордеру.
5. Контракт перевіряє цифровий підпис користувачів і виконує всі умови угоди. Якщо все правильно, то задіяні активи будуть атомарно обміняні між двома користувачами. Якщо будь-яку з умов замовлення не буде виконано, заявку на виконання ордеру буде відхилено.

> _Зауваження. Як ми згадували раніше, у 0x є два типи ордерів: broadcast order і point-to-point order. Перший аналогічний до звичайного ордеру на біржі: користувач відправляє в мережу заявку про те, що готовий купити (продати) певну суму токенів за вказаною ціною. Другий же передбачає наявність попередньої домовленості про купівлю-продаж між володільцями двох конкретних акаунтів. Ця схема дозволяє здійснювати обмін багатьма каналами, зокрема email і месенджерами. Ініціатор угоди відправляє на relayer-вузол свою заявку, а відгукнутися на неї може лише володілець зазначеного в ній акаунта._


### Internal exchanges

Internal exchange – це біржа, яка функціонує в межах облікової системи та дозволяє користувачам обмінюватися між собою правами власності на активи, облік яких здійснюється в цій системі. Біржі цього типу функціонують на платформах Stellar і Bitshares.

Система Stellar може використовуватися для зберігання та передавання прав власності на будь-який актив: на долари, євро, біткоїни, акції, золото й інші. Будь-який актив у системі можна обміняти на будь-який інший.

Уявімо, що користувач хоче обміняти BTC на ETH.

1. Користувач створює offer, який потім перевіряється на відповідність в order book для заданої пари активів.
2. Якщо знаходиться відповідність, то відбувається угода. В іншому разі offer зберігається в order book і перебуває там, доки не буде створено відповідний йому order або доки його не скасує користувач.
3. Можливий варіант, коли обмін відбуватиметься не однією операцією. Якщо ж order book обміну має дуже великий розкид або його навіть немає, тоді можна отримати більше вигоди, якщо зробити обмін декількома ходами (рис. 1.35). Наприклад, якщо хочемо обміняти актив BTC на ETH, то можна спочатку обміняти BTC на XLM, і тільки потім – XLM  на ETH.

![Рисунок 1.35 – Обмін із декількома посередниками](/resources/img/volume-3/1.4-Decentralized-exchange-technologies/F-1.35-exchange-through-several-intermediaries.png "Рисунок 1.35 – Обмін із декількома посередниками")

Ці шляхи конвертування активів можуть містити до 6 стрибків (hops), але весь платіж атомарний – або він буде успішний, або жодний із переказів не буде виконано (відправник платежу ніколи не залишиться з непотрібним йому активом). Процес пошуку найкращого шляху сплачування називається pathfinding. Пошук шляху включає перегляд поточних замовлень і пошук серії обмінів, яка забезпечує найвигіднішу угоду.

> _Зауваження. Internal exchange в Bitshares має власну on-chain order book. Цоби зробити обмін, необхідно створити транзакцію, де користувач заявляє, що готовий міняти один актив на інший. Потім ця транзакція розповсюджується в мережі й отримує підтвердження, після чого інший користувач може у такий самий спосіб заявити, що хоче міняти ті самі активи в тому самому відношенні. У момент підтвердження другої транзакції згідно з протоколом оновлюються баланси обох користувачів. Принципи функціонування Bitshares ми розглядали в другій частині цього навчального посібника._

### \*\*\*Часті запитання\*\*\*

_– Чому внутрішні біржі облікових систем Bitshares і Stellar теж називають децентралізованими біржами (DEX), хоча вони існують тільки в межах однієї облікової системи та не підтримують активи інших систем?_

Річ у тому, що варіант внутрішніх бірж з'явився набагато раніше, ніж метод atomic swap й ідея trustless обмінів між різними обліковими системами. До того ж, якщо всі процеси внутрішньої біржі децентралізовані, то її за визначенням можна назвати DEX. Також можна відзначити, що у внутрішньої біржі є низка переваг порівняно з біржею на основі atomic swap. Наприклад, менший час підтвердження, відсутність необхідності прямої взаємодії учасників угоди, виконання угоди без участі користувача, зазвичай менша кількість транзакцій і комісій для виконання однієї угоди.

_– Що під час обміну за допомогою Stellar гарантує те, що користувач не залишиться з проміжною валютою, яка йому не потрібна?_

Групування (batching) – це концепція об'єднання декількох операцій в одній транзакції. Це гарантія того, що під час виконання низки операцій після відправлення в мережу в разі збою однієї операції всі операції в транзакції завершуються невдало [80]. Наприклад, якщо ми хочемо обміняти BTC на ETH, то за відсутності можливості здійснити обмін безпосередньо, можна, припустімо, спочатку обміняти BTC на XLM, і тільки потім – XLM на ETH. У такому разі ці транзакції групуються, і якщо одну з них не буде виконано, то й усі інші буде скасовано.

_– Чи є у децентралізованих бірж внутрішні токени чи криптовалюти?_

На сьогодні є кілька бірж, що використовують свій внутрішній токен для сплачування комісійних зборів під час проведення транзакцій на своїх платформах. Прикладами платформ, що використовують свій нативний токен усередині власної екосистеми, є такі біржі: Binance (Binance Coin), Bitfinex (UNUS SED LEO), Huobi (Huobi Token), OKEx (OKB), Kucoin (KuCoin shares), Exmo (EXMO Coin), BitMax (BitMax Token), Bibox (BibBox Token), FTX (FTX Token), Gate.io (GateChain Token).

_– Припустімо, на деяку біржу ми вносимо деяку суму USDT однієї облікової системи (Omni Layer), а потім виводимо з неї відповідну суму USDT іншої системи (Ethereum). Чи вважається в такому разі активи взаємозамінними (fungible)?_

За цією самою схемою можна обміняти в незнайомця на вулиці $100 на цеглу. Утім, після такого обміну взаємозамінними долар і цегла не стають, чи не так? Є погляд, що цифрові активи не можна вважати повноцінно взаємозамінними, якщо їх можливо мінімально відрізнити один від одного. Якщо хоча б одна сторона обміну не погоджується обмінювати актив A<sub>1</sub> на актив A<sub>2</sub>, що мінімально відрізняється від A<sub>1</sub>, то взаємозамінності між цими активами фактично немає.


## 1.5 Децентралізований аукціон

Аукціон – це спеціально організований ринок продажу товарів, послуг або активів, у класичному варіанті якого учасники самі пропонують ціну (роблять ставки), за яку готові купити товар, а покупцем (переможцем) стає учасник, який зробив найвищу ставку. Таким чином, головне завдання аукціону – не здійснення угод, а визначення переможця та ціни.

Спочатку організація таких ринків полягала в тому, що продавці та покупці збиралися разом, оглядали товар і проводили аукціон за чергою для кожного товару. Надійність такої організації аукціону полягає у відкритості дій учасників, тобто кожний бачить (чує) ставку кожного безпосередньо та може переконатися в правильності визначення переможця та ціни (рис. 1.36).

![Рисунок 1.36 – Схема взаємодії учасників офлайн-аукціону](/resources/img/volume-3/1.5-Decentralized-auction/F-1.36-interaction-in-offline-auction.png "Рисунок 1.36 – Схема взаємодії учасників офлайн-аукціону")


### Принцип роботи онлайн-аукціону

З поширенням Інтернету почали з'являтися й онлайн-аукціони. Такий підхід організування має наступні переваги: брати участь в аукціоні можна віддалено, тривалість аукціону може бути значно більшою, аукціони можуть проходити паралельно для багатьох товарів.

Однак до 2015 року онлайн-аукціони створювалися виключно як централізовані рішення. На таких майданчиках, за суттю, крім учасників аукціону (продавців і покупців), необхідний організатор. Роль організатора полягає в тому, що він приймає ставки від учасників і після завершення аукціону оголошує переможця (рис. 1.37). У цьому разі організатор і є центр прийняття рішень, який не передбачає можливості аудиту кожного запиту користувача. Очевидний недолік такої організації полягає в тому, що учасники не можуть переконатися в правильності рішень, які прийняв організатор.

![Рисунок 1.37 – Схема взаємодії учасників централізованого онлайн-аукціону](/resources/img/volume-3/1.5-Decentralized-auction/F-1.37-interaction-in-centralized-online-auction.png "Рисунок 1.37 – Схема взаємодії учасників централізованого онлайн-аукціону")

Опишімо найпростіший сценарій поведінки порушника. Припустімо, Анатолій – організатор онлайн-аукціону, де незабаром буде виставлено на продаж велику ділянку з гарним цегляним будинком біля центрального парку. Про це знає Тарас. Тарас також знає, що такий будинок можна без труднощів продати за 100 тисяч монет. Тому до початку аукціону з будинком Тарас приходить до Анатолія та просить його налаштувати свій онлайн-майданчик так, щоб він не брав ставки вищі за 30 тисяч монет. Тарас пропонує Анатолію винагороду 10 тисяч монет, якщо він оголосить Тараса переможцем аукціону з можливістю купити ділянку з будинком за 30 тисяч монет. У такому разі після закінчення аукціону Тарас може купити ділянку з будинком за заниженою ціною, а продавець навіть не буде знати про те, що були охочі сплатити більше.

Незважаючи на те, що організатор централізованого онлайн-аукціону не є посередник і не бере участі в самій угоді, він може вибрати переможця на свій розсуд і в такий спосіб уплинути на ціну товару. Тому централізовані онлайн-аукціони вимагають довіри з боку як продавців, так і покупців. Проблему довіри, а також проблему взаємодії користувачів різних майданчиків можна вирішити за допомогою децентралізованого підходу.


### Принцип роботи децентралізованого онлайн-аукціону

Виконання завдання забезпечення відмовостійкості аукціону під час приймання ставок від учасників можна забезпечити через використання спільної бази даних, захищеної від модифікацій. Наприклад, якщо всі учасники публікуватимуть дані про товар і ставки до бази даних Bitcoin, то історія їхніх дій залишатиметься цілісною та захищеною від модифікацій, а оскільки база даних відкрита, то кожний учасник самостійно може обчислити переможця.

На перший погляд може здатися, що цього достатньо для нормального функціонування аукціону та вже можна обійтися й без участі організатора. Але на практиці такий спосіб не працюватиме, позаяк він не захищений від учасників, які не збираються купувати товар, а лише завищують ціну фальшивими ставками.

Далі розгляньмо один із підходів до організації децентралізованого онлайн-аукціону, який успішно застосовується на практиці [48]. Він передбачає, що є велика кількість незалежних майданчиків, де продавець може зареєструватися та створити лот на продаж товару, а покупець може зареєструватися, довести свою платоспроможність і робити ставки. Зазвичай у різних майданчиків різні власники, різні застосунки й інтерфейси користувача, різна локалізація, різні методи доведення платоспроможності, різні набори підтримуваних категорій товарів і т. ін. Однак усі ці майданчики підтримують єдиний протокол спільного обліку лотів і ставок. Вони є фактичні вузли-валідатори децентралізованої облікової системи, куди самі ж і записують дії своїх користувачів. У цьому разі лот, створений користувачем одного майданчику, буде доступний і користувачам усіх інших майданчиків, а також ставку, зроблена користувачем одного майданчику, збережуть усі майданчики та буде видно всім користувачам (рис. 1.38).

![Рисунок 1.38 – Схема взаємодії учасників децентралізованого онлайн-аукціону](/resources/img/volume-3/1.5-Decentralized-auction/F-1.38-interaction-in-decentralized-online-auction.png "Рисунок 1.38 – Схема взаємодії учасників децентралізованого онлайн-аукціону")

Цей підхід як механізм досягнення консенсусу використовує алгоритм на основі BFT, де вага кожного валідатора (майданчику) пропорційний кількості його користувачів. Таким чином, що якісніший сервіс надає майданчик, то більше в нього буде користувачів і то більше буде його вага в досягненні консенсусу за аналогією з механізмами досягнення консенсусу на основі proof-of-stake. Якщо користувачі помічають, що володілець їхнього майданчика неправильно обробляє їхні запити чи відмовляє в обслуговуванні, то вони переходять на інший майданчик, у такий спосіб зменшуючи вагу «поганих» майданчиків і збільшуючи вагу «добрих».

Для захищення системи від фальшивих користувачів і фальшивих ставок використовуються цифрові квитанції, які засвідчив банк. Під час реєстрації на майданчику користувач надає квитанцію, засвідчену цифровим підписом свого банку, яка підтверджує його платоспроможність. Усі майданчики публікують такі квитанції в спільній базі даних для підтвердження кількості своїх користувачів і відповідних платежів за лотами.

З погляду простоти використання децентралізованого аукціону, побудованого за таким підходом, він порівнюваний із централізованим рішенням – застосунком зі звичайним акаунтом. А з погляду можливостей і надійності – має переваги: лоти та ставки синхронізуються між усіма майданчиками, імовірність змови мінімізована.

Ще одна відмінна риса цього підходу полягає в тому, що володільці вже давно наявних централізованих платформ онлайн-аукціонів можуть відносно легко перейти на нову платформу. Для цього не потрібно будувати всю інфраструктуру з нуля чи переводити користувачів на нові незвичні застосунки; достатньо в наявну інфраструктуру інтегрувати вузол децентралізованої мережі (network node), а для початку синхронізації володільці майданчиків мають обмінятися адресами мереж і відкритими ключами.


### \*\*\*Поширені міфи\*\*\*

_Децентралізований аукціон гарантує переможцю отримання відповідного товару чи послуги._

Децентралізований аукціон може гарантувати тільки те, що будь-хто охочий може самостійно провести аудит облікової системи й отримати той самий результат, що й інші чесні аудитори. Фактично, результат роботи аукціону – не виконана угода, а визначений переможець і ціна. Далі переможець і продавець діють самостійно та можуть використовувати результати роботи аукціону для захищення своїх прав.

### \*\*\*Часті запитання\*\*\*

_– Як боротися з можливими перевантаженнями децентралізованої облікової системи, яка обробляє дії всіх користувачів за всіма лотами?_

Одночасно може бути декілька окремих децентралізованих облікових систем, кожна з яких обробляє аукціони за окремим типом товарів або послуг. Водночас майданчик може синхронізуватися з декількома обліковими системами одночасно, а її користувачі навіть можуть не знати, що їхні дії фіксуються в різних системах. Це виключає наявність однієї перевантаженої облікової системи та позбавляє майданчики оброблення даних про товари, які не цікавлять її користувачів. Наприклад, майданчик Аліси синхронізується з обліковими системами аукціонів із торгівлі автомобілями, домашніми меблями та зимовим одягом, а майданчик Боба синхронізується з обліковими системами аукціонів із торгівлі автомобілями, комп'ютерами та домашніми тваринами.

_– Чи будь-який користувач може виставити лот на торговельний майданчик?_

Так. Зазвичай усі цифрові аукціони розміщені на цифрових біржах та кожний учасник ідентифікований для участі в аукціонах. Однак перш ніж виставити лот, необхідно підтвердити його наявність. Це може бути реалізовано за допомогою цифрових сертифікатів, що видає сторона, якій довіряє та чи інша біржа, на чиїй платформі розташований торговельний майданчик та проводиться аукціон.

# [2 ПІДПИСИ ШНОРРА ТА ПОВ'ЯЗАНІ З НИМИ ОНОВЛЕННЯ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ua/2-Schnorr-signatures-and-their-application.md)
