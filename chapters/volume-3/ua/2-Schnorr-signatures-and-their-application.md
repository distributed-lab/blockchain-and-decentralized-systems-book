# [1 ЗАСТОСУВАННЯ ДЕЦЕНТРАЛІЗОВАНИХ ПІДХОДІВ ДЛЯ ОРГАНІЗУВАННЯ РІЗНИХ СИСТЕМ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ua/1-Applying-decentralized-approaches-to-different-system-designs.md)

# 2 ПІДПИСИ ШНОРРА ТА ПОВ'ЯЗАНІ З НИМИ ОНОВЛЕННЯ


## 2.1 Особливості та застосування підписів Шнорра

Ще з 2014 року спільнота Bitcoin розглядає можливість і необхідність додання підписів Шнорра до протоколу облікової системи. Основна причина додання такого типу підписів полягає в поточному розмірі доказів володіння монетами. Справа в тому, що понад 40% звичайної транзакції займають докази володіння монетами – значення відкритого ключа та цифрового підпису. У разі реалізації механізму мультипідпису така ситуація погіршується ще сильніше, позаяк підпис надається для кожного відкритого ключа окремо, що, зі свого боку, веде до пропорційного збільшення розміру доказів.

А що означають для Bitcoin великі обсяги доказів? Це величезні транзакції, за які користувачам потрібно платити. Це мала кількість транзакцій у блоках і в підсумку низька пропускна здатність системи. Це великий розмір mempool і збільшення комісії за використання мультипідпису.

Алгоритм підпису Шнорра було розроблено ще в 1980 році, і він теоретично може позбавити користувачів від перерахованих вище недоліків [49]. Однак чому ж його відразу не було реалізовано в протоколі Bitcoin? Справа в тому, що на момент створення першої версії ПЗ він був запатентований і його не можна було використовувати в програмному забезпеченні з відкритим вихідним кодом. Водночас ECDSA був чинний, перевірений стандарт, і тому саме його і було реалізовано в протоколі Bitcoin. У цьому розділі ми розглянемо принципи функціонування підписів Шнорра, особливості їх застосування в протоколі Bitcoin і причини для їх застосування, а також те, як ці підписи вже було впроваджено в інших облікових системах і те, до чого призвело їх додання.


### Переваги підписів Шнорра

У другій частині навчального посібника ми розглядали особливості функціонування двох типів мультипідпису: тип, який передбачає агрегування відкритих ключів і значень підпису, і тип, який не дозволяє цього (окреме значення підпису перевіряється окремим відкритим ключем). Підписи Шнорра, на відміну від ECDSA, належать до першого типу підписів, а саме дозволяють агрегування відкритих ключів до єдиного спільного значення, а також агрегування значень підпису. Тобто, на відміну від використовуваних ECDSA-мультіподпісей (розмір яких лінійно збільшується залежно від кількості підписантів), мультипідпис, сформований за допомогою алгоритму Шнорра, не відрізняється за розміром від одиночного підпису (рис. 2.1).

![Рисунок 2.1 – Розмір мультипідпису, обчисленого за ECDSA та за алгоритмом Шнорра](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.1-size-comparison-for-multisignatures.png "Рисунок 2.1 – Розмір мультипідпису, обчисленого за ECDSA та за алгоритмом Шнорра")

У цьому й полягає основна та найбільш попитна властивість підписів Шнорра: зменшення розміру доказів володіння монетами за використання мультипідпису. Зменшення підсумкового розміру підпису на вході транзакції призводить до збільшення пропускної здатності системи (відповідно, до зменшення розміру комісії, яку потрібно сплатити за місце в блоці).

Утім, цю концепцію може бути розширено ще більше. Що, якщо ми використовуватимемо такі підписи одночасно для всіх входів транзакції? Процедура підпису найчастіше полягає в поданні всіх полів транзакції як байтового рядка та підписанні цього рядка (точніше, її геш-значення). Відповідно, найчастіше (коли використовується signature hash type SIGHASH_ALL) кожний вхід однієї транзакції містить підпис від тих самих даних – усіх полів цієї транзакції – за допомогою конкретного ключа. З цього випливає, що ми можемо застосувати принципи агрегування не тільки для окремого входу транзакції, але й для транзакції загалом (рис. 2.2).

![Рисунок 2.2 – Використання єдиного значення підпису для всіх входів транзакції](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.2-single-signature-value-for-all-transaction-inputs.png "Рисунок 2.2 – Використання єдиного значення підпису для всіх входів транзакції")

> _Зауваження. В історії Bitcoin були періоди, коли кількість транзакцій у mempool досягала 140 тисяч, хоча за нормального навантаження на систему їхня кількість не перевищує 10 тисяч (рис. 2.3). Це були періоди, коли проводилися навмисні flood-атаки на Bitcoin. Для цього публікувалося багато транзакцій із великою кількістю входів, унаслідок чого в блоці вміщувалося лише кілька десятків транзакцій замість кількох тисяч [50]. Підпис Шнорра дозволить уникнути ненавмисного виникнення таких ситуацій і підвищити пропускну здатність системи, позаяк можна реалізувати схему, за якої кожній транзакції відповідатиме лише один підпис (спільний доказ володіння монетами для всіх входів)._

![Рисунок 2.3 - Графік завантаженості mempool у Bitcoin](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.3-Bitcoin-mempool-load-chart.png "Рисунок 2.3 - Графік завантаженості mempool у Bitcoin")

Також важливо розглянути необхідність впровадження підписів Шнорра з погляду конфіденційності транзакцій. Як ми згадували раніше, основна перевага підписів Шнорра – можливість створення транзакції з мультипідписом, яка є невідрізнювана від звичайної транзакції. Водночас жодний із учасників мережі не може бачити, які відкриті ключі належать до конкретної транзакції: фігурувати може тільки спільне агреговане значення [51].

На сьогодні мультипідпис у Bitcoin реалізується за допомогою механізму P2SH. Цей підхід дозволяє перекласти частину сплачування комісії (переплату за використання великих умов витрачання монет) на приймальну сторону, однак водночас умова витрачання монет усе одно відома третім особам (позаяк його має бути опубліковано для доведення володіння монетами). У ролі альтернативи було запропоновано механізм MAST, який ми розглянемо в наступному розділі.

Концепція MAST дозволяє забезпечити конфіденційність невикористаних умов, але водночас умова, яку було виконано, доступна всім учасникам мережі. Також розмір доказів володіння монетами може видати присутність інших умов.

Упровадження підписів Шнорра відкриває шлях для пропозицій, як-от Taproot і Graftroot (де потрібна можливість агрегування ключів) [52]. Taproot пропонує всі переваги MAST-структур, але водночас ніхто не знатиме, що за простою транзакцією приховувався складний смарт-контракт (якщо буде виконано умову, що перебуває на вершині дерева Меркла, інакше третя сторона також може дізнатися про наявність додаткових умов). Graftroot же дозволяє повністю приховати наявність складних умов (інші користувачі ніколи не дізнаються про наявність альтернативних сценаріїв). Детальніше ми розглянемо ці підходи в розділах 2.3 та 2.4.


### Будова підписів Шнорра

Для того, щоби показати, які властивості має мультипідпис, вироблений за алгоритмом Шнорра, розгляньмо принципи функціонування одиночного підпису. Спочатку користувач має ключову пару: особистий і відкритий криптографічний ключ. Водночас процес отримання відкритого ключа з особистого нічим не відрізняється від ECDSA: відкритий ключ дорівнює особистому, помноженому на значення базової точки. Важливо відзначити, що реалізація підписів Шнорра не вимагає зміни використовуваних параметрів еліптичної кривої (відповідно, порядок формування ключової пари та підсумкової адреси не зміниться для користувача).

Сам процес підписання повідомлення доволі простий і складається з двох кроків: генерування рандомізатора та використання особистого ключа та рандомізатора для формування підпису (рис. 2.4).

![Рисунок 2.4 – Алгоритм підпису Шнорра](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.4-Schnorr-signature-algorithm.png "Рисунок 2.4 – Алгоритм підпису Шнорра")

Значення підпису – це два значення: _R_ і _s_ (причому _R_ – точка на кривій, а _s_ – натуральне число). Під час верифікування підпису перевіряється виконання умови, як на рисунку 2.5. Якщо рівність виконується, то підпис вважається правильним.

![Рисунок 2.5 – Алгоритм перевіряння підпису](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.5-signature-verification-algorithm.png "Рисунок 2.5 – Алгоритм перевіряння підпису")

> _Зауваження. Значення підпису – комбінація (R, s), де R – точка на еліптичній кривій. Тобто сумарний розмір значення підпису дорівнює 96 байт. Однак якщо ми згадаємо про можливість стиснення координати точки (її розглянуто в другій частині навчального посібника на прикладі стиснення відкритого ключа), то ми можемо подати значення точки на еліптичній кривій як координату х і байт, який відповідає за знак координати у. У результаті, ми можемо стиснути значення підпису до 65 байт._


### Мультипідпис за допомогою алгоритму Шнорра

Механізм мультипідпису, фактично, не відрізняється від звичайного підпису, за винятком того, що значення підпису та відкритого ключа дорівнюють їхньому агрегованому значенню всіх учасників (рис. 2.6). Агрегований відкритий ключ дорівнює сумі відкритих ключів усіх учасників підпису й також є точка на кривій. Значення підпису – це, зі свого боку, сума підписів усіх учасників, зведена за модулем порядку базової точки.

![Рисунок 2.6 – Порівняння алгоритмів формування одиночного підпису та мультипідпису Шнорра](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.6-comparison-of-single-signature-and-multisignature-algorithms.png "Рисунок 2.6 – Порівняння алгоритмів формування одиночного підпису та мультипідпису Шнорра")

Можна помітити, що розмір мультипідпису нічим не відрізняється від одиночного підпису й алгоритми верифікування обох підписів повністю ідентичні. Це значить, що сторонньому спостерігачу невідомо, чи був це одиночний підпис або мультипідпис.


### Принцип проведення rogue key attack

Механізм мультипідпису, який ми описали раніше, може використовуватися, якщо кожний учасник системи гарантовано знає відкриті ключі інших учасників, з якими взаємодіє. Однак на практиці такий підхід використовуватися не буде (принаймні в Bitcoin й інших подібних системах), позаяк він дозволяє одній зі сторін зшахраювати на етапі формування агрегованого відкритого ключа [53].

Для того, щоби пояснити такого роду атаку, пропонуємо відразу розглянути приклад: Аліса та Боб хочуть відправити свої кошти на адресу, доступ до якого вони можуть отримати тільки спільно (тобто на MultiSig-адресу).

Для цього їм потрібно сформувати агрегований відкритий ключ, за яким і буде закріплено монети. Під час його формування Аліса та Боб обмінюються відкритими ключами й обчислюють агреговане значення як суму їхніх відкритих ключів. Потім Аліса та Боб формують транзакції (чи одну спільну транзакцію), які витрачають монети за вказаним агрегованим значенням (рис. 2.7).

![Рисунок 2.7 – Відправлення монет на агреговане значення відкритого ключа](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.7-sending-coins-to-aggregated-public-key-value.png "Рисунок 2.7 – Відправлення монет на агреговане значення відкритого ключа")

Після того, як таку транзакція підтверджено в мережі, Аліса та Боб тільки спільно можуть витратити заблоковані монети. Для цього кожний із них формує власне значення підпису, яке згодом буде агреговано та додано до доказу володіння монетами. Процес витрачання коштів за допомогою мультипідпису зображено на рис. 2.8.

![Рисунок 2.8 – Витрачання коштів із MultiSig-адреси](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.8-spending-funds-with-multisignature-addresses.png "Рисунок 2.8 – Витрачання коштів із MultiSig-адреси")

Як ми вже згадували раніше, верифікатор може перевірити правильність підпису, перевіривши рівність, зазначену на рис. 2.9.

![Рисунок 2.9 – Процедура перевіряння підпису](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.9-signature-verification-procedure.png "Рисунок 2.9 – Процедура перевіряння підпису")

Тепер розгляньмо ситуацію, у якій Боб хоче обманути Алісу та забрати її монети собі. Для цього йому просто потрібно на етапі обмінювання відкритими ключами відправити Алісі не істинне значення відкритого ключа, а модифіковане в спеціальний спосіб. Розгляньмо таку саму схему, як на рисунку 2.7, проте коли Боб передає не власне значення відкритого ключа _X<sub>B</sub>_, а результат обчислення $X_{\text{B}}-X_{\text{A}}$ (рис. 2.10).

![Рисунок 2.10 – Підмінювання з боку Боба значення власного відкритого ключа](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.10-spoofing-public-key-value.png "Рисунок 2.10 – Підмінювання з боку Боба значення власного відкритого ключа")

Ми бачимо, що в цьому разі значення агрегованого ключа дорівнює значенню відкритого ключа Боба. Відповідно, Боб знає особистий ключ, за допомогою якого він може обчислити підпис, який перевірятиметься за допомогою зазначеного відкритого ключа. Таким чином, Бобу не потрібне підтвердження Аліси для розблокування монет, які прив'язані до такої адреси.

> _Зауваження. Відзначмо, що за проведення цієї атаки Боб не знає значення секретного ключа, який би відповідав відкритому ключу X<sub>B</sub>-X<sub>A</sub>, завдяки властивостям еліптичних кривих. Проте цю атаку може бути проведено за базових умов, оскільки Аліса не перевіряє знання секрету з боку Боба._

Як одне з рішень такої проблеми можна використовувати додаткову ітерацію після обміну ключами, під час якої учасники мають довести, що вони знають відповідні особисті ключі. Для цього кожний із них може згенерувати випадкове значення nonce і попросити контрагента підписати його, після чого перевірити підпис отриманим раніше відкритим ключем (рис. 2.11). Водночас цей спосіб вимагає додаткові 4 ітерації та не є найоптимальніше рішення (на відміну від способу, який ми розглянемо далі).

![Рисунок 2.11 – Перевіряння факту, що Боб володіє зазначеним відкритим ключем](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.11-verifying-ownership-of-public-key.png "Рисунок 2.11 – Перевіряння факту, що Боб володіє зазначеним відкритим ключем")


### Схема Bellare–Neven

Інша пропозиція для захисту від атаки підмінювання ключа – використання підпису Bellare–Neven [54]. Розгляньмо особливості функціонування цієї схеми (рис. 2.12).

![Рисунок 2.12 – Схема формування підпису Bellare–Neven](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.12-Bellare--Neven-signature-scheme.png "Рисунок 2.12 – Схема формування підпису Bellare–Neven")

Як можна помітити, у схемі відсутнє агреговане значення відкритого ключа та для верифікування підпису використовуються всі відкриті ключі учасників окремо. Така схема дійсно не дозволяє одній зі сторін підробити відкритий ключ, позаяк відповідне секретне значення буде необхідне для обчислення підпису. Водночас значення підпису теж за розміром не відрізняється від підпису, який обчислив один учасник.

Однак очевидний недолік цієї схеми – те, що алгоритм її верифікування повністю відрізняється від стандартного підпису та вимагає використання відкритих ключів усіх сторін, що, зі свого боку, деанонімізує учасників взаємодії.


### Схема MuSig

15 січня 2018 року було опубліковано пропозицію нової схеми, яка використовує підхід Bellare–Neven, але водночас дозволяє зробити мультипідпис невідрізнюваним від стандартного підпису (зі збереженням захисту від атаки з підмінюванням відкритого ключа) [55]. Розгляньмо алгоритм формування такого підпису (рис. 2.13).

![Рисунок 2.13 - Схема формування підпису MuSig](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.13-MuSig-signature-scheme.png "Рисунок 2.13 - Схема формування підпису MuSig")

Фактично, значення агрегованого ключа в цьому разі дорівнює не просто сумі відкритих ключів, а сумі відкритих ключів, помножених на додаткове значення (геш-значення, яке включає геш від усіх відкритих ключів учасників підпису, а також частковий відкритий ключ).

MuSig, фактично, і є та схема, яка здатна вирішити завдання, пов'язані зі зменшенням розміру доказу володіння монетами (через зменшення підсумкового розміру підпису) та конфіденційністю учасників угоди (агрегований відкритий ключ і спільне значення підпису). До того ж, завдяки тому, що алгоритм верифікування одиночного підпису не відрізняється від алгоритму верифікування мультипідпису, валідатори можуть навіть не здогадуватися про участь в угоді декількох сторін (а за використання додаткових методів, як-от Taproot і Graftroot, – і про наявність додаткових умов).


### Обмеження використання підписів Шнорра

Незважаючи на описані раніше переваги підписів Шнорра, виникає низка завдань, які необхідно вирішити для їх застосування. 

Раніше ми згадували про те, що транзакція може містити один підпис для всіх своїх входів. Така можливість дійсно є, проте варто врахувати, що за підписування кожного з входів мають враховуватися відкриті ключі всіх входів. Наприклад, у нас є транзакція з трьома входами на 2, 3 та 5 монет. Кожний із цих входів (попередніх невитрачених виходів) закріплений за окремим відкритим ключем, доказ володіння яким визначає доказ володіння монетами.

Для агрегування підписів до одного, кожний із входів, фактично, має містити підписи певного типу, як на рис. 2.14.

![Рисунок 2.14 – Значення підписів на входах транзакції](/resources/img/volume-3/2.1-Features-and-application-of-Schnorr-signatures/F-2.14-signature-values-for-transaction-inputs.png "Рисунок 2.14 – Значення підписів на входах транзакції")

Ці значення може бути агреговано, тільки якщо кожний із підписантів має однакове значення агрегованого відкритого ключа (Х), тобто знає відкриті ключі всіх інших входів. Таким чином, користувач не може підписати свої входи та використовувати входи інших користувачів для формування спільної транзакції без попередньої згоди всіх сторін на це. Ця особливість сильно ускладнює реалізування підходів, як-от CoinJoin (і його модифікації), CoinShuffle й інші.

Друге обмеження полягає в тому, що підхід із агрегуванням підписів у транзакції може використовуватися, тільки якщо підпис охоплює всю транзакцію (SIGHASH_ALL). Signature hash types дозволяють користувачу підписати тільки певні входи та виходи транзакції, зберігши гнучкість взаємодії для інших учасників транзакції (наприклад, можливість додання додаткових входів і виходів тощо). Однак такі типи підпису передбачають підписування різних даних і, відповідно, різних геш-значень. З цього випливає, що значення підписів входів із різними типами даних, що підписуються, не може бути агреговано.


### Особливості реалізації підписів Шнорра

Станом на січень 2020 року ніщо не перешкоджає реалізувати підписи Шнорра в протоколі Bitcoin (за винятком необхідності переконати спільноту, що це доцільне).

У червні 2018 року було оприлюднено проект, у якому викладено технічну реалізацію підписів Шнорра [56]. Пітер Вейлле (Pieter Wuille), хто, власне, й оприлюднив проект, заявив, що підпис Шнорра – це «будівельний блок для різних подальших покращень». Він висловив надію, що зміни врешті-решт буде прийнято, хоча це повністю залежить від рішення користувачів. Також вийшло математичне пояснення принципів роботи підпису Шнорра в співавторстві з провідними розробниками, як-от Ґреґорі Максвелл (Gregory Maxwell) і Джонсон Лау (Johnson Lau) [55].

Упровадженню підписів Шнорра передувало оновлення протоколу під назвою Segregated Witness, що дозволяє винести підписи транзакції до структури поза основним блоком. І хоча саме SegWit для реалізування підпису Шнорра не обов'язкова умова, його активація дозволяє зробити весь процес простішим. Використання мультипідпису за алгоритмом Шнорра разом із SegWit дозволяє ще більше зменшити розмір транзакції та підвищити рівень конфіденційності кожного користувача завдяки можливості об'єднання всіх підписів транзакції в один.

### \*\*\*Часті запитання\*\*\*

_– Чи можна розвинути ідею ще далі та дозволити валідаторам агрегувати значення підписів всіх транзакцій у блоці?_

Агрегування підписів можливе, тільки якщо підписи охоплюють один набір даних. Але оскільки користувачі підписують тільки свої транзакції (різні дані), не можна агрегувати їхні значення в межах блоку.

_– Чи можна з використанням MuSig організувати схему, де один користувач створює транзакцію, підписує її своїм ключем і кладе до сейфу, а згодом її бере інший користувач, допідписує своїм ключем і публікує?_

Теоретично така можливість є, проте такий підхід не буде зручним для користувачів. Уся справа в тому, що для генерування підпису сторони мають попередньо обмінятися значеннями _R<sub>i</sub>_ і сформувати спільне _R<sub>aggr</sub>_, яке необхідне для обчислень. Тому єдиний спосіб це зробити для цієї схеми – попередньо згенерувати _R<sub>i</sub>_, обмінятися ними та розійтися. Тоді може бути реалізовано варіант, коли транзакцію підписує спочатку один, а потім інший користувач, але кожний із них має додатково зберігати власне _R<sub>i</sub>_ і спільне _R<sub>aggr</sub>_.


## 2.2 Концепція MAST у Bitcoin 

Протокол Bitcoin дозволяє описувати умови витрачання монет за допомогою спеціальної скриптової мови (Bitcoin Script). Вона не є повна за Тьюрингом, однак визначений у ній набір операцій дозволяє реалізовувати найчастіше використовувані сценарії і, до того ж, забезпечити функціонування протоколів верхнього рівня (як-от atomic swaps, payment channels тощо).

Поточний протокол Bitcoin передбачає, що всі умови витрачання монет (навіть якщо скрипт містить декілька альтернативних умов) має бути опубліковано чи явно в виході транзакції, чи у вході наступної транзакції з доказами виконання цих умов (підхід P2SH). Такий підхід дозволяє гарантовано перевірити виконання умов, проте його не можна назвати найефективнішим через такі причини.

> * _Велика кількість невикористовуваних даних_
> * _Низький рівень конфіденційності_
> * _Обмеження розміру контрактів_

Перший недолік полягає в тому, що транзакція має містити весь контракт (усі умови) незалежно від того, яку конкретно умову було виконано. Таким чином, якщо ми маємо сценарій, як на рисунку 2.15, то всі дані цього скрипту має бути поміщено до транзакції, хоча, фактично, монети буде розблоковано лише за виконання однієї умови з усіх можливих.

![Рисунок 2.15 – Скрипт, що поміщається до умови витрачання монет](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.15-script-placed-in-coin-spending-condition.png "Рисунок 2.15 – Скрипт, що поміщається до умови витрачання монет")

З цієї самої причини є деякі проблеми з конфіденційністю умов: кожний учасник мережі бачить усі альтернативні умови незалежно від того, яку з них дійсно було виконано.

Протокол Bitcoin обмежує максимальний розмір транзакції до 1/4 від максимального розміру блоку і максимальний розмір скрипту до 520 байт. Крім цього, обмеження є ціна записування даних до ланцюжка блоків Bitcoin. На відміну від платформ смарт-контрактів (як-от Ethereum), де комісія розраховується на підставі витрачених на виконання контракту ресурсів, контракт у Bitcoin сплачується строго залежно від його розміру, і, відповідно, економічно невигідно створювати контракти з великою кількістю умов, з яких використано буде тільки одну.

У цьому підрозділі ми поговоримо про один із способів вирішення цих проблем – про концепцію MAST і її застосування в протоколі Bitcoin. Концепція MAST передбачає використання дерев Меркла й абстрактних синтаксичних дерев, щоби задавати умови витрачання монет на виходах транзакцій. Розгляньмо за порядком, як це побудовано. 


### Абстрактні синтаксичні дерева

Для початку ознайомімося з поняттям _абстрактне синтаксичне дерево_ (abstract syntax tree, AST) [57]. Це дерево, яке подає деякий алгоритм. Листки таких дерев – операнди (змінні чи константні значення), а вузли – відповідні оператори (інструкції чи функції). Синтаксичні дерева переважно використовуються для спрощення оптимізації й аналізу програмного коду.

Як приклад наведімо просту підпрограму, мета якої – знаходження числа, найближчого до заданого, яке ділиться на 32 без залишку (для спрощення прикладу припустимо, що пошук здійснюється тільки у верхній бік). Наведімо псевдокод такої підпрограми на рисунку 2.16.

![Рисунок 2.16 – Псевдокод програми знаходження числа, яке ділиться на 32](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.16-pseudocode-for-finding-number-divisible-by-32.png "Рисунок 2.16 – Псевдокод програми знаходження числа, яке ділиться на 32")

На рисунку 2.17 зображено синтаксичне дерево, яке описує цю саму підпрограму. У дереві ромбом позначені вузли, які задають інструкції, овалом – змінні, а прямокутником – константні значення. Ребра дерева визначають переходи між операціями.

![Рисунок 2.17 – Абстрактне синтаксичне дерево для програми](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.17-abstract-syntax-tree-for-program.png "Рисунок 2.17 – Абстрактне синтаксичне дерево для програми")

На вершині дерева перебуває інструкція _while_. Це інструкція створення циклу, яка перевіряє деякі умови та залежно від них виконує тіло циклу (або не виконує). Умова в цьому разі розташована в лівій частині дерева. Розгляньмо її детальніше (рис. 2.18).

![Рисунок 2.18 – Подання умови програми](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.18-representation-of-program-conditions.png "Рисунок 2.18 – Подання умови програми")

Спочатку змінна А ділиться на константне значення 32. Інструкція _mod_ повертає нам залишок від ділення. Після цього виконується інструкція _no equal_, яка порівнює два операнди та повертає _true_ за їхньої нерівності. Операнди інструкції в цьому разі – константне значення "0" і значення, яке нам поверне оператор _mod_. 

Таким чином, після виконання всіх інструкцій у цьому піддереві, оператор _while_ отримає значення або _false_, якщо А ділиться на 32 без залишку, або _true_, якщо 32 – не дільник A. Якщо _while_ отримає на вхід _false_, то цикл завершується та тіло циклу не виконується. Однак якщо буде повернуто значення _true_, то починають виконуватися інструкції в правому піддереві (рис. 2.19).

![Рисунок 2.19 – Подання інструкцій програми](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.19-representation-of-program-instructions.png "Рисунок 2.19 – Подання інструкцій програми")

У цьому піддереві, фактично, відбувається інкрементування вхідного значення А. Спочатку операція _add_ складає А з "1", після чого операція _assign_ виконує присвоєння результату змінній А. Після того, як тіло циклу виконається, знову перевіряється виконання умови, як ми розглядали раніше.

Отже, використання AST дозволяє розбити програму на різні частини та побачити, як ці частини буде виконано (і чи буде їх виконано взагалі) залежно від інших умов. Цю особливість абстрактних синтаксичних дерев ми й використовуватимемо для побудування MAST.


### Що ж таке MAST?

Другий складник концепції MAST – це використання дерев Меркла. Оскільки ми вже розглядали будову дерев Меркла, то не заглиблюватимемося та не пояснюватимемо деталі повторно, просто ще раз нагадаємо їхні ключові переваги: забезпечення можливості перевірки цілісності даних, які входять до дерева, і забезпечення автентифікації окремого листа за Merkle branch без розголошення вмісту інших листів дерева.

Тепер визначмо, що таке MAST і як ця концепція може застосовуватися. MAST – це merklized abstract syntax tree, де застосовуються ідеї дерева Меркла й абстрактного синтаксичного дерева для задання взаємовиключних умов витрачання монет [58]. Водночас як мова опису умов виступає, як зазвичай, Bitcoin Script. 

Схематично merklized abstract syntax tree матиме вигляд, як на рисунку 2.20.

![Рисунок 2.20 – Merklized abstract syntax tree](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.20-merklized-abstract-syntax-tree.png "Рисунок 2.20 – Merklized abstract syntax tree")

MAST root – кореневе геш-значення, яке міститиме вихід транзакції. Овалом позначено геш-значення вузлів дерева, які ведуть до умов витрачання монет. Таким чином, піддерева містять взаємовиключні умови, за якими монети може бути витрачено. Отже, той, хто витрачає монети, використовуватиме чи одне піддерево, чи інше.

Прямокутником позначено умови, які задаються за допомогою Bitcoin Script. Ті умови, за якими монети буде витрачено найімовірніше, рекомендується поміщати якомога ближче до кореня дерева: це зробить доказ володіння монетами меншим за розміром.

Щоби довести володіння монетами за умовами конкретного піддерева, стороні, що доводить, необхідно опублікувати скрипт використовуваного піддерева (як у разі P2SH), а також набір значень Merkle branch, які необхідні для перевірки факту, що використовувана умова дійсно перебуває серед альтернативних.


### Спрощена схема MAST

Для того, щоби зрозуміти принцип функціонування MAST, наведімо такий приклад. Припустімо, у загальному сценарії задано дві взаємовиключні умови витрачання монет. У першому випадку монети можна витратити, надавши один підпис і дочекавшись настання певного часу, а в другому потрібно надати декілька підписів (наприклад, 2 з 2) (рис. 2.21).

![Рисунок 2.21 – Альтернативні умови витрачання монет](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.21-alternative-coin-spending-conditions.png "Рисунок 2.21 – Альтернативні умови витрачання монет")

Користувачі можуть вдатися до одного з варіантів, водночас MAST дозволяє домогтися того, що умови іншого не буде розголошено. Ми можемо перетворити ці альтернативні умови в єдине merklized abstract syntax tree, як на рисунку 2.22. Фактично, ми обчислюємо геш-значення кожної умови, після чого конкатенуємо їх і отримуємо MAST root через повторне гешування отриманого значення. 

![Рисунок 2.22 – Подання умов у формі MAST](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.22-representation-of-conditions-in-MAST.png "Рисунок 2.22 – Подання умов у формі MAST")

Тепер ми можемо довести, що конкретна умова перебувала в MAST. Для цього стороні, що доводить, потрібно просто надати геш-значення альтернативної умови як Merkle branch (для умови з мультипідписом це значення _H<sub>1</sub>_). Верифікатор обчислює геш-значення від опублікованої умови, після чого, використовуючи Merkle branch, обчислює значення Merkle root і порівнює його з наявними у виході попередньої транзакції.

Як ми згадували раніше, MAST root – 32-байтне значення, яке містить вихід транзакції (рис. 2.23). Це набагато менше порівняно з розміщенням повного скрипту (167 байт).

![Рисунок 2.23 – Поміщення в умові витрачання монет значення MAST root замість скрипту](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.23-putting-MAST-Root-values-instead-of-script.png "Рисунок 2.23 – Поміщення в умові витрачання монет значення MAST root замість скрипту")

Тепер розгляньмо, як відбувається витрачання монет, які заблоковані на такій адресі. У разі стандартної (pay to contract) транзакції нам необхідно було б просто надати докази володіння монетами – або значення відкритого ключа та підпису (перша умова, 129 байт), або два значення підпису (128 байт). 

У разі використання підходу P2SH (у виході попередньої транзакції розташоване 32-байтне геш-значення всього скрипту) докази містять увесь скрипт (167 байт), а також дані для його виконання, що в підсумку досягає близько 300 байт.

MAST дозволяє подати на вхід транзакції умову, яку було виконано (або 30 байт, або 134 байт), дані, які задовольняють цим умовам, а також доказ того, що умова – одна з альтернативних. Для цього до доказів додається Merkle branch (у нашому випадку 32 байт – геш-значення альтернативної умови).

Порівняльну характеристику використання стандартного, P2SH і MAST підходів подано на рисунку 2.24.

![Рисунок 2.24 – Порівняльна характеристика підходів до задання умов витрачання](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.24-comparison-of-approaches.png "Рисунок 2.24 – Порівняльна характеристика підходів до задання умов витрачання")

Ми бачимо, що MAST значно дозволяє скоротити обсяг даних, поміщуваних до транзакції, в разі виконання першої умови. Відмінності за виконання другої умови не такі значні, проте розгляньмо, як збільшення контракту (збільшення альтернативних умов) впливають на розмір скрипту.


### Переваги й особливості  MAST

У прикладі вище було подано лише дві умови виконання скрипту. Але розгляньмо ситуацію, коли таких умов набагато більше. У разі використання стандартного підходу чи P2SH обсяг даних скрипту сильно зростатиме залежно від кількості умов. Однак за використання MAST розмір скрипту зростатиме не набагато (щонайбільше на 32 байт з кожною додатковою умовою). До того ж, якщо правильно розташовувати умови в дереві, то можна дуже сильно заощадити й на значенні Merkle branch. Уявімо, що в нас є 7 альтернативних умов, але водночас ми знаємо, з якою ймовірністю може бути використано кожну з них (рис. 2.25).

![Рисунок 2.25 – Набір альтернативних умов витрачання з різними можливостями виконання](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.25-set-of-alternative-spending-conditions.png "Рисунок 2.25 – Набір альтернативних умов витрачання з різними можливостями виконання")

Відповідно, використовуючи концепцію MAST, можна розташувати ці умови в дереві в такий спосіб, щоб із високою ймовірністю заплатити якомога меншу комісію. Для цього потрібно умову _А_ (яку може бути виконано з більшою ймовірністю) помістити ближче до вершини дерева, а умови _F_ і _G_ – подалі (рис. 2.26).

![Рисунок 2.26 – MAST із альтернативних умов](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.26-MAST-with-many-alternative-conditions.png "Рисунок 2.26 – MAST із альтернативних умов")

У цьому разі, якщо буде використано умову _А_, у доказах витрачання монет буде розташовано саме умову _А_, докази, які їй задовольняють, а також одне геш-значення як Merkle branch – _H<sub>BCDEFG</sub>_ розміру 32 байт. У найгіршому разі, тобто якщо буде використано умова _G_ (або _F_), доказ володіння монетами міститиме відповідний скрипт, дані, які задовольняють йому, і значення Merkle branch, яке включає _H<sub>F</sub>_, _H<sub>E</sub>_, _H<sub>CD</sub>_, _H<sub>B</sub>_, и _H<sub>A</sub>_. Якщо ми надамо порівняльну характеристику для цієї складного умови, то отримаємо таку картину (як середній розмір однієї умови було взято 100 байт, доказів – 150 байт) (рис. 2.27).

![Рисунок 2.27 – Порівняльна характеристика розмірів умов залежно від способу їх задання](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.27-comparison-of-size-of-conditions.png "Рисунок 2.27 – Порівняльна характеристика розмірів умов залежно від способу їх задання")

Звернімо увагу на оптимізацію обсягу даних, які в підсумку потрапляють до ланцюжка блоків. Уважно подивіться на графік нижче. На вертикальній осі позначено обсяг даних в байтах, водночас сама шкала логарифмічна. На горизонтальній осі зазначено кількість альтернативних умов витрачання монет (рис. 2.28) [59].

![Рисунок 2.28 – Графік залежності загального розміру умови від кількості альтернативних складових частин](/resources/img/volume-3/2.2-MAST-concept-in-Bitcoin/F-2.28-graph-of-total-size-of-data-volume.png "Рисунок 2.28 – Графік залежності загального розміру умови від кількості альтернативних складових частин")

Синьою лінією позначено залежність обсягу даних від кількості умов без використання MAST. Червоною лінією – залежність обсягу даних від кількості умов з використанням MAST. Блакитна лінія – це границя розміру Bitcoin Script для P2SH. Зелена лінія – це границя розміру Bitcoin Script у структурі witness.


### Застосування MAST на практиці

MAST можна застосувати для більш оптимізованого реалізування HTLC (hash time locked contracts), які застосовуються в протоколі Lightning Network, і для реалізування atomic swap. Також концепцію може бути застосовано для більш оптимізованого реалізування escrow. MAST дає можливість реалізувати дуже великі конструкції з використанням multisignature.

Завдяки MAST здебільшого можна відмовитися від операції OP_RETURN для додання геш-значень від даних до ланцюжка блоків. Замість цього, можна включати ці дані до дерева та за потреби доводити, що конкретні дані було зафіксовано в ланцюжку блоків Bitcoin. Водночас таке додання не вплине на розмір транзакції.


### Розвиток концепції та поточний стан

Розвивати та просувати ідею MAST у спільноті Біткоїна почали Рассел О’Коннор (Russell O'Connor), Пітер Вейлле (Pieter Wuille), Пітер Тодд (Peter Todd) і Джонсон Лау (Johnson Lau). На початку 2016 року було опубліковано пропозицію щодо покращення протоколу Біткоїна під номером 114 (BIP114), де було описано специфікацію одного з варіантів реалізування цього підходу з використанням witness programs, які, зі свого боку, було впроваджено з оновленням SegWit. BIP114 також пропонує програмну реалізацію, яка додає нові правила досягнення консенсусу до протоколу Біткоїна.

Пізніше, у 2017-му році, запропонували альтернативний варіант реалізації концепції MAST, який описано в BIP117. Він заснований на BIP114 і вносить деякі модифікації. На момент 2018 року обидві пропозиції залишаються на стадії розгляду.

Відзначмо, що MAST може бути інтегровано до Bitcoin за допомогою softfork-оновлення протоколу. Це теж дуже важлива особливість цієї концепції.


### \*\*\*Часті запитання\*\*\*

_– Чи буде MAST root задано в структурі witness? Де саме його буде вказано?_

MAST root разом із даними, які його визначають, буде вказано в ScriptPubKey на виході транзакції. Ці дані займатимуть 25–35 байт і, найімовірніше, легко кодуватимуться до звичної Bitcoin-адреси. А у структурі witness, де доводиться володіння монетами, буде вказано Merkle branch, умови і дані, які задовольняють цим умовам.

_– Чи буде розширено множину доступних OP_CODEs у мові Bitcoin Script?_

На цю мить ще не ясно, тому що пропозиція – на стадії розгляду та може бути внесено додаткові правки та покращення. Імовірно, буде додано OP_CODE, як-от OP_MERKLEBRANCHVERIFY, для гнучкості використання MAST.

_– Чи ймовірне впровадження MAST у Bitcoin найближчим часом?_

Малоймовірне. Це оновлення важливе, але не термінове, тому воно може почекати, поки розробники думають над іншими покращеннями протоколу. Пізніше вони зможуть інтегрувати відразу кілька покращень в одному оновленні, як це було з SegWit.


## 2.3 Принципи функціонування Taproot

Підписи Шнорра надають дуже важливу особливість – можливість агрегування відкритих ключів і значень підпису. Це, зі свого боку, призводить до підвищення пропускної здатності мережі та підвищенню рівня приватності користувачів. Збільшення пропускної здатності забезпечується через заощадження місця в транзакції (завдяки агрегуванню доказів володіння монетами). Підвищений рівень приватності полягає в тому, що для стороннього спостерігача транзакція з одиночним підписом невідрізнювана від транзакції, що використовує мультипідпис.

Друга концепція, спрямована на покращення цих властивостей, – MAST. MAST дозволяє уникнути додання невикористаних умов витрачання монет до транзакції, що також заощаджує місце в ланцюжку блоків і не розкриває альтернативних умов. Однак особливість концепції MAST – те, що інші учасники мережі можуть бачити, що були альтернативні умови витрачання монет (позаяк доказ володіння монетами містять відповідний Merkle branch). Самі умови не розкриваються, але розкривається факт їхньої наявності. Тому мета Taproot – створення та додання до Bitcoin покращення, яке дозволить «маскувати» складні контракти під звичайні транзакції.

У цьому підрозділі ми розглянемо, як підписи Шнорра можуть використовуватися для вирішення такої проблеми. Ми розглянемо, що таке концепція Taproot, як вона покращує властивість конфіденційності умов контрактів і які є можливості для її реалізування в протоколі Bitcoin.


### Порядок застосування альтернативних умов

У повсякденному житті треті сторони (і договори) для вирішення конфліктів між суб'єктами потрібні, тільки якщо такі конфлікти виникають [60]. Якщо ж сторони домовляються між собою, то немає потреби залучати додаткові інструменти. У цьому сенсі більшість умов витрачання монет нічим не відрізняється від повсякденного вирішення розбіжностей. Найбільш цікаві та використовувані смарт-контракти побудовано в такий спосіб, що один із альтернативних сценаріїв передбачає розподілення цінності, якщо всі сторони підпишуть транзакцію (рис. 2.29).

![Рисунок 2.29 – Контракт, у якому одна умова передбачає розподілення монет у разі згоди всіх сторін](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.29-contract-in-which-one-condition-involves-distribution-of-coins.png "Рисунок 2.29 – Контракт, у якому одна умова передбачає розподілення монет у разі згоди всіх сторін")

На рисунку ми бачимо, що якщо буде використано першу умову, то інші нам не потрібні і необов'язково інші учасники системи мають знати, що вони були. MAST показав, у який спосіб ми можемо заощаджувати на розмірах транзакції, публікуючи лише використовувані умови (і зберігаючи конфіденційність інших). Проте повторимо, що MAST приховує умови, але не факт їхньої наявності.

Спробуймо ще сильніше розширити цю концепцію та розбити контракт на два складника: умову з мультипідписом і набір альтернативних умов, які зібрані в MAST (рис. 2.30).

![Рисунок 2.30 – Розбиття контракту на складники](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.30-contract-component-separation.png "Рисунок 2.30 – Розбиття контракту на складники")

Мета Taproot, фактично, – комбінування цих двох альтернативних сценаріїв ув одноподібну умову витрачання монет, поміщення до транзакції якої не призведе до розголошення цих сценаріїв. Розгляньмо, як для цього можуть застосовуватися підписи Шнорра.


### Підписи Шнорра як базовий елемент Taproot

Ми переконані, що для того, щоб найкраще розібратися, як працює окрема технологія, потрібно розібрати простий і зрозумілий приклад, який її використовує. Тому уявіть ситуацію, коли Аліса та Боб хочуть створити цікавий контракт з великою кількістю складних умов.

Кожний із учасників володіє особистим і відкритим ключем. В Аліси є особистий ключ _a_ та відкритий $A=aG$; у Боба – особистий ключ _b_ і відкритий $B=bG$. Вони вирішують заблокувати свої монети на контракті з такими умовами розподілу: або монети може бути витрачено за згодою Аліси і Боба (мультипідпис), або Єва може витратити їх з настанням свого повноліття (через 2 роки). Альтернативні умови матимуть вигляд, як на рисунку 2.31.

![Рисунок 2.31 – Наявність альтернативних умов у контракті](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.31-alternative-conditions-in-contract.png "Рисунок 2.31 – Наявність альтернативних умов у контракті")

Проте припустімо, що Аліса та Боб можуть дозволити собі використовувати трюк, як-от Taproot, тому замість опублікування зазначеної вище умови, вони роблять таке. Для початку Аліса та Боб агрегують значення своїх відкритих ключів. Після цього вони конкатенують агрегований відкритий ключ із альтернативною умовою й обчислюють геш-значення від результату. Отримане геш-значення вони множать на базову точку _G_, після чого отриманий результат складають із агрегованим ключем (рис. 2.32).

![Рисунок 2.32 – Створення Taproot з боку сторін](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.32-creating-Taproot-by-contracting-parties.png "Рисунок 2.32 – Створення Taproot з боку сторін")

Отримане в результаті значення _P_ буде використано як відкритий ключ, за яким і буде заблоковано монети.

Уявімо, що в першому випадку Аліса та Боб разом вирішують витратити ці монети. Для цього їм потрібно надати значення підпису, яке задовольнить відкритому ключу _P_. У який спосіб вони можуть це зробити? Подамо значення _P_ в такій формі:

![Рисунок 2.33-А – Детальне представлення відкритого ключа](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.33-A-detailed-presentation-of-public-key.png "Рисунок 2.33-А – Детальне представлення відкритого ключа")

Щоби відповідати відкритому ключу _P_, транзакція має бути підписана за допомогою особистого ключа, значення якого дорівнює такому [60]:

![Рисунок 2.33-Б – Відповідне значення закритого ключа](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.33-B-corresponding-value-of-private-key.png "Рисунок 2.33-Б – Відповідне значення закритого ключа")

Позаяк Аліса з Бобом знають власні особисті ключі, а також їм відомі альтернативні умови, то відповідний підпис може бути обчислено в такий спосіб. Боб підписує транзакцію за допомогою власного особистого ключа, а Аліса додає до свого особистого ключа геш-значення від альтернативної умови, після чого також підписує транзакцію вже отриманим значенням. Далі сторони обмінюються отриманими значеннями підписів. Позаяк підписи Шнорра дозволяють агрегувати значення підпису, то до доказів володіння монетами буде поміщено єдине значення підпису, яке відповідає єдиному значенню агрегованого відкритого ключа.

Проте що станеться в ситуації, за якої Аліса та Боб разом не витрачають монети? У цьому разі після закінчення двох років Єва може отримати доступ до монет. Розгляньмо, у який спосіб це відбувається.

Для доведення володіння монетами Єва має довести, що знає коректне значення AggKey й альтернативної умови, а також що вона може цю умову виконати. Фактично, ситуація схожа з підходом P2SH, за винятком того, що під час верифікування транзакції перевіряється не відповідність умови заданому геш-значенню, а виконання рівняння нижче (рис. 2.33).

![Рисунок 2.33-B – Перевіряння виконання умов](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.33-C-equation-inspected-during-transaction-verification.png "Рисунок 2.33-B – Перевіряння виконання умов")

Якщо рівняння виконується, верифікатор перевіряє виконання умови (Condition). У нашому випадку це перевіряння того, що минула потрібна кількість часу (2 роки), і перевіряння підпису відкритим ключем Єви.

> _Зауваження. Варто відзначити важливість того, що взято геш-значення від конкатенованих значень агрегованого ключа й умови витрачання монет. Якби було використано геш-значення тільки від альтернативної умови витрачання монет (рис. 2.34), то монети міг би викрасти будь-хто._
> 
> _Для цього зловмиснику потрібно було би створити будь-яку умову, яку він може виконати, розрахувати геш-значення від цієї умови та помножити на базову точку, після чого розрахувати значення агрегованого ключа як різницю P й отриманого значення. Тоді для верифікаторів дані агрегованого ключа й альтернативної умови були би валідні._

![Рисунок 2.34 – Обчислення геш-значення тільки від умов витрачання](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.34-calculation-of-hash-value-based-exclusively-on-spending-conditions.png "Рисунок 2.34 – Обчислення геш-значення тільки від умов витрачання")

Таким чином, ми бачимо, що відсутні будь-які додаткові витрати за задання умови витрачання монет за допомогою Taproot. Коли Аліса та Боб домовилися між собою та провели транзакцію, вона нічим не відрізняється від звичайної (P2PK або же P2PKH). Однак якщо монети розблокувала Єва, то розкривається альтернативна умова і, відповідно, сам факт використання Taproot.

Відзначмо, що альтернативна умова може бути не скрипт в явній формі (як це було в описаному вище прикладі), а становити великий набір альтернативних умов, які складено до структури MAST. Тобто візьмімо дерево з попереднього підрозділу (з 7 альтернативними умовами) і подивімося на нього ж, але вже з урахуванням використання Taproot (рис. 2.35).

![Рисунок 2.35 – Умова, яку задано за допомогою TapRoot і MAST](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.35-condition-defined-using-Taproot-and-MAST.png "Рисунок 2.35 – Умова, яку задано за допомогою TapRoot і MAST")

За використання Taproot ми можемо домогтися того, що вихід транзакції, який цю умову містить, не відрізнятиметься від звичайного виходу, який платить на одиночний ключ/адресу. Однак це працюватиме тільки за умови, що сторони домовляться між собою. Якщо ж буде використано найменш імовірну умову, то потрібно буде надати Merkle branch, цю альтернативну умову та дані, що задовольняють їй (рис. 2.36).

![Рисунок 2.36 – Порівняльна характеристика залежності розміру умов від способу їх задання](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.36-comparison-of-dependence-of-conditions-size.png "Рисунок 2.36 – Порівняльна характеристика залежності розміру умов від способу їх задання")


### Каскади сценаріїв Taproot

Також для побудови дерев сценаріїв може бути використано каскади з використанням Taproot. Фактично, альтернативна гілка може містити не MAST root, а інше значення відкритого ключа, як за використання класичного Taproot [60]. У цьому разі ми матимемо дерево нижче (рис. 2.37).

![Рисунок 2.37 – Каскад умов Taproot](/resources/img/volume-3/2.3-Taproot-operational-principles/F-2.37-cascade-of-Taproot-scripts.png "Рисунок 2.37 – Каскад умов Taproot")

У цьому разі доведення володіння монетами нічим не відрізняється від підходу, що використовує MAST. Якщо всі сторони домовляються між собою та формують відповідний підпис для найвищого рівня, то альтернативні умови не розкриваються. Якщо ж користувачі формують відповідний підпис для другого рівня, то не розкриваються умови, які розташовані нижче в дереві, але водночас потрібно довести, що даний Pn входить до загальної умови.

За використання каскадів Taproot не можна домогтися набагато більшої ефективності та конфіденційності порівняно з MAST, але в наступному розділі ми опишемо схему, яка дозволяє використовувати різні гілки (сценарії) і водночас не розголошувати навіть факт наявності альтернативних гілок.


## 2.4 Будова Graftroot

У попередньому підрозділі ми розглянули, у який спосіб Taproot дозволяє замаскувати складний смарт-контракт під звичайну транзакцію і водночас не розкривати його, якщо сторони домовилися та витратили монети за допомогою мультипідпису. Однак, як ви вже зрозуміли, у Taproot є одне серйозне обмеження, яке пов'язане з можливістю задання тільки однієї умови, використання якої не розкриє факт використання Taproot і присутність альтернативних умов.

У цьому підрозділі ми розглянемо концепцію під назвою Graftroot, яку запропонував Ґреґорі Максвелл (Gregory Maxwell), а також те, які проблеми вона вирішує та на які вимоги необхідно зважати для її реалізування.


### Окреме підписання кожної альтернативної умови

Graftroot так само, як і Taproot, побудовано на припущенні про те, що кожний контракт (який би він ні був складний) передбачає розподілення монет, якщо сторони домовляться між собою (разом підпишуть транзакцію). Однак, на відміну від Taproot, Graftroot дозволяє приховати кількість альтернативних умов, а також додавати нові після створення транзакції [60].

У концепції Taproot усі альтернативні умови враховуються під час обчислення відкритого ключа, за яким закріплено монети. Відмінність же Graftroot – те, що за допомогою агрегованого ключа буде окремо підписано всі альтернативні умови витрачання монет.

Розгляньмо приклад із попереднього підрозділу, у якому Аліса та Боб вирішили заблокувати монети на спільній адресі та надати до них доступ або за допомогою мультипідпису, або Єві 2 роки по тому (рис. 2.38).

![Рисунок 2.38 – Альтернативні умови витрачання монет](/resources/img/volume-3/2.4-Graftroot-design/F-2.38-alternative-conditions-for-spending.png "Рисунок 2.38 – Альтернативні умови витрачання монет")

Як і в попередньому прикладі, сторони формують спільний відкритий ключ, агрегуючи значення власних відкритих ключів. Також вони створюють альтернативну умову (у якій монети може витратити Єва), після чого разом підписують її та віддають самій Єві. Услід за цим, Аліса і Боб формують транзакцію, у якій просто блокують монети за агрегованим значенням відкритого ключа (рис. 2.39).

![Рисунок 2.39 – Формування транзакції з блокуванням монет за конкретним ключем](/resources/img/volume-3/2.4-Graftroot-design/F-2.39-locking-coins.png "Рисунок 2.39 – Формування транзакції з блокуванням монет за конкретним ключем")

Як в цьому разі монети може бути витрачено? У першому випадку Аліса і Боб разом домовляються витратити монети. Усе, що їм потрібно для цього зробити, – це разом підписати наступну транзакцію. Верификатор перевіряє, що значення підпису відповідає агрегованому значенню відкритого ключа, і, якщо значення підпису валідне, монети може бути витрачено (рис. 2.40).

![Рисунок 2.40 – Витрачання монет із використанням мультипідпису](/resources/img/volume-3/2.4-Graftroot-design/F-2.40-spending-with-multisignature.png "Рисунок 2.40 – Витрачання монет із використанням мультипідпису")

Проте уявімо, що за 2 роки Аліса та Боб не витратили монети та їх хоче витратити Єва. У цьому разі вона надає підписане значення скрипту (альтернативної умови), а також докази володіння монетами (підпис Єви). Верифікатор спочатку перевіряє підпис скрипту. Нагадуємо, що цей скрипт підписали Аліса та Боб за допомогою мультипідпису, а значить, відкритий ключ для перевіряння підпису – агреговане значення їхніх відкритих ключів (воно розташоване в умовах витрачання монет). Якщо підпис правильний, то верифікатор переконується, що альтернативну умову дійсно підписали Аліса та Боб і що вони згодні з її вмістом (рис. 2.41).

![Рисунок 2.41 – Надання з боку Єви скрипту для розблокування монет](/resources/img/volume-3/2.4-Graftroot-design/F-2.41-script-to-unlock-coins.png "Рисунок 2.41 – Надання з боку Єви скрипту для розблокування монет")

Після цього вже перевіряється виконання умови скрипту. У цьому разі верифікатор перевіряє, що час розблокування було досягнуто, а також що транзакцію дійсно підписала Єва. Якщо всі перевірки пройшли, монети може бути витрачено.

У результаті, ми бачимо, що якщо всі сторони домовляються між собою, то вони можуть сформувати транзакцію, яка нічим не відрізняється від звичайної (платить на один ключ/адресу). Однак якщо використовується альтернативна умова, то розкриваються деталі тільки цієї умови, а всі інші залишаються конфіденційними. Важлива особливість Graftroot – незалежність розміру доказів від кількості альтернативних умов (рис. 2.42) [60].

![Рисунок 2.42 – Формування альтернативних умов для розблокування](/resources/img/volume-3/2.4-Graftroot-design/F-2.42-alternative-conditions-for-unlocking.png "Рисунок 2.42 – Формування альтернативних умов для розблокування")


### Можливість додання нових умов

Ще одна дуже важлива особливість Graftroot – відсутність необхідності спочатку визначати всі можливі сценарії для витрачання монет. Користувачі, які брали участь у формуванні агрегованого значення відкритого ключа, можуть у будь-який момент часу створити та підписати новий сценарій витрачання монет. Вимога водночас – тільки необхідність підписання скрипту з боку всіх учасників транзакції [60].

Наприклад, уявіть ситуацію, що Аліса та Боб заблокували свої монети на multisig-адресі без жодних початкових альтернативних умов. Дещо згодом вони посварилися – і жодна зі сторін не хоче поступатися навіть частиною монет із цієї адреси іншій стороні. Єва пропонує їм вирішити ситуацію в мирний спосіб і віддати всі кошти їй, щоби вони не дісталися ні Алісі, ні Бобу. Вони погоджуються з цим і разом формують нову умову, згідно з якої монети може витратити Єва. Для цього їм не потрібно формувати нову транзакцію, а просто потрібно разом підписати потрібний скрипт і передати його Єві (рис. 2.43).

![Рисунок 2.43 – Формування нової альтернативної умови після підтвердження транзакції в мережі](/resources/img/volume-3/2.4-Graftroot-design/F-2.43-new-alternative-condition-after-transaction-confirmation.png "Рисунок 2.43 – Формування нової альтернативної умови після підтвердження транзакції в мережі")

Після отримання цього скрипту та підпису, Єва в будь-який момент може сформувати транзакцію, яка витрачає ці монети.

Переваги Graftroot – в такому. Якщо всі сторони домовляться, то така транзакція нічим не відрізнятиметься від звичайної транзакції (P2PK). Якщо ж потрібно виконати іншу умову для отримання монет, то в підсумку буде видно, що виповнилася умова, але буде відсутня інформація про інші умови та їхню кількість, позаяк розмір доказів не залежить від кількості альтернативних сценаріїв (на відміну від використання MAST і Taproot).

Важливий момент під час використання Graftroot – необхідність зберігання підписів альтернативних умов із боку зацікавлених сторін. У разі втрати такого підпису альтернативну умову не може бути виконано (підпис можуть відновити тільки сторони, відкриті ключі яких використовувалися для отримання агрегованого значення).

Водночас варто відзначити особливості видалення альтернативних умов (які схожі зі змінюванням умов витрачання монет у разі використання звичайної MultiSig-транзакції). Після того, як альтернативні сценарії підписано та відправлено, їх може бути скасовано тільки через змінювання агрегованого значення.

Тобто якщо Аліса та Боб уже відправили підписаний скрипт Єві, але після цього передумали, то єдиний спосіб урятувати монети – першими сформувати та підтвердити транзакцію, яка платить на нове агреговане значення ключа (Аліса та Боб генерують нові ключові пари, формують новий агрегований відкритий ключ і на нього відправляють монети) (рис. 2.44).

![Рисунок 2.44 – Змінювання значення відкритого ключа, за яким закріплено монети](/resources/img/volume-3/2.4-Graftroot-design/F-2.44-changing-value-of-public-key.png "Рисунок 2.44 – Змінювання значення відкритого ключа, за яким закріплено монети")

У цьому разі Єва вже не зможе витратити монети, позаяк транзакція, яку створить вона, буде такою, що конфліктує, і її не підтвердять валідатори.

### \*\*\*Часті запитання\*\*\*

_– Чи є сенс додавати в Біткоїн одночасно механізми MAST, Taproot і Graftroot? Чи краще реалізувати тільки один із них?_

Насправді є сенс додавати всі ці механізми, оскільки вони мають різну архітектуру та властивості. Але водночас не всі з них можуть використовуватися в сукупності. Наприклад, використання Taproot разом із MAST – дуже зручне рішенням (у розділі 2.3 ми розглянули, як це працює). Проте немає сенсу використовувати MAST разом з Graftroot, оскільки останній дозволяє встановлювати необмежену кількість різних умов, причому навіть після підписання транзакції. Це і є деяке обмеження протоколу: сторона, якій делегували скрипт, не може бути впевнена, що не створено новий скрипт витрачання монет.

Тому, якщо потрібна гнучкість під час задання умов, гарна ідея – використання Graftroot. Якщо ж важливо забезпечити незворотність умов, варто використовувати Taproot (можливо, разом із MAST, якщо є кілька альтернатив).

# [3 ЗАСТОСУВАННЯ КОНЦЕПЦІЙ SHARDING, OFF-CHAIN І DAG](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ua/3-Applying-the-concepts-of-sharding-off-chain-and-DAG.md)
