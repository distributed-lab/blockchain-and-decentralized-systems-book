# [3 ЗАСТОСУВАННЯ КОНЦЕПЦІЙ SHARDING, OFF-CHAIN І DAG](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ua/3-Applying-the-concepts-of-sharding-off-chain-and-DAG.md)

# 4 МЕХАНІЗМИ ЗАБЕЗПЕЧЕННЯ КОНФІДЕНЦІЙНОСТІ В ІНТЕРНЕТІ


## 4.1 Принципи функціонування та застосування Tor

У цьому підрозділі розглянуто найпопулярніші підходи до підвищення рівня анонімності користувача мережі через приховування тих чи інших даних від інших користувачів або сторонніх спостерігачів.

Поняття приватності (privacy) включає два основних складника: невідстежуваність (untraceability) й анонімність (anonymity). Невідстежуваність передбачає неможливість виявлення зв’язку між діями деякого користувача мережі. Анонімність означає неможливість достовірно встановити особу користувача в цій мережі.

Водночас слід розуміти, що поняття приватність користувача включає різні аспекти: технічний (зв'язок дій користувача із конкретним обладнанням або ПЗ), соціальний (зв'язок користувача з його колом спілкування й інтересами), часовий (зв'язок дій користувача з часом доби), поведінковий (зв'язок користувача з манерою введення тексту, використовуваними мовами) й інші. Тому в анонімності немає однозначного порогу, одиниць вимірювання чи абсолютного значення.

На практиці ж усе зводиться до того, що, з одного боку, люди винаходять методи аналізу, які дозволяють установити зв'язок між діями та користувачами, а, з іншого боку, покращують методи заплутування та приховування таких зв'язків, що дозволяє збільшити складність і вартість аналізу.

Варто відзначити різницю між _анонімністю_ та _псевдонімністю_. Користувач мережі вважається _анонімним_, якщо неможливо (складно практично) визначити його мережну адресу, розташування, персональні дані чи присвоїти йому ідентифікатор, за яким можна визначати його надалі. Якщо ж дії користувача можна пов'язати з абстрактним ідентифікатором, то він вважається _псевдонімним_. Наприклад, якщо користувач створив акаунт із підробленими даними та постійно його використовує, то він уже не анонімний – в найкращому разі псевдонімний [82].

### Підходи до анонімізування користувача мережі

> * _Передавання трафіку через проксі-сервер_
> * _Використання цибульної маршрутизації_
> * _Використання цибульної маршрутизації та спеціального браузера_
> * _Системи розповсюдження даних із великими затримкам_

Передавання трафіку через проксі-сервер, використання SSH-тунелю, підключення через VPN або подібних посередників дозволяє приховати мережну адресу користувача мережі від ресурсу, до якого він звертається. А сторонній спостерігач, який бачить трафік між користувачем і проксі-сервером, не може визначити, до якого саме ресурсу звертається користувач.

Недолік такого підходу полягає в тому, що сам посередник, який виконує роль прокси-серверу, знає, до яких ресурсів підключаються всі його користувачі. Крім цього, користувачі зазвичай налаштовують з'єднання з одним прокси-сервером і тривало використовують його, що дозволяє сторонньому спостерігачу та самому ресурсу, не знаючи мережного адреси користувача, стверджувати, що всі дії виконує той самий користувач. Такий підхід також неефективний проти глобального спостерігача, який, аналізуючи трафік у всій мережі одночасно, побачить кореляцію за часом і розміром пакетів між відправником й отримувачем, незважаючи на те, що вони спрямовуються не безпосередньо.

Підхід із використанням цибульної маршрутизації чи її модифікацій дозволяє приховати мережні адреси отримувача та відправника не тільки від стороннього спостерігача, але навіть від посередників. А наявність великої кількості вузлів, з яких користувач може сам вибирати посередників, дозволяє йому доволі часто перебудовувати маршрут і навіть використовувати декілька різних ланцюжків посередників одночасно для різних підключень. Утім, такий підхід усе одно не ефективний проти глобального спостерігача та не захищає користувача від навмисних спроб ресурсу присвоїти йому ідентифікатор на основі браузерних даних, як-от назви та версії браузера, особливості виконання скриптів, роздільна здатність екрана, збереження та використання даних про попередні сесії й т. ін.

Використання попереднього підходу разом зі спеціалізованим на анонімності браузером захищає користувача від низки способів його ідентифікування з боку ресурсу, до якого він підключається. Такий браузер не видає справжні дані про операційну систему, браузер, підключені плаґіни та справжню роздільну здатність екрана, а також дозволяє повністю відключити виконання скриптів і збереження даних про попередні сесії. Завдання спеціалізованого браузера – зробити так, щоб усі його користувачі «мали однаковий вигляд». Очевидно, що використання такого браузера буде марним, якщо користувач відвідує ресурси, які вимагають реєстрації та водночас використовує той самий акаунт.

Підхід із використанням систем розповсюдження даних із великими затримками дозволяє приховати зв'язок між відправником, отримувачем і самими даними, які передаються між ними. Водночас навіть глобальний спостерігач не може побачити кореляцію в передаванні даних між учасниками такої системи. Основний принцип такого підходу полягає в тому, що дані передаються через посередників, але весь маршрут передачі заздалегідь не відомий. Одне повідомлення може бути розбито на декілька складових частин, кожну з яких буде передано незалежно від інших. 

Для передавання від посередника до посередника частини різних повідомлень об'єднуються у випадковий спосіб й очікують випадкову кількість часу, а до отримувача вони надходять в асинхронному порядку. Час передавання одного повідомлення від відправника отримувачу може досягати 30 хвилин. Очевидно, що організований у такий спосіб зв'язок не є система передавання даних загального призначення. Вона не може використовуватися для доступу до традиційних HTTP-серверів, аудіо-/відеодзвінків або переписування в режимі реального часу. Протоколи, які використовують цей підхід підвищення анонімності, зазвичай реалізують ізольоване середовище спілкування на кшталт електронної пошти, публічних форумів або мікроблоґів.


### Принцип роботи цибульної маршрутизації

Концепцію цибульної маршрутизації (onion routing) вперше було запропоновано в 1995 році в дослідницькій лабораторії військово-морських сил США. Спочатку ці дослідження фінансувалися за рахунок грантів від уряду США. Вихідний код сучасної версії ПЗ Tor було опубліковано під вільною ліцензією в жовтні 2003 року, щоб усі охочі могли провести перевірку на відсутність помилок і закладок. Пізніше з'явилася некомерційна організація, яка займається виключно розвитком Tor Project, і її почали фінансувати різні спонсори. Щоби домогтися незалежності від бюджету уряду США, у 2015 році проект почав приймати пожертвування від приватних осіб.

Основне завдання цибульної маршрутизації полягає в приховуванні від стороннього спостерігача факту спілкування одного користувача мережі з іншим. Ідея полягає в тім, щоби передавати пакети даних не безпосередньо від відправника отримувачу, а через ланцюжок із декількох посередників, причому посередники знатимуть не увесь шлях окремого пакету, а тільки необхідну для його передавання частину.

Розгляньмо роботу цибульної маршрутизації на прикладі передавання даних між Алісою та Бобом. Охочі використовувати цибульну маршрутизацію, зокрема Аліса та Боб, починають використовувати той самий протокол, утворюючи однорангову мережу, яка використовує Інтернет в ролі транспорту. Вузли такої мережі мають ключі для направленого шифрування й обмінюються адресами мереж і відкритими ключами один одного, щоби кожний знав кожного, а також міг підключитися та відправити пакет даних, який зможе розшифрувати тільки отримувач.

Аліса зашифровує повідомлення, яке хоче передати Бобу, за допомогою відкритого ключа Боба. Далі Аліса формує пакет даних _P1_, куди поміщає зашифроване повідомлення та де вказує адресу Боба як отримувача (рис. 4.1). Тепер Аліса вибирає випадковий вузол мережі _R1_ і зашифровує пакет _P1_ відкритим ключем вузла _R1_. Далі Аліса формує пакет _Р2_, куди поміщає зашифрований _Р1_ і де вказує адресу _R1_ як отримувача. У такий самий спосіб Аліса вибирає вузли _R2_, _R3_ та формує пакети _Р3_ та _Р4_.

![Рисунок 4.1 – Схема шифрування даних за цибульної маршрутизації](/resources/img/volume-3/4.1-Operating-principles-and-application-of-Tor/F-4.1-data-encryption-for-onion-routing.png "Рисунок 4.1 – Схема шифрування даних за цибульної маршрутизації")

Унаслідок «багатошарового» шифрування повідомлення від Аліси Бобу виходить пакет даних _Р4_, який називають цибулею через її багатошарову будову. Цей пакет Аліса відправляє вузлу _R3_ через звичайний Інтернет (рис. 4.2). Вузол _R3_ може розшифрувати отриманий пакет й отримати пакет _Р3_, який адресовано вузлу _R2_. У такий самий спосіб вузол _R2_ відправляє пакет _Р2_, а вузол _R1_ відправляє пакет _P1_. У результаті, Боб розшифровує дані пакету _Р1_ своїм особистим ключем і може прочитати повідомлення. Відзначмо, що Боб може побудувати маршрут для відправлення відповідно́го повідомлення Алісі через новий набір посередників, а може використати маршрут, який уже побудовала Аліса, залежно від конкретного протоколу.

![Рисунок 4.2 – Схема передавання даних за цибульної маршрутизації](/resources/img/volume-3/4.1-Operating-principles-and-application-of-Tor/F-4.2-data-transmission-for-onion-routing.png "Рисунок 4.2 – Схема передавання даних за цибульної маршрутизації")

У такій ситуації сторонній спостерігач, який може переглядати пакети даних, які передаються в Інтернеті, не бачить спілкування між Алісою та Бобом. Сторонній спостерігач може бачити пакети _Р1_, _Р2_, _Р3_ і _Р4_, але не може зв'язати їх в один ланцюжок, оскільки вони містять різний шифротекст, а ключі невідомі. Кожний із вузлів-посередників також не може розкрити факт спілкування Аліси та Боба, оскільки з усього маршруту знає адреси тільки сусідніх вузлів. Факт передавання повідомлення від Аліси Бобу може бути доведено, якщо всі задіяні посередники змовляться й опублікують усі проміжні дані, які вони обробляли. Проте ймовірність такої змови мінімізується завдяки вибиранню посередників у випадковий спосіб із багатьох незалежних вузлів.

До таких підходів до маршрутизації можуть застосовуватися методи розкриття, базовані на аналізі часу появи пакетів даних у мережі, їхніх розмірів і т. ін. Однак протоколи, які реалізують таку маршрутизацію, можуть використовувати механізми, що значно ускладнюють аналізування пакетів і встановлення маршрутів, як-от складені пакети, динамічні маршрути і т. ін. Відповідно, різні протоколи налаштовані на різну кількість посередників, які вибираються випадково; зазвичай їхня кількість дорівнює двом або трьом.


### Особливості застосування Tor

У 2019 році налічується понад два мільйони клієнтів мережі Tor, а передаванням трафіку займається понад 7000 активних вузлів. Вони розташовані в усьому світі та працюють завдяки добровольцям, які погоджуються віддати частину пропускної здатності свого каналу на підтримання мережі.

Пропускна здатність і рівень анонімності Tor залежать від кількості вузлів: що вона більша, то кращі. Це обумовлено тим, що пропускна здатність кожного вузла обмежена, а велику кількість вузлів складніше аналізувати.

За замовчуванням користувачі Tor передають трафік через 3 випадково вибрані вузли. У такий спосіб трафік проходить такий шлях:

* Користувач (client) 
* Вхідний вузол (guard relay) 
* Проміжний вузол (middle relay) 
* Вихідний вузол (exit relay) 
* Пункт призначення (destination)

Спочатку користувач зашифровує дані так, щоби їх міг розшифрувати тільки вихідний вузол. Далі отриманий шифротекст він зашифровує так, щоби його міг розшифрувати тільки проміжний вузол. А потім цей шифротекст знову зашифровує так, щоби його міг розшифрувати тільки вхідний вузол (рис. 4.3).

![Рисунок 4.3 – Схема оброблення даних для передавання в Tor](/resources/img/volume-3/4.1-Operating-principles-and-application-of-Tor/F-4.3-data-transmission-in-Tor.png "Рисунок 4.3 – Схема оброблення даних для передавання в Tor")

У загальному разі запускання та підтримання вузла мережі, який буде виконувати роль вхідного та проміжного вузла, передаючи трафік інших користувачів, вважається безпечним. Оператора такого вузла складно звинуватити в розповсюдженні забороненого контенту чи подібних діях, оскільки він приймає та відправляє дані в зашифрованій формі, а ключів для отримання оригінальних даних він не має.

У цьому контексті оператори вихідних вузлів несуть набагато більшу відповідальність. Якщо зловмисник виконує незаконні дії, використовуючи мережу Tor, то ці дії буде пов'язано не з комп'ютером зловмисника, а з вихідним вузлом, який вибрав зловмисник. Для звичайних людей це означає, що запускання та підтримання вихідного вузла Tor може призвести до не дуже приємних ситуацій.

Інша особливість пов'язана з тим, що якщо відправник й отримувач додатково не забезпечують конфіденційність даних (наприклад, використовують HTTP або FTP), то вихідний вузол побачить ці дані у відкритій формі.


### Отримання списку вузлів Tor

Після запуску клієнту мережі Tor потрібно отримати списки всіх вхідних, проміжних і вихідних вузлів. Складенням, актуалізуванням і розповсюдженням цих списків займається спеціальний сервіс, що складається з багатьох серверів, які підтримують розробники протоколу. Списки адрес вузлів мережі Tor мають бути загальнодоступними – на практиці будь-хто охочий може їх отримати. Проте з цим пов'язана проблема блокувань.

Зацікавлені особи можуть використовувати списки адрес усіх вузлів, щоби заблокувати використання Tor. У теорії для цього є два варіанти: блокувати трафік від вихідних вузлів або блокувати трафік, спрямований до вхідних вузлів.

Перший варіант реалізується безпосередньо на боці веб-сервісів. Для цього їм достатньо іноді актуалізувати список вихідних вузлів Tor і блокувати весь трафік від них. В такому разі частина веб-сервісів недоступна з мережі Tor, і протистояти цьому практично неможливо.

Другий варіант значно гірший: блокування трафіку, спрямованого вхідним вузлам, не дасть використовувати Tor взагалі. Якщо його реалізують провайдери в усьому світі, Tor стане непотрібним. Проте розробники Tor придумали гарне рішення цієї проблеми: підключатися до вхідних вузлів можна не безпосередньо, а через мости.

Мости в контексті Tor – це вузли, які є посередники між користувачем і мережею Tor, тобто які є додаткова ланка між клієнтом і вхідним вузлом. Мости пускають в дію користувачі, які не можуть підключитися до вхідного вузла Tor або які хочуть приховати факт використання Tor від стороннього спостерігача. Список мережних адрес мостів складають й актуалізують ті ж таки спеціалізовані сервери розробників, проте він ніколи не публікується в загальному доступі цілком. Охочий може відправити запит або надіслати лист електронною поштою для отримання даних про мости, проте сервіс видає адреси тільки декількох мостів за раз. Використання такого підходу не дозволить заблокувати всі мости та водночас буде прийнятне для функціонування користувача.


### Методи деанонімізування користувачів dark networks

Під час деанонімізування користувачів dark networks мета зловмисника – установлення зв'язку або між даними та відправником, або між даними й отримувачем, або між відправником й отримувачем. У загальному разі для досягнення мети зловмисник може виконувати такі дії:

* Бачити весь трафік будь-якого учасника мережі
* Спостерігати за трафіком двох припустимих співрозмовників одночасно
* Створювати, змінювати, видаляти чи затримувати трафік
* Підтримувати декілька вузлів посередників
* Компрометувати декількох наявних посередників чи встановлювати контроль над ними

Розгляньмо метод деанонімізування користувача, що ґрунтується на кореляції пакетів даних за часом, оскільки він здебільшого простий і ефективний для мереж із низькими затримками. У цьому разі зловмисник може абстрагуватися від особливостей роботи системи анонімізування та сприймати її як «чорний ящик». Йому достатньо спостерігати за всім вхідним і вихідним трафіком припустимих співрозмовників (наприклад, користувача та ресурсу), а також проводити нескладний аналіз (рис. 4.4). У результаті, зловмисник може визначити, чи спілкуються між собою припустимі співрозмовники чи ні (наприклад, чи отримує конкретний користувач обслуговування від конкретного ресурсу чи ні).

![Рисунок 4.4 – Схема підключення зловмисника до припустимих співрозмовників](/resources/img/volume-3/4.1-Operating-principles-and-application-of-Tor/F-4.4-attacker-connecting-to-suspicious-parties.png "Рисунок 4.4 – Схема підключення зловмисника до припустимих співрозмовників")

Відповідно до цього методу зловмисник має фіксувати точний час появи кожного отримуваного та відправлюваного пакету двох припустимих співрозмовників одночасно. Залежно від порядку й інтенсивності взаємодії співрозмовників він може збирати дані для аналізування протягом декількох хвилин або годин. Аналізування даних полягає в пошуку збігів між групою відправлених і групою прийнятих пакетів зі зсувом у часі (рис. 4.5). Наприклад, користувач відправляє ресурсу запит, який складається з семи поспіль пакетів, а через 20 мілісекунд ресурс отримує сім поспіль пакетів. Водночас зловмисник не аналізує саме вміст пакетів й адреси, зазначені в їхніх заголовках, оскільки передбачається, що співрозмовники використовують багатошарове шифрування та ланцюжок посередників.

![Рисунок 4.5 – Схема виявлення кореляції пакетів за часом](/resources/img/volume-3/4.1-Operating-principles-and-application-of-Tor/F-4.5-detecting-packet-correlation-by-time.png "Рисунок 4.5 – Схема виявлення кореляції пакетів за часом")

Для підтвердження факту взаємодії припустимих співрозмовників зловмисник має виявити доволі багато збігів між групами відправлюваних і прийманих пакетів. Однак варто також враховувати, що припустимі співрозмовники можуть обмінюватися пакетами не тільки один із одним, але й з іншими учасниками мережі, що може збільшити кількість хибних збігів або зменшити кількість істинних. Проте, активно втручаючись в обмінювання пакетами, зловмисник може підтвердити результат своєї перевірки. Для цього, вибірково видаляючи чи затримуючи частину пакетів відправника, йому потрібно стежити за змінами в потоці пакетів отримувача.

Немає універсального методу деанонімізування для всіх dark networks, а також методу, який би гарантовано видавав результат за визначений час. Можна лише сказати, що для будь-якої атаки потрібні великі ресурси. Наприклад, для атаки зі зловмисними посередниками потрібно запустити та підтримувати велику кількість підроблених вузлів анонімізувальної мережі. А для атаки з виявленням кореляції за часом звичайному спостерігачу потрібно витратити багато часу, щоби перевірити всіх припустимих співрозмовників попарно.

Теоретично зловмисником може виявитися не звичайний спостерігач, а так званий глобальний спостерігач – той, хто одночасно стежить за всіма каналами передавання даних. Глобальний спостерігач може перевіряти будь-яких припустимих спостерігачів одночасно. Dark networks із низькими затримками зазвичай не розглядають глобального спостерігача у своїй моделі загроз; його наявність на практиці малоймовірна [83].

### \*\*\*Часті запитання\*\*\*

_– Яка середня продуктивність, доступна для клієнту мережі To?_

Середній час передавання файлу з розміром 50 кіБ (сторінки тексту) становить 0,5–2,5 с, а файлу з розміром 5 МіБ (фотографії) – 5–20 с залежно від вибраних проміжних вузлів.


## 4.2 Будова Tox

Tox – це один із найпопулярніших протоколів децентралізованих месенджерів. Основні його переваги полягають у забезпеченні конфіденційності, цілісності, справжності повідомлень, що передаються, а також у приховуванні зв'язку між мережною адресою користувача та його повідомленнями.

Відправною точкою створення Tox стало розголошення з боку Едварда Сноудена інформації про програми стеження АНБ. Після того, як в оприлюднених документах було виявлено згадки масового співробітництва Microsoft із державними агентствами, а також деталі операцій з прослуховування Skype, почалося обговорення проекту зі створення захищеного месенджера, який би функціонально не поступався Skype і був би доволі простий у використанні для середньостатистичного користувача [86].

Згодом з'явилося багато застосунків, які працюють за протоколом Tox і підтримують популярні операційні системи. У цьому підрозділі буде розглянуто найцікавіші особливості будови та використання Tox.


### Як улаштовано акаунти Tox?

Користувача Tox може мати один або декілька акаунтів. Унікальний ідентифікатор кожного акаунта – довгостроковий відкритий ключ користувача. Відповідну пару ключів для цифрового підпису користувач генерує особисто, використовуючи алгоритм ED25519 (довжина особистого та відкритого ключу – 256 біт). Користувач може прикріпити до свого акаунту ім'я (або псевдонім), фото, опис й аналогічні дані. Ці дані зберігає застосунок самого користувача, та вони передаються тільки його контактам (щоразу під час з'єднання з контактом й оновлення даних).

Контактом у Tox називають акаунт іншого користувача, з яким було проведено обмін довгостроковими відкритими ключами, а в застосунках, які обробляють відповідні акаунти, було підтверджено запит на додання до контактів. Щоби виявити іншого користувача в мережі та відправити йому запит на додання до контактів, необхідно знати його Tox ID. 

Tox ID формується з таких даних: довгострокового відкритого ключа, значення nospam і контрольної суми. Tox ID подано одним шістнадцятковим числом (рис. 4.6).

![Рисунок 4.6 – Схема формування Tox ID](/resources/img/volume-3/4.2-Tox-design/F-4.6-Tox-ID-structure.png "Рисунок 4.6 – Схема формування Tox ID")

Відкритий ключ використовується для взаємної автентифікації користувачів і встановлення ключів сесії. Протягом усього часу життя акаунту за ним закріплено ту саму довгострокову пару ключів. Якщо користувач хоче змінити довгострокову пару ключів, то йому потрібно створити новий акаунт, передати новий Tox ID іншим користувачам і заново додати їх до списку контактів.

Значення _nospam_ займає 4 байт і є частина Tox ID, яку власник акаунту може змінити в довільний спосіб. Це значення використовується для захисту від спам-атаки з великою кількістю запитів на додання до контактів. Якщо зловмисник знає довгостроковий відкритий ключ жертви та дійсне значення nospam, то він може передавати в мережі велику кількість правильних запитів на додання до контактів. Застосунок жертви муситиме всіх їх обробляти. У такій ситуації жертва може просто згенерувати нове значення nospam й очікувати на запити на додання до контактів уже за новим Tox ID. А всі запити за старим Tox ID будуть недійсними.

Значення контрольної суми займає 2 байт і потрібне для виявлення помилок після передавання та введення Tox ID. Контрольна сума обчислюється як послідовний XOR 36 байт даних (32 байт відкритого ключа + 4 байт значення nospam), розбитих на блоки по 2 байт [87].


### Типи вузлів і застосунки

Кожний вузол Tox визначають мережна адреса, номер порту та відкритий ключ. Усі наявні вузли можна розділити на два види: _bootstrap-вузол_ і _client-вузол_. Bootstrap-вузол займається тільки обслуговуванням мережі (з'єднується з іншими вузлами, передає їхні дані, підтримує DHT й т. ін.), але водночас не взаємодіє з застосунками користувачів безпосередньо. Client-вузол, крім обслуговування мережі, також виконує роль застосунка користувача або чат-бота (з'єднуючись зі своїми контактами й обробляючи повідомлення).

У загальному разі сторонній спостерігач не може визначити, до якого виду належить конкретний вузол мережі, оскільки неможливо визначити, чи передає він свої повідомлення чи транслює повідомлення інших вузлів. У цьому контексті слід відзначити важливу особливість – застосунок і вузол використовують різні пари ключів: одну – для цибульної маршрутизації, іншу – для авторизації контактів.

Для підключення до мережі Tox необхідно мати дані для підключення хоча би до одного активного вузла, який допоможе «розвідати» інші. За замовчуванням для цього використовується список із загальнодоступних bootstrap-вузлів, які працюють в Інтернеті. Зв'язок із іншими вузлами потрібний для підтримки DHT, а також для пошуку та підключення до користувачів зі свого списку контактів.

Tox також може доволі ефективно працювати в інтранеті чи в ізольованій локальній мережі. Для цього бібліотека libtoxcore реалізує відправлення пакетів на широкомовні адреси, що дозволяє підключитися до приватної мережі Tox, не маючи виходу до інтернету (якщо в сегменті мережі є вузол). Таким чином, навіть двох вузлів Tox може бути достатньо для забезпечення взаємодії локальних клієнтів [88].

### З'єднання співрозмовників

Вузли Tox діють у мережі відкрито: їхні відкриті ключі та мережні адреси доступні будь-кому, водночас кожний вузол готовий відповісти на запит будь-якого іншого вузла. Застосунок користувача, на відміну від вузла, прагне не розголошувати дані про користувача. Наприклад, сторонньому спостерігачу недостатньо знання Tox ID деякого користувача для визначення його мережної адреси та навпаки. Тому навіть для обмінювання запитами на додання контакту та передавання даних для автентифікації вже відомого контакту використовувати пряме з'єднання недопустимо. Для приховування мережної адреси користувачів застосунка Tox використовують механізм цибульної маршрутизації.

Розгляньмо процес установлення зв'язку між користувачами Tox. Наприклад, Аліса та Боб знають Tox ID один одного та запустили застосунки Tox, але ще не встановили з'єднання. Кожному з них потрібно анонсувати свою появу в мережі, щоби контакти могли виявити їх. Для цього Аліса та Боб у випадковий спосіб вибирають по одному вузлу – відповідно, А та В – так, що відкритий ключ вузла А наближений за значенням до відкритого ключа Аліси, а відкритий ключ вузла В наближений за значенням до відкритого ключа Боба (рис. 4.7). Далі Аліса та Боб, використовуючи цибульну маршрутизацію, передають значення своїх відкритих ключів вузлам А і В відповідно, щоби вони могли прийняти та передати запит на з'єднання, водночас не знаючи відповідності між відкритим ключем користувача та його мережною адресою.

![Рисунок 4.7 – Побудування маршруту для анонсування відкритого ключа](/resources/img/volume-3/4.2-Tox-design/F-4.7-building-route-to-announce-public-key.png "Рисунок 4.7 – Побудування маршруту для анонсування відкритого ключа")

Застосунки користувачів регулярно перевіряють стан своїх контактів (в мережі/не в мережі), відправляючи запити на пошук їхніх відкритих ключів у DHT. Припустімо, що Боб виконує такий запит за ключем Аліси та це приводить його до вузла А. Тоді Боб формує запит на з'єднання з Алісою та, використовуючи цибульну маршрутизацію, передає його вузлу А, який, зі свого боку, спрямовує його Алісі (рис. 4.8).

![Рисунок 4.8 – Відправлення запиту через вузол, який анонсує ключ](/resources/img/volume-3/4.2-Tox-design/F-4.8-sending-request-through-node-announcing-key.png "Рисунок 4.8 – Відправлення запиту через вузол, який анонсує ключ")

Отримавши запит на з'єднання, Аліса виконує його ідентифікацію й автентифікацію. Визначивши, що цей запит відправив Боб, вона формує відповідь і, використовуючи цибульну маршрутизацію, відправляє його вузлу B, який спрямовує його Бобу. Боб, зі свого боку, перевіряє отриману відповідь, переконуючись у тому, що його сформувала Аліса (рис. 4.9).

![Рисунок 4.9 – Відправлення відповіді через вузол, який анонсує ключ](/resources/img/volume-3/4.2-Tox-design/F-4.9-responding-through-node-announcing-key.png "Рисунок 4.9 – Відправлення відповіді через вузол, який анонсує ключ")

Під час відправлення таких запитів і відповідей учасники обмінюються відкритими ключами сесії, а також можуть розголошувати свої мережні адреси один одному для встановлення прямого з'єднання. Якщо учасники не бажають ділитися своїми мережними адресами, вони можуть використовувати вузли, які підтримують TCP relay (рис. 4.10).

![Рисунок 4.10 – Варіанти з'єднання співрозмовників після автентифікування один одного](/resources/img/volume-3/4.2-Tox-design/F-4.10-connection-options-for-parties.png "Рисунок 4.10 – Варіанти з'єднання співрозмовників після автентифікування один одного")


### Вузли TCP relay

Одна з проблем P2P застосунків здебільшого полягає в тому, що значна частина користувачів підтримує тільки вихідні з'єднання, тобто, знаючи адресу потрібного вузла та номер порту, який він «прослуховує», можуть ініціювати з'єднання з ним. Але самі вони не можуть прийняти з'єднання від охочих до них підключитися через налаштування мережного обладнання, обмеження фаєрволу, операційної системи і т. ін. Крім того, можуть бути причини, через які користувач не може використовувати трафік UDP. У децентралізованих системах це дійсно проблема: коли двом учасникам потрібно з'єднатися для обмінювання даними (наприклад, для здійснення аудіо- чи відеодзвінку) і жодний із них не може прийняти з'єднання від другого, вони можуть з'єднатися тільки через посередника. Однак у децентралізованій системі, за визначенням, не може бути одного вузла, до якого підключається значна частина всіх користувачів. Розробники Tox додали до ПЗ вузлів функцію TCP relay, завдяки якій будь-який вузол мережі, здатний приймати вхідні з'єднання, може виконувати роль посередника між іншими користувачами. Тепер користувачі, які не можуть з'єднатися безпосередньо, можуть самостійно вибрати собі посередника.

Працює це так. Під час запускання клієнт Tox намагається підключитися до потрібних вузлів безпосередньо, використовуючи UDP. Незалежно від результату (тобто навіть якщо підключення успішне) він підключається до одного з вузлів із функцією TCP relay, який буде готовий його обслужити, якщо виникнуть проблеми з прямим підключенням. Якщо клієнтові не вдається відкрити пряме з'єднання, він використовуватиме TCP relay, але продовжить спроби з'єднатися безпосередньо.

Зі свого боку, особливість вузлів, які підтримують TCP relay, полягає в тому, що вони намагаються використовувати широко відомі порти 80 (HTTP), 443 (HTTPS) і 3389 (RDP). Це ускладнює відстеження та фільтрування трафіку Tox, а також дозволяє йому здебільшого проходити міжмережні екрани, які обмежують конкретні номери портів [89].


### Використання DHT для пошуку контактів у мережі

Модуль DHT використовує окрему пару ключів, причому щоразу під час запускання генерується нова пара. Відповідний відкритий ключ – це ідентифікатор вузла в DHT, тобто відповідність між цим ключем, адресою та портом вузла заноситься до розподіленої таблиці окремим рядком.

Під час роботи програми виконується моніторинг стану всіх контактів користувача. Для кожного контакту, з яким немає з'єднання, застосунок здійснює пошук за його Tox ID в DHT. Результат пошуку – мережна адреса вузла, який було вибрано для анонсування відкритого ключа цього контакту.

За успішного встановлення з'єднання контакту присвоюється статус у мережі та з ним можна починати обмінювання текстовими повідомленнями та файлами чи ініціювати дзвінок. За розірвання з'єднання статус контакту відразу змінюється на не в мережі. Відзначмо, що за замовчуванням повідомлення зберігають тільки самі співрозмовники, а їх передавання можливе лише тоді, коли між співрозмовниками є з'єднання.

### \*\*\*Часті запитання\*\*\*

_– Який обсяг трафіку споживає вузол мережі Tox без самого застосунка?_

Якщо окремо запустити такий вузол (Tox-bootstrap), то його споживання трафіку становитиме близько 250 кбіт/с, що становить приблизно 2,5 ГіБ на день.

_– Чи можна визначити тип повідомлень, які передаються між користувачами, аналізуючи розмір і частоту передавання пакетів між ними?_

Такий метод аналізу дійсно доволі ефективний і може застосовуватися навіть проти протоколів, що використовують цибульну маршрутизацію. Для ускладнення відстеження типу повідомлень, які передаються, за розміром пакетів даних учасники мережі Tox додають випадкову кількість випадкових байтів до кожного пакету. Тому те саме повідомлення буде передано між транзитними вузлами в пакетах із різним розміром.

_– Tox ID – це досить довгий рядок, який незручно вводити з пам'яті чи друкувати на візитці. Як краще вирішувати цю проблему?_

У спільноті Tox було затверджено та реалізовано стандарт DNS Discovery, який дозволяє асоціювати довгі Tox ID з коротшими іменами. Використовуючи його, можна зареєструвати собі адресу виду username@example.com.


## 4.3 Invisible Internet project

Invisible Internet project (I2P) – це проєкт, який реалізує однорангову оверлейну мережу передавання даних із підвищеним рівнем анонімності користувачів, яка функціонує без центральних серверів. Проєкт I2P було розпочато в 2003 році з метою створення анонімного засобу розповсюдження даних із низькими затримками, порівняно з альтернативними засобами більш розподіленого та стійкого до атак порівняно з альтернативними засобами. Цей проєкт також базовано на передаванні трафіку через ланцюжок посередників (проміжних вузлів), проте способи пошуку вузлів і організування потоку пакетів відрізняються.

Мережа I2P насамперед орієнтована на передачу даних між її учасниками. Тому обидва співрозмовники (наприклад, користувач і ресурс) мають використовувати спеціальне програмне забезпечення – _I2P-маршрутизатор_. Можливість користувача I2P підключитися до ресурсу у звичайному Інтернеті також підтримується, проте таке підключення відбувається через один із спеціально налаштованих вузлів (_outproxy_), яких у мережі набагато менше.

### Часникова маршрутизація

Технологію часникової маршрутизації запропонував Майкл Фридман у 2000 році; це модифікація цибульної маршрутизації [61]. У цибульній маршрутизації кожний пакет між конкретним відправником і отримувачем передають посередники окремо. Модифікація часникової маршрутизації полягає в тому, що такий пакет буде передано не окремо, а в групі з іншими пакетами, які в той самий момент часу потрібно відправити тому самому вузлу.

Таким чином, вузли мережі обмінюються так званими _часниками_, які складаються з пакетів різних співрозмовників, для яких збіглася частина маршруту. У цьому разі такі пакети називають _зубчиками часнику_. На рис. 4.11 наведено спрощену схему оброблення часників з боку вузла мережі. 

Тут Боб отримує від Аліси часник із зубчиками C, E і F, які потрібно передати Керол, Єві та Френку відповідно. Водночас Боб отримує часник від Дейва, де зубчик B призначений самому Бобу, а зубчики F, E і C потрібно передати Френку, Єві та Керол відповідно. Отримавши два таких часники, Боб їх розпаковує та дізнається про отримувачів кожного з зубчиків; виходячи з цього, він формує три нових часники. Сам Боб хоче передати Єві (або через Єву) пакет даних від себе, тому до часнику, сформованого для Єви, він додає ще один зубчик.

![Рисунок 4.11 – Спрощена схема часникової маршрутизації](/resources/img/volume-3/4.3-Invisible-Internet-project/F-4.11-simplified-garlic-routing.png "Рисунок 4.11 – Спрощена схема часникової маршрутизації")

Під час створення зубчику застосовується схема багатошарового шифрування. Якщо Аліса хоче передати повідомлення Бобу, то вона зашифровує його так, що тільки Боб може його розшифрувати, після чого додає до отриманого шифротексту адресу Боба (рис. 4.12). Отриманий пакет Аліса зашифровує так, що тільки посередник може розшифрувати його, і додає до отриманого шифротексту адресу посередника. У такий спосіб додаються шари для кожного посередника, і тільки після цього зубчик включається до часнику. Зі свого боку, часник зашифровано так, що тільки вузол-отримувач може його розшифрувати.

![Рисунок 4.12 – Схема багатошарового шифрування в часниковій маршрутизації](/resources/img/volume-3/4.3-Invisible-Internet-project/F-4.12-multilayer-encryption-in-garlic-routing.png "Рисунок 4.12 – Схема багатошарового шифрування в часниковій маршрутизації")

Варто відзначити, що сторонній спостерігач не бачить зубчики часнику, що передаються між вузлами мережі; він може бачити тільки часник цілком. Отже, сторонній спостерігач не знає, для яких зубчиків конкретний вузол є отримувач, а для яких – транзитний вузол. Транзитний вузол також не знає, який ліком посередник він є для кожного зубчика. А щоб ускладнити відстежування повного маршруту конкретного зубчика за розміром часників, що передаються, до кожному часнику під час його формування додається випадкова кількість випадкових байтів [84].

### Вибирання проміжних вузлів і створення тунелів

Важливий об'єкт у функціонуванні I2P – _тунель_. Тунель – це орієнтований шлях передавання даних через декількох вузлів-посередників. Дані через тунель може бути відправлено тільки в одному напрямку, тому користувачі зазвичай використовують два типи тунелів: _вихідні (outbound)_ і _вхідні (inbound)_.

Щоб Аліса могла передати повідомлення Бобу (рис. 4.13), вона має створити вихідний тунель (що складається з посередників, які вибрала Аліса), а Боба, зі свого боку, має створити вхідний тунель (що складається з посередників, які вибрав Боб). Водночас Аліса не знає мережну адресу Боба у звичайному Інтернеті; вона знає тільки його адресу в мережі I2P, за якою знаходить мережну адресу _шлюзу (gateway)_ актуального вхідного тунелю Боба. 

Далі Аліса формує зубчик, за допомогою якого повідомлення буде передано через її вихідної тунель на шлюз вхідного тунелю Боба. Зі свого боку, шлюз вхідного тунелю Боба сформує зубчик, який передасть повідомлення Бобу через його вхідний тунель.

![Рисунок 4.13 – Схема передавання повідомлення через тунелі в I2P](/resources/img/volume-3/4.3-Invisible-Internet-project/F-4.13-transmitting-messages-through-tunnels-in-I2P.png "Рисунок 4.13 – Схема передавання повідомлення через тунелі в I2P")

Щоб відповісти на повідомлення Аліси, Бобу необхідно мати вихідний тунель, знати мережну адресу шлюзу вхідного тунелю Аліси та на основі відповідно́го повідомлення сформувати відповідний зубчик. 

Таким чином, повідомлення від Аліси до Боба та від Боба до Аліси передаються абсолютно різними маршрутами. Користувачі мережі можуть використовувати одночасно декілька вхідних і декілька вихідних тунелів, наприклад, окремі для кожної програми чи співрозмовника. За замовчуванням час життя тунелю становить 10 хвилин. Це означає, що незалежно від тривалості взаємодії співрозмовників зв'язок через поточних посередників перерветься, буде вибрано інші вузли-посередники та буде створено нові тунелі, через які відновиться зв'язок.

### Адресування та пошук вузлів

Повна адреса ресурсу в мережі I2P включає наступні дані: відкритий ключ для направленого шифрування, відкритий ключ цифрового підпису та дані сертифікатів. Ці дані зазвичай конкатенуються та кодуються в base64; у результаті виходить рядок довжини 516 символів. Також використовуються коротші варіанти адрес, які обчислюються як геш-значення від повної адреси ресурсу, закодоване в base32. Довжина короткого варіанту адреси становить 52 символи.

Звісно, недостатньо знати коротку адресу ресурсу (base32), щоби підключитися до нього. Для цього потрібно знайти повну адресу (base64) за його геш-значенням. Пошук нових вузлів-посередників, повних адрес ресурсів (відповідних відкритих ключів), а також мережних адрес шлюзів, через які можна відправляти запити цим ресурсам, здійснюється через розподілену базу даних – _NetDB_. Ця база даних обробляє інформацію та відповідні запити, поділяючи їх на дві групи: _RouterInfo_ та _LeaseSet_.

_RouterInfo_ дозволяє отримати дані, потрібні для використання інших вузлів мережі як транзитних: мережні адреси, відкриті ключі та деякі статистичні дані.

_LeaseSet_ дозволяє отримати дані, потрібні для того, щоби підключитися до конкретного вузлу мережі як до ресурсу (співрозмовника); факт зв'язку з цим вузлом має бути приховано від інших. У цьому разі NetDB повертає мережну адресу шлюзу вхідного тунелю отримувача, час закінчення дії (expiration time) цього тунелю та відкриті ключі отримувача.

Усі запити та відповіді в NetDB зашифровані. Це потрібно для того, щоби сторонній спостерігач не міг з'ясувати, які саме дані шукає конкретний користувач. Але варто також відзначити, що вузли мережі передають RouterInfo безпосередньо один одному, а LeaseSet – тільки через тунелі. Це потрібно для того, щоб уникнути кореляції між мережною адресою вузла й адресою ресурсу, за яким він фактично розташований, а також між мережною адресою користувача й адресою ресурсу, яким він цікавиться. Завдяки цьому встановити фактичне місце розташування ресурсів і користувачів у мережі I2P вважається неможливим.

Для створення власних вхідних і вихідних тунелів Аліса відправляє запити NetDB та збирає RouterInfo. У такий спосіб вона формує список вузлів (мережні адреси та відкриті ключі), які вона може використовувати в ролі посередників для її тунелів.

Коли Аліса хоче послати повідомлення Бобу, вона спочатку виконує пошук у NetDB, щоби знайти LeaseSet Боба й отримати дані про поточні вхідні тунелі Боба. Потім вона вибирає один зі своїх вихідних тунелів і відправляє через нього повідомлення з інструкціями для кінцевої точки вихідного тунелю, щоби переслати повідомлення на один зі шлюзів вхідного тунелю Боба.

Щоби відповісти Алісі, Бобу також потрібно спочатку звернутися до NetDB й отримати її LeaseSet. Але Аліса, відправляючи перше повідомлення Бобу, може скоротити час відгуку, додавши до повідомлення свій актуальний LeaseSet; тоді Бобу не доведеться звертатися до NetDB, коли він вирішить відповісти [85].


### \*\*\*Часті запитання\*\*\*

_– Яка середня продуктивність, доступна для клієнта мережі I2P?_

Середній час передавання файлу розміру 50 KiB (сторінка тексту) становить 3–7 с, а передавання файлу розміру декілька мегабайтів може забере декілька хвилин.


## 4.4 Стеганографічні методи приховування інформації

Стеганографія – це спосіб зберігання чи передавання даних, який дозволяє приховати їхню наявність серед інших даних (які зберігаються чи передаються). У цьому разі приховувані дані називають повідомленням, а дані, серед яких приховується повідомлення, – контейнером. _Стенографічна система (стегосистема)_ складається з сукупності алгоритмів для убудовування, виявлення та витягнення повідомлень для певних типів контейнерів.

Простий і наочний приклад стегосистеми – використання невидимого чорнила та паперу зі стороннім текстом як контейнеру. У цьому разі відправник наносить своє повідомлення понад видимим текстом (або між рядків) і передає контейнер отримувачу як звичайну книгу, газету чи журнал. А отримувач має знати про те, що в контейнер убудовано повідомлення, і те, як його витягти (рис. 4.14), тобто як правильно обробити папір (змінити температуру, нанести спеціальний реактив, використовувати нестандартне освітлення й т. ін.).

![Рисунок 4.14 – Приклад виявлення прихованого повідомлення](/resources/img/volume-3/4.4-Steganographic-methods-of-information-hiding/F-4.14-hidden-message-detection.png "Рисунок 4.14 – Приклад виявлення прихованого повідомлення")

Тоді як криптографія дозволяє приховати вміст повідомлення від сторонніх осіб, стеганографія дозволяє приховати факт наявності повідомлення. Таким чином, повідомлення вбудовується в контейнер зазвичай у відкритій формі, проте сторонні спостерігачі можуть припустити, що співрозмовники використовують стеганографію та зробити спроби виявлення та витягнення повідомлень. Тому в низці стегосистем є сенс убудовувати повідомлення в зашифрованій формі, позаяк це ускладнює виявлення повідомлення в контейнері чи взагалі внеможливлює це.

Для деяких стегосистем це працює так: навіть якщо сторонні правильно витягнуть повідомлення з контейнера, воно буде таке, яке не прочитати. До того ж, його буде неможливо відрізнити від шуму, який присутній у таких контейнерах, навіть якщо вони не містять убудованого повідомлення.


### Особливості роботи та переваги

Про стеганографію можна сказати, що вона організовує безпеку повідомлення за принципом «_security through obscurity_», що буквально означає безпеку завдяки незнанню. За таким самим принципом забезпечується захист програмних продуктів із закритим вихідним кодом від зламування: якщо порушник не знає вихідний код програми, то йому набагато складніше виявити в ній уразливості.

Чому приховувати сам факт наявності повідомлення за допомогою стеганографії краще, ніж приховувати вміст повідомлення за допомогою криптографії? Відповідь на це питання може бути не зовсім очевидна. Якщо дані захищено тільки криптографічними методами, то їх дуже легко виявити (отримати, перехопити). Здебільшого з використаного протоколу та залучених сторін доволі просто визначити конкретний алгоритм і того, хто володіє потрібним секретом. Тому якщо порушник виявив захищені дані, але не може самостійно їх прочитати, він може впливати на того, хто володіє потрібним секретом, зокрема й насильницькими способами. У разі застосування стеганографії порушнику набагато складніше виявити присутність потрібних даних.

Основні характеристики стегосистеми – _ступінь прихованості, місткість контейнеру та складність убудовування/витягнення_. Ступінь прихованості визначає, наскільки складно порушнику відрізнити заповнений контейнер від незаповненого (виявити присутність повідомлення в ньому). Місткість контейнеру визначає відношення розміру контейнера до максимального розміру повідомлення, яке можна вбудувати в цей контейнер. Іншими словами, – те,  наскільки ефективно буде використано канал передавання даних (наприклад, що 100 байт контейнеру містить 1 байт прихованого повідомлення). Складність стегосистеми визначає кількість обчислень, необхідних для вбудовування та витягнення повідомлення з контейнеру (наприклад кількість елементарних операцій, які потрібно виконати, щоб убудувати в контейнер повідомлення з розміром 100 байт).


### Класична стеганографія

Стеганографія використовувалася ще до нашої ери для передавання таємних повідомлень про військові напади і т. ін. Контейнерами могли бути, наприклад, воскові таблички, причому повідомлення наносилося на дерев'яну підкладку, яка вже потім покривалася воском. Інший варіант передбачає використання глиняних табличок, на яких вирізали текст повідомлення, а потім наносили ще один шар глини та вирізали текст стороннього повідомлення. Є також згадки про те, що в ролі контейнеру використовувалася виголена голова раба, на яку записувалося повідомлення, а після того, як відростало волосся, він вирушав до отримувача повідомлення.

До класичних методів стеганографії також можна віднести записи на бічній поверхні колоди карт, розташованих в умовному порядку. Можливе також використання різних трафаретів, які за накладання на текст залишають тільки значущі слова.

Класична стеганографія також включає низку фізичних методів приховування повідомлень. Найпопулярніший з них використовує оптичне зменшення зображень або тексту для нанесення його на так звану _мікрокрапку_. Створення мікрокрапки схоже на процес створення фотографії на світлочутливій плівці. Мікрокрапки зазвичай створювалися круглої форми з діаметром декілька десятих міліметра, що дозволяло вбудовувати їх у папір, уклеювати під марку поштового листа, передавати голубиною поштою порівняно великий обсяг даних і т. ін. Для зчитування повідомлення з мікрокрапки отримувач зазвичай використовував мікроскоп. Головна перевага мікрокрапки полягає в тому, що необізнаний спостерігач не може її виявити, навіть якщо її просто прикріплено до аркуша паперу з текстом, оскільки вона має вигляд звичайної чорнильної крапки [90].


### Комп'ютерна стеганографія

Цей напрямок стеганографії базовано на використанні особливостей комп'ютерної платформи, що дозволяє зберегти дані так, що їх не буде виявлено під час переглядання файлової системи звичайними оглядачами. Далі розгляньмо кілька прикладів.

Багато форматів файлів передбачає наявність полів, зарезервованих під майбутні оновлення формату. Цей підхід дозволяє забезпечити сумісність між версіями ПЗ. Тому поки ці поля не використовуються, вони за умовчанням заповнюються нулями. Відповідно, можна створити в файлової системі деяку кількість таких файлів, кожний з яких окремо буде непотрібним, але не спричинятиме підозр. Далі за допомогою спеціального ПО можна вбудувати повідомлення (або інші корисні файли) в невикористовувані поля непотрібних файлів. Недолік цього методу – низький ступінь прихованості.

Був також метод приховування інформації в невикористовуваних місцях гнучких дисків. Назва методу говорить сама за себе: приховувані дані поміщаються до невикористовуваних частин диска, наприклад, можуть бути записані на нульову доріжку чи після прапора, який позначає кінець записаних даних.

Використання особливих полів і форматів дозволяє додати приховане повідомлення до текстових документів так, що його не буде видно за звичайного відображення документа на екрані. Наприклад, повідомлення може бути написано білим шрифтом на білому фоні в зоні поля для виносок. Недолік такого способу – низька місткість контейнеру.

Використання незаповнених кластерів файлової системи дозволяє доволі просто й ефективно приховувати доволі великі обсяги даних. У файлових системах здебільшого записаний на диск файл займає ціле число кластерів (мінімальних адресованих чарунок пам'яті). Зазвичай розмір кластера становить від 2 кБ до 32 кБ. Відповідно, для зберігання файлу з розміром 1 кБ на диску виділяється обсяг пам'яті, який дорівнює одному кластеру, наприклад 16 кБ. Таким чином, у цьому кластері 1 кБ потрібно для зберігання самого файлу, а решту 15 кБ може використовувати спеціальне ПЗ для зберігання прихованих даних. Однак такий метод має низьку ступінь прихованості.


### Цифрова стеганографія

Напрям цифрової стеганографії базований на вбудовуванні повідомлень у цифрові мультимедійні файли чи потоки (зображення, аудіо, відео). Убудовування повідомлення в такий контейнер спричиняє його спотворення. Тому для кожного типу контейнеру (формату стиснення та кодування) має бути використано спеціальні алгоритми вбудовування та витягнення, завдяки яким внесені спотворення перебувають нижче за поріг чутливості середньостатистичної людини. Тому вбудовування повідомлень не призводить до помітних змін відповідних мультимедійних контейнерів. Крім того, в оцифрованих об'єктах, що початково мають аналогову природу, завжди присутній шум, що підвищує ступінь прихованості таких стегосистем.

Детальніше зупинімося на одному з найпростіших способів убудовування повідомлення в зображення, що ґрунтується на зміненні найменш значущих бітів. Найчастіше зображення кодується як група пікселів, кожний із яких задається червоним, зеленим і синім складником (RGB). Яскравість кожного складника може набувати 256 значень, тобто задається одним байтом даних. Метод змінення найменш значущих бітів (LSB, least significant bit) в цьому разі передбачає замінювання одного чи декількох молодших бітів складників пікселя на біти вбудовуваного повідомлення. Схематично процес убудовування зображено на рис. 4.15.

![Рисунок 4.15 – Схема вбудовування повідомлення в зображення](/resources/img/volume-3/4.4-Steganographic-methods-of-information-hiding/F-4.15-embedding-message-in-image.png "Рисунок 4.15 – Схема вбудовування повідомлення в зображення")

У наведеному прикладі повідомлення розділяється на порції по 2 біт та кожна порція вбудовується в один із складників пікселя. Наприклад, у піксель № 103 зі значеннями складників R: 35, G: 118, B: 242 потрібно вбудувати таку частину повідомлення: 101001. Відповідно, модифікований піксель матиме значення складників R: 34, G: 118, B: 241. Якщо замінювати два найменш значущі біти кожного складника кольору, то його значення в найгіршому разі збільшиться чи зменшиться на 3 одиниці з 256 можливих. Тому візуально відрізнити модифіковане зображення від оригінального неможливо. Проте якщо в кожному складнику кольору змінювати більш ніж 2 біт даних, то це призведе до такого спотворення зображення, яке буде помітне «неозброєним оком».

У цьому разі також дуже просто оцінити обсяг контейнеру. Якщо в кожний складник кольору вбудовувати по 2 біт даних повідомлення, то в кожний піксель можна вбудувати по 6 біт. Отже, якщо використовувати зображення з роздільною здатністю 200 на 100 пікселів, то в нього можна вбудувати повідомлення довжини 120 000 біт.

Очевидно, що метод змінення найменш значущих бітів застосовується для форматів зображень без стиснення або зі стисненням без утрат. Є й інші методи вбудовування повідомлень у зображення, які забезпечують стійкість до перекодування, стиснення, геометричних перетворень і деяких інших модифікацій зображення-контейнеру.

Є низка модифікацій цього методу приховування повідомлень у зображеннях, які підвищують стійкість до ручного та автоматизованого виявлення вбудованих даних. Покращення підходу полягає в тому, що повідомлення вбудовується не безпосередньо в пікселі, а як сума значень групи пікселів. Спосіб розбиття зображення на групи встановлюється заздалегідь і відомий тільки відправнику й отримувачу. Зображення може розбиватися як на прості групи пікселів, наприклад, рядки, стовпці або квадрати, так і на складніші, наприклад, хрести чи пересічні матриці. У цьому разі відправник змінює кожну групу пікселів у такий спосіб, щоби сума всіх пікселів групи дорівнювала черговій частини вбудованого повідомлення. Отримувач, зі свого боку, розбиває зображення на ті самі групи, обчислює з них суми та складає з них повідомлення. Ще одна особливість полягає в тому, що якщо в той самий контейнер убудувати те саме повідомлення, то заповнені контейнери будуть різними, навіть якщо використовувався один спосіб розбиття на групи пікселів.

Для вбудовування повідомлень в аудіофайли або аудіопотоки зазвичай використовуються такі методи: ехо-методи, фазове кодування, метод розширеного спектру. Ехо-методи базовані на тому, що звукова хвиля накладається сама на себе з невеликим зсувом у часі та зі зменшеною амплітудою. З одного боку, таке відлуння досить просто виявити; з іншого боку, звичайний цифровий аудіосигнал завжди містить відлуння, яке з'являється з природних причин у момент запису мікрофоном.

У цьому разі відлуння характеризується початковою амплітудою, ступенем згасання та затримкою, які вибираються у такий спосіб, щоби відлуння залишалося непомітним для людського сприйняття. За допомогою декількох різних значень затримки в аудіосигнал вбудовується саме повідомлення. Наприклад, відлуння з затримкою 0,001 с позначає нульовий біт повідомлення, а відлуння з затримкою 0,002 с – одиничний біт повідомлення.


### Приховування повідомлень за допомогою геш-стеганографії

Цей метод стеганографії ​​особливий, оскільки він не вимагає змінювання контейнера, а порядок убудовування та витягнення повідомлення сильно відрізняється від розглянутих вище методів. Принцип роботи полягає в тому, що відправник підбирає такий контейнер (картинку, аудіофайл, текстовий файл або інший), геш-значення від якого збігається з повідомленням, яке потрібно передати. Авжеж, відправник й отримувач мають заздалегідь узгодити канал передавання даних і використовувану функцію гешування. Для витягнення повідомлення отримувачу потрібно просто обчислити геш-значення від контейнера.

Варто відзначити, що чим довше геш-значення використовуваної функції гешування, то складніше підібрати контейнер, який за гешування даватиме потрібне повідомлення. Наприклад, для вихідного значення геш-функції довжини 8 біт є 256 можливих значень, а для значення довжини 16 біт – 65536. Крім цього, потрібно враховувати, що зазвичай довжина повідомлення набагато більша, ніж довжина геш-значення. Тому геш-стеганографія передбачає використання групи упорядкованих контейнерів для передавання одного повідомлення. Водночас функція гешування може бути використана навіть із довгим вихідним значенням, але використано буде тільки його частину.

Розгляньмо порядок убудовування та витягнення прихованого повідомлення за допомогою геш-стеганографії на прикладі. Припустімо, Аліса та Боб домовилися, що використовуватимуть геш-стеганографію з геш-функцією SHA-1 на довжині 128 біт, використовуючи перший байт вихідного значення; у ролі контейнерів буде використано фотографії, а каналом зв'язку послуговуватиме особистий фотоальбом Аліси в соціальній мережі. Тепер, якщо Алісі потрібно передати Бобу повідомлення довжини 44 байт, з усіх фотографій, які ще не було опубліковано, вибирає таку, перший байт геш-значення якої збігається з її повідомленням, і публікує. У такий самий спосіб Аліса вибирає фотографію для другого байта повідомлення тощо, поки всі 44 фотографії не буде опубліковано в потрібному порядку (рис. 4.16). Очевидно, що завдання витягнення повідомлення для Боба набагато простіше. Йому для отримання повідомлення достатньо обчислити геш-значення фотографій у порядку, у якому їх опублікувала Аліса.

![Рисунок 4.16 – Схема роботи геш-стеганографії](/resources/img/volume-3/4.4-Steganographic-methods-of-information-hiding/F-4.16-operation-of-hash-steganography.png "Рисунок 4.16 – Схема роботи геш-стеганографії")

Однак завдання Аліси можна трохи оптимізувати. Замість того, щоб для кожного байта повідомлення виконувати грубий перебір фотографій під час пошуку тієї, що підходить, вона може одного разу пройтися всіма неопублікованими фотографіями та класифікувати їх залежно від першого байта геш-значення. Іншими словами, Аліса складає таблицю фотографій, кожний рядок якої містить фотографії, перший байт геш-значень яких збігається з номером рядка (рис. 4.17). Тепер для передавання кожного наступного байта прихованого повідомлення Алісі достатньо опублікувати фотографію з потрібного рядку таблиці. Щоб у фотоальбомі не було повторень і це не викликало підозру в сторонніх, Аліса відразу після опублікування видаляє фотографію з таблиці. Це означає, що за активного передавання прихованих у такий спосіб повідомлень, Алісі потрібно поповнювати свою таблицю новими фотографіями.

![Рисунок 4.17 – Таблиця фотографій, яку підготувала Аліса](/resources/img/volume-3/4.4-Steganographic-methods-of-information-hiding/F-4.17-prepared-table-of-photos.png "Рисунок 4.17 – Таблиця фотографій, яку підготувала Аліса")

Перевага геш-стеганографії – дуже високий ступінь прихованості, оскільки контейнери не вимагають модифікування та можуть бути довільні файли. Це дозволяє вибирати будь-які контейнери залежно від ситуації. Недолік цього методу – низька місткість контейнера: один контейнер може містити не більш ніж декілька байтів прихованого повідомлення.


### Особливості застосування й атаки

Для забезпечення захисту авторського права на цифровий контент часто застосовують системи цифрових відбитків (digital fingerprint) і цифрові водяні знаки (digital watermarking), які використовують стеганографію для непомітного вбудовування ідентифікаторів автора, цифрових підписів або інших відміток.

Є також припущення, що агенти спецслужб й учасники терористичних угруповань використовують стеганографію для спілкування в Інтернеті. Це зумовлено тим, що публікація контейнерів у відкритих ресурсах не викликає підозри порівняно з використанням захищених месенджерів або dark networks.

Під атаками на стеганографічні системи розуміють спроби виявити, витягти чи підмінити вбудоване в контейнер повідомлення, а відповідну діяльність називають стегоаналізом. Атаки на стегосистеми можуть бути на основі відомого методу вбудовування, на основі відомого вбудованого повідомлення чи на основі відомого порожнього контейнеру.


### \*\*\*Часті запитання\*\*\*

_– Які зображення краще підходять для вбудовування повідомлень?_

Для методів убудовування на основі LSB монотонні, низькоконтрастні зображення з повторюваними чи одноподібними текстурами (зображення піску, неба, трави, дерев, моря й т. ін.) підходять набагато краще, ніж висококонтрастні (зображення з текстом, діаграмами й т. ін.). Крім цього, слід ураховувати, що людське око найбільш чутливе до змін у спектрі зеленого кольору; навпаки, його найменша чутливість спостерігається відносно спектру синього кольору. Отже, до синього каналу (згідно з моделлю кольорів RGB) зображення можна вбудувати більше даних, ніж до зеленого каналу, і водночас заповнений контейнер залишиться візуально невідрізнюваним від вихідного зображення.

# [5  РОЛЬ КРИПТОГРАФІЧНИХ ЗОБОВ'ЯЗАНЬ В ОБЛІКОВИХ СИСТЕМАХ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ua/5-Role-of-cryptographic-commitments-in-accounting-systems.md)
