# [2 ПІДПИСИ ШНОРРА ТА ПОВ'ЯЗАНІ З НИМИ ОНОВЛЕННЯ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ua/2-Schnorr-signatures-and-their-application.md)

# 3 ЗАСТОСУВАННЯ КОНЦЕПЦІЙ SHARDING, OFF-CHAIN І DAG

Одне з найскладніших завдань під час побудування облікової системи – забезпечення можливості її масштабування. Під масштабованістю системи слід розуміти здатність системи обробляти більший обсяг даних (запитів, транзакцій, станів акаунтів) за збільшення кількості її серверів (вузлів-аудиторів, валідаторів). У контексті облікової системи, що використовує технологію blockchain, її масштабованість можна оцінити трьома метриками: пропускна здатність, час підтвердження блоку та вимоги до апаратного та програмного забезпеченню вузлів.

Залежно від архітектури системи збільшення навантаження і збільшення кількості валідаторів може призвести до низки проблем нижче.

> * _Нездатність системи обробляти весь потік транзакцій_
> * _Збільшення обсягів пам'яті, необхідних для зберігання історії_
> * _Збільшення часу підтвердження транзакцій_
> * _Підвищення комісій_

Отже, перша проблема пов'язана з пропускною здатністю системи. Пропускна здатність будь-якої облікової системи обмежена (не вірте, якщо володілець системи стверджує протилежне – у будь-якої системи є порогове навантаження, яке вона подолати не зможе). У разі децентралізованої облікової системи пропускна здатність залежить від часу досягнення консенсусу між валідаторами та кількості подій (наприклад, транзакцій), щодо яких консенсус буде досягнуто. 

Різні системи мають різну максимальну пропускну здатність: Bitcoin – 3–7 транзакцій на секунду, EOS і Bitshares – до декількох тисяч. Однак у будь-якому разі, якщо навантаження буде перевищувати допустиме значення, частину транзакцій система просто не зможе обробити.

Обліковим системам, що використовують технологію блокчейн, необхідно зберігати всю історію транзакцій для забезпечення цілісності кінцевого стану реєстру. Отже, історія транзакцій може тільки зростати в обсязі. Що більше транзакцій система здатна обробити за одиницю часу, то швидше збільшуватиметься база даних і вимоги до обладнання для підтримання системи. Це значить, що з часом у системі зменшується кількість вузлів, які можуть зберігати повну історію транзакцій, що, зі свого боку, впливає на ступінь децентралізації та відмовостійкості системи загалом.

Від кількості валідаторів залежить рівень децентралізації системи. У разі використання PoW і PoS як алгоритмів досягнення консенсусу збільшення кількості валідаторів не впливає на час досягнення консенсусу (але через специфіку протоколів не забезпечується незмінність історії). Однак за використання алгоритмів, побудованих на основі BFT (які передбачають нескасовність кінцевого стану системи), збільшення кількості валідаторів впливає на час досягнення консенсусу і, зі свого боку, на пропускну здатність мережі.


## 3.1 Використання off-chain протоколів

Розвиток off-chain протоколів масштабованості облікових систем почалося з появою платіжних каналів і Lightning Network [62]. Нагадаємо, що off-chain протоколи – це протоколи другого рівня, що працюють понад конкретною обліковою системою (декількома системами). Фактично, такі пропозиції не передбачають змінювання базового протоколу облікової системи, але водночас дозволяють перенести взаємодію користувачів за межі основного ланцюжка блоків, зберігаючи властивості основного протоколу.

Основна суть off-chain протоколів полягає в блокуванні з боку користувачів монет ув основному ланцюжку й обмінюванні між собою транзакціями, які можуть змінити вихідний розподіл монет. Водночас у деякому сенсі змінюється підхід до досягнення консенсусу: після блокування коштів у каналі досягається вже не глобальний консенсус щодо оновлення стану всієї облікової системи, а тільки консенсус між учасниками каналу безпосередньо (рис. 3.1). Математика, яка лежить в основі off-chain взаємодії, не дозволяє шахраювати обом контрагентам.

![Рисунок 3.1 – Процес досягнення консенсусу в основній мережі й у платіжних каналах](/resources/img/volume-3/3.1-Using-off-chain-protocols/F-3.1-reaching-consensus-in-accounting-system-and-in-payment-channels.png "Рисунок 3.1 – Процес досягнення консенсусу в основній мережі й у платіжних каналах")

До протоколів, які використовують схожі ідеї, можна віднести такі:

> * _Lightning Network_
> * _Plasma_
> * _Celer Network_
> * _Raiden Network_
> * _Trinity_
> * _Interledger_
> * _GEO Protocol_

Нагадаємо, що Lightning Network – це протокол, який уже функціонує понад Bitcoin і може функціонувати понад схожими з Bitcoin протоколами. Lightning Network використовує механізм комутування двоспрямованих каналів і дозволяє сформувати trustless систему для швидких переказів у межах цих каналів (час оброблення транзакцій залежить тільки від затримок на оброблення та передавання даних між учасниками). Детальний принцип роботи LN і його властивості ми розглядали в 2-й частині навчального посібника.

Основна ідея Plasma полягає у використанні сайдчейнів для підвищення пропускної здатності мережі Ethereum [63]. Фактично, Plasma використовує структуру з великої кількості ланцюжків блоків, пов'язаних у дерева, стан кожного дочірнього ланцюжка зафіксовано в стані батьківського аж до основного ланцюжка блоків (рис. 3.2). Кожний із дочірніх ланцюжків може мати власний механізм досягнення консенсусу та метод зв'язування з батьківським ланцюжком.  

![Рисунок 3.2 – Архітектура протоколу Plasma](/resources/img/volume-3/3.1-Using-off-chain-protocols/F-3.2-Plasma-protocol-architecture.png "Рисунок 3.2 – Архітектура протоколу Plasma")

> _Зауваження. Ще один із представників off-chain протоколів – GEO Protocol [64]. GEO – це децентралізована однорангова мережа, яка дозволяє її учасникам обліковувати активи між собою, зокрема обмінюватися активами з різних облікових систем. Протокол використовує тільки платіжні канали та канали довіри між вузлами (вага довіри визначається незалежно від користувачів один до одного). У GEO консенсус досягається тільки між залученими до конкретної транзакції сторонами. Водночас у них немає жодної інформації про решту стану мережі. Також відсутній глобальний реєстр для активів, які подано в мережі, і немає єдиного джерела інформації про мережу._


## 3.2 Концепція шардингу

Спочатку концепція _шардинг (sharding)_, або _сегментування_, застосовувалася щодо баз даних [65]. Цей процес передбачав розділення великої бази даних на неперетинні _шарди (shards)_, або _сегменти_, із забезпеченням швидшого доступу до кожного окремого сегменту та простотою управління ним. Важлива особливість – неперетинальність наборів даних сегментів (відсутність у шардах повторень).

Розрізняють вертикальний і горизонтальний тип шардингу. Вертикальний шардинг полягає у виокремленні деяких таблиць із бази даних і перенесення їх на інші сервери (рис. 3.3) [66]. У цьому разі запити до різних таблиць оброблятимуть різні сервери бази даних, що може збільшити пропускну здатність системи загалом. Але водночас дуже важливо забезпечити резервування (реплікування) окремих шардів для підвищення відмовостійкості системи, позаяк обмеження доступу до одного з шардів може критично вплинути на роботу з іншими шардами.

![Рисунок 3.3 – Процес вертикального шардування](/resources/img/volume-3/3.2-Sharding-concept/F-3.3-vertical-sharding.png "Рисунок 3.3 – Процес вертикального шардування")

Горизонтальний шардинг передбачає розбиття єдиної таблиці на складники відповідно до спільних ознак (причому заздалегідь визначеним) (рис. 3.4) [67]. Водночас розподілення відбувається за таким принципом:

> * _Кожний шард має таку саму структуру, що й початкова таблиця_
> * _Розподілення виконується на підставі певних атрибутів елементів_
> * _Під час звернення до системи вона визначає, до якого шарду слід звернутися_

![Рисунок 3.4 – Процес горизонтального шардування](/resources/img/volume-3/3.2-Sharding-concept/F-3.4-horizontal-sharding.png "Рисунок 3.4 – Процес горизонтального шардування")

Перевага горизонтального шардингу також полягає в можливості розподілення оброблення різних частин бази даних з боку окремих серверів (або груп серверів), що впливає на збільшення пропускної здатності системи. Проте поряд з перевагами, які цей підхід надає, у класичному варіанті він має набір обмежень [66]:

> * _Складність складання вибірок елементів, їх пошуку та фільтрування_
> * _Перебалансування (перерозподілення) даних у таблицях_
> * _Підвищені вимоги до реплікування шардів_

Перше обмеження полягає в складності складення загальної вибірки елементів за шардами. Наприклад, якщо ми хочемо отримати декілька записів, які були додано останніми, то це досить складно зробити, оскільки записи додаються до різних шардів, кожний із яких веде власний облік. Також ускладнюються процедури пошуку та фільтрування даних за шардами (якщо мова, звісно, йде не про ті ознаки, за якими ці шарди було розбито).

> _Зауваження. Уявімо приклад, коли таблиця розбита на 5 шардів і ми хочемо зробити вибірку з останніх 100 елементів, які було додано до спільної бази. У цьому разі дуже просто визначити 100 останніх елементів для кожного шарду окремо, але оскільки кожний шард веде власний облік, то вибрати 100 спільних елементів досить складно (потрібно проводити поелементне порівняння). До того ж, позаяк елементи розподіляються шардами не зовсім рівномірно, ми не можемо вибрати 20 останніх із кожного шарду для отримання описаної вибірки._

Другий важливий момент, який варто враховувати, – перебалансування даних у разі появи додаткових шардів. Правила шардингу має бути задано ще до процесу розділення таблиці як такого. Якщо архітектура шардингу не продумана, то це може призвести до втрати деяких даних або пошкодження таблиць. У найкращому разі може виникнути ситуація, коли потрібно буде аналізувати всі наявні шарди для додання нового.

Також за збільшення шардів збільшується ймовірність відмовлення одного з них. Якщо вони розташовані на різних серверах/вузлах, то кожний зі зберігачів сегментів має забезпечити реплікування (резервування) окремого шарду.


### Шардинг у системах на основі blockchain

Щодо систем, що використовують технологію блокчейн, шардинг – це розбиття системи на дрібніші компоненти, кожний із яких займається обробленням окремого (непересічного з іншими) набору транзакцій і зберігає інформацію, що стосується його шарду (транзакції та стани акаунтів).

Кожний із таких сегментів складається з відносно невеликої підмножини валідаторів, які досягають консенсусу щодо свого шарду. Завдяки тому, що кількість шардів зростає пропорційно збільшенню навантаження на облікову систему, це дозволяє справлятися з потоком транзакцій і підтримувати час їх підтвердження в допустимих границях.

Фактично, замість єдиного ланцюжка блоків, ми розділяємо історію на кілька ланцюжків, кожний із яких є шард (рис. 3.5) [68].

![Рисунок 3.5 – Розбиття облікової системи на шарди](/resources/img/volume-3/3.2-Sharding-concept/F-3.5-dividing-into-shards.png "Рисунок 3.5 – Розбиття облікової системи на шарди")

Кожний шард, зі свого боку, має свій власний набір валідаторів, які досягають консенсусу щодо оновлення його стану. Однак водночас виникає низка завдань, які необхідно вирішити за використання шардингу в обліковій системі.

> * _Забезпечення високого рівня захищеності окремого шарду_
> * _Розподілення валідаторів між шардами_
> * _Забезпечення доступності даних_
> * _Підтвердження транзакцій, що стосуються декількох шардів_

Тут ми бачимо перше обмеження, яке пов'язане з меншим ступенем захищеності шарду порівняно з єдиним ланцюжком, над якою працюють усі валідатори. Наприклад, якщо ми уявимо ситуацію, коли консенсус у мережі досягається за допомогою PoW, то розбиття на шарди спричинить пропорційне зменшення обчислювальної потужності в окремих шардах (рис 3.6). Це набагато спрощує проведення атаки 51% [69].

![Рисунок 3.6 – Зниження захищеності окремого шарду порівняно з одним лише ланцюжком](/resources/img/volume-3/3.2-Sharding-concept/F-3.6-reduced-security-of-individual-shard.png "Рисунок 3.6 – Зниження захищеності окремого шарду порівняно з одним лише ланцюжком")

Друге завдання пов'язане з вирішенням питання, хто з валідаторів працює над яким із шардів. Абзацом раніше ми згадували атаку 51%, припускаючи, що потужності валідаторів розподіляються рівномірно між шардами. Якщо же валідатори самі вибирають, над яким сегментом системи їм працювати, то це може призвести до погіршення ситуації та спричинити більшу кількість атак. Відповідно, у системі має бути присутній механізм розподілення валідаторів серед шардів, щодо яких вони досягати згоди.

Третє завдання пов'язане з доступом до даних між шардами. Фактично, вузли-валідатори окремого шарду створюють власний ланцюжок блоків, який містить транзакції, які впливають на зміну локального стану шарду. Однак є низка випадків, коли для прийняття рішень валідаторам необхідно отримати інформацію з іншого шарду.

Якщо транзакція з платежем торкається акаунтів, які розташовані всередині одного шарду, то в цьому разі не виникає жодних проблем: ця транзакція обробляють валідатори цього шарду. Однак необхідно забезпечувати сумісність на етапі, коли транзакція стосується акаунтів, облік яких ведеться в різних шардах: адже якщо шарди не можуть «спілкуватися між собою», то вони нічим не відрізняються від двох незалежних облікових систем, кожна з яких веде власну історію подій.


### Архітектура TON

Один із найяскравіших представників платформ, які використовують у своїй архітектурі технологію шардингу, – TON (Telegram open network) [70]. Технологія передбачає можливість розділення єдиної системи на 2<sup>92</sup> підсистем, які функціонують незалежно та, утім, уміють спілкуватися між собою. У цьому розділі ми розглянемо основні механізми, які лягли в побудову мережі TON, а також розберемося, чи дійсно використання шардингу може вирішити проблеми масштабованості, яким піддана більшість сучасних облікових систем.

Telegram open network містить велику кількість компонентів.

> * _Облікова система_
> * _Розподілене файлове сховище_
> * _Інструменти анонімізування мережі_
> * _DHT_ 
> * _DNS_
> * _Набір інструментів для функціонування платіжних каналів і зв'язування з іншими обліковими системами_

Основний компонент (ядро) TON – облікова система. Інші компоненти допоміжні та дозволяють розширити функціональність платформи. 


### Будова ланцюжка блоків у TON

На відміну від традиційного ланцюжка блоків, яка використовується в багатьох системах, TON пропонує використання багаторівневої архітектури. Для цього передбачено декілька типів ланцюжків блоків:

> * _Masterchain_
> * _Workchain_
> * _Shardchain_

Masterchain – це єдиний кореневий ланцюжок, який використовується для зберігання стану всіх дочірніх ланцюжків. Masterchain зберігає інформацію про поточну версію та параметри протоколу TON, про поточний набір валідаторів і розмірі їхнього stake, про набір поточних активних workchains і shardchains, а також геш-значення актуальних блоків цих ланцюжків. Для досягнення консенсусу в masterchain використовується алгоритм PoS [70].

Masterchain розбивається на workchains – дочірні системи, максимальна кількість яких може дорівнювати 2<sup>32</sup> (рис. 3.7). Кожний workchain – це підсистема, яка має власний протокол обліку, власний формат акаунтів і транзакцій, власну віртуальну машину для виконання контрактів, власну внутрішню валюту тощо. У кожному workchain виконується облік тільки акаунтів, що належать до нього, тому його можна уявити як окрему облікову систему. Водночас до кожної такої системи висувається низка вимог для можливості комунікації з іншими workchains і masterchain (докладніше ці вимоги ми розглянемо далі).

![Рисунок 3.7 – Розбиття masterchain на workchains](/resources/img/volume-3/3.2-Sharding-concept/F-3.7-dividing-into-workchains.png "Рисунок 3.7 – Розбиття masterchain на workchains")

Workchains, зі свого боку, можуть розділятися на shardchains. Кожний із shardchain має таку саму архітектуру, що й батьківський workchain, але водночас він обробляє тільки певну підмножину акаунтів. Максимальна кількість shardchains в одному workchain може досягати 2<sup>60</sup>. 

> _Зауваження. Насправді workchain – абстрактне поняттям; це просто набір shardchains, які одноподібно функціонують за заздалегідь заданими правилами. Якщо пояснити це на простішому прикладі, уявіть таблицю, розділену на шарди. У цьому разі кожний окремий шард – це незалежна таблиця, а глобальний стан – це набір таких таблиць-шардів. Єдиний випадок, за якого workchain можна подати у формі єдиної структури даних, – той, коли цей workchain складається з одного shardchain._

У кожного workchain є власний 32-бітний ідентифікатор (_workchain_id_). Для створення workchain створюється відповідна транзакція, яку має бути підтверджено в masterchain. За замовчуванням із моменту ініціалізації TON підтримує workchain zero (_workchain_id_ = 0). Цей workchain призначений для роботи з TON-контрактами, а також для передавання базової валюти (gram).

Shardchain, зі свого боку, ідентифікується з використанням пари значень: _workchain_id_ – ідентифікатора батьківського _workchain_ – і _shard_prefix_ – значення від 1 до 2<sup>60</sup>, яке визначає простір акаунтів, які оброблятиме цей shardchain.


### Розділення й об'єднання shardchains

Є два типи розділення workchain на shardchains: статичний і динамічний. Статичне розділення передбачає початкове визначення кількості можливих shardchains за певними ознаками. Наприклад, ми хочемо розділити систему на 8 шардів – для кожного з них задаємо підмножину акаунтів, які оброблятимуться (рис. 3.8).

![Рисунок 3.8 – Статичне розділення на shardchains](/resources/img/volume-3/3.2-Sharding-concept/F-3.8-static-splitting-into-shardchains.png "Рисунок 3.8 – Статичне розділення на shardchains")

Це найпростіший спосіб шардування, проте він не найефективніший. Неефективність такого підходу полягає в тому, що потрібно заздалегідь зробити припущення щодо навантаження на систему. Якщо користувач створить невелику кількість shardchains, то за великого навантаження на систему не всі з них зможуть обробляти пов'язані з ним транзакції. Якщо ж, навпаки, задано занадто велику кількість shardchains, то в кожному з них окремо транзакції з'являтимуться дуже рідко, що призведе до додаткових витрат на підтримання системи.

Динамічне сегментування дозволяє заздалегідь не визначати необхідну кількість шардів, а розділяти/об'єднувати shardchains у режимі реального часу. Ця особливість передбачає, що кожний окремий шард може в будь-який момент часу бути автоматично розділено, якщо його пропускної здатності недостатньо (рис. 3.9). За створення нового workchain TON передбачає початкове створення одного shardchain, який надалі може ділитися залежно від навантаження.

![Рисунок 3.9 – Принципи динамічного шардування](/resources/img/volume-3/3.2-Sharding-concept/F-3.9-principles-of-dynamic-sharding.png "Рисунок 3.9 – Принципи динамічного шардування")


### Прийняття рішень щодо стану системи

Раніше ми згадували, що кожний блок masterchain зберігає актуальні на момент його формування геш-значення блоків усіх shardchains мережі. Щойно геш-значення блоку shardchain буде включено до блоку masterchain, цей блок вважається підтвердженим в системі та на нього можуть посилатися наступні блоки.

Кожний новий блок у shardchain також містить останнє значення блоку в masterchain, яке підтверджує всі раніше створені блоки shardchain. Такий зв'язок між masterchain і shardchains потрібний для того, щоби shardchains могли орієнтуватися на стани один одного (рис. 3.10). Фактично, masterchain потрібний для синхронізування всіх дочірніх shardchains (і, відповідно, workchains) і визначення глобального стану системи.

![Рисунок 3.10 – Зв'язок між masterchain і shardchains](/resources/img/volume-3/3.2-Sharding-concept/F-3.10-relation-between-masterchain-and-shardchains.png "Рисунок 3.10 – Зв'язок між masterchain і shardchains")

> _Зауваження. Припускається, що валідатори платформи TON буде кілька сотень учасників, які володіють найбільшими stakes. Усі валідатори в псевдовипадковий спосіб розбиваються на підмножини, кожна з яких протягом деякого часу виконує валідування блоків у межах окремого shardchain (кожного валідатора може бути вибрано до кількох підмножин). Досягнення консенсусу виконується за допомогою алгоритму BFT. Якщо один із валідаторів підписує невалідний блок, то його може бути оштрафовано: він може втратити свій stake (або його частину), а також його може бути виключено з набору валідаторів._

Після того, як усі нові блоки в шардах було згенеровано (або минув час, виділений для їх генерування), генерується новий блок masterchain, який містить геш-значення блоків shardchains. Консенсус щодо додання нового блоку до masterchain досягається через використання протоколу BFT серед усіх валідаторів.


### Обмінювання повідомленнями між shardchains

Повторімо, що обов'язкова вимога до облікової системи, яка підтримує шардинг, – можливість шардів відправляти повідомлення один одному. Є два підходи до побудування такої взаємодії: асинхронні транзакції й атомарні [68].

Розберімо, у чому суть асинхронних транзакцій між шардами на прикладі переказу монет між акаунтами. Уявімо, що Аліса хоче передати Бобу 100 монет, причому їхні акаунти розташовані в різних шардах. У цьому разі в шарді, що відповідає за нарахування коштів Бобу, валідатори підтвердять транзакцію тільки після того, як у них буде достатньо доказів того, що підтверджено пов'язану транзакцію в шарді Аліси, що відповідає за вирахування коштів у неї. Розгляньмо детальніше взаємодію користувачів на рисунку 3.11.

![Рисунок 3.11 – Проведення асинхронних транзакцій](/resources/img/volume-3/3.2-Sharding-concept/F-3.11-conducting-asynchronous-transactions.png "Рисунок 3.11 – Проведення асинхронних транзакцій")

1. Аліса відправляє транзакцію в шарді А, яка вираховує з її акаунта 100 монет.
2. Валідатори шарду А підтверджують транзакцію. Аліса отримує відповідне підтвердження (наприклад, шлях автентифікації в дереві Меркла для цієї транзакції). 
3. Аліса відправляє в шарді B іншу транзакцію, яка містить доказ підтвердження попередньої транзакції. 
4. Валідатори перевіряють докази та підтверджують транзакцію в шарді B.

Однак такий підхід недосконалий і не може застосовуватися в будь-яких облікових системах. Одна з причин – те, що користувач не може бути впевнений в тому, що після підтвердження транзакції в одному з шардів відповідне підтвердження виконається й в іншому. До того ж, якщо шарди можуть розгалужуватися (за правилами протоколу), то ситуація, за якої підтвердження виконається тільки в одному з шардів, набагато ймовірніша. 

> _Зауваження. У TON загальна форма повідомлення, що відправляється, залежить від шарда-отримувача та від акаунта (або контракту) отримувача, проте повідомлення обов'язково має підтримувати загальні поля, які дозволять здійснювати таке відправлення між workchains._
> 
> _Кожне повідомлення містить ідентифікатори акаунтів відправника й отримувача. Ідентифікатор облікового запису в цьому разі – це два значення: workchain_id (для визначення якого workchain належить акаунт) й account_id (у базовому разі 256-бітне значення, яке ідентифікує акаунт всередині workchain)._
> 
> _Ідентифікатори акаунтів можуть відрізнятися в різних workchain. Одна лише вимога, яка висувається, – те, що довжина ідентифікатора повинна бути не меншою за 64 біт (необхідна для шардування)_
> 
> _Деякі повідомлення можуть не мати відправника чи отримувача (обов'язкова є присутність щонайменше одного). Такі повідомлення використовуються для комунікування з зовнішніми системами та застосунками. Повідомлення, яке не містить відправника, безпосередньо включається до відповідного shardchain (якщо воно коректне). Комісія за додання цього повідомлення буде стягнуто з акаунта-отримувача. Повідомлення, яке не містить отримувача, додається до shardchain його відправника. Але водночас не можна гарантувати, що це повідомлення отримала зовнішня система._


## 3.3 Конструкція та застосування DAG

З розвитком технології blockchain багато хто намагався вдосконалити різні аспекти облікових систем, побудованих на її основі, але суть залишалася незмінною: в основі системи завжди лежить єдиний ланцюжок блоків, а самі блоки додаються одним за раз.

Багато в чому DAG-based системи дуже схожі на blockchain-based. Транзакції точно так само зв’язуються між собою за допомогою геш-значень, а в обліковій системі присутні валідатори, які додають і підтверджують нові транзакції. Однак через відмітні риси розгалуженої структури даних потрібно забезпечити пригожий алгоритм досягнення консенсусу. Для цього використовуються, насамперед, механізми ваг і обходів графа, на основі яких і побудовані алгоритми досягнення консенсусу.

Однією з перших спроб впровадити напрямлені ациклічні графи в обліковій системі стала облікова система IOTA, спрямована на потреби IoT-індустрії. У такій сфері вкрай важливо забезпечити високу масштабованість, низьке споживання ресурсів і можливість стійкої роботи за перебоїв зв’язку, водночас не жертвуючи безпекою системи. Але чи вдалося розробникам IOTA й інших облікових систем забезпечити ті переваги, до яких вони прагнули?


### Походження поняття граф

Саме поняття графів виникло досить давно. Математик Леонард Ойлер запровадив його ще у XVIII сторіччі, працюючи над розв’язанням відомої задачі про кеніґсберзькі мости [71–72], суть якої полягала в проходженні семи мостами міста та поверненні до початкового пункту, побувавши на кожному мості тільки одного разу. Як виявилося пізніше, це неможливо. Розберімося ж, чому та як графи допомогли Ойлеру в розв’язанні задачі.

> _Зауваження. Якщо зобразити мости Кеніґсберґа як дуги, а частини міста, звідки можна почати свою подорож, як вершини, вийде такий граф (рис. 3.12). Під час міркувань Ойлер дійшов обґрунтування неможливості обійти всі мости, не перетинаючи їх двічі: будь-який граф, що має більше за дві вершини, до яких веде непарна кількість ребер, неможливо намалювати, не відриваючи олівець від паперу. У нашому разі до всіх вершин веде непарна кількість ребер, отже, обійти їх не вийде._

![Рисунок 3.12 – Схема кеніґсберзьких мостів](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.12-Königsberg-bridges-scheme.png "Рисунок 3.12 – Схема кеніґсберзьких мостів")

Відтоді теорія графів пройшла довгий шлях і зараз використовується в різних сферах, від економіки до комп’ютерних наук. Наприклад, у сфері комп’ютерних наук графи – основа багатьох деревоподібних структур даних. У фізиці та схемотехніці за допомогою графів зображують принципові схеми, а в економіці графи використовуються для прийняття локально оптимальних розв’язків на кожному етапі розв’язання задачі. Також графи знайшли застосування у сфері маршрутизування даних і навігації.


### Що таке DAG?

_Напрямлений ациклічний граф (directed acyclic graph, DAG) – це орієнтований граф, для якого неможливо здійснити замкнений обхід_. Це визначення може звучати доволі заплутано, тому спочатку згадаймо основні визначення з теорії графів.

Передусім, графом називають абстрактну структуру, що складається зі множини вершин і ребер, які пов’язують вершини між собою (рис. 3.13). Самі вершини мають довільну структуру та можуть бути різні об’єкти (міста, стани, комутатори і т. ін.).

![Рисунок 3.13 – Неорієнтований граф](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.13-undirected-graph.png "Рисунок 3.13 – Неорієнтований граф")

Графи поділяються на такі категорії:

* _Неорієнтований граф – граф, у якому ребра не мають напрямків (рис. 3.13)_
* _Напрямлений (орієнтований) граф – вид графа, ребра якого мають напрямок_

Водночас в орієнтованому графі може бути присутній цикл (замкнений обхід) – обхід за послідовністю ребер, за якого ми повертаємося до вихідної вершини. Отже, ациклічним графом називають той, у якому замкнені обходи відсутні. Для кращого розуміння продемонструймо напрямлений циклічний граф на рис. 3.14 і напрямлений ациклічний граф на рис. 3.15.

![Рисунок 3.14 – Приклад напрямленого циклічного графа](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.14-directed-cyclic-graph.png "Рисунок 3.14 – Приклад напрямленого циклічного графа")

![Рисунок 3.15 – Приклад напрямленого ациклічного графа](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.15-directed-acyclic-graph.png "Рисунок 3.15 – Приклад напрямленого ациклічного графа")


### Архітектура децентралізованих облікових систем на основі DAG

Облікові системи на основі DAG, на відміну від blockchain-based систем, дозволяють підтверджувати транзакції паралельно (кількома незалежними потоками одночасно). Об’єкти в облікових системах на основі DAG зв’язуються за допомогою геш-значень, тобто нові транзакції посилаються на ті, які вже включено до структури.

Кожний новий об’єкт має послатися на кілька попередніх, що дозволяє графу, збільшуючись, лишатися доволі зв’язним.

Для описання взаємозв’язків між транзакціями вводяться поняття _прямого_ та _непрямого_ підтвердження. Якщо подати транзакції у формі вершин графа, а посилання – у формі ребер, одна транзакція _прямо підтверджуватиме_ іншу, якщо між ними є ребро. _Непряме підтвердження_ з’являється, коли дві транзакції не мають ребра, яке зв’язує їх, але є шлях, яким можна пройти від однієї транзакції до іншої. Наочний приклад продемонстровано на рис. 3.16.

![Рисунок 3.16 – Зв’язок транзакцій у граф](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.16-relation-of-transactions-in-graph.png "Рисунок 3.16 – Зв’язок транзакцій у граф")

Як видно з рисунка, транзакція А _прямо_ підтверджує транзакції B та C, а також _непрямо_ підтверджує транзакції D й E. Таким чином, генезис-транзакцію (G) підтверджують _усі_ подальші чи то прямо, чи то непрямо.

Транзакція, яку тільки додано до графа та яка ще не має підтверджень, називається _tip_. У нашому разі транзакції A й I – це tips. Після того, як транзакцію додано, інформація про неї ретранслюється мережею.

За отримання нової транзакції валідатор перевіряє її структуру й інші параметри, які безпосередньо залежать від конкретної облікової системи (наприклад, чи присутній у ній доказ виконаної роботи та чи всі підписи дійсні) [73–74].


### Досягнення консенсусу та вирішення розбіжностей

Під час додавання нової транзакції до графа послатися можна на будь-які попередні транзакції, але чи має це сенс? Авжеж, ні, оскільки це не приносить жодної користі для системи. Найлогічніше підтверджувати та посилатися на tips. Однак часто кількість tips у заданий момент часу буде набагато більше за 1, тому має бути алгоритм їх вибирання.

Найочевидніший варіант буде випадковий обхід графом у пошуках непідтверджених транзакцій, на які можна послатися. Проте в такому разі немає способу вберегтися від tips, які посилаються на давно підтверджені транзакції, оскільки неможливо абсолютно точно сказати, коли прийшла конкретна транзакція, змусивши в такий спосіб валідаторів вибирати тільки найостанніші. Рішення подібної проблеми буде застосування механізмів cumulative weight і weighted random walks.

Cumulative weight – це «сукупна вага» конкретної транзакції, тобто кількість транзакцій, які прямо чи непрямо на неї посилаються (з урахуванням цієї самої транзакції).

Weighted random walks – це механізм рандомізованого проходу графом, у якому той, хто проходить, імовірніше пройде шляхом до транзакції з найбільшою сукупним вагою.

Основна ідея такого підходу полягає в тому, що чесні валідатори не посилатимуться на некоректні транзакції, через що вага цих транзакцій буде набагато меншою та врешті-решт їх буде відкинуто. Такий підхід не тільки змушує валідаторів вибирати транзакції, які, найімовірніше, коректні, але й запобігає ситуації, коли валідатор вирішує послатися на вже давно підтверджену транзакцію, не приносячи користі для системи.

Розгляньмо приклад роботи цих механізмів на рис. 3.17.

![Рисунок 3.17 – Приклад ситуації з транзакцією, що посилається на давно підтверджену](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.17-transaction-referring-to-already-confirmed-transaction.png "Рисунок 3.17 – Приклад ситуації з транзакцією, що посилається на давно підтверджену")

Валідатор, який створив транзакцію 16, вирішив послатися на вже підтверджену транзакцію 7 замість того, щоби підтвердити та послатися на 15 або 8. Коли наступний валідатор вибиратиме tips, на які йому послатися, і дійде до транзакції 7, імовірність того, що він перейде в 16, украй мала, оскільки її сумарна вага дорівнює 1. Натомість він перейде до 9 і продовжить обхід.

Такий підхід не тільки мотивує валідаторів підтверджувати нові транзакції, але й забезпечує захист від невалідних транзакцій. Уявімо, що транзакція 16 насправді невалідна. Навіть якщо хтось із чесних валідаторів перейде до неї (адже цей метод обходження передбачає деякий ступінь випадковості), він не стане на неї посилатися.

Однак якщо транзакція потрапила до графа та на неї хтось послався, це не робить її підтвердженою. Для запобігання атак подвійної витрати застосовується механізм _confirmation confidence_. Confirmation confidence – це значення, яке обчислюється для кожної конкретної транзакції та позначає ступінь прийняття транзакції з боку учасників мережі. Значення confirmation confidence варіюється від 0 до 100 % й обчислюється в такий спосіб: певну кількість разів виконується алгоритм обходу графа, після чого виконується підрахунок кількості транзакцій, які посилаються на поточну, і на їхній основі виконується розрахунок confirmation confidence.

Імовірність того, що транзакцію з високим значенням confirmation confidence (більшим за 95 %) буде відкинуто, украй мала. Єдина можливість виконати атаку подвійної витрати в такій ситуації – підтвердити цієї транзакцією дві давно підтверджені, після чого почати генерувати велику кількість нових транзакцій, підвищуючи сукупну вагу нової гілки. Проте такий сценарій можливий, тільки коли зацікавлена в подвійній витраті сторона здатна згенерувати більше транзакцій, ніж усі інші учасники системи.

> _Зауваження. У деяких системах, наприклад, IOTA, використовується більш централізований підхід, базований на публікації в мережі спеціальних транзакцій (з боку спеціально призначеного учасника), які фіксують стан системи._

Розібравши основи архітектури та функціонування облікових систем на основі напрямлених ациклічних графів, розгляньмо декілька прикладів представників систем такого класу.


### IOTA

IOTA – це асинхронна permissionless облікова система, розроблена з урахуванням потреб індустрії IoT, які вимагають масштабованості, низького споживання ресурсів, відсутність комісій, можливості стійкої роботи за перебоїв зв’язку та високого рівня безпеки. IOTA працює на основі tangle; таку назву дали розподіленому DAG-реєстру розробники [75].


### Транзакції в IOTA

Перш ніж рухатися далі, докладніше розгляньмо структуру та життєвий цикл транзакції, а також етапи, які вона має пройти, перш ніж вважатися підтвердженою. Загальну структуру транзакції наведено на рис. 3.18.

![Рисунок 3.18 – Структура транзакції в IOTA](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.18-IOTA-transaction-structure.png "Рисунок 3.18 – Структура транзакції в IOTA")

До поля hash поміщається геш-значення, яке покриває всі поля транзакції.

> _Зауваження. У ролі алгоритму гешування IOTA використовує Curl-P-R. Curl-P-R – алгоритм гешування, розроблений спеціально для роботи з трійковою системою числення. За своєю суттю Curl-P-R – це модифікована функція губки (клас криптографічних алгоритмів). Числом R в цьому разі позначено кількість раундів гешування._
> 
> _У 2019 році дослідники з Boston University, MIT Media Lab і Harvard University подали публікацію, у якій було доведено вразливість алгоритму Curl-P-27 до колізій [76]. Із заяв самих розробників, у реальних умовах практично неможливо реалізувати подібну атаку через методи захисту, реалізовані в централізованому механізмі підтвердження транзакцій._
> 
> _Однак на цю мить для обчислення геш-значення транзакцій і доказів виконаної роботи замість Curl-P-27 застосовується Curl-P-8 [77]._

Поле _signatureMessageFragment_ містить значення підпису (WOTS) або довільне інформаційне повідомлення. Підпис покриває геш-значення зв’язки транзакцій і залежно від довжини належить до одного з трьох рівнів безпеки: першого (2187 трайт), другого (4374 трайт) чи третього (6561 трайт). Водночас розмір поля signatureMessageFragment обмежено до 2187 трайт, і в разі перевищення цього розміру підпис потрібно буде ділити на декілька частин.

Поле _address_ вказує на адресу отримувача чи відправника залежно від типу транзакції. Типи транзакцій ми розглянемо далі в цьому підрозділі.

У полі _value_ задано кількість відправлених або отриманих монет. Якщо ж потрібно просто передати в мережі певне повідомлення, не прикріплюючи до нього монети, можна вказати нульове значення цього поля.

Поле _timestamp_ містить часову мітку створення транзакції, але вона не перевіряється і, фактично, може містити довільне значення.

Поля _currentIndex_ і _lastIndex_ містять індекси відповідно поточної та останньої транзакції у зв’язці (bundle).

Поле _trunkTransaction_ містить геш-значення наступної ліком транзакції у зв’язці або геш-значення іншої транзакції в tangle (тільки для останньої транзакції). Докладніше формування цього поля ми розглянемо далі.

Поле _branchTransaction_ використовується, щоби послатися на одну з опублікованих транзакцій у графі. Далі ми докладно опишемо, що таке bundle, а також розглянемо, у який спосіб транзакції посилаються одна на одну.

У полі _bundle_ указано геш-значення, необхідне для визначення того, до якої зв’язки належить ця транзакція. Для цього геш-значення покриває поля _address_, _value_, _currentIndex_, _lastIndex_ і _timestamp_ для всіх транзакцій в одній зв’язці [79].

Поле _attachmentTag_ дозволяє встановити довільну службову мітку повідомлення. Передусім, це використовується для ідентифікації повідомлень під час обмінювання інформацією між IoT-пристроями.

У полі _attachmentTimestamp_ указано час формування транзакції.

Значення в _полі_ nonce інкрементується після кожної спроби розв'язання задачі PoW [73]. На цю мить складність – константна величина, проте розробники IOTA працюють над впровадженням протоколу Coordicide, який, зокрема, упровадить механізм адаптивної складності [74].

Самі транзакції бувають трьох типів: _input_, _output_ і _zero-value_ (рис. 3.19). Тип транзакції залежить від її призначення. Однак для переказування коштів кожній input транзакції має відповідати output транзакція.

![Рисунок 3.19 – Типи транзакцій в IOTA та їхні обов’язкові поля](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.19-transaction-types-in-IOTA-and-their-required-fields.png "Рисунок 3.19 – Типи транзакцій в IOTA та їхні обов’язкові поля")

Input транзакція має негативне значення в полі value, вказуючи в такий спосіб, що монети списуються з певної адреси. Також у ній обов’язково вказано адресу, на якій перебуває достатня кількість монет, підпис або його фрагмент і коректне значення nonce.

Output-транзакція, зі свого боку, має містити позитивне значення в полі value, коректну адресу та nonce.

Zero-value транзакції містять 0 у полі value, а в полі address необов’язково вказувати коректну адресу. Цей тип транзакцій використовується для обмінювання повідомленнями між учасниками мережі.


### Структура та призначення bundle

Раніше в розділі ми згадували термін bundle. Bundle – це зв’язка взаємозалежних транзакцій [81]. Наприклад, транзакція, яка перераховує монети на адресу Аліси прямо залежить від транзакції, яка списує ці монети з балансу Боба. Отже, їх обох буде поміщено до однієї зв’язки.

Bundle складається з трьох частин: _head_, _body_ та _tail_. До tail поміщається перша транзакція у зв’язці (з нульовим значенням currentIndex), а до head, відповідно, – остання транзакція (currentIndex якої дорівнює lastIndex).

Усі транзакції в bundle, крім head, зв’язуються через поле trunkTransaction. Цей зв’язок дозволяє вузлам визначити належність транзакцій до однієї зв’язки та провалідувати їх. Поле branchTransaction використовується, щоби посилатися на одну з раніше доданих до графа транзакцій. Для кращого розуміння детально розгляньмо приклад bundle на рис. 3.20.

![Рисунок 3.20 – Структура bundle](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.20-bundle-structure.png "Рисунок 3.20 – Структура bundle")

Як можна побачити з рисунка, усі чотири транзакції пов’язані між собою: у полі _trunkTransaction_ вказано геш-значення транзакції з наступним ліком індексом. У полі _branchTransaction_ вказується геш-значення _trunk tip_ – уже доданої до реєстру tail транзакції з іншого bundle. Оскільки TX(3, 3) остання, у полі trunkTransaction вона також посилається на trunktip, а в branchTransaction вказано геш-значення _branch tip_ – другої транзакції, яку було додано до реєстру раніше.

Bundle також поділяються на типи: _transfer bundles_ і _zero-value bundles_. У разі перших зв’язка містить щонайменше одну вхідну й одну вихідну транзакції. Зі свого боку, zero-value bundles містять zero-value транзакції з інформаційними повідомленнями. Розгляньмо короткий приклад.

Аліса хоче відправити Бобу одну монету, використовуючи підпис 2 рівня. У bundle буде три транзакції: перша зараховує монету на баланс Боба; друга списує її з балансу Аліси та містить фрагмент підпису, за допомогою якого Аліса доводить володіння своїм особистим ключем; третя містить фрагмент підпису, що залишився, оскільки підпис має занадто велику довжину та не поміститься до однієї транзакції (рис. 3.21). Водночас відзначмо, що транзакція зарахування монет на баланс Боба не вимагає підпису, тому поле _signatureMessageFragment_ залишається порожнім.

![Рисунок 3.21 – Приклад bundle із трьох транзакцій, що забезпечують переказ однієї монети з адреси Аліси на адресу Боба](/resources/img/volume-3/3.3-Design-and-application-of-DAG/F-3.21-bundle-with-three-transactions-transferring-one-coin.png "Рисунок 3.21 – Приклад bundle із трьох транзакцій, що забезпечують переказ однієї монети з адреси Аліси на адресу Боба")

### \*\*\*Часті запитання\*\*\*

_– Чому в IOTA використовується трійкова система числення?_

Трійкова система числення забезпечує не тільки більшу ефективність обчислень, але також дозволяє працювати з від’ємними числами на арифметичному рівні без необхідності вдаватися до доповняльного коду, як у разі двійкової системи числення.

_– Хто такий координатор і яка його роль в IOTA?_

Оскільки мережа IOTA ще перебуває на ранньому етапі свого розвитку, вона не може дозволити собі бути повністю децентралізована, через що розробникам довелося вдатися до впровадження механізму координатора. Координатор – це вузол-валідатор у мережі IOTA, який належить IOTA Foundation. Усі транзакції, на які посилаються транзакції, що створює координатор (їх називають milestones), вважаються остаточно підтвердженими.

# [4 МЕХАНІЗМИ ЗАБЕЗПЕЧЕННЯ КОНФІДЕНЦІЙНОСТІ В ІНТЕРНЕТІ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ua/4-Privacy-and-anonymity-on-the-Internet.md)
