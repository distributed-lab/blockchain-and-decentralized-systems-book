# [4 МЕХАНІЗМИ ЗАБЕЗПЕЧЕННЯ КОНФІДЕНЦІЙНОСТІ В ІНТЕРНЕТІ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ua/4-Privacy-and-anonymity-on-the-Internet.md)

# 5 РОЛЬ КРИПТОГРАФІЧНИХ ЗОБОВ'ЯЗАНЬ В ОБЛІКОВИХ СИСТЕМАХ

Низька конфіденційність становить серйозну загрозу безпеці облікової системи. Наприклад, ваші конкуренти можуть дізнатися про всі угоди, які ви провели, вивчити деталі вашого бізнесу тощо. У Bitcoin, наприклад, питання забезпечення анонімності частково вирішується через присвоєння адрес. Якщо третя сторона не знає, що саме вам належить та чи інша адреса, її можливість впливати на вас помітно знижується.

Проте мережа передбачає взаємодію сторін. Унаслідок цієї взаємодії сторони дізнаються про адреси/акаунти одна одної. Отже, третя сторона, з якою ви взаємодієте, може переглянути інформацію про ваші попередні дії й отримати потрібну їй інформацію, позаяк деталі всіх транзакцій за замовчуванням відкриті.

Засоби, завдяки яким можна забезпечити вищий рівень конфіденційності, часто дуже дорого коштують системі (знижують її продуктивність і пропускну здатність), однак для деяких платформ конфіденційність – дійсно важлива вимога, заощаджувати на якій не варто. У цьому розділі ми розглянемо принципи побудови confidential transaction (CT) як одного з методів забезпечення конфіденційності (з можливістю публічного аудиту) у відкритих системах (рис. 5.1).

![Рисунок 5.1 – Розкриття деталей транзакції з боку стороннього спостерігача та використання CT для приховування цих деталей](/resources/img/volume-3/5.0/F-5.1-disclosure-of-transaction-details-and-using-CT.png "Рисунок 5.1 – Розкриття деталей транзакції з боку стороннього спостерігача та використання CT для приховування цих деталей")


## 5.1 Методи побудування криптографічних зобов'язань

У цьому розділі ми розглянемо функціонування фундаментальних основ доказів із нульовим розголошенням – _криптографічних зобов'язань_. 

Криптографічні зобов'язання зазвичай використовуються тоді, коли ви хочете зафіксувати деяке значення і згодом за його розголошення довести, що саме його було зафіксовано. Наприклад, ви хочете зробити ставку на одного з коней, який, як ви вважаєте, добіжить до фінішу першим. Водночас ви не хочете, щоби хтось дізнався, на якого коня ви поставили, до моменту закінчення забігу, і хочете мати можливість довести (з підсумку забігу), що ви поставили на конкретного коня.

Криптографічні зобов'язання можуть працювати тільки завдяки наявності односпрямованих функцій: сторона, що доводить, повинна мати можливість надати вихідне значення односпрямованої функції, яка сама по собі не розкриває вхідне повідомлення (сторона-перевіряч використовуватиме таку саму функцію для перевіряння знання) [91].

З цією роллю, наприклад, відмінно справляються геш-функції. Користувач може зробити ставку на коня під номером 2, надавши геш-значення від цього числа. Після того як кінь перемагає в забігу, користувач розголошує секрет, а перевіряч запевняється, що це значення відповідає раніше наданому зобов'язанню (рис. 5.2).

![Рисунок 5.2 – Використання зобов'язання для номера коня](/resources/img/volume-3/5.1-Methods-of-building-cryptographic-commitments/F-5.2-using-commitment-to-bet.png "Рисунок 5.2 – Використання зобов'язання для номера коня")


### Додання випадковості як компоненту зобов'язань

Описаний вище підхід не дуже безпечний, тому що щоразу, надаючи зобов'язання знання 2, користувач надаватиме те саме геш-значення. Відповідно, за допомогою цього перевіряч зможе розкрити знання користувача.

> _Зауваження. Якщо набір можливих варіантів знання невеликий (наприклад, у забігу бере участь тільки 10 коней), то, отримавши геш-значення від певного числа, перевіряч може швидко перебрати всі варіанти та розкрити значення секрету. Однак навіть якщо врахувати, що кількість варіантів велика (наприклад, 2<sup>256</sup>), то зобов'язання для тих самих знань не відрізнятимуться одне від одного. Якщо ми надаємо геш-значення від 2, перевіряч може зберегти цю відповідність (зобов'язання–знання). Якщо дещо згодом ми надаємо зобов'язання для цього самого знання, перевіряч може швидко розкрити секрет._

Який є спосіб вирішити це? Усе дуже просто: уявіть, що сторона, що доводить, відправляє перевірячу не тільки значення 2, а й кілька випадкових байтів, які йдуть після 2 (рис. 5.3). Оскільки геш-функція стійка до знаходження прообразу та колізії, то ми можемо використовувати цю властивість для того, щоби той, хто перевіряє, не розкрив знання, маючи тільки зобов'язання, і той, хто доводить, не зміг це значення змінити [91].

![Рисунок 5.3 – Додання випадковості під час формування зобов'язань](/resources/img/volume-3/5.1-Methods-of-building-cryptographic-commitments/F-5.3-adding-randomness-to-commitments.png "Рисунок 5.3 – Додання випадковості під час формування зобов'язань")

Хоча геш-функції й можуть забезпечити ці властивості, вони не мають нічого спільного з гомоморфізмом, який є дуже важлива властивість у доказах із нульовим розголошенням.

> _Зауваження. Нагадаємо, що гомоморфізм полягає в можливості проводити деякі математичні операції з зобов'язаннями і водночас забезпечувати комутативність й асоціативність цих операцій. Якщо ж використовувати в ролі зобов'язань геш-значення, то_ $\mathrm{hash} (a)+ \mathrm{hash} (b) \neq \mathrm{hash} (a+b)$_; це значить, що ми не можемо проводити операції над зобов'язаннями для отримання коректного результату_ [92]_._


### Зобов'язання Педерсена

У ролі зобов'язань ми можемо використовувати зобов'язання Педерсена [93]. У них роль односпрямованої функції виконує операція множення точки еліптичної кривої на скаляр. Зобов'язання Педерсена можна подати у формі такого рівняння: $C=rH+aG$, де _a_ – секрет (знання), _G_ і _Н_ – генератори групи точок (точки на кривій), _r_ – випадкове значення. Тут _r_ використовується так само, як й у геш-функції в прикладі вище. Крім того, сторона, що доводить, не повинна має можливості встановити залежність _Н_ від _G_ (далі докладно розглянемо, чому так).

Зобов'язання Педерсена можуть забезпечити _необерненість_ (неможливість отримати секрет за наявністі тільки зобов'язання), _доказовність_ (маючи зобов'язання, верифікатор може з високим рівнем достовірності перевірити правильність знання) і _гомоморфізм_. Незворотність і доказованість забезпечуються завдяки складності задачі дискретного логарифмування. Гомоморфізм полягає в такому:

![Рисунок 5.4 – Суть гомоморфизма в обязательствах Педерсена](/resources/img/volume-3/5.1-Methods-of-building-cryptographic-commitments/F-5.4-homomorphism-in-Pedersen-commitments.png "Рисунок 5.4 – Суть гомоморфизма в обязательствах Педерсена")

Тобто можна сформувати _одне зобов'язання_ (одне значення точки), щоб довести виконання _набору зобов'язань_ (за умови, що надлишкові значення також надано коректно).

Тепер той, хто доводить, може надати перевірячу одне зобов'язання, після чого – набір знань, який задовольняє йому (рис. 5.4). Наприклад, той, хто доводить, хоче одночасно поставити на 10 різних верхогонів, надавши одне значення.

![Рисунок 5.4 – Надання єдиного зобов'язання для великого набору знань](/resources/img/volume-3/5.1-Methods-of-building-cryptographic-commitments/F-5.5-single-commitment-to-set-of-knowledge-values.png "Рисунок 5.4 – Надання єдиного зобов'язання для великого набору знань")

> _Зауваження. У цьому підрозділі ми розглядаємо зобов'язання Педерсена, які використовують еліптичну криптографію. Однак є ще «класична» реалізація цієї схеми зобов'язань. Згідно з протоколом параметрами виступають h і g (уже не точки еліптичної кривої, а великі прості числа). Сторона, що доводить, володіє секретом a та генерує випадкове значення r. Доказ – це значення_ $C=g^{a}h^{r}$_. Верифікатор, отримуючи значення a та r, у такий самий спосіб може перевірити, що зобов'язання задоволено._


### Підмінювання знань і підходи «nothing up my sleeve»

Як ми відзначали раніше, важлива випадковість значення точки _H_. Якщо сторона, що доводить, може встановити залежність між точками _H_ і _G_, то він може формувати підроблені докази, які задовольнять зобов'язанню.

Ця властивість полягає в тому, що зобов'язання – це точка на кривій, яку було отримано внаслідок складання двох точок – _rH_ й _aG_. _H_ – точка, похідна від _G_: _H = xG_, де х невідоме значення. У підсумку, зобов'язання має такий вигляд: $C=rH+aG=rxG+aG=(rx+a)G$.

Стороні, що доводить, відомі значення _r_ й _a_. Якби їй було відомо й значення _х_, то вона могла б змінювати _а_, _r_ й _х_ так, щоб вони задовольняли зобов'язанню. Однак позаяк той, хто доводить, не знає x, то він не може підібрати модифіковане _x_', за допомогою якого можна сформувати підроблений доказ. 

Промоделюймо таку атаку на нашому прикладі зі ставками. Отже, точка _H_ не випадкова: сторона, що доводить, знає значення секрету, яке за множення на _G_ дає значення _H_ (наприклад _H = 3G_). Сторона, що доводить, хоче поставити на коня під номером 2 (значення _a_). Вона генерує випадкове значення _r = 2_ та передає перевірячу зобов'язання (рис. 5.5).

![Рисунок 5.5 – Надання зобов'язання перевірячу: r = 2, a = 2](/resources/img/volume-3/5.1-Methods-of-building-cryptographic-commitments/F-5.6-A-providing-of-commitment-to-verifier.png "Рисунок 5.5 – Надання зобов'язання перевірячу: r = 2, a = 2")

Раптово у верхогонах виграє кінь під номером 5. Якби сторона, що доводить, не знала _x_, то вона точно втратила би гроші. Але позаяк вона знає _х_, вона відправляє перевірячу підроблені значення $a=5$ і $r=1$ (рис. 5.6).

![Рисунок 5.6 – Передання підроблених доказів: r = 1, a = 5](/resources/img/volume-3/5.1-Methods-of-building-cryptographic-commitments/F-5.6-B-successful-use-of-fake-commitments.png "Рисунок 5.6 – Передання підроблених доказів: r = 1, a = 5")

Як бачимо з рис. 5.6, перевіряч прийняв докази, хоча спочатку сторона, що доводить, надавала зобов'язання для абсолютно інших значень. Таким чином, ми довели важливість того, що _H_ має бути задано випадково.

Для доведення того, що _H_ не було задано в спеціальний спосіб, є набір методів «nothing up my sleeve» [94; 95]. Цей набір доволі широкий, але основні принципи можна пояснити на такому прикладі. 

Уявіть, що ви просто берете геш-значення від будь-яких даних і перевіряєте, чи є це значення точка на еліптичній кривій. Якщо так, то ви можете задати його як _H_. Водночас, хоча ви й знаєте початковий набір даних, ви не можете знайти _x_. Це дуже схоже на створення адреси, з якої не можна витратити монети (non-spendable address).

На практиці для отримання точки _H_ найчастіше беруть геш-значення від точки _G_ та конкатенують із лічильником до моменту, поки не буде знайдено точку на кривій (точніше, дійсну координату _x_): 

$x_{H}= \mathrm{hash} (G \Vert i)$.

> _Зауваження. Для перевіряння факту, чи дійсно координату х вибрано правильно, потрібно обчислити відповідне ціле значення у із рівняння еліптичної кривої:_ $y^{2}=ax^{3}+bx+c$_. Отримані координати і будуть координати точки H._


### Одне зобов'язання для вектора значень

Одна з цікавих властивостей зобов'язань Педерсена – також те, що розмір зобов'язань не залежить від того, чи приховуємо ми один секрет або вектор значень. У будь-якому разі зобов'язання – це єдине значення точки на кривій (рис. 5.7) [91].

![Рисунок 5.7 – Зобов'язання – це єдине значення точки незалежно від обсягу приховуваних знань](/resources/img/volume-3/5.1-Methods-of-building-cryptographic-commitments/F-5.7-A-commitment-is-single-point-value.png "Рисунок 5.7 – Зобов'язання – це єдине значення точки незалежно від обсягу приховуваних знань")

У цьому разі ці зобов'язання може бути перевірено, якщо сторона, що доводить, надасть _r_ і всі значення вектора _a_. Але повторимо, що водночас незалежно від кількості елементів у векторі зобов'язання буде одна точка. 

До того ж, ми можемо створити такі самі зобов'язання для великої кількості різних векторів, водночас зберігши розмір цих зобов'язань.

![Рисунок 5.7-Б – Приблизний вигляд зобовʼязань для різних видів значень](/resources/img/volume-3/5.1-Methods-of-building-cryptographic-commitments/F-5.7-B-commitment-for-different-value-vectors.png "Рисунок 5.7-Б – Приблизний вигляд зобовʼязань для різних видів значень")

> **_Властивості зобов'язань Педерсена_**  
> * _Perfect hiding_
> * _Computational binding_
> * _Equivocality_

_Рerfect hiding_ означає, що третя сторона не може отримати секрет, маючи тільки відповідне йому зобов'язання. Навіть якщо вона знайде значення, які задовольняють зобов'язанню, вона не зможе бути впевнена в тому, що це саме той секрет, яким володіє сторона, що доводить. 

_Computationally binding_ передбачає, що зловмисник не може підібрати інші дані, що задовольняють конкретним зобов'язанням, не розв'язавши завдання дискретного логарифмування в групі точок еліптичної кривої (за умови, що він не має додаткових даних про використовувані параметри).

_Equivocality_ – деяке обмеження цієї схеми зобов'язань і випливає з попередніх властивостей. Воно передбачає, що певним зобов'язанням можуть задовольняти різні набори даних і сторона, що доводить, може переконати перевіряча, що знає секрет, без знання такого, якщо генерація параметрів не була випадкова [91].


### Схема зобов’язань Ель-Ґамаля

Схема зобов'язань Ель-Ґамаля [96] також доволі часто використовується, але має трохи інші властивості, на відміну від зобов'язань Педерсена. Розгляньмо, як вона працює. Ми маємо два випадкових генератори групи: _g_ й _h_. Сторона, що доводить, хоче надати зобов'язання до секрету _a_. Спочатку вона також генерує випадкове значення _r_, за допомогою якого додає випадковості зобов'язанню. Самі зобов'язання – це пара значень, і вони розраховуються в такий спосіб: $C=(g^{r},ah^{r})$.

Для доведення знання користувачу необхідно надати значення _a_ й _r_. Перевіряч у такий самий спосіб обчислює зобов'язання; якщо воно дорівнює отриманому раніше – знання секрету доведено.

> **_Властивості зобов’язань Ель-Ґамаля_**  
> * _Perfect binding_
> * _Computational hiding_
> * _Extractability_

_Perfect binding_ указує на те, що зобов'язання строго прив'язані до вихідному секрету, тобто незалежно від обчислювальної потужності зловмисник не зможе підібрати інший секрет, який задовольняє доказу. 

_Computational hiding_ означає, що зловмисник не зможе розрізнити два зобов'язання для двох різних повідомлень (за умови, що він не зможе розв'язати задачу факторизування).

_Extractability_ передбачає, що якщо зловмисник розв’яже задачу факторизування, то він зможе розкрити секрет для будь-якого зобов'язання. 


## 5.2 Протокол ідентифікації Шнорра як схема інтерактивного доведення з нульовим розголошенням

Щоб розібратися, як працюють інтерактивні докази з нульовим розголошенням і як у них використовуються схеми зобов'язань (розглянуті в попередньому підрозділі), розгляньмо одну з інтерактивних схем доказів – схему ідентифікації Шнорра. Схема ідентифікації дуже схожа на схему підписання Шнорра, за винятком того, що вона проходить інтерактивно (не вимагає комунікації між підписантом і перевірячем під час перевіряння підпису) і повідомлення не використовуватимуться.


### Схема ідентифікації Шнорра

Згідно з цим протоколом сторона, що доводить, володіє деяким секретом _x_ і відповідним зобов’язанням $P = xG$. Тут зв'язок між зобов’язанням і секретом точно такий самий, як між відкритим й особистим ключем в схемі однойменного підпису. Сторона, що доводить, хоче надати доказ знання x, водночас не розкриваючи його значення [97]. 

Алгоритм складається з чотирьох етапів. На першому етапі сторона, що доводить, генерує новий секрет _r_ і формує відповідне йому зобов'язання $R = rG$. Відкрите значення передається верифікатору. У відповідь на це перевіряч генерує випадковий скаляр _e_ й повертає його стороні, що доводить (другий етап протоколу). На третьому етапі за допомогою секрету _x_, а також значень _r_ й _e_ сторона, що доводить формує доказ знання секрету та відправляє його перевірячу. На останньому етапі перевіряч верифікує отриманий доказ і переконується в знанні секрету з боку сторони, що доводить (якщо перевіряння завершено успішно). Опис протоколу подано на рис. 5.8.

![Рисунок 5.8 – Схема ідентифікації Шнорра](/resources/img/volume-3/5.2-Schnorr-identification-protocol-as-an-interactive-zero-knowledge-proof-scheme/F-5.8-Schnorr-identification-scheme.png "Рисунок 5.8 – Схема ідентифікації Шнорра")

1. Той, хто доводить, генерує випадкове значення _r_ й обчислює $R = rG$. Після цього він передає _R_ перевірячу. Перевіряч не може обчислити _r_ (розв'язати задачу дискретного логарифмування в групі точок еліптичної кривої). 
2. Перевіряч генерує відкритий параметр _e_ й передає його тому, хто доводить.
3. Той, хто доводить, обчислює $s = r + ex$ і передає його тому, хто перевіряє. Маючи тільки значення _s_ й _e_, перевіряч не може отримати секрет _x_.
4. Перевіряч верифікує доказ знання _х_ згідно з виразами на рис. 5.9.

![Рисунок 5.9 – Перевіряння доказу з боку верифікатора](/resources/img/volume-3/5.2-Schnorr-identification-protocol-as-an-interactive-zero-knowledge-proof-scheme/F-5.9-proof-verification.png "Рисунок 5.9 – Перевіряння доказу з боку верифікатора")

Як бачимо, цей протокол задовольняє вимогам протоколів доведення знання з нульовим розголошенням (у прикладі – доведення того, що користувач володіє конкретним відкритим ключем):

* Сторона, що доводить, гарантовано переконує верифікатора, що вона володіє необхідними знаннями.
* Якщо сторона, що доводить, не володіє секретом, вона не може переконати верифікатора в протилежному
* Під час доведення знання секрету не розкривається сам секрет


### Підроблення доказу з боку сторони, що доводить

Якщо сторона, що доводить, знає значення _e_ (скаляр, який згенерував перевіряч) до початку взаємодії з перевірячем, вона може підробляти докази, не знаючи значення секрету. Розберімо, як це працює (рис. 5.10).

![Рисунок 5.10 – Процес підроблення доказу](/resources/img/volume-3/5.2-Schnorr-identification-protocol-as-an-interactive-zero-knowledge-proof-scheme/F-5.10-proof-forging.png "Рисунок 5.10 – Процес підроблення доказу")

1. Сторона, що доводить, генерує випадкове значення _s_ й обчислює $S = sG$. Після цього вона розраховує $R = sG − eP$ (вона може це зробити, позаяк знає значення _e_).
2. Сторона, що доводить, передає перевірячу _R_.
3. Перевіряч повертає значення _e_. Після цього той, хто доводить, відправляє перевірячу заздалегідь згенероване _s_.
4. Перевіряч робить таку саму перевірку, що й у попередньому прикладі, і переконується, що той, хто доводить, знає секрет (хоча насправді це не так).

Однак особливість такої схеми полягає не в тім, що той, хто доводить, може ошукати перевіряча, заздалегідь дізнавшись про значення _e_ (якщо перевіряч знає правильний порядок взаємодії, то він не дасть себе ошукати в такий спосіб), а те, що цей протокол інтерактивний. Тобто третя сторона не може переконатися в тім, що ітерації протоколу було виконано коректно та що перевіряч спочатку не передав стороні, що доводить, значення _e_. Такий протокол може використовуватися тільки між двома сторонами (для перевіряння, що сторона, що доводить, володіє секретом у конкретний момент часу), і той, хто доводить, і перевіряч не можуть переконати будь-яку третю сторону в коректності проведених дій.


### Перетворення інтерактивного протоколу на неінтерактивний

У протоколі ідентифікації, описаному вище, випадкове значення _e_, на якому ґрунтується безпека цієї схеми, надає перевіряч. Отже, від перевіряча безпосередньо залежить, чи зможе сторона, що доводить, ці докази підробити [91].

Ми можемо змінити джерело випадковості, використовуючи для цього, наприклад, геш-функцію. У неінтерактивному протоколі _e_ вже не генерує перевіряч: воно обчислюється як $e= \mathrm{hash} (R)$.

Що це дає? Раніше сторона, що доводить, обчислювала значення _R_ на підставі згенерованого _s_ і могла зробити правильні обчислення, тільки якщо попередньо отримувала доступ до _e_. Тепер ж _e_ залежить від _R_ і не може бути обчислене раніше, ніж _R_.


## 5.3 Використання зобов'язань Педерсена для формування доказів із нульовим розголошенням

У попередніх розділах ми окремо розглянули, що таке зобов'язання Педерсена та як працює протокол ідентифікації Шнорра. Тепер розгляньмо варіант, коли той, хто доводить, інтерактивно взаємодіятиме з тим, хто перевіряє, у режимі реального часу (як у разі інтерактивного протоколу Шнорра), але водночас в ролі зобов'язань буде використано зобов'язання Педерсена.

Доказ знання надаватиметься після того, як той, хто доводить, генерує набір зобов'язань для кожного з m векторів, знання яких і доводитиметься (причому докази знання буде подано однією парою значень).

$C_{i}=r_{i}H+ \overline{x_{i}G}$, $i \in \{ 1,2, \ldots ,m \}$

Після того, як сторона, що доводить, передала верифікатору набір цих зобов'язань $(C_{1},C_{2}, \ldots ,C_{m})$, вона може за один крок довести, що знає початкові вектори-секрети. Розгляньмо, як виглядає цей процес в інтерактивній формі.

Спочатку сторона, що доводить, формує випадкове нове зобов'язання _C<sub>0</sub>_ і відправляє його тому, хто перевіряє. Після цього верифікатор генерує випадкове значення _e_ (скаляр) і повертає його стороні, що доводить. Сторона, що доводить, формує два значення: _z_ і _s – і_ відправляє їх верифікатору. Ці значення обчислюються, як на рис. 5.11.

![Рисунок 5.11 – Інтерактивний протокол доведення](/resources/img/volume-3/5.3-Using-Pedersen-commitments-for-zero-knowledge-proofs/F-5.11-A-interactive-proof-protocol.png "Рисунок 5.11 – Інтерактивний протокол доведення")

> _Зауваження. Кроки ітерації в цьому протоколі схожі на кроки протоколу ідентифікації Шнорра, а значить, можна припустити, що й у цьому разі має місце атака підмінювання зобов'язання (далі ми розглянемо детальніше, як це працює)._

У цьому разі вектори _x<sub>i</sub>_ приховані від того, хто перевіряє, тобто складання елементів не розкриває кожний із них окремо: 

$z_{i}=x_{0,i}+ex_{1,i}+e^{2}x_{2,i}+ \ldots +e^{m}x_{m,i}$

За отримання зобов'язань верифікатор перевіряє таке (рис. 5.12):

![Рисунок 5.12 – Перевіряння доказів](/resources/img/volume-3/5.3-Using-Pedersen-commitments-for-zero-knowledge-proofs/F-5.11-B-verification-of-proofs.png "Рисунок 5.12 – Перевіряння доказів")

Якщо рівняння виконано, то верифікатор переконується, що той, хто доводить, знає весь набір секретів.

> _Зауваження. Уявімо приклад, який показує, чому такі докази працюють. Перше, що ми спростимо для цього прикладу: уявіть, що кожний вектор-знання – це просто одне значення, тобто ми працюватимемо з зобов'язаннями Педерсена, що стосуються приховування одного секрету._
> _Припустімо, Аліса відправляє Бобу 3 набори зобов'язань _C<sub>1</sub>_, _C<sub>2</sub>_, _C<sub>3</sub>_ того, що вона знає значення _a<sub>1</sub>_, _a<sub>2</sub>_, _a<sub>3</sub>_, як на рис. 5.13._

![Рисунок 5.13 – Відправлення з боку Аліси набору зобов'язань](/resources/img/volume-3/5.3-Using-Pedersen-commitments-for-zero-knowledge-proofs/F-5.12-A-Alice-sends-set-of-commitments.png "Рисунок 5.13 – Відправлення з боку Аліси набору зобов'язань")

> _Після цього вона хоче довести знання цих значень. Для цього вона відправляє Бобу нове зобов'язання _C<sub>0</sub>_ для випадкового значення _a<sub>0</sub>_. Боб повертає Алісі скаляр _е_. Далі Аліса розраховує та відправляє Бобу пару значень_ $(z,s)$_, як на рис. 5.14._

![Рисунок 5.14 – Процес доведення володіння знаннями](/resources/img/volume-3/5.3-Using-Pedersen-commitments-for-zero-knowledge-proofs/F-5.12-B-knowledge-proof.png "Рисунок 5.14 – Процес доведення володіння знаннями")

>_Боб, зі свого боку, може перевірити знання, маючи тільки значення (z, s), у такий спосіб (рис. 5.15):_

![Рисунок 5.15 – Перевіряння правильності доказів](/resources/img/volume-3/5.3-Using-Pedersen-commitments-for-zero-knowledge-proofs/F-5.12-C-proof-verification.png "Рисунок 5.15 – Перевіряння правильності доказів")

Отже, ми бачимо, що перебуваємо в схожому становищі, що й у разі протоколу ідентифікації Шнорра. Єдина відмінність полягає в тому, що на останньому кроці ітерації в протоколі Шнорра передається одне значення скаляра _s_, а в розглянутому протоколі – пара значень $(z, s)$. Для розглянутого прикладу _z_ також був єдиний скаляр, але він також може бути вектор значень. 

Тому, якщо стороні, що доводить, з самого початку відоме значення _e_, вона може підробляти докази. Для цього вона генерує випадкові значення $(z, s)$, після чого розраховує значення зобов'язання _C<sub>0</sub>_ у такий спосіб:

$C_{0} = (sH+aG)- \displaystyle\sum_{i=1}^{m}{e^{i}C_{i}}$.

> _Зауваження. Розгляньмо, як це працюватиме для нашого прикладу. Аліса відправляє Бобу 3 набори зобов'язань  _C<sub>1</sub>_, _C<sub>2</sub>_, _C<sub>3</sub>_ того, що вона знає значення _a<sub>1</sub>_, _a<sub>2</sub>_, _a<sub>3</sub>_. Після цього Аліса випадково генерує значення _z_ і _s_. Маючи значення _е_, Аліса формує _C<sub>0</sub>_ і відправляє його тому, хто перевіряє (рис. 5.16)._

![Рисунок 5.16 – Процес підроблення доказів](/resources/img/volume-3/5.3-Using-Pedersen-commitments-for-zero-knowledge-proofs/F-5.13-A-proof-forging.png "Рисунок 5.16 – Процес підроблення доказів")

> _Боб, зі свого боку, для перевіряння знання обчислює таке:_

![Рисунок](/resources/img/volume-3/5.3-Using-Pedersen-commitments-for-zero-knowledge-proofs/F-5.13-B-successful-verification-of-fake-proof.png "Рисунок")

> _У цьому разі ми також бачимо, що Аліса, не володіючи секретними знаннями, але заздалегідь маючи значення е, може підробляти докази для зобов'язань._


### Використання зобов'язань Педерсена в confidential transactions

Для того, щоб визначити як зобов'язання Педерсена можуть використовуватися в CT, спочатку потрібно визначитися, які деталі транзакцій потрібно приховувати. Припустімо, що нам потрібно приховати суми на вході (_a_) і виході (_b_) транзакції, а також суму комісії (_c_). Для того, щоби транзакція вважалася правильною та її могли підтвердити валідатори, важливо, щоби виконувалася така умова:

$a-b-c=0$

Щоби приховати кожне значення, ми й використовуємо зобов'язання Педерсена:

$A=r_{A}H+aG$, 
$B=r_{B}H+bG$, 
$C=r_{C}H+cG$

Оскільки зобов'язання гомоморфні, то над ними можна провести такі обчислення:

$A-B-C=0G+(r_{A}-r_{B}-r_{C})H$

Якщо сторона, що доводить, надасть доказ того, що вона знає підсумкове значення $(r_{A}-r_{B}-r_{C})$ (може бути використано той самий алгоритм ідентифікації Шнорра або підпис), то верифікатор може переконатися, що входи та виходи транзакції збігаються.

Проте водночас виникає необхідність доведення того, що значення _b_ (сума виходу) та _c_ (комісія) невід'ємні (і гроші не взято з повітря). Для цього використовуються докази діапазону (range proofs), які у своїй основі можуть використовувати зобов'язання Педерсена.

### Використання зобов'язань Педерсена для range proofs

Докази діапазону використовуються для перевіряння того, що конкретне число перебуває в певних заздалегідь позначених межах. У нашому разі потрібно довести те, що значення _b_ та _c_ невід'ємні, а також те, що сума цих значень не перевищує максимально допустимого _n_ (значення модуля). Водночас дуже важливо не розкрити самих значень [98].

Ми можемо подати _b_ та _c_ у формі бітової послідовності. Якщо довжина модуля дорівнює $k + 2 $біт, то максимальна довжина суми _b_ та _c_ не має перевищувати $k + 1$ біт, а розмір кожного зі значень – _k_ біт. Відповідно, завдання полягає в доведенні того, що _b_ та c складаються з _k_-бітної послідовності. 

Як приклад сформуймо такий доказ для _b_. Для початку його можна подати у формі такого полінома:

$b=b_{0}+2b_{1}+2^{2}b_{2}+ \ldots +2^{k-1}b_{k-1}$

Ми вже маємо зобов'язання для _b_, яке подано як $B=r_{B}H+bG$. Також ми можемо сформувати аналогічні зобов'язання для кожного доданка полінома _b_. Для цього ми генеруємо новий набір значень:

1. $(r_{B,0},r_{B,1}, \ldots ,r_{B,k-2})$ 
2. $r_{B,k-1}=r_{B}- \displaystyle\sum_{i=0}^{k-2}{r_{B,i}}$ 

Далі, використовуючи ці значення, ми формуємо зобов'язання для кожного складника вихідного полінома:

$P_{i}=r_{B,i}H+2^{i}b_{i}G$

Позаяк зобов'язання гомоморфні, то виконується таке рівняння:

$P= \displaystyle\sum_{i=0}^{k-1}{P_{i}}$.

Таким чином, ми можемо довести, що розмір _b_ не перевищує _k_ біт. Однак ми ще не довели, що кожне _b<sub>i</sub> дійсно є конкретний біт (0 або 1). Для доведення цього може використовуватися механізм кільцевих підписів [98].

# [6 ОСНОВИ ПОСТКВАНТОВОЇ КРИПТОГРАФІЇ](https://github.com/distributed-lab/blockchain-and-decentralized-systems-book/blob/main/chapters/volume-3/ua/6-Basics-of-post-quantum-cryptography.md)
